<?DTDIdentifier.IdentifierValue article.dtd?>
<?DTDIdentifier.IdentifierType system?>
<?SourceDTD.DTDName article.dtd?>
<?SourceDTD.Version 1.0?>
<?ConverterInfo.XSLTName bmc2nlmx2.xsl?>
<?ConverterInfo.Version 2?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">BMC Genomics</journal-id>
    <journal-id journal-id-type="iso-abbrev">BMC Genomics</journal-id>
    <journal-title-group>
      <journal-title>BMC Genomics</journal-title>
    </journal-title-group>
    <issn pub-type="epub">1471-2164</issn>
    <publisher>
      <publisher-name>BioMed Central</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">3582441</article-id>
    <article-id pub-id-type="publisher-id">1471-2164-14-S2-S5</article-id>
    <article-id pub-id-type="doi">10.1186/1471-2164-14-S2-S5</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Research</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>MixSIH: a mixture model for single individual haplotyping</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" corresp="yes" id="A1">
        <name>
          <surname>Matsumoto</surname>
          <given-names>Hirotaka</given-names>
        </name>
        <xref ref-type="aff" rid="I1">1</xref>
        <email>matsumoto@cb.k.u-tokyo.ac.jp</email>
      </contrib>
      <contrib contrib-type="author" id="A2">
        <name>
          <surname>Kiryu</surname>
          <given-names>Hisanori</given-names>
        </name>
        <xref ref-type="aff" rid="I1">1</xref>
        <email>kiryu-h@k.u-tokyo.ac.jp</email>
      </contrib>
    </contrib-group>
    <aff id="I1"><label>1</label>Department of Computational Biology, Faculty of Frontier Science, The University
of Tokyo, 5-1-5 Kashiwanoha, Kashiwa, Chiba 277-8561, Japan</aff>
    <pub-date pub-type="collection">
      <year>2013</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>15</day>
      <month>2</month>
      <year>2013</year>
    </pub-date>
    <volume>14</volume>
    <issue>Suppl 2</issue>
    <supplement>
      <named-content content-type="supplement-title">Selected articles from ISCB-Asia 2012</named-content>
      <named-content content-type="supplement-editor">Victor Jin and Paul Horton</named-content>
      <named-content content-type="supplement-sponsor">Publication of this supplement was funded by the authors.</named-content>
    </supplement>
    <fpage>S5</fpage>
    <lpage>S5</lpage>
    <permissions>
      <copyright-statement>Copyright ©2013 Matsumoto and Kiryu; licensee BioMed Central Ltd.</copyright-statement>
      <copyright-year>2013</copyright-year>
      <copyright-holder>Matsumoto and Kiryu; licensee BioMed Central Ltd.</copyright-holder>
      <license license-type="open-access" xlink:href="http://creativecommons.org/licenses/by/2.0">
        <license-p>This is an open access article distributed under the terms of the Creative Commons
Attribution License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/2.0">http://creativecommons.org/licenses/by/2.0</ext-link>), which
permits unrestricted use, distribution, and reproduction in any medium, provided the
original work is properly cited.</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="http://www.biomedcentral.com/1471-2164/14/S2/S5"/>
    <abstract>
      <sec>
        <title>Background</title>
        <p>Haplotype information is useful for various genetic analyses, including
genome-wide association studies. Determining haplotypes experimentally is
difficult and there are several computational approaches that infer haplotypes
from genomic data. Among such approaches, single individual haplotyping or
haplotype assembly, which infers two haplotypes of an individual from aligned
sequence fragments, has been attracting considerable attention. To avoid incorrect
results in downstream analyses, it is important not only to assemble haplotypes as
long as possible but also to provide means to extract highly reliable haplotype
regions. Although there are several efficient algorithms for solving haplotype
assembly, there are no efficient method that allow for extracting the regions
assembled with high confidence.</p>
      </sec>
      <sec>
        <title>Results</title>
        <p>We develop a probabilistic model, called MixSIH, for solving the haplotype
assembly problem. The model has two mixture components representing two
haplotypes. Based on the optimized model, a quality score is defined, which we
call the 'minimum connectivity' (MC) score, for each segment in the haplotype
assembly. Because existing accuracy measures for haplotype assembly are designed
to compare the efficiency between the algorithms and are not suitable for
evaluating the quality of the set of partially assembled haplotype segments, we
develop an accuracy measure based on the pairwise consistency and evaluate the
accuracy on the simulation and real data. By using the MC scores, our algorithm
can extract highly accurate haplotype segments. We also show evidence that an
existing experimental dataset contains chimeric read fragments derived from
different haplotypes, which significantly degrade the quality of assembled
haplotypes.</p>
      </sec>
      <sec>
        <title>Conclusions</title>
        <p>We develop a novel method for solving the haplotype assembly problem. We also
define the quality score which is based on our model and indicates the accuracy of
the haplotypes segments. In our evaluation, MixSIH has successfully extracted
reliable haplotype segments. The C++ source code of MixSIH is available at
<ext-link ext-link-type="uri" xlink:href="https://sites.google.com/site/hmatsu1226/software/mixsih">https://sites.google.com/site/hmatsu1226/software/mixsih</ext-link>.</p>
      </sec>
    </abstract>
    <conference>
      <conf-date>17-19 December 2012</conf-date>
      <conf-name>ISCB-Asia 2012 </conf-name>
      <conf-loc>Shenzhen, China</conf-loc>
    </conference>
  </article-meta>
</front>
<body>
  <sec>
    <title>Introduction</title>
    <p>Human somatic cells are diploid and contain two homologous copies of chromosomes, each
of which is derived from either paternal or maternal chromosomes. The two chromosomes
differ at a number of loci and the most abundant type of variation is single nucleotide
polymorphism (SNP). Most current research does not determine the chromosomal origin of
the variations and uses only genotype information for the analyses. However, haplotype
information is valuable for genome-wide association studies (GWAS) [<xref ref-type="bibr" rid="B1">1</xref>] and for analyzing genetic structures such as linkage
disequilibrium, recombination patterns [<xref ref-type="bibr" rid="B2">2</xref>], and
correlations between variations and diseases [<xref ref-type="bibr" rid="B3">3</xref>].</p>
    <p>Let us consider a simple example to demonstrate the importance of haplotype information.
Suppose that in a gene coding region, there are two SNP loci, each of which has an
independent deleterious mutation in either one of the two homologous chromosomes. If
both of the two deleterious mutations are located on the same chromosome, the other
chromosome can produce normal proteins. On the other hand, if each chromosome contains
either one of the two deleterious mutations, the cells cannot produce normal proteins.
It is not possible to distinguish these two cases with only genotype information.</p>
    <p>There is a group of algorithms for haplotype inference that statistically construct a
set of haplotypes from population genotypes [<xref ref-type="bibr" rid="B4">4</xref>-<xref ref-type="bibr" rid="B8">8</xref>] Review see [<xref ref-type="bibr" rid="B9">9</xref>]. These
algorithms have been developed in response to technological advances such as SNP arrays
that efficiently measure personal genotypes at a genomic scale. The algorithms infer
haplotype blocks based on the assumption that the variety of combinations of alleles is
very limited. Therefore, these algorithms fail to identify correct haplotypes in regions
with low linkage disequilibrium (LD) where there are frequent recombination events.
These algorithms also cannot identify spontaneous mutations. These difficulties are
partially resolved by using genotypes of pedigrees. However, family data are not always
available, and furthermore, they cannot determine the haplotypes of the loci at which
all the family members have the same genotype.</p>
    <p>Another group of algorithms is single individual haplotyping (SIH) or haplotype
assembly. These algorithms infer the two haplotypes of an individual from sequenced DNA
fragments [<xref ref-type="bibr" rid="B10">10</xref>-<xref ref-type="bibr" rid="B17">17</xref>]. These
algorithms take as input the read fragments that are aligned to the reference genome,
and output the two assembled haplotypes (Figure <xref ref-type="fig" rid="F1">1</xref>). The algorithms
utilize the fact that each read fragment is derived from either one of two chromosomes,
though the observed data are a mixture of fragment data from both the chromosomes. If a
read fragment spans two or more heterozygous loci, the haplotype can be determined for
these sites from the co-occurrence of alleles in the fragment. Two read fragments are
determined to originate from the same chromosome if they overlap at a region that has at
least one heterozygous locus, and they have the same alleles at these loci. In this
case, we obtain a larger haplotype-resolved region by merging the two fragments. The SIH
problem is complicated because the fragment data contain many inconsistent fragments
caused by sequencing or mapping error.</p>
    <fig id="F1" position="float">
      <label>Figure 1</label>
      <caption>
        <p><bold>An illustration of SIH</bold>. An illustration of single individual haplotyping
(SIH). The input data for SIH are the SNP fragments (B) which are extracted from
the heterozygous alleles in aligned DNA fragments (A). SIH algorithms (C)
reconstruct the original haplotypes (D) from the SNP fragments.</p>
      </caption>
      <graphic xlink:href="1471-2164-14-S2-S5-1"/>
    </fig>
    <p>SIH algorithms did not attract much attention until recently, since the read fragments
of next-generation sequencing experiments are not long enough to span multiple
heterozygous loci, which exist at only one in one kilo-base on average [<xref ref-type="bibr" rid="B18">18</xref>], and the Sanger sequencing that produces long read
fragments is too expensive to be conducted at a genomic scale. However, this situation
is changing rapidly with the advent of real-time single-molecule sequencing
technologies, which are able to sequence DNA fragments as long as 50 kilo-bases
[<xref ref-type="bibr" rid="B19">19</xref>], and with the development of a novel
experimental technique called 'fosmid pool-based next-generation sequencing'
[<xref ref-type="bibr" rid="B13">13</xref>,<xref ref-type="bibr" rid="B20">20</xref>,<xref ref-type="bibr" rid="B21">21</xref>], which randomly assigns a bar-code to each read cluster that
is derived from the same region in the same chromosome. Because of these advances in
experimental techniques, SIH has emerged as one of the most promising approaches for
analyzing the haplotype structures of diploid organisms.</p>
    <p>The haplotype information which contains errors is likely to lead to wrong results in
downstream analyses. For example, in detecting the recombination events from the
parent-offspring haplotypes [<xref ref-type="bibr" rid="B22">22</xref>], the
haplotyping errors are regarded as recombination events by mistake. Another example is
that haplotyping errors considerably decrease the detection power of amplified
haplotypes in cancer [<xref ref-type="bibr" rid="B23">23</xref>] and fetus haplotypes
[<xref ref-type="bibr" rid="B24">24</xref>]. To use haplotype information in
downstream analyses while avoiding such harmful influence of haplotyping errors, it is
important not only to assemble haplotypes as long as possible but also to provide means
to extract highly reliable haplotype regions. In the statistical haplotype phasing,
reliable haplotype regions are determined by selecting the blocks of limited haplotype
diversity and level of LD [<xref ref-type="bibr" rid="B25">25</xref>-<xref ref-type="bibr" rid="B27">27</xref>]. Although there are many algorithms
for SIH, none of these algorithms can provide confidence scores to extract reliable
haplotype regions.</p>
    <p>The algorithms for SIH are classified into two strategies; most of the previous
algorithms use deterministic strategies [<xref ref-type="bibr" rid="B10">10</xref>-<xref ref-type="bibr" rid="B13">13</xref>,<xref ref-type="bibr" rid="B15">15</xref>,<xref ref-type="bibr" rid="B17">17</xref>] but a few take a
probabilistic modeling approach [<xref ref-type="bibr" rid="B14">14</xref>,<xref ref-type="bibr" rid="B16">16</xref>]. The deterministic algorithms usually include solving the
MAX-CUT problem of graph theory [<xref ref-type="bibr" rid="B28">28</xref>] in their
computational procedures in order to partition the set of the input fragments into two
groups representing the two haplotypes. Because these algorithms are designed to
optimize only a certain global score function that measures the number of inconsistent
fragments and do not model the fragments and haplotypes themselves, it is difficult to
produce confidence scores for each region of the assembled haplotypes.</p>
    <p>On the other hand, the probabilistic approaches of Kim [<xref ref-type="bibr" rid="B14">14</xref>] and Li [<xref ref-type="bibr" rid="B16">16</xref>] assume
that each observed fragment is sampled from one of the two unobserved haplotypes. Unlike
the deterministic approaches, probabilistic models allow the computation of various
expected values and confidence values from the Bayesian posterior distributions. For
example, Kim [<xref ref-type="bibr" rid="B14">14</xref>] and Li [<xref ref-type="bibr" rid="B16">16</xref>] defined a confidence value for the haplotype
reconstruction of each segment of SNP loci. Unfortunately, those researchers chose a
model structure for which the exact computation of the likelihood is extremely
computationally intensive. Because the complexity of this summation is exponential in
the number of SNP sites, only the posterior probabilities of the haplotypes for
neighboring loci are considered. The complete haplotypes are reconstructed by connecting
plausible haplotypes of neighboring pairs according to their posterior probabilities.
Hence, their approach cannot take into account the full information of fragments that
span three or more SNP loci. Their confidence scores for haplotype segments include a
summation over all the possible haplotypes, and it is not possible to compute their
confidence scores for all the possible segments in the assembled haplotypes.</p>
    <p>In this paper, we develop a novel probabilistic SIH model that is very different from
the probabilistic models of Kim [<xref ref-type="bibr" rid="B14">14</xref>] and Li
[<xref ref-type="bibr" rid="B16">16</xref>]. Our model takes a 'mixture model'
approach: each fragment is emitted completely independently of the other fragments. In
contrast, Kim [<xref ref-type="bibr" rid="B14">14</xref>] and Li [<xref ref-type="bibr" rid="B16">16</xref>] took a 'hidden variables' approach: all the
fragments are correlated through hidden haplotype variables (see the Additional file
<xref ref-type="supplementary-material" rid="S1">1</xref> for further explanation). This difference allows us to
compute the likelihood with a computational time proportional to the total length of the
input fragments. We use the variational Bayes expectation maximization (VBEM) algorithm
[<xref ref-type="bibr" rid="B29">29</xref>] to compute the approximate posterior
distribution of the haplotypes. By using the optimized distribution, we compute the
'minimum connectivity' (MC) score for each segment in the reconstructed haplotypes; this
measures whether the segment is free from switch errors. We show that we can extract
accurately assembled regions by selecting regions with high MC scores. We also analyze a
recent dataset from fosmid pool-based next-generation sequencing and find evidence that
the processed dataset contains chimeric fragments derived from the erroneous merging of
read clusters in different haplotypes, which degrades the quality of assembled
haplotypes significantly.</p>
  </sec>
  <sec sec-type="methods">
    <title>Methods</title>
    <sec>
      <title>Algorithms and implementation</title>
      <sec>
        <title>Notation</title>
        <p>Throughout the paper, we denote the number of elements of any set <italic>A </italic>by
<italic>|A|</italic>, and the direct product set <inline-formula><mml:math id="M1" name="1471-2164-14-S2-S5-i1" overflow="scroll"><mml:mrow><mml:munder class="msub"><mml:mrow><mml:munder accentunder="false"><mml:mrow><mml:mi>A</mml:mi><mml:mo class="MathClass-bin">×</mml:mo><mml:mo class="MathClass-rel">⋯</mml:mo><mml:mo class="MathClass-bin">×</mml:mo><mml:mi>A</mml:mi></mml:mrow><mml:mo>︸</mml:mo></mml:munder></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:munder></mml:mrow></mml:math></inline-formula>
by <italic>A</italic><sup>⊗<italic>n</italic></sup>. Let <italic>X </italic>= {1, 2, . . . ,
<italic>M</italic>} be the set of SNP loci, and <inline-formula><mml:math id="M2" name="1471-2164-14-S2-S5-i42" overflow="scroll"><mml:mi mathvariant="script">H</mml:mi><mml:mo class="MathClass-rel">=</mml:mo><mml:mrow><mml:mo class="MathClass-open">{</mml:mo><mml:mrow><mml:mn>0</mml:mn><mml:mo class="MathClass-punc">,</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo class="MathClass-close">}</mml:mo></mml:mrow></mml:math></inline-formula> be the two haplotypes. It
is convenient to introduce a <italic>phase vector </italic>Φ = <italic>φ</italic><sub>1
</sub>... <italic>φ<sub>M</sub></italic>. The pair <italic>φ<sub>j </sub></italic>=
(<italic>φ<sub>j0</sub></italic>, <italic>φ<sub>j</sub></italic><sub>1</sub>) is
referred to as <italic>phase</italic>, and represents the two alleles of haplotype 0 and 1
at site <italic>j</italic>, respectively. Because the haplotype assembly problem is
trivial for homozygous sites, and because it is usually much easier to determine
the genotype than to determine the haplotypes, it is often convenient to restrict
the SNP loci <italic>X </italic>to heterozygous sites. Furthermore, if sequence-specific
sequencing errors are not considered, it is convenient to use a simple binary
representation of alleles; we randomly assign 0 to one of the two alleles at each
heterozygous site <italic>j</italic>, and 1 to the other allele. In this case, the set of
alleles is denoted by Σ = {0, 1}, and the set of possible phases is denoted
by Δ = {(0, 1), (1, 0)}. We assume this binary representation throughout the
paper.</p>
        <p>Let <italic>F </italic>= {<italic>f<sub>i</sub>|i </italic>= 1, . . . , <italic>N</italic>} be the set of
input fragments which are supposed to be aligned to the reference genome, and each
fragment <italic>f<sub>i </sub></italic>takes value <italic>f<sub>ij </sub></italic>∈ Σ
at locus <italic>j </italic>∈ <italic>X </italic>if a nucleotide is aligned and equal to one
of two alleles, and <italic>f<sub>ij </sub></italic>= ∅ if fragment <italic>f<sub>i
</sub></italic>is unaligned, gapped, ambiguous, or a base different from the two
alleles, at site <italic>j</italic>. For any subset <italic>X</italic>' ⊆ <italic>X</italic>, we say
fragment <italic>f<sub>i </sub></italic><italic>spans </italic>the sites <italic>X' </italic>if
<italic>f<sub>ij </sub></italic>≠ ∅ for all <italic>j </italic>∈
<italic>X'</italic>. We refer to the subset of <italic>X </italic>spanned by fragment <italic>f
</italic>as <italic>X</italic>(<italic>f</italic>). We say fragment <italic>f<sub>i </sub></italic><italic>covers
</italic>site <italic>j </italic>if there exists a pair of spanning two different (possible
non consecutive) SNP sites <italic>j</italic><sub>1</sub>, <italic>j</italic><sub>2 </sub>∈
<italic>X</italic>(<italic>f<sub>i</sub></italic>) such that <italic>j</italic><sub>1 </sub><italic>&lt; j
</italic><italic>≤ </italic><italic>j</italic><sub>2</sub>. The set of fragments that cover
site <italic>j </italic>is denoted by <italic>F<sup>c</sup></italic>(<italic>j</italic>). Further, we
refer to the set of all the possible haplotypes for sites
<italic>X</italic>(<italic>f<sub>i</sub></italic>) as <inline-formula><mml:math id="M3" name="1471-2164-14-S2-S5-i2" overflow="scroll"><mml:mi mathvariant="normal">Δ</mml:mi><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow><mml:mo class="MathClass-rel">=</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="normal">Δ</mml:mi></mml:mrow><mml:mrow><mml:mo class="MathClass-bin">⊗</mml:mo><mml:mo class="MathClass-rel">|</mml:mo><mml:mi>X</mml:mi><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow><mml:mo class="MathClass-rel">|</mml:mo></mml:mrow></mml:msup></mml:math></inline-formula>.</p>
        <p>The SIH problem takes a set of aligned SNP fragments <italic>F </italic>as input and
outputs a hidden phase vector Φ (Figure <xref ref-type="fig" rid="F1">1</xref>). Because the
SIH problem does not associate the inferred haplotypes <inline-formula><inline-graphic xlink:href="1471-2164-14-S2-S5-i43.gif"/></inline-formula>with the real paternal and maternal
chromosomes, the switched configuration <inline-formula><mml:math id="M4" name="1471-2164-14-S2-S5-i3" overflow="scroll"><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="normal">Φ</mml:mi></mml:mrow><mml:mo class="MathClass-op">¯</mml:mo></mml:mover><mml:mo class="MathClass-rel">=</mml:mo><mml:msub><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>φ</mml:mi></mml:mrow><mml:mo class="MathClass-op">¯</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo class="MathClass-rel">⋯</mml:mo><mml:msub><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>φ</mml:mi></mml:mrow><mml:mo class="MathClass-op">¯</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>M</mml:mi></mml:mrow></mml:msub><mml:mo class="MathClass-punc">,</mml:mo><mml:mspace class="thinspace" width="0.3em"/><mml:mspace class="thinspace" width="0.3em"/><mml:msub><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>φ</mml:mi></mml:mrow><mml:mo class="MathClass-op">¯</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo class="MathClass-rel">=</mml:mo><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>φ</mml:mi></mml:mrow><mml:mo class="MathClass-op">¯</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mover accent="true"><mml:mrow><mml:mn>0</mml:mn></mml:mrow><mml:mo class="MathClass-op">
¯</mml:mo></mml:mover></mml:mrow></mml:msub><mml:mo class="MathClass-punc">,</mml:mo><mml:msub><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>φ</mml:mi></mml:mrow><mml:mo class="MathClass-op">¯</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mover accent="true"><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mo class="MathClass-op">
¯</mml:mo></mml:mover></mml:mrow></mml:msub></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow></mml:math></inline-formula>
with <inline-formula><mml:math id="M5" name="1471-2164-14-S2-S5-i4" overflow="scroll"><mml:mover accent="true"><mml:mrow><mml:mn>0</mml:mn></mml:mrow><mml:mo class="MathClass-op">
¯</mml:mo></mml:mover><mml:mo class="MathClass-rel">=</mml:mo><mml:mn>1</mml:mn></mml:math></inline-formula> and
<inline-formula><mml:math id="M6" name="1471-2164-14-S2-S5-i5" overflow="scroll"><mml:mover accent="true"><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mo class="MathClass-op">
¯</mml:mo></mml:mover><mml:mo class="MathClass-rel">=</mml:mo><mml:mn>0</mml:mn></mml:math></inline-formula>, must be regarded as a
completely equivalent prediction. Therefore, SIH has no meaning if there is only
one heterozygous site, and it is only meaningful if one considers co-occurrences
of alleles on the same haplotype for two or more heterozygous sites.</p>
      </sec>
      <sec>
        <title>Mixture model</title>
        <p>We model the probabilistic distribution of the observed fragments <italic>F
</italic>by</p>
        <p>
          <disp-formula>
            <mml:math id="M7" name="1471-2164-14-S2-S5-i6" overflow="scroll">
              <mml:mrow>
                <mml:mi>P</mml:mi>
                <mml:mrow>
                  <mml:mo class="MathClass-open">(</mml:mo>
                  <mml:mrow>
                    <mml:mi>F</mml:mi>
                    <mml:mo class="MathClass-rel">|</mml:mo>
                    <mml:mi mathvariant="normal">Θ</mml:mi>
                  </mml:mrow>
                  <mml:mo class="MathClass-close">)</mml:mo>
                </mml:mrow>
                <mml:mo class="MathClass-rel">=</mml:mo>
                <mml:munder class="msub">
                  <mml:mrow>
                    <mml:mo mathsize="big"> ∑</mml:mo>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>H</mml:mi>
                    <mml:mo class="MathClass-rel">∈</mml:mo>
                    <mml:msup>
                      <mml:mrow>
                        <mml:mi mathvariant="script">H</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mo class="MathClass-bin">⊗</mml:mo>
                        <mml:mi>N</mml:mi>
                      </mml:mrow>
                    </mml:msup>
                  </mml:mrow>
                </mml:munder>
                <mml:munderover accent="false" accentunder="false">
                  <mml:mrow>
                    <mml:mo mathsize="big">∏</mml:mo>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>i</mml:mi>
                    <mml:mo class="MathClass-rel">=</mml:mo>
                    <mml:mn>1</mml:mn>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>N</mml:mi>
                  </mml:mrow>
                </mml:munderover>
                <mml:munder class="msub">
                  <mml:mrow>
                    <mml:mo mathsize="big">∑</mml:mo>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:msup>
                      <mml:mrow>
                        <mml:mi mathvariant="normal">Φ</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mrow>
                          <mml:mo class="MathClass-open">(</mml:mo>
                          <mml:mrow>
                            <mml:mi>i</mml:mi>
                          </mml:mrow>
                          <mml:mo class="MathClass-close">)</mml:mo>
                        </mml:mrow>
                      </mml:mrow>
                    </mml:msup>
                    <mml:mo class="MathClass-rel">∈</mml:mo>
                    <mml:mi mathvariant="normal">Δ</mml:mi>
                    <mml:mrow>
                      <mml:mo class="MathClass-open">(</mml:mo>
                      <mml:mrow>
                        <mml:msub>
                          <mml:mrow>
                            <mml:mi>f</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mi>i</mml:mi>
                          </mml:mrow>
                        </mml:msub>
                      </mml:mrow>
                      <mml:mo class="MathClass-close">)</mml:mo>
                    </mml:mrow>
                  </mml:mrow>
                </mml:munder>
                <mml:mi>P</mml:mi>
                <mml:mrow>
                  <mml:mo class="MathClass-open">(</mml:mo>
                  <mml:mrow>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>f</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>i</mml:mi>
                      </mml:mrow>
                    </mml:msub>
                    <mml:mo class="MathClass-rel">|</mml:mo>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>h</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>i</mml:mi>
                      </mml:mrow>
                    </mml:msub>
                    <mml:mo class="MathClass-punc">,</mml:mo>
                    <mml:mspace class="tmspace" width="2.77695pt"/>
                    <mml:msup>
                      <mml:mrow>
                        <mml:mi mathvariant="normal">Φ</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mrow>
                          <mml:mo class="MathClass-open">(</mml:mo>
                          <mml:mrow>
                            <mml:mi>i</mml:mi>
                          </mml:mrow>
                          <mml:mo class="MathClass-close">)</mml:mo>
                        </mml:mrow>
                      </mml:mrow>
                    </mml:msup>
                  </mml:mrow>
                  <mml:mo class="MathClass-close">)</mml:mo>
                </mml:mrow>
                <mml:msup>
                  <mml:mrow>
                    <mml:mi>p</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>m</mml:mi>
                  </mml:mrow>
                </mml:msup>
                <mml:mrow>
                  <mml:mo class="MathClass-open">(</mml:mo>
                  <mml:mrow>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>h</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>i</mml:mi>
                      </mml:mrow>
                    </mml:msub>
                  </mml:mrow>
                  <mml:mo class="MathClass-close">)</mml:mo>
                </mml:mrow>
                <mml:mi>P</mml:mi>
                <mml:mrow>
                  <mml:mo class="MathClass-open">(</mml:mo>
                  <mml:mrow>
                    <mml:msup>
                      <mml:mrow>
                        <mml:mi mathvariant="normal">Φ</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mrow>
                          <mml:mo class="MathClass-open">(</mml:mo>
                          <mml:mrow>
                            <mml:mi>i</mml:mi>
                          </mml:mrow>
                          <mml:mo class="MathClass-close">)</mml:mo>
                        </mml:mrow>
                      </mml:mrow>
                    </mml:msup>
                  </mml:mrow>
                  <mml:mo class="MathClass-close">)</mml:mo>
                </mml:mrow>
                <mml:mo class="MathClass-punc">,</mml:mo>
              </mml:mrow>
            </mml:math>
          </disp-formula>
        </p>
        <p>
          <disp-formula>
            <mml:math id="M8" name="1471-2164-14-S2-S5-i7" overflow="scroll">
              <mml:mrow>
                <mml:mi>P</mml:mi>
                <mml:mrow>
                  <mml:mo class="MathClass-open">(</mml:mo>
                  <mml:mrow>
                    <mml:msup>
                      <mml:mrow>
                        <mml:mi mathvariant="normal">Φ</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mrow>
                          <mml:mo class="MathClass-open">(</mml:mo>
                          <mml:mrow>
                            <mml:mi>i</mml:mi>
                          </mml:mrow>
                          <mml:mo class="MathClass-close">)</mml:mo>
                        </mml:mrow>
                      </mml:mrow>
                    </mml:msup>
                  </mml:mrow>
                  <mml:mo class="MathClass-close">)</mml:mo>
                </mml:mrow>
                <mml:mo class="MathClass-rel">=</mml:mo>
                <mml:munder class="msub">
                  <mml:mrow>
                    <mml:mo mathsize="big"> ∏</mml:mo>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>j</mml:mi>
                    <mml:mo class="MathClass-rel">∈</mml:mo>
                    <mml:mi>X</mml:mi>
                    <mml:mrow>
                      <mml:mo class="MathClass-open">(</mml:mo>
                      <mml:mrow>
                        <mml:msub>
                          <mml:mrow>
                            <mml:mi>f</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mi>i</mml:mi>
                          </mml:mrow>
                        </mml:msub>
                      </mml:mrow>
                      <mml:mo class="MathClass-close">)</mml:mo>
                    </mml:mrow>
                  </mml:mrow>
                </mml:munder>
                <mml:msubsup>
                  <mml:mrow>
                    <mml:mi>p</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>j</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi mathvariant="normal">Φ</mml:mi>
                  </mml:mrow>
                </mml:msubsup>
                <mml:mrow>
                  <mml:mo class="MathClass-open">(</mml:mo>
                  <mml:mrow>
                    <mml:msubsup>
                      <mml:mrow>
                        <mml:mi>φ</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>j</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mrow>
                          <mml:mo class="MathClass-open">(</mml:mo>
                          <mml:mrow>
                            <mml:mi>i</mml:mi>
                          </mml:mrow>
                          <mml:mo class="MathClass-close">)</mml:mo>
                        </mml:mrow>
                      </mml:mrow>
                    </mml:msubsup>
                  </mml:mrow>
                  <mml:mo class="MathClass-close">)</mml:mo>
                </mml:mrow>
                <mml:mo class="MathClass-punc">,</mml:mo>
              </mml:mrow>
            </mml:math>
          </disp-formula>
        </p>
        <p>where Θ represents a set of parameters defined later, Φ<sup>(<italic>i</italic>)
</sup>∈ Δ(<italic>f<sub>i</sub></italic>) represents a partial haplotype
reconstruction over the sites <italic>X</italic>(<italic>f<sub>i</sub></italic>) spanned by
fragment <italic>f<sub>i</sub></italic>, <italic>H </italic>= <italic>h</italic><sub>1 </sub>. . .
<italic>h<sub>N </sub></italic>where <inline-formula><mml:math id="M9" name="1471-2164-14-S2-S5-i8" overflow="scroll"><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo class="MathClass-rel">∈</mml:mo><mml:mi mathvariant="script">H</mml:mi></mml:math></inline-formula> represents the haplotype origin of
fragment <italic>f<sub>i</sub></italic>, <italic>p<sup>m</sup></italic>(<italic>h</italic>) is the mixture
probability of haplotype <inline-formula><mml:math id="M10" name="1471-2164-14-S2-S5-i9" overflow="scroll"><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo class="MathClass-rel">∈</mml:mo><mml:mi mathvariant="script">H</mml:mi></mml:math></inline-formula>, and <inline-formula><mml:math id="M11" name="1471-2164-14-S2-S5-i10" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">Φ</mml:mi></mml:mrow></mml:msubsup><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:mi>ν</mml:mi></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow></mml:math></inline-formula> is
the probability that phase <italic>ν </italic>∈ Δ is instantiated at site
<italic>j</italic>. We define the probability of emitting fragment <italic>f<sub>i
</sub></italic>from haplotype <italic>h<sub>i </sub></italic>given a fixed phase vector
Φ<sup>(<italic>i</italic>) </sup>as follows.</p>
        <p>
          <disp-formula>
            <mml:math id="M12" name="1471-2164-14-S2-S5-i11" overflow="scroll">
              <mml:mrow>
                <mml:mi>P</mml:mi>
                <mml:mrow>
                  <mml:mo class="MathClass-open">(</mml:mo>
                  <mml:mrow>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>f</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>i</mml:mi>
                      </mml:mrow>
                    </mml:msub>
                    <mml:mo class="MathClass-rel">|</mml:mo>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>h</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>i</mml:mi>
                      </mml:mrow>
                    </mml:msub>
                    <mml:mo class="MathClass-punc">,</mml:mo>
                    <mml:mspace class="tmspace" width="2.77695pt"/>
                    <mml:msup>
                      <mml:mrow>
                        <mml:mi mathvariant="normal">Φ</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mrow>
                          <mml:mo class="MathClass-open">(</mml:mo>
                          <mml:mrow>
                            <mml:mi>i</mml:mi>
                          </mml:mrow>
                          <mml:mo class="MathClass-close">)</mml:mo>
                        </mml:mrow>
                      </mml:mrow>
                    </mml:msup>
                  </mml:mrow>
                  <mml:mo class="MathClass-close">)</mml:mo>
                </mml:mrow>
                <mml:mo class="MathClass-rel">=</mml:mo>
                <mml:munder class="msub">
                  <mml:mrow>
                    <mml:mo mathsize="big"> ∏</mml:mo>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>j</mml:mi>
                    <mml:mo class="MathClass-rel">∈</mml:mo>
                    <mml:mi>X</mml:mi>
                    <mml:mrow>
                      <mml:mo class="MathClass-open">(</mml:mo>
                      <mml:mrow>
                        <mml:msub>
                          <mml:mrow>
                            <mml:mi>f</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mi>i</mml:mi>
                          </mml:mrow>
                        </mml:msub>
                      </mml:mrow>
                      <mml:mo class="MathClass-close">)</mml:mo>
                    </mml:mrow>
                  </mml:mrow>
                </mml:munder>
                <mml:msup>
                  <mml:mrow>
                    <mml:mi>p</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>e</mml:mi>
                  </mml:mrow>
                </mml:msup>
                <mml:mrow>
                  <mml:mo class="MathClass-open">(</mml:mo>
                  <mml:mrow>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>f</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>i</mml:mi>
                        <mml:mi>j</mml:mi>
                      </mml:mrow>
                    </mml:msub>
                    <mml:mo class="MathClass-rel">|</mml:mo>
                    <mml:msubsup>
                      <mml:mrow>
                        <mml:mi>φ</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>j</mml:mi>
                        <mml:msub>
                          <mml:mrow>
                            <mml:mi>h</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mi>i</mml:mi>
                          </mml:mrow>
                        </mml:msub>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mrow>
                          <mml:mo class="MathClass-open">(</mml:mo>
                          <mml:mrow>
                            <mml:mi>i</mml:mi>
                          </mml:mrow>
                          <mml:mo class="MathClass-close">)</mml:mo>
                        </mml:mrow>
                      </mml:mrow>
                    </mml:msubsup>
                  </mml:mrow>
                  <mml:mo class="MathClass-close">)</mml:mo>
                </mml:mrow>
              </mml:mrow>
            </mml:math>
          </disp-formula>
        </p>
        <p>where,</p>
        <p>
          <disp-formula>
            <mml:math id="M13" name="1471-2164-14-S2-S5-i12" overflow="scroll">
              <mml:mrow>
                <mml:msup>
                  <mml:mrow>
                    <mml:mi>p</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>e</mml:mi>
                  </mml:mrow>
                </mml:msup>
                <mml:mrow>
                  <mml:mo class="MathClass-open">(</mml:mo>
                  <mml:mrow>
                    <mml:mi>σ</mml:mi>
                    <mml:mo class="MathClass-rel">|</mml:mo>
                    <mml:msup>
                      <mml:mrow>
                        <mml:mi>σ</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>′</mml:mi>
                      </mml:mrow>
                    </mml:msup>
                  </mml:mrow>
                  <mml:mo class="MathClass-close">)</mml:mo>
                </mml:mrow>
                <mml:mo class="MathClass-rel">=</mml:mo>
                <mml:mfenced open="{">
                  <mml:mrow>
                    <mml:mtable class="array" columnlines="none none none none none none none none none none none none none none none none none none none" equalcolumns="false" equalrows="false">
                      <mml:mtr>
                        <mml:mtd class="array" columnalign="center">
                          <mml:mrow>
                            <mml:mo class="MathClass-open">(</mml:mo>
                            <mml:mrow>
                              <mml:mn>1</mml:mn>
                              <mml:mo class="MathClass-bin">-</mml:mo>
                              <mml:mi>α</mml:mi>
                            </mml:mrow>
                            <mml:mo class="MathClass-close">)</mml:mo>
                          </mml:mrow>
                        </mml:mtd>
                        <mml:mtd class="array" columnalign="center">
                          <mml:mstyle class="text">
                            <mml:mtext class="textsf" mathvariant="sans-serif">for</mml:mtext>
                          </mml:mstyle>
                          <mml:mspace class="tmspace" width="2.77695pt"/>
                          <mml:mi>σ</mml:mi>
                          <mml:mo class="MathClass-rel">=</mml:mo>
                          <mml:msup>
                            <mml:mrow>
                              <mml:mi>σ</mml:mi>
                            </mml:mrow>
                            <mml:mrow>
                              <mml:mi>′</mml:mi>
                            </mml:mrow>
                          </mml:msup>
                        </mml:mtd>
                      </mml:mtr>
                      <mml:mtr>
                        <mml:mtd class="array" columnalign="center">
                          <mml:mi>α</mml:mi>
                        </mml:mtd>
                        <mml:mtd class="array" columnalign="center">
                          <mml:mstyle class="text">
                            <mml:mtext class="textsf" mathvariant="sans-serif">for</mml:mtext>
                          </mml:mstyle>
                          <mml:mspace class="tmspace" width="2.77695pt"/>
                          <mml:mi>σ</mml:mi>
                          <mml:mo class="MathClass-rel">≠</mml:mo>
                          <mml:msup>
                            <mml:mrow>
                              <mml:mi>σ</mml:mi>
                            </mml:mrow>
                            <mml:mrow>
                              <mml:mi>′</mml:mi>
                            </mml:mrow>
                          </mml:msup>
                        </mml:mtd>
                      </mml:mtr>
                      <mml:mtr>
                        <mml:mtd class="array" columnalign="center"/>
                      </mml:mtr>
                    </mml:mtable>
                  </mml:mrow>
                </mml:mfenced>
              </mml:mrow>
            </mml:math>
          </disp-formula>
        </p>
        <p>is the probability that we observe <italic>σ </italic>∈ Σ when the true
allele is <italic>σ' </italic>∈ Σ and <italic>α </italic>represents the
sequence error rate which we assume is independent of fragments and positions.</p>
        <p>We take <italic>α </italic>as a fixed constant because it is better estimated from
other resources rather than from only the bases at the SNP sites. For example, we
may estimate <italic>α </italic>by using the all the read sequences or by using
information from other dedicated studies about sequencing and mapping errors. In
the following, we use <italic>α </italic>= 0.1 unless otherwise mentioned and the
dependency of the <italic>α </italic>is described in Additional file <xref ref-type="supplementary-material" rid="S1">1</xref>. We further assume the mixture probabilities are equal,
<italic>p<sup>m</sup></italic>(0) = <italic>p<sup>m</sup></italic>(1) = 0.5, as they often
converge to around 0.5. Therefore, the parameter set Θ that needs to be
optimized consists only of the set of phase probabilities: <inline-formula><mml:math id="M14" name="1471-2164-14-S2-S5-i13" overflow="scroll"><mml:mi mathvariant="normal">Θ</mml:mi><mml:mo class="MathClass-rel">=</mml:mo><mml:mrow><mml:mo class="MathClass-open">{</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mi>ν</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo class="MathClass-close">}</mml:mo></mml:mrow><mml:mo class="MathClass-rel">=</mml:mo><mml:mrow><mml:mo class="MathClass-open">{</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">Φ</mml:mi></mml:mrow></mml:msubsup><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:mi>ν</mml:mi></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow></mml:mrow><mml:mo class="MathClass-close">}</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
        <p>Let <inline-formula><mml:math id="M15" name="1471-2164-14-S2-S5-i14" overflow="scroll"><mml:msub><mml:mrow><mml:mi mathvariant="script">I</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>h</mml:mi><mml:mi>j</mml:mi><mml:mi>ν</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula>
be the indicator function that is one if fragment <italic>f<sub>i </sub></italic>is
derived from haplotype <italic>h</italic>, <italic>X</italic>(<italic>f<sub>i</sub></italic>) includes
<italic>j</italic>, and the haplotypes have phase <italic>ν </italic>at site <italic>j</italic>,
and that is zero otherwise. <inline-formula><mml:math id="M16" name="1471-2164-14-S2-S5-i15" overflow="scroll"><mml:msub><mml:mrow><mml:mi mathvariant="script">I</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>h</mml:mi><mml:mi>j</mml:mi><mml:mi>ν</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula>
is uniquely determined if the haplotype origins <italic>H </italic>= {<italic>h<sub>i</sub>|i
</italic>= 1, . . . , <italic>N</italic>} and phase vectors Ψ =
{Φ<sup>(<italic>i</italic>)</sup><italic>|i </italic>= 1, . . . , <italic>N</italic>} of fragments
<italic>F </italic>are specified. Then the marginalized likelihood <italic>P
</italic>(<italic>F|</italic>Θ) is given by</p>
        <p>
          <disp-formula>
            <mml:math id="M17" name="1471-2164-14-S2-S5-i16" overflow="scroll">
              <mml:mrow>
                <mml:mtable class="gathered">
                  <mml:mtr>
                    <mml:mtd>
                      <mml:mi>P</mml:mi>
                      <mml:mrow>
                        <mml:mo class="MathClass-open">(</mml:mo>
                        <mml:mrow>
                          <mml:mi>F</mml:mi>
                          <mml:mo class="MathClass-rel">|</mml:mo>
                          <mml:mi mathvariant="normal">Θ</mml:mi>
                        </mml:mrow>
                        <mml:mo class="MathClass-close">)</mml:mo>
                      </mml:mrow>
                      <mml:mo class="MathClass-rel">=</mml:mo>
                      <mml:munder class="msub">
                        <mml:mrow>
                          <mml:mo mathsize="big"> ∑</mml:mo>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi>H</mml:mi>
                          <mml:mo class="MathClass-punc">,</mml:mo>
                          <mml:mi mathvariant="normal">Ψ</mml:mi>
                        </mml:mrow>
                      </mml:munder>
                      <mml:mi>P</mml:mi>
                      <mml:mrow>
                        <mml:mo class="MathClass-open">(</mml:mo>
                        <mml:mrow>
                          <mml:mi>F</mml:mi>
                          <mml:mo class="MathClass-punc">,</mml:mo>
                          <mml:mspace class="tmspace" width="2.77695pt"/>
                          <mml:mi>H</mml:mi>
                          <mml:mo class="MathClass-punc">,</mml:mo>
                          <mml:mspace class="tmspace" width="2.77695pt"/>
                          <mml:mi mathvariant="normal">Ψ</mml:mi>
                          <mml:mo class="MathClass-rel">|</mml:mo>
                          <mml:mi mathvariant="normal">Θ</mml:mi>
                        </mml:mrow>
                        <mml:mo class="MathClass-close">)</mml:mo>
                      </mml:mrow>
                      <mml:mo class="MathClass-punc">,</mml:mo>
                    </mml:mtd>
                  </mml:mtr>
                  <mml:mtr>
                    <mml:mtd>
                      <mml:mtext>log</mml:mtext>
                      <mml:mrow>
                        <mml:mo class="MathClass-open">(</mml:mo>
                        <mml:mrow>
                          <mml:mi>P</mml:mi>
                          <mml:mrow>
                            <mml:mo class="MathClass-open">(</mml:mo>
                            <mml:mrow>
                              <mml:mi>F</mml:mi>
                              <mml:mo class="MathClass-punc">,</mml:mo>
                              <mml:mspace class="tmspace" width="2.77695pt"/>
                              <mml:mi>H</mml:mi>
                              <mml:mo class="MathClass-punc">,</mml:mo>
                              <mml:mspace class="tmspace" width="2.77695pt"/>
                              <mml:mi mathvariant="normal">Ψ</mml:mi>
                              <mml:mo class="MathClass-rel">|</mml:mo>
                              <mml:mi mathvariant="normal">Θ</mml:mi>
                            </mml:mrow>
                            <mml:mo class="MathClass-close">)</mml:mo>
                          </mml:mrow>
                        </mml:mrow>
                        <mml:mo class="MathClass-close">)</mml:mo>
                      </mml:mrow>
                      <mml:mo class="MathClass-rel">=</mml:mo>
                      <mml:mi>N</mml:mi>
                      <mml:mtext>log</mml:mtext>
                      <mml:mrow>
                        <mml:mo class="MathClass-open">(</mml:mo>
                        <mml:mrow>
                          <mml:mn>0</mml:mn>
                          <mml:mi>.</mml:mi>
                          <mml:mn>5</mml:mn>
                        </mml:mrow>
                        <mml:mo class="MathClass-close">)</mml:mo>
                      </mml:mrow>
                      <mml:mo class="MathClass-bin">+</mml:mo>
                    </mml:mtd>
                  </mml:mtr>
                  <mml:mtr>
                    <mml:mtd>
                      <mml:munderover accent="false" accentunder="false">
                        <mml:mrow>
                          <mml:mo mathsize="big"> ∑</mml:mo>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi>i</mml:mi>
                          <mml:mo class="MathClass-rel">=</mml:mo>
                          <mml:mn>1</mml:mn>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi>N</mml:mi>
                        </mml:mrow>
                      </mml:munderover>
                      <mml:munder class="msub">
                        <mml:mrow>
                          <mml:mo mathsize="big">∑</mml:mo>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi>h</mml:mi>
                          <mml:mo class="MathClass-rel">∈</mml:mo>
                          <mml:mi mathvariant="script">H</mml:mi>
                        </mml:mrow>
                      </mml:munder>
                      <mml:munder class="msub">
                        <mml:mrow>
                          <mml:mo mathsize="big">∑</mml:mo>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi>j</mml:mi>
                          <mml:mo class="MathClass-rel">∈</mml:mo>
                          <mml:mi>X</mml:mi>
                          <mml:mrow>
                            <mml:mo class="MathClass-open">(</mml:mo>
                            <mml:mrow>
                              <mml:msub>
                                <mml:mrow>
                                  <mml:mi>f</mml:mi>
                                </mml:mrow>
                                <mml:mrow>
                                  <mml:mi>i</mml:mi>
                                </mml:mrow>
                              </mml:msub>
                            </mml:mrow>
                            <mml:mo class="MathClass-close">)</mml:mo>
                          </mml:mrow>
                        </mml:mrow>
                      </mml:munder>
                      <mml:munder class="msub">
                        <mml:mrow>
                          <mml:mo mathsize="big">∑</mml:mo>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi>ν</mml:mi>
                          <mml:mo class="MathClass-rel">∈</mml:mo>
                          <mml:mi mathvariant="normal">Δ</mml:mi>
                        </mml:mrow>
                      </mml:munder>
                      <mml:msub>
                        <mml:mrow>
                          <mml:mi mathvariant="script">I</mml:mi>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi>i</mml:mi>
                          <mml:mi>h</mml:mi>
                          <mml:mi>j</mml:mi>
                          <mml:mi>ν</mml:mi>
                        </mml:mrow>
                      </mml:msub>
                      <mml:mrow>
                        <mml:mo class="MathClass-open">[</mml:mo>
                        <mml:mrow>
                          <mml:msub>
                            <mml:mrow>
                              <mml:mi>μ</mml:mi>
                            </mml:mrow>
                            <mml:mrow>
                              <mml:mi>i</mml:mi>
                              <mml:mi>h</mml:mi>
                              <mml:mi>j</mml:mi>
                              <mml:mi>ν</mml:mi>
                            </mml:mrow>
                          </mml:msub>
                          <mml:mo class="MathClass-bin">+</mml:mo>
                          <mml:mtext>log</mml:mtext>
                          <mml:msub>
                            <mml:mrow>
                              <mml:mi>θ</mml:mi>
                            </mml:mrow>
                            <mml:mrow>
                              <mml:mi>j</mml:mi>
                              <mml:mi>ν</mml:mi>
                            </mml:mrow>
                          </mml:msub>
                        </mml:mrow>
                        <mml:mo class="MathClass-close">]</mml:mo>
                      </mml:mrow>
                      <mml:mo class="MathClass-punc">,</mml:mo>
                    </mml:mtd>
                  </mml:mtr>
                  <mml:mtr>
                    <mml:mtd>
                      <mml:msub>
                        <mml:mrow>
                          <mml:mi>μ</mml:mi>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi>i</mml:mi>
                          <mml:mi>h</mml:mi>
                          <mml:mi>j</mml:mi>
                          <mml:mi>ν</mml:mi>
                        </mml:mrow>
                      </mml:msub>
                      <mml:mo class="MathClass-rel">=</mml:mo>
                      <mml:mtext>log</mml:mtext>
                      <mml:mrow>
                        <mml:mo class="MathClass-open">(</mml:mo>
                        <mml:mrow>
                          <mml:msup>
                            <mml:mrow>
                              <mml:mi>p</mml:mi>
                            </mml:mrow>
                            <mml:mrow>
                              <mml:mi>e</mml:mi>
                            </mml:mrow>
                          </mml:msup>
                          <mml:mrow>
                            <mml:mo class="MathClass-open">(</mml:mo>
                            <mml:mrow>
                              <mml:msub>
                                <mml:mrow>
                                  <mml:mi>f</mml:mi>
                                </mml:mrow>
                                <mml:mrow>
                                  <mml:mi>i</mml:mi>
                                  <mml:mi>j</mml:mi>
                                </mml:mrow>
                              </mml:msub>
                              <mml:mo class="MathClass-rel">|</mml:mo>
                              <mml:msub>
                                <mml:mrow>
                                  <mml:mi>ν</mml:mi>
                                </mml:mrow>
                                <mml:mrow>
                                  <mml:mi>h</mml:mi>
                                </mml:mrow>
                              </mml:msub>
                            </mml:mrow>
                            <mml:mo class="MathClass-close">)</mml:mo>
                          </mml:mrow>
                        </mml:mrow>
                        <mml:mo class="MathClass-close">)</mml:mo>
                      </mml:mrow>
                      <mml:mi>.</mml:mi>
                    </mml:mtd>
                  </mml:mtr>
                  <mml:mtr>
                    <mml:mtd/>
                  </mml:mtr>
                </mml:mtable>
              </mml:mrow>
            </mml:math>
          </disp-formula>
        </p>
        <p>We explain the difference between our model and the models of Kim [<xref ref-type="bibr" rid="B14">14</xref>] and Li [<xref ref-type="bibr" rid="B16">16</xref>] in Additional file <xref ref-type="supplementary-material" rid="S1">1</xref>.</p>
      </sec>
      <sec>
        <title>The minimum connectivity score</title>
        <p>As described above, the two haplotypes <inline-formula><inline-graphic xlink:href="1471-2164-14-S2-S5-i43.gif"/></inline-formula> in the SIH problem have no
particular identity and it is not possible to predict which of them converges to
the actual paternal or maternal chromosome. In relation to this, the likelihood
function <italic>P </italic>(<italic>F</italic>, <italic>H</italic>, Ψ<italic>|</italic>Θ) has a
symmetry between the switched configurations: <inline-formula><mml:math id="M18" name="1471-2164-14-S2-S5-i17" overflow="scroll"><mml:mrow><mml:mi>P</mml:mi><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:mi>F</mml:mi><mml:mo class="MathClass-punc">,</mml:mo><mml:mover accent="true"><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mo class="MathClass-op">
¯</mml:mo></mml:mover><mml:mo class="MathClass-punc">,</mml:mo><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="normal">Ψ</mml:mi></mml:mrow><mml:mo class="MathClass-op">¯</mml:mo></mml:mover><mml:mo class="MathClass-rel">|</mml:mo><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="normal">Θ</mml:mi></mml:mrow><mml:mo class="MathClass-op">¯</mml:mo></mml:mover></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow><mml:mo class="MathClass-rel">=</mml:mo><mml:mi>P</mml:mi><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:mi>F</mml:mi><mml:mo class="MathClass-punc">,</mml:mo><mml:mi>H</mml:mi><mml:mo class="MathClass-punc">,</mml:mo><mml:mi mathvariant="normal">Ψ</mml:mi><mml:mo class="MathClass-rel">|</mml:mo><mml:mi mathvariant="normal">Θ</mml:mi></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>, where
<inline-formula><mml:math id="M19" name="1471-2164-14-S2-S5-i18" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mo class="MathClass-op">
¯</mml:mo></mml:mover><mml:mo class="MathClass-rel">=</mml:mo><mml:mrow><mml:mo class="MathClass-open">{</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mo class="MathClass-op">
¯</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo class="MathClass-rel">|</mml:mo><mml:mi>i</mml:mi><mml:mo class="MathClass-rel">=</mml:mo><mml:mn>1</mml:mn><mml:mo class="MathClass-punc">,</mml:mo><mml:mo class="MathClass-op">…</mml:mo><mml:mo class="MathClass-punc">,</mml:mo><mml:mi>N</mml:mi></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> and
<inline-formula><mml:math id="M20" name="1471-2164-14-S2-S5-i19" overflow="scroll"><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="normal">Ψ</mml:mi></mml:mrow><mml:mo class="MathClass-op">¯</mml:mo></mml:mover><mml:mo class="MathClass-rel">=</mml:mo><mml:mrow><mml:mo class="MathClass-open">{</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="normal">Φ</mml:mi></mml:mrow><mml:mo class="MathClass-op">¯</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow></mml:mrow></mml:msup><mml:mo class="MathClass-rel">|</mml:mo><mml:mi>i</mml:mi><mml:mo class="MathClass-rel">=</mml:mo><mml:mn>1</mml:mn><mml:mo class="MathClass-punc">,</mml:mo><mml:mo class="MathClass-op">…</mml:mo><mml:mo class="MathClass-punc">,</mml:mo><mml:mi>N</mml:mi></mml:mrow><mml:mo class="MathClass-close">}</mml:mo></mml:mrow></mml:math></inline-formula> represent the
configuration that all the haplotype origins of the fragments are exchanged, and
<inline-formula><mml:math id="M21" name="1471-2164-14-S2-S5-i20" overflow="scroll"><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="normal">Θ</mml:mi></mml:mrow><mml:mo class="MathClass-op">¯</mml:mo></mml:mover><mml:mo class="MathClass-rel">=</mml:mo><mml:mrow><mml:mo class="MathClass-open">{</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mo class="MathClass-op">¯</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mi>v</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo class="MathClass-close">}</mml:mo></mml:mrow><mml:mo class="MathClass-punc">,</mml:mo><mml:msub><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mo class="MathClass-op">¯</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mi>v</mml:mi></mml:mrow></mml:msub><mml:mo class="MathClass-rel">=</mml:mo><mml:msub><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mover accent="true"><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mo class="MathClass-op">
¯</mml:mo></mml:mover></mml:mrow></mml:msub></mml:math></inline-formula> are the
switched phase probabilities. Therefore, the marginal likelihood
<inline-formula><mml:math id="M22" name="1471-2164-14-S2-S5-i21" overflow="scroll"><mml:mi>P</mml:mi><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:mi>F</mml:mi><mml:mo class="MathClass-rel">|</mml:mo><mml:mi mathvariant="normal">Θ</mml:mi></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow><mml:mo class="MathClass-rel">=</mml:mo><mml:msub><mml:mrow><mml:mo class="MathClass-op">
∑</mml:mo></mml:mrow><mml:mrow><mml:mi>H</mml:mi><mml:mo class="MathClass-punc">,</mml:mo><mml:mi mathvariant="normal">Ψ</mml:mi></mml:mrow></mml:msub><mml:mi>P</mml:mi><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:mi>F</mml:mi><mml:mo class="MathClass-punc">,</mml:mo><mml:mi>H</mml:mi><mml:mo class="MathClass-punc">,</mml:mo><mml:mi mathvariant="normal">Ψ</mml:mi><mml:mo class="MathClass-rel">|</mml:mo><mml:mi mathvariant="normal">Θ</mml:mi></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow></mml:math></inline-formula> is
symmetric for the two parameter sets: <inline-formula><mml:math id="M23" name="1471-2164-14-S2-S5-i22" overflow="scroll"><mml:mi>P</mml:mi><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:mi>F</mml:mi><mml:mo class="MathClass-rel">|</mml:mo><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="normal">Θ</mml:mi></mml:mrow><mml:mo class="MathClass-op">¯</mml:mo></mml:mover></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow><mml:mo class="MathClass-rel">=</mml:mo><mml:mi>P</mml:mi><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:mi>F</mml:mi><mml:mo class="MathClass-rel">|</mml:mo><mml:mi mathvariant="normal">Θ</mml:mi></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
        <p>Suppose that the probabilistic model is optimized for two segments of SNP sites
between which there are no connecting fragments, then the association of the
haplotypes {0, 1} to the true paternal and maternal chromosomes are selected at
random for each segment. Even if there are several connecting fragments, the
associations in each segment are determined almost randomly if the number of
connecting fragments is not sufficient or there are many conflicting fragments.
Such sites often cause switch errors. We define the connectivity at site
<italic>j</italic><sub>0 </sub>as a log ratio of the marginal log likelihoods:</p>
        <p>
          <disp-formula>
            <mml:math id="M24" name="1471-2164-14-S2-S5-i23" overflow="scroll">
              <mml:mi mathvariant="normal">connectivity</mml:mi>
              <mml:mrow>
                <mml:mo class="MathClass-open">(</mml:mo>
                <mml:mrow>
                  <mml:msub>
                    <mml:mrow>
                      <mml:mi>j</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mn>0</mml:mn>
                    </mml:mrow>
                  </mml:msub>
                </mml:mrow>
                <mml:mo class="MathClass-close">)</mml:mo>
              </mml:mrow>
              <mml:mo class="MathClass-rel">=</mml:mo>
              <mml:mtext>log</mml:mtext>
              <mml:mfenced close=")" open="(">
                <mml:mrow>
                  <mml:mfrac>
                    <mml:mrow>
                      <mml:mi>P</mml:mi>
                      <mml:mrow>
                        <mml:mo class="MathClass-open">(</mml:mo>
                        <mml:mrow>
                          <mml:mi>F</mml:mi>
                          <mml:mo class="MathClass-rel">|</mml:mo>
                          <mml:mi mathvariant="normal">Θ</mml:mi>
                        </mml:mrow>
                        <mml:mo class="MathClass-close">)</mml:mo>
                      </mml:mrow>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi>P</mml:mi>
                      <mml:mrow>
                        <mml:mo class="MathClass-open">(</mml:mo>
                        <mml:mrow>
                          <mml:mi>F</mml:mi>
                          <mml:mo class="MathClass-rel">|</mml:mo>
                          <mml:msup>
                            <mml:mrow>
                              <mml:mi mathvariant="normal">Θ</mml:mi>
                            </mml:mrow>
                            <mml:mrow>
                              <mml:mi>′</mml:mi>
                            </mml:mrow>
                          </mml:msup>
                        </mml:mrow>
                        <mml:mo class="MathClass-close">)</mml:mo>
                      </mml:mrow>
                    </mml:mrow>
                  </mml:mfrac>
                </mml:mrow>
              </mml:mfenced>
              <mml:mo class="MathClass-rel">=</mml:mo>
              <mml:mtext>log</mml:mtext>
              <mml:mfenced close=")" open="(">
                <mml:mrow>
                  <mml:mfrac>
                    <mml:mrow>
                      <mml:mi>P</mml:mi>
                      <mml:mrow>
                        <mml:mo class="MathClass-open">(</mml:mo>
                        <mml:mrow>
                          <mml:msup>
                            <mml:mrow>
                              <mml:mi>F</mml:mi>
                            </mml:mrow>
                            <mml:mrow>
                              <mml:mi>c</mml:mi>
                            </mml:mrow>
                          </mml:msup>
                          <mml:mrow>
                            <mml:mo class="MathClass-open">(</mml:mo>
                            <mml:mrow>
                              <mml:msub>
                                <mml:mrow>
                                  <mml:mi>j</mml:mi>
                                </mml:mrow>
                                <mml:mrow>
                                  <mml:mn>0</mml:mn>
                                </mml:mrow>
                              </mml:msub>
                            </mml:mrow>
                            <mml:mo class="MathClass-close">)</mml:mo>
                          </mml:mrow>
                          <mml:mo class="MathClass-rel">|</mml:mo>
                          <mml:mi mathvariant="normal">Θ</mml:mi>
                        </mml:mrow>
                        <mml:mo class="MathClass-close">)</mml:mo>
                      </mml:mrow>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi>P</mml:mi>
                      <mml:mrow>
                        <mml:mo class="MathClass-open">(</mml:mo>
                        <mml:mrow>
                          <mml:msup>
                            <mml:mrow>
                              <mml:mi>F</mml:mi>
                            </mml:mrow>
                            <mml:mrow>
                              <mml:mi>c</mml:mi>
                            </mml:mrow>
                          </mml:msup>
                          <mml:mrow>
                            <mml:mo class="MathClass-open">(</mml:mo>
                            <mml:mrow>
                              <mml:msub>
                                <mml:mrow>
                                  <mml:mi>j</mml:mi>
                                </mml:mrow>
                                <mml:mrow>
                                  <mml:mn>0</mml:mn>
                                </mml:mrow>
                              </mml:msub>
                            </mml:mrow>
                            <mml:mo class="MathClass-close">)</mml:mo>
                          </mml:mrow>
                          <mml:mo class="MathClass-rel">|</mml:mo>
                          <mml:msup>
                            <mml:mrow>
                              <mml:mi mathvariant="normal">Θ</mml:mi>
                            </mml:mrow>
                            <mml:mrow>
                              <mml:mi>′</mml:mi>
                            </mml:mrow>
                          </mml:msup>
                        </mml:mrow>
                        <mml:mo class="MathClass-close">)</mml:mo>
                      </mml:mrow>
                    </mml:mrow>
                  </mml:mfrac>
                </mml:mrow>
              </mml:mfenced>
            </mml:math>
          </disp-formula>
        </p>
        <p>Where <inline-formula><mml:math id="M25" name="1471-2164-14-S2-S5-i24" overflow="scroll"><mml:msup><mml:mrow><mml:mi mathvariant="normal">Θ</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msup><mml:mo class="MathClass-rel">=</mml:mo><mml:mrow><mml:mo class="MathClass-open">{</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msubsup></mml:mrow><mml:mo class="MathClass-close">}</mml:mo></mml:mrow></mml:math></inline-formula>
with <inline-formula><mml:math id="M26" name="1471-2164-14-S2-S5-i25" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msubsup><mml:mo class="MathClass-rel">=</mml:mo><mml:msub><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mi>v</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula>
for <italic>j </italic>&lt;<italic>j</italic><sub>0 </sub>and <inline-formula><mml:math id="M27" name="1471-2164-14-S2-S5-i26" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msubsup><mml:mo class="MathClass-rel">=</mml:mo><mml:msub><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mo class="MathClass-op">¯</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mi>v</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula>
for <italic>j </italic>≥ <italic>j</italic><sub>0</sub>. The second equality follows from
the symmetry of <italic>P </italic>(<italic>F|</italic>Θ) described above, and shows that
only the fragments covering site <italic>j</italic><sub>0 </sub>are necessary to compute
the connectivity of site <italic>j</italic><sub>0</sub>. The connectivity measures the
resilience of the assembly result against swapping the two haplotypes 0 and 1 in
the right part <italic>j </italic>= <italic>j</italic><sub>0</sub>, . . . , <italic>M </italic>of the
sites. We refer to this change of parameters Θ <italic>→ </italic>Θ<italic>'
</italic>as <italic>twisting the parameters at site </italic><italic>j</italic><sub>0</sub>.</p>
        <p>For each pair of sites (<italic>j</italic><sub>1</sub>, <italic>j</italic><sub>2</sub>)
(<italic>j</italic><sub>1 </sub><italic>&lt; j</italic><sub>2</sub>), we define the minimum
connectivity (MC) score as</p>
        <p>
          <disp-formula>
            <mml:math id="M28" name="1471-2164-14-S2-S5-i27" overflow="scroll">
              <mml:mrow>
                <mml:mstyle class="text">
                  <mml:mtext class="textsf" mathvariant="sans-serif">MC</mml:mtext>
                </mml:mstyle>
                <mml:mrow>
                  <mml:mo class="MathClass-open">(</mml:mo>
                  <mml:mrow>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>j</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mn>1</mml:mn>
                      </mml:mrow>
                    </mml:msub>
                    <mml:mo class="MathClass-punc">,</mml:mo>
                    <mml:mspace class="tmspace" width="2.77695pt"/>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>j</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mn>2</mml:mn>
                      </mml:mrow>
                    </mml:msub>
                  </mml:mrow>
                  <mml:mo class="MathClass-close">)</mml:mo>
                </mml:mrow>
                <mml:mo class="MathClass-rel">=</mml:mo>
                <mml:munder class="msub">
                  <mml:mrow>
                    <mml:mtext>min</mml:mtext>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>j</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mn>1</mml:mn>
                      </mml:mrow>
                    </mml:msub>
                    <mml:mo class="MathClass-rel">&lt;</mml:mo>
                    <mml:mi>j</mml:mi>
                    <mml:mo class="MathClass-rel">≤</mml:mo>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>j</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mn>2</mml:mn>
                      </mml:mrow>
                    </mml:msub>
                  </mml:mrow>
                </mml:munder>
                <mml:mstyle class="text">
                  <mml:mtext class="textsf" mathvariant="sans-serif">connectivity</mml:mtext>
                </mml:mstyle>
                <mml:mrow>
                  <mml:mo class="MathClass-open">(</mml:mo>
                  <mml:mrow>
                    <mml:mi>j</mml:mi>
                  </mml:mrow>
                  <mml:mo class="MathClass-close">)</mml:mo>
                </mml:mrow>
                <mml:mi>.</mml:mi>
              </mml:mrow>
            </mml:math>
          </disp-formula>
        </p>
        <p>We extract confidently assembled regions by selecting the pairs
(<italic>j</italic><sub>1</sub>, <italic>j</italic><sub>2</sub>) with high MC values. From the
above definition, it is obvious that if the MC value is higher than a given
threshold for some pair (<italic>j</italic><sub>1</sub>, <italic>j</italic><sub>2</sub>), then all
the pairs inside range [<italic>j</italic><sub>1</sub>, <italic> j</italic><sub>2</sub>] have MC
values higher than the threshold. In this sense, MC(<italic>j</italic><sub>1</sub>, <italic>
j</italic><sub>2</sub>) can be considered as defined on the range
[<italic>j</italic><sub>1</sub>, <italic> j</italic><sub>2</sub>].</p>
      </sec>
      <sec>
        <title>Variational bayesian inference</title>
        <p>We use the VBEM algorithm to optimize the parameters Θ [<xref ref-type="bibr" rid="B29">29</xref>]. We approximate the Bayesian posterior
distribution <italic>P </italic>(<italic>H</italic>, Ψ, Θ<italic>|F</italic>) with factorized
variational functions <italic>Q</italic>(<italic>H</italic>, Ψ, Θ) =
<italic>Q<sup>H</sup></italic><sup>Ψ</sup>(<italic>H</italic>, Ψ)
·<italic>Q</italic><sup>Θ</sup>(Θ) such that the Kullback-Leibler
divergence <italic>KL<sub>H</sub></italic><sub>ΨΘ</sub>(<italic>Q</italic>(<italic>H</italic>,
Ψ, Θ)<italic>||P </italic>(<italic>H</italic>, Ψ, Θ<italic>|F</italic>)) between the
two distributions is minimized. The solution to this optimization problem has the
form</p>
        <p>
          <disp-formula>
            <mml:math id="M29" name="1471-2164-14-S2-S5-i28" overflow="scroll">
              <mml:mrow>
                <mml:mtable class="gathered">
                  <mml:mtr>
                    <mml:mtd>
                      <mml:msup>
                        <mml:mrow>
                          <mml:mi>Q</mml:mi>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi>H</mml:mi>
                          <mml:mi mathvariant="normal">Ψ</mml:mi>
                        </mml:mrow>
                      </mml:msup>
                      <mml:mrow>
                        <mml:mo class="MathClass-open">(</mml:mo>
                        <mml:mrow>
                          <mml:mi>H</mml:mi>
                          <mml:mo class="MathClass-punc">,</mml:mo>
                          <mml:mspace class="tmspace" width="2.77695pt"/>
                          <mml:mi mathvariant="normal">Ψ</mml:mi>
                        </mml:mrow>
                        <mml:mo class="MathClass-close">)</mml:mo>
                      </mml:mrow>
                      <mml:mo class="MathClass-rel">=</mml:mo>
                      <mml:mfrac>
                        <mml:mrow>
                          <mml:mn>1</mml:mn>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:msup>
                            <mml:mrow>
                              <mml:mi>Z</mml:mi>
                            </mml:mrow>
                            <mml:mrow>
                              <mml:mi>H</mml:mi>
                              <mml:mi mathvariant="normal">Ψ</mml:mi>
                            </mml:mrow>
                          </mml:msup>
                        </mml:mrow>
                      </mml:mfrac>
                      <mml:mtext>exp</mml:mtext>
                      <mml:mfenced close=")" open="(">
                        <mml:mrow>
                          <mml:munderover accent="false" accentunder="false">
                            <mml:mrow>
                              <mml:mo mathsize="big">∑</mml:mo>
                            </mml:mrow>
                            <mml:mrow>
                              <mml:mi>i</mml:mi>
                              <mml:mo class="MathClass-rel">=</mml:mo>
                              <mml:mn>1</mml:mn>
                            </mml:mrow>
                            <mml:mrow>
                              <mml:mi>N</mml:mi>
                            </mml:mrow>
                          </mml:munderover>
                          <mml:munder class="msub">
                            <mml:mrow>
                              <mml:mo mathsize="big">∑</mml:mo>
                            </mml:mrow>
                            <mml:mrow>
                              <mml:mi>h</mml:mi>
                              <mml:mo class="MathClass-rel">∈</mml:mo>
                              <mml:mi mathvariant="script">H</mml:mi>
                            </mml:mrow>
                          </mml:munder>
                          <mml:munder class="msub">
                            <mml:mrow>
                              <mml:mo mathsize="big">∑</mml:mo>
                            </mml:mrow>
                            <mml:mrow>
                              <mml:mi>j</mml:mi>
                              <mml:mo class="MathClass-rel">∈</mml:mo>
                              <mml:mi>X</mml:mi>
                              <mml:mrow>
                                <mml:mo class="MathClass-open">(</mml:mo>
                                <mml:mrow>
                                  <mml:msub>
                                    <mml:mrow>
                                      <mml:mi>f</mml:mi>
                                    </mml:mrow>
                                    <mml:mrow>
                                      <mml:mi>i</mml:mi>
                                    </mml:mrow>
                                  </mml:msub>
                                </mml:mrow>
                                <mml:mo class="MathClass-close">)</mml:mo>
                              </mml:mrow>
                            </mml:mrow>
                          </mml:munder>
                          <mml:munder class="msub">
                            <mml:mrow>
                              <mml:mo mathsize="big">∑</mml:mo>
                            </mml:mrow>
                            <mml:mrow>
                              <mml:mi>v</mml:mi>
                              <mml:mo class="MathClass-rel">∈</mml:mo>
                              <mml:mi mathvariant="normal">Δ</mml:mi>
                            </mml:mrow>
                          </mml:munder>
                          <mml:msub>
                            <mml:mrow>
                              <mml:mi mathvariant="script">I</mml:mi>
                            </mml:mrow>
                            <mml:mrow>
                              <mml:mi>i</mml:mi>
                              <mml:mi>h</mml:mi>
                              <mml:mi>j</mml:mi>
                              <mml:mi>v</mml:mi>
                            </mml:mrow>
                          </mml:msub>
                          <mml:mtext>log</mml:mtext>
                          <mml:mrow>
                            <mml:mo class="MathClass-open">(</mml:mo>
                            <mml:mrow>
                              <mml:msub>
                                <mml:mrow>
                                  <mml:mi>β</mml:mi>
                                </mml:mrow>
                                <mml:mrow>
                                  <mml:mi>i</mml:mi>
                                  <mml:mi>h</mml:mi>
                                  <mml:mi>j</mml:mi>
                                  <mml:mi>ν</mml:mi>
                                </mml:mrow>
                              </mml:msub>
                            </mml:mrow>
                            <mml:mo class="MathClass-close">)</mml:mo>
                          </mml:mrow>
                        </mml:mrow>
                      </mml:mfenced>
                      <mml:mo class="MathClass-punc">,</mml:mo>
                    </mml:mtd>
                  </mml:mtr>
                  <mml:mtr>
                    <mml:mtd>
                      <mml:msup>
                        <mml:mrow>
                          <mml:mi>Q</mml:mi>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi mathvariant="normal">Θ</mml:mi>
                        </mml:mrow>
                      </mml:msup>
                      <mml:mrow>
                        <mml:mo class="MathClass-open">(</mml:mo>
                        <mml:mrow>
                          <mml:mi mathvariant="normal">Θ</mml:mi>
                        </mml:mrow>
                        <mml:mo class="MathClass-close">)</mml:mo>
                      </mml:mrow>
                      <mml:mo class="MathClass-rel">=</mml:mo>
                      <mml:munderover accent="false" accentunder="false">
                        <mml:mrow>
                          <mml:mo mathsize="big"> ∏</mml:mo>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi>j</mml:mi>
                          <mml:mo class="MathClass-rel">=</mml:mo>
                          <mml:mn>1</mml:mn>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi>M</mml:mi>
                        </mml:mrow>
                      </mml:munderover>
                      <mml:mstyle class="text">
                        <mml:mtext class="textsf" mathvariant="sans-serif">Dir</mml:mtext>
                      </mml:mstyle>
                      <mml:mrow>
                        <mml:mo class="MathClass-open">(</mml:mo>
                        <mml:mrow>
                          <mml:msub>
                            <mml:mrow>
                              <mml:mi>θ</mml:mi>
                            </mml:mrow>
                            <mml:mrow>
                              <mml:mi>j</mml:mi>
                            </mml:mrow>
                          </mml:msub>
                          <mml:mo class="MathClass-rel">|</mml:mo>
                          <mml:msub>
                            <mml:mrow>
                              <mml:mi>λ</mml:mi>
                            </mml:mrow>
                            <mml:mrow>
                              <mml:mi>j</mml:mi>
                            </mml:mrow>
                          </mml:msub>
                        </mml:mrow>
                        <mml:mo class="MathClass-close">)</mml:mo>
                      </mml:mrow>
                      <mml:mo class="MathClass-punc">,</mml:mo>
                    </mml:mtd>
                  </mml:mtr>
                  <mml:mtr>
                    <mml:mtd/>
                  </mml:mtr>
                </mml:mtable>
              </mml:mrow>
            </mml:math>
          </disp-formula>
        </p>
        <p>where <italic>Z<sup>H</sup></italic><sup>Ψ </sup>is a normalization constant,
<italic>β<sub>ihjν </sub></italic>and <italic>λ<sub>jν
</sub></italic>represent the hyperparameters that specify the posterior distributions,
and Dir(<italic>θ<sub>j</sub>|λ<sub>j</sub></italic>) is the Dirichlet
probability distribution of <italic>|</italic>Δ<italic>| </italic>parameters. Because
<italic>Q<sup>H</sup></italic><sup>Ψ</sup>(<italic>H</italic>, Ψ) and
<italic>Q</italic><sup>Θ</sup>(Θ) are connected through the dependencies
among the hyperparameters, they cannot be found simultaneously. Therefore, we
optimize <italic>β<sub>ihjν </sub></italic>and <italic>λ<sub>jν
</sub></italic>by an iterative method.</p>
        <p>In our model, the parameters often converge to sub-optimal solutions, because
switch errors existing in the sub-optimal configurations are not removed by
gradual parameter changes. Therefore, we apply a heuristic procedure that re-runs
the VBEM several times with twisted parameter configurations after every
convergence:</p>
        <p>1. Do VBEM and calculate the connectivities for all the sites.</p>
        <p>2. Do another VBEM with a parameter set Λ that is twisted at a
site with low connectivity.</p>
        <p>3. Repeat until convergence.</p>
        <p>Here, the twist of hyperparameters Λ = {<italic>λ<sub>jν</sub></italic>} is
defined similarly to that of parameters Θ =
{<italic>θ<sub>jν</sub></italic>}. We describe the details of this procedure
in Additional file <xref ref-type="supplementary-material" rid="S1">1</xref>.</p>
      </sec>
      <sec>
        <title>Inferring haplotypes</title>
        <p>We set <inline-formula><mml:math id="M30" name="1471-2164-14-S2-S5-i29" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">Φ</mml:mi></mml:mrow></mml:msubsup><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow></mml:math></inline-formula> to
the posterior mean estimate of <italic>θ<sub>jv </sub></italic>with respect to the
converged posterior distribution:</p>
        <p>
          <disp-formula>
            <mml:math id="M31" name="1471-2164-14-S2-S5-i30" overflow="scroll">
              <mml:mrow>
                <mml:msubsup>
                  <mml:mrow>
                    <mml:mi>p</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>j</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi mathvariant="normal">Φ</mml:mi>
                  </mml:mrow>
                </mml:msubsup>
                <mml:mrow>
                  <mml:mo class="MathClass-open">(</mml:mo>
                  <mml:mrow>
                    <mml:mi>v</mml:mi>
                  </mml:mrow>
                  <mml:mo class="MathClass-close">)</mml:mo>
                </mml:mrow>
                <mml:mo class="MathClass-rel">=</mml:mo>
                <mml:mo class="MathClass-op"> ∫ </mml:mo>
                <mml:mi>d</mml:mi>
                <mml:mi mathvariant="normal">Θ</mml:mi>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>θ</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>j</mml:mi>
                    <mml:mi>v</mml:mi>
                  </mml:mrow>
                </mml:msub>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>Q</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi mathvariant="normal">Θ</mml:mi>
                  </mml:mrow>
                </mml:msub>
                <mml:mrow>
                  <mml:mo class="MathClass-open">(</mml:mo>
                  <mml:mrow>
                    <mml:mi mathvariant="normal">Θ</mml:mi>
                  </mml:mrow>
                  <mml:mo class="MathClass-close">)</mml:mo>
                </mml:mrow>
                <mml:mo class="MathClass-rel">=</mml:mo>
                <mml:mfrac>
                  <mml:mrow>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>λ</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>j</mml:mi>
                        <mml:mi>v</mml:mi>
                      </mml:mrow>
                    </mml:msub>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mo mathsize="big">∑</mml:mo>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:msup>
                          <mml:mrow>
                            <mml:mi>v</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mi>′</mml:mi>
                          </mml:mrow>
                        </mml:msup>
                      </mml:mrow>
                    </mml:msub>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>λ</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>j</mml:mi>
                        <mml:msup>
                          <mml:mrow>
                            <mml:mi>v</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mi>′</mml:mi>
                          </mml:mrow>
                        </mml:msup>
                      </mml:mrow>
                    </mml:msub>
                  </mml:mrow>
                </mml:mfrac>
                <mml:mi>.</mml:mi>
              </mml:mrow>
            </mml:math>
          </disp-formula>
        </p>
        <p>We select the phase <italic>ν </italic>at site <italic>j </italic>for which this
<inline-formula><mml:math id="M32" name="1471-2164-14-S2-S5-i31" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">Φ</mml:mi></mml:mrow></mml:msubsup><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow></mml:math></inline-formula> is
the highest. We limit the predicted haplotype segments to the regions with high MC
values.</p>
      </sec>
      <sec>
        <title>Possible extensions of the model</title>
        <p>In this paper, we consider only the binary representation of heterozygous sites.
We also constrain the error rate to be constant throughout the sequence. However,
some of these constraints are easily removed. We can include homozygous sites and
four nucleotide alleles by expanding the phase set Δ. For example, the phase
set of a multi-allelic variant is represented like Δ =
{(A,C),(A,G),(C,A),(C,G),(G,A),(G,C)}. We can even include small structural
variations if they can be represented by additional allele symbols and the phase
set of a structural variant is represented such as Δ<sub>1 </sub>=
{(A,-),(-,A)} for indel and Δ<sub>2 </sub>= {("AC","ACAC"),("ACAC","AC")} for
short tandem repeats. With these extensions, the accuracy of genotype calling of
multi-allelic variants from sequencing data might be improved by considering
haplotypes simultaneously [<xref ref-type="bibr" rid="B30">30</xref>] and the
accuracy and the recall of the haplotype region might be improved because all
variant sites add information to infer the derivation of the fragments.
Furthermore, we can make the error probability matrix
<italic>p<sup>e</sup></italic>(<italic>σ|σ'</italic>) dependent on the alleles of
each fragment, which may be useful for incorporating the quality scores of
sequenced reads.</p>
      </sec>
    </sec>
  </sec>
  <sec>
    <title>Datasets and data processing</title>
    <sec>
      <title>Dataset generation</title>
      <p>Simulation data were created through a strategy similar to the one reported by Geraci
[<xref ref-type="bibr" rid="B31">31</xref>]. We first generated <italic>M
</italic>binary heterozygous phase vectors and then we generated SNP fragments by
replicating each haplotype <italic>c </italic>times and randomly dividing them into
subsequences of length between <italic>l</italic><sub>1 </sub>and <italic>l</italic><sub>2</sub>. We
then randomly flipped the binary values of the fragments from 0(1) to 1(0) with
probability <italic>e</italic>. In the following, we use <italic>M </italic>= 1000, <italic>c </italic>= 5,
<italic>l</italic><sub>1 </sub>= 3, <italic>l</italic><sub>2 </sub>= 7 and <italic>e </italic>= 0.1 unless
otherwise mentioned.</p>
      <p>For the real data, we used the dataset of Duitama's work [<xref ref-type="bibr" rid="B13">13</xref>], who conducted fosmid pool-based next-generation
sequencing for HapMap trio child NA12878 from the CEU population. NA12878 had about
1.65 × 10<sup>6 </sup>heterozygous sites on autosomal chromosome and the
haplotypes of about 1.36<italic>×</italic>10<sup>6 </sup>sites were determined by a
trio-based statistical phasing method [<xref ref-type="bibr" rid="B18">18</xref>].
In the fosmid pool-based next-generation sequencing, the diploid genomic DNA was
fragmented into pieces of length about 40 kilo-bases, and partitioned into 32 pools
with low concentration, so that the fragments were long enough to span several
heterozygous sites and each pool rarely contained homologous chromosomal regions of
different haplotypes. Each pool was sequenced separately using a next-generation
sequencer and the read data were mapped onto the reference genome. Since a read
cluster in which the reads were close to each other and had the same pool origin were
supposed to originate from the same DNA fragment, the alleles observed in the same
cluster were merged into a SNP fragment. Duitama [<xref ref-type="bibr" rid="B13">13</xref>] converted the fragment data to a binary representation by
collecting only the alleles of the heterozygous sites determined by the 1000 genomes
project. The coverage of the data was about 3.03. We used the trio-based data and the
sequencing data in binary format for our experiment.</p>
      <p>The normalized linkage disequilibrium <italic>D' </italic>for the CEU population was
downloaded from the HapMap Project [<xref ref-type="bibr" rid="B2">2</xref>].</p>
      <p>We compared our MixSIH software with ReFHap [<xref ref-type="bibr" rid="B13">13</xref>], FastHare [<xref ref-type="bibr" rid="B17">17</xref>], DGS
[<xref ref-type="bibr" rid="B15">15</xref>], which were implemented by Duitama
[<xref ref-type="bibr" rid="B13">13</xref>], and HapCUT [<xref ref-type="bibr" rid="B11">11</xref>]. We selected these algorithms because they have
been shown to be superior to other algorithms [<xref ref-type="bibr" rid="B13">13</xref>].</p>
      <p>For the comparison of the runtimes, we generated simulation data with <italic>M </italic>=
100, 200, 500, 1000. We repeated the measurement 10 times for each <italic>M </italic>and the
average runtimes are reported here. The computations were performed on a cluster of
Linux machines equipped with dual Xeon X5550 processors and 24 GB RAM.</p>
    </sec>
    <sec>
      <title>Accuracy measures</title>
      <p>As described in the introduction, our algorithm is focusing on extracting the
reliable haplotype regions. To examine whether we have succeeded in extracting the
reliable haplotype regions, an accuracy measure which evaluates the quality of the
piecewise haplotype regions is needed. However, existing accuracy measures are
designed to compare the efficiency between the algorithms and are not suitable for
evaluating the quality of the piecewise haplotype regions.</p>
      <p>Let Φ<sup>(<italic>t</italic>) </sup>be the true haplotypes, and Φ be inferred
haplotypes. Because the inferred haplotypes Φ are sets of partially assembled
haplotype segments Φ = (Φ<sub>1</sub>, Φ<sub>2</sub>, <italic> . . .
</italic>, Φ<italic><sub>B</sub></italic>) where each of Φ<italic><sub>b </sub></italic>is
independently predicted, the accuracy measures have to be applicable for such
predictions.</p>
      <p>Many previous papers used the Hamming distance to measure the quality of assembled
haplotypes [<xref ref-type="bibr" rid="B31">31</xref>]:</p>
      <p>
        <disp-formula>
          <mml:math id="M33" name="1471-2164-14-S2-S5-i32" overflow="scroll">
            <mml:mrow>
              <mml:mtable class="gathered">
                <mml:mtr>
                  <mml:mtd>
                    <mml:mi>R</mml:mi>
                    <mml:mrow>
                      <mml:mo class="MathClass-open">(</mml:mo>
                      <mml:mrow>
                        <mml:msub>
                          <mml:mrow>
                            <mml:mi mathvariant="normal">Φ</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mn>0</mml:mn>
                          </mml:mrow>
                        </mml:msub>
                      </mml:mrow>
                      <mml:mo class="MathClass-close">)</mml:mo>
                    </mml:mrow>
                    <mml:mo class="MathClass-rel">=</mml:mo>
                    <mml:mn>1</mml:mn>
                    <mml:mo class="MathClass-bin">-</mml:mo>
                    <mml:mfrac>
                      <mml:mrow>
                        <mml:mn>1</mml:mn>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mn>2</mml:mn>
                        <mml:mi>M</mml:mi>
                      </mml:mrow>
                    </mml:mfrac>
                    <mml:mtext>min</mml:mtext>
                    <mml:mfenced close="]" open="[">
                      <mml:mrow>
                        <mml:mi>D</mml:mi>
                        <mml:mrow>
                          <mml:mo class="MathClass-open">(</mml:mo>
                          <mml:mrow>
                            <mml:msub>
                              <mml:mrow>
                                <mml:mi mathvariant="normal">Φ</mml:mi>
                              </mml:mrow>
                              <mml:mrow>
                                <mml:mn>0</mml:mn>
                              </mml:mrow>
                            </mml:msub>
                            <mml:mo class="MathClass-punc">,</mml:mo>
                            <mml:mspace class="tmspace" width="2.77695pt"/>
                            <mml:msup>
                              <mml:mrow>
                                <mml:mi mathvariant="normal">Φ</mml:mi>
                              </mml:mrow>
                              <mml:mrow>
                                <mml:mrow>
                                  <mml:mo class="MathClass-open">(</mml:mo>
                                  <mml:mrow>
                                    <mml:mi>t</mml:mi>
                                  </mml:mrow>
                                  <mml:mo class="MathClass-close">)</mml:mo>
                                </mml:mrow>
                              </mml:mrow>
                            </mml:msup>
                          </mml:mrow>
                          <mml:mo class="MathClass-close">)</mml:mo>
                        </mml:mrow>
                        <mml:mo class="MathClass-punc">,</mml:mo>
                        <mml:mspace class="tmspace" width="2.77695pt"/>
                        <mml:mi>D</mml:mi>
                        <mml:mrow>
                          <mml:mo class="MathClass-open">(</mml:mo>
                          <mml:mrow>
                            <mml:msub>
                              <mml:mrow>
                                <mml:mi mathvariant="normal">Φ</mml:mi>
                              </mml:mrow>
                              <mml:mrow>
                                <mml:mn>0</mml:mn>
                              </mml:mrow>
                            </mml:msub>
                            <mml:mo class="MathClass-punc">,</mml:mo>
                            <mml:msup>
                              <mml:mrow>
                                <mml:mover accent="true">
                                  <mml:mrow>
                                    <mml:mi mathvariant="normal">Φ</mml:mi>
                                  </mml:mrow>
                                  <mml:mo class="MathClass-op">¯</mml:mo>
                                </mml:mover>
                              </mml:mrow>
                              <mml:mrow>
                                <mml:mrow>
                                  <mml:mo class="MathClass-open">(</mml:mo>
                                  <mml:mrow>
                                    <mml:mi>t</mml:mi>
                                  </mml:mrow>
                                  <mml:mo class="MathClass-close">)</mml:mo>
                                </mml:mrow>
                              </mml:mrow>
                            </mml:msup>
                          </mml:mrow>
                          <mml:mo class="MathClass-close">)</mml:mo>
                        </mml:mrow>
                      </mml:mrow>
                    </mml:mfenced>
                    <mml:mspace class="tmspace" width="2.77695pt"/>
                    <mml:mo class="MathClass-punc">,</mml:mo>
                  </mml:mtd>
                </mml:mtr>
                <mml:mtr>
                  <mml:mtd>
                    <mml:mi>D</mml:mi>
                    <mml:mrow>
                      <mml:mo class="MathClass-open">(</mml:mo>
                      <mml:mrow>
                        <mml:mi mathvariant="normal">Φ</mml:mi>
                        <mml:mo class="MathClass-punc">,</mml:mo>
                        <mml:mspace class="tmspace" width="2.77695pt"/>
                        <mml:msup>
                          <mml:mrow>
                            <mml:mi mathvariant="normal">Φ</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mi>′</mml:mi>
                          </mml:mrow>
                        </mml:msup>
                      </mml:mrow>
                      <mml:mo class="MathClass-close">)</mml:mo>
                    </mml:mrow>
                    <mml:mo class="MathClass-rel">=</mml:mo>
                    <mml:munderover accent="false" accentunder="false">
                      <mml:mrow>
                        <mml:mo mathsize="big"> ∑</mml:mo>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>j</mml:mi>
                        <mml:mo class="MathClass-rel">=</mml:mo>
                        <mml:mn>1</mml:mn>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>M</mml:mi>
                      </mml:mrow>
                    </mml:munderover>
                    <mml:munder class="msub">
                      <mml:mrow>
                        <mml:mo mathsize="big">∑</mml:mo>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>h</mml:mi>
                        <mml:mo class="MathClass-rel">∈</mml:mo>
                        <mml:mi mathvariant="script">H</mml:mi>
                      </mml:mrow>
                    </mml:munder>
                    <mml:mi>I</mml:mi>
                    <mml:mrow>
                      <mml:mo class="MathClass-open">(</mml:mo>
                      <mml:mrow>
                        <mml:msub>
                          <mml:mrow>
                            <mml:mi>φ</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mi>j</mml:mi>
                            <mml:mi>h</mml:mi>
                          </mml:mrow>
                        </mml:msub>
                        <mml:mo class="MathClass-rel">=</mml:mo>
                        <mml:msub>
                          <mml:mrow>
                            <mml:msup>
                              <mml:mrow>
                                <mml:mi>φ</mml:mi>
                              </mml:mrow>
                              <mml:mrow>
                                <mml:mi>′</mml:mi>
                              </mml:mrow>
                            </mml:msup>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mi>j</mml:mi>
                            <mml:mi>h</mml:mi>
                          </mml:mrow>
                        </mml:msub>
                      </mml:mrow>
                      <mml:mo class="MathClass-close">)</mml:mo>
                    </mml:mrow>
                    <mml:mo class="MathClass-punc">,</mml:mo>
                  </mml:mtd>
                </mml:mtr>
                <mml:mtr>
                  <mml:mtd/>
                </mml:mtr>
              </mml:mtable>
            </mml:mrow>
          </mml:math>
        </disp-formula>
      </p>
      <p>where Φ<sub>0 </sub>represents a fully assembled haplotype prediction and
<italic>I</italic>(<italic>a </italic>= <italic>b</italic>) represents the indicator function which
assumes 1 if <italic>a </italic>= <italic>b </italic>and 0 otherwise. A simple modification of the
above formula to the partially assembled haplotype segments might be</p>
      <p>
        <disp-formula>
          <mml:math id="M34" name="1471-2164-14-S2-S5-i33" overflow="scroll">
            <mml:mrow>
              <mml:msup>
                <mml:mrow>
                  <mml:mi>R</mml:mi>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi>′</mml:mi>
                </mml:mrow>
              </mml:msup>
              <mml:mrow>
                <mml:mo class="MathClass-open">(</mml:mo>
                <mml:mrow>
                  <mml:mi mathvariant="normal">Φ</mml:mi>
                </mml:mrow>
                <mml:mo class="MathClass-close">)</mml:mo>
              </mml:mrow>
              <mml:mo class="MathClass-rel">=</mml:mo>
              <mml:mn>1</mml:mn>
              <mml:mo class="MathClass-bin">-</mml:mo>
              <mml:mfrac>
                <mml:mrow>
                  <mml:mn>1</mml:mn>
                </mml:mrow>
                <mml:mrow>
                  <mml:mn>2</mml:mn>
                  <mml:mi>M</mml:mi>
                </mml:mrow>
              </mml:mfrac>
              <mml:munderover accent="false" accentunder="false">
                <mml:mrow>
                  <mml:mo mathsize="big"> ∑</mml:mo>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi>b</mml:mi>
                  <mml:mo class="MathClass-rel">=</mml:mo>
                  <mml:mn>1</mml:mn>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi>B</mml:mi>
                </mml:mrow>
              </mml:munderover>
              <mml:mtext>min</mml:mtext>
              <mml:mfenced close="]" open="[">
                <mml:mrow>
                  <mml:mi>D</mml:mi>
                  <mml:mrow>
                    <mml:mo class="MathClass-open">(</mml:mo>
                    <mml:mrow>
                      <mml:msub>
                        <mml:mrow>
                          <mml:mi mathvariant="normal">Φ</mml:mi>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi>b</mml:mi>
                        </mml:mrow>
                      </mml:msub>
                      <mml:mo class="MathClass-punc">,</mml:mo>
                      <mml:mspace class="tmspace" width="2.77695pt"/>
                      <mml:msubsup>
                        <mml:mrow>
                          <mml:mi mathvariant="normal">Φ</mml:mi>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi>b</mml:mi>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mrow>
                            <mml:mo class="MathClass-open">(</mml:mo>
                            <mml:mrow>
                              <mml:mi>t</mml:mi>
                            </mml:mrow>
                            <mml:mo class="MathClass-close">)</mml:mo>
                          </mml:mrow>
                        </mml:mrow>
                      </mml:msubsup>
                    </mml:mrow>
                    <mml:mo class="MathClass-close">)</mml:mo>
                  </mml:mrow>
                  <mml:mo class="MathClass-punc">,</mml:mo>
                  <mml:mspace class="tmspace" width="2.77695pt"/>
                  <mml:mi>D</mml:mi>
                  <mml:mrow>
                    <mml:mo class="MathClass-open">(</mml:mo>
                    <mml:mrow>
                      <mml:msub>
                        <mml:mrow>
                          <mml:mi mathvariant="normal">Φ</mml:mi>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi>b</mml:mi>
                        </mml:mrow>
                      </mml:msub>
                      <mml:mo class="MathClass-punc">,</mml:mo>
                      <mml:msubsup>
                        <mml:mrow>
                          <mml:mover accent="true">
                            <mml:mrow>
                              <mml:mi mathvariant="normal">Φ</mml:mi>
                            </mml:mrow>
                            <mml:mo>¯</mml:mo>
                          </mml:mover>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi>b</mml:mi>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mrow>
                            <mml:mo class="MathClass-open">(</mml:mo>
                            <mml:mrow>
                              <mml:mi>t</mml:mi>
                            </mml:mrow>
                            <mml:mo class="MathClass-close">)</mml:mo>
                          </mml:mrow>
                        </mml:mrow>
                      </mml:msubsup>
                    </mml:mrow>
                    <mml:mo class="MathClass-close">)</mml:mo>
                  </mml:mrow>
                </mml:mrow>
              </mml:mfenced>
              <mml:mi>.</mml:mi>
            </mml:mrow>
          </mml:math>
        </disp-formula>
      </p>
      <p>However, this definition is inconvenient because the minimization is applied for each
segment and this accuracy measure can always be improved just by breaking a segment
into smaller pieces at random positions.</p>
      <p>The switch error rate [<xref ref-type="bibr" rid="B13">13</xref>] is another measure
used for comparing SIH algorithms. A switch error is defined by the inconsistency
between Φ and Φ<sup>(<italic>t</italic>) </sup>at neighboring heterozygous sites:
<inline-formula><mml:math id="M35" name="1471-2164-14-S2-S5-i34" overflow="scroll"><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>φ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo class="MathClass-punc">,</mml:mo><mml:mspace class="thinspace" width="0.3em"/><mml:mspace class="tmspace" width="2.77695pt"/><mml:msub><mml:mrow><mml:mi>φ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo class="MathClass-bin">+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow><mml:mo class="MathClass-rel">=</mml:mo><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>φ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow></mml:mrow></mml:msubsup><mml:mo class="MathClass-punc">,</mml:mo><mml:mspace class="thinspace" width="0.3em"/><mml:mspace class="thinspace" width="0.3em"/><mml:msubsup><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>φ</mml:mi></mml:mrow><mml:mo class="MathClass-op">¯</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo class="MathClass-bin">+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow></mml:mrow></mml:msubsup></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow><mml:mspace class="tmspace" width="2.77695pt"/><mml:mstyle class="text"><mml:mtext class="textsf" mathvariant="sans-serif">or</mml:mtext></mml:mstyle><mml:mspace class="tmspace" width="2.77695pt"/><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>φ</mml:mi></mml:mrow><mml:mo class="MathClass-op">¯</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow></mml:mrow></mml:msubsup><mml:mo class="MathClass-punc">,</mml:mo><mml:mspace class="tmspace" width="2.77695pt"/><mml:mspace class="thinspace" width="0.3em"/><mml:msubsup><mml:mrow><mml:mi>φ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo class="MathClass-bin">+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow></mml:mrow></mml:msubsup></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow></mml:math></inline-formula>. The
switch error rate is defined by the total number of switch errors divided by the
total number of neighboring pairs of heterozygous sites in all the segments. Although
the switch error rate is useful for comparing different algorithms, it does not
reflect the global influence of switch errors. Figure <xref ref-type="fig" rid="F2">2(B)</xref>
shows the example of the case that the switch error rate is not suitable to evaluate
the quality of the segments. A single switch error in the middle of a reconstructed
haplotype segment has a greater influence on downstream analyses such as detecting
amplified haplotypes [<xref ref-type="bibr" rid="B23">23</xref>] than a switch error
located at an end of the segment (top and middle of Figure <xref ref-type="fig" rid="F2">2(B)</xref>). Two contiguous switch errors, which are likely to be caused by
sequencing error or genotyping error, do not disrupt the consistency between front
and back parts of the haplotype segments. However, such two contiguous switch error
disrupt twice in terms of switch error rate (bottom of Figure <xref ref-type="fig" rid="F2">2(B)</xref>).</p>
      <fig id="F2" position="float">
        <label>Figure 2</label>
        <caption>
          <p><bold>An illustration of pair consistency</bold>. Consistency of pair sites. A. a. We
assume that the two true haplotypes are the sequences of all 0 and all 1. b.
Inferred haplotypes contain switch errors indicated by the arrows: (i) a
consistent pair, (ii) an inconsistent pair, and (iii) if there are an
uncontrolled number of switch errors between a pair, the probabilities of being
consistent or inconsistent are both 0.5. B. The example of the case that switch
error rate is not suitable to evaluate the quality of the segment. The
consistency of a reconstructed haplotype which has single switch error in the
middle (top) is high than a reconstructed haplotype which has single switch
error located at an end of the segment, but switch error rate cannot
distinguish these situations. Two contiguous switch errors, which are caused by
sequencing error or genotyping error and do not disrupt the consistency between
front and back parts, are regarded as twice of a single switch error in switch
error rate (bottom).</p>
        </caption>
        <graphic xlink:href="1471-2164-14-S2-S5-2"/>
      </fig>
      <p>Here, we propose another simple accuracy measure based on the pairwise consistency of
the prediction with the true haplotypes. This pairwise consistency score is inspired
by the <italic>D'</italic>-measure of linkage disequilibrium where the statistical
correlations among population genomes are measured for pair sites. Similarly to the
switch error, a pair of heterozygous sites <italic>j </italic>and <italic>j</italic>' (<italic>j &lt;
j</italic>') is defined as consistent if <inline-formula><mml:math id="M36" name="1471-2164-14-S2-S5-i35" overflow="scroll"><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>φ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo class="MathClass-punc">,</mml:mo><mml:mspace class="tmspace" width="2.77695pt"/><mml:msub><mml:mrow><mml:mi>φ</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:msub></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow><mml:mo class="MathClass-rel">=</mml:mo><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>φ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow></mml:mrow></mml:msubsup><mml:mo class="MathClass-punc">,</mml:mo><mml:mspace class="tmspace" width="2.77695pt"/><mml:msubsup><mml:mrow><mml:mi>φ</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow></mml:mrow></mml:msubsup></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow><mml:mspace class="tmspace" width="2.77695pt"/><mml:mstyle class="text"><mml:mtext class="textsf" mathvariant="sans-serif">or</mml:mtext></mml:mstyle><mml:mspace class="tmspace" width="2.77695pt"/><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>φ</mml:mi></mml:mrow><mml:mo class="MathClass-op">¯</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow></mml:mrow></mml:msubsup><mml:mo class="MathClass-punc">,</mml:mo><mml:msubsup><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>φ</mml:mi></mml:mrow><mml:mo class="MathClass-op">¯</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow></mml:mrow></mml:msubsup></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow></mml:math></inline-formula>, and
inconsistent otherwise. A pair (<italic>j</italic>, <italic>j</italic>') in a haplotype segment is
consistent if there is no switch error in range [<italic>j, j<sup>'</sup></italic>] and
inconsistent if there is one switch error in the segment. If there are uncontrolled
number of switch errors in range [<italic>j, j</italic>'], the probabilities that pair
(<italic>j, j<sup>'</sup></italic>) is consistent or inconsistent are both 0.5, which is
equivalent to selecting a random phase at each site (Figure <xref ref-type="fig" rid="F2">2(A)</xref>). For each haplotype segment, we count the consistent and
inconsistent pairs. The total numbers of consistent and inconsistent pairs over all
the haplotype segments are denoted by CP and IP, respectively. We define
<italic>precision </italic>by CP/(CP + IP). This is used as the measure of accuracy in the
later sections. Unlike the switch error rate, this precision accounts for the global
influence of switch errors because a switch error in the middle of a haplotype
segment leads to a much smaller CP than switch errors at an end of the segment.</p>
      <p>We define the total prediction space as follows. We consider a graph whose nodes are
the set of all the heterozygous sites. We connect two nodes by an edge if there is a
fragment spanning both the sites. We collect all the connected components with at
least two nodes and consider each of the corresponding clusters of heterozygous sites
as an independent segment. The total number of pairs is the sum of the numbers of all
the pair sites over the segments. Although it is rare, there are cases in which some
segments consist of noncontiguous heterozygous sites. For example, segment sets such
as {(1, 4, 5), (2, 3)} and {(1, 3), (2, 4, 5)} may occur for the consecutive
heterozygous sites (1, 2, 3, 4, 5). We define <italic>recall </italic>as the ratio of the
predicted pairs divided by the total number of pairs. Because the previous algorithms
provide no score to limit the prediction to highly confident regions, recall is
always nearly equal to one for these algorithms. On the other hand, our algorithm is
able to make predictions with high precision at the expense of reduced recall.</p>
      <p>A more detailed discussions of other accuracy measures is given in Additional file
<xref ref-type="supplementary-material" rid="S1">1</xref>.</p>
    </sec>
    <sec>
      <title>Potential chimeric fragments</title>
      <p>The processed sequence data derived from fosmid pool-based next-generation sequencing
might contain chimeric fragments if a pool contains DNA fragments derived from the
same region of different chromosomes and reads with different chromosomal origins are
merged into a single SNP fragment. By using the trio-based haplotypes, we compute the
'chimerity' of each SNP fragment <italic>f </italic>by measuring the change of its likelihood
after breaking it into two pieces:</p>
      <p>
        <disp-formula>
          <mml:math id="M37" name="1471-2164-14-S2-S5-i36" overflow="scroll">
            <mml:mrow>
              <mml:mstyle class="text">
                <mml:mtext class="textsf" mathvariant="sans-serif">chimerity</mml:mtext>
              </mml:mstyle>
              <mml:mrow>
                <mml:mo class="MathClass-open">(</mml:mo>
                <mml:mrow>
                  <mml:mi>f</mml:mi>
                </mml:mrow>
                <mml:mo class="MathClass-close">)</mml:mo>
              </mml:mrow>
              <mml:mo class="MathClass-rel">=</mml:mo>
              <mml:mo class="MathClass-bin">-</mml:mo>
              <mml:mtext>log</mml:mtext>
              <mml:mfenced close=")" open="(">
                <mml:mrow>
                  <mml:mfrac>
                    <mml:mrow>
                      <mml:msub>
                        <mml:mrow>
                          <mml:mtext>max</mml:mtext>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi>h</mml:mi>
                          <mml:mo class="MathClass-rel">∈</mml:mo>
                          <mml:mi mathvariant="script">H</mml:mi>
                        </mml:mrow>
                      </mml:msub>
                      <mml:msub>
                        <mml:mrow>
                          <mml:mi>P</mml:mi>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mn>0</mml:mn>
                        </mml:mrow>
                      </mml:msub>
                      <mml:mrow>
                        <mml:mo class="MathClass-open">(</mml:mo>
                        <mml:mrow>
                          <mml:mi>f</mml:mi>
                          <mml:mo class="MathClass-rel">|</mml:mo>
                          <mml:mi>h</mml:mi>
                        </mml:mrow>
                        <mml:mo class="MathClass-close">)</mml:mo>
                      </mml:mrow>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:msub>
                        <mml:mrow>
                          <mml:mtext>max</mml:mtext>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi>j</mml:mi>
                          <mml:mo class="MathClass-rel">∈</mml:mo>
                          <mml:mi>X</mml:mi>
                          <mml:mrow>
                            <mml:mo class="MathClass-open">(</mml:mo>
                            <mml:mrow>
                              <mml:mi>f</mml:mi>
                            </mml:mrow>
                            <mml:mo class="MathClass-close">)</mml:mo>
                          </mml:mrow>
                          <mml:mo class="MathClass-punc">,</mml:mo>
                          <mml:mi>h</mml:mi>
                          <mml:mo class="MathClass-rel">∈</mml:mo>
                          <mml:mi mathvariant="script">H</mml:mi>
                        </mml:mrow>
                      </mml:msub>
                      <mml:msub>
                        <mml:mrow>
                          <mml:mi>P</mml:mi>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mn>0</mml:mn>
                        </mml:mrow>
                      </mml:msub>
                      <mml:mrow>
                        <mml:mo class="MathClass-open">(</mml:mo>
                        <mml:mrow>
                          <mml:mi>f</mml:mi>
                          <mml:msub>
                            <mml:mrow>
                              <mml:mo class="MathClass-rel">≤</mml:mo>
                            </mml:mrow>
                            <mml:mrow>
                              <mml:mi>j</mml:mi>
                            </mml:mrow>
                          </mml:msub>
                          <mml:mo class="MathClass-rel">|</mml:mo>
                          <mml:mi>h</mml:mi>
                        </mml:mrow>
                        <mml:mo class="MathClass-close">)</mml:mo>
                      </mml:mrow>
                      <mml:msub>
                        <mml:mrow>
                          <mml:mi>P</mml:mi>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mn>0</mml:mn>
                        </mml:mrow>
                      </mml:msub>
                      <mml:mrow>
                        <mml:mo class="MathClass-open">(</mml:mo>
                        <mml:mrow>
                          <mml:mi>f</mml:mi>
                          <mml:msub>
                            <mml:mrow>
                              <mml:mo class="MathClass-rel">&gt;</mml:mo>
                            </mml:mrow>
                            <mml:mrow>
                              <mml:mi>j</mml:mi>
                            </mml:mrow>
                          </mml:msub>
                          <mml:mo class="MathClass-rel">|</mml:mo>
                          <mml:mover accent="true">
                            <mml:mrow>
                              <mml:mi>h</mml:mi>
                            </mml:mrow>
                            <mml:mo class="MathClass-op"> ¯</mml:mo>
                          </mml:mover>
                        </mml:mrow>
                        <mml:mo class="MathClass-close">)</mml:mo>
                      </mml:mrow>
                    </mml:mrow>
                  </mml:mfrac>
                </mml:mrow>
              </mml:mfenced>
              <mml:mo class="MathClass-punc">,</mml:mo>
            </mml:mrow>
          </mml:math>
        </disp-formula>
      </p>
      <p>
        <disp-formula>
          <mml:math id="M38" name="1471-2164-14-S2-S5-i37" overflow="scroll">
            <mml:msub>
              <mml:mrow>
                <mml:mi>P</mml:mi>
              </mml:mrow>
              <mml:mrow>
                <mml:mn>0</mml:mn>
              </mml:mrow>
            </mml:msub>
            <mml:mrow>
              <mml:mo class="MathClass-open">(</mml:mo>
              <mml:mrow>
                <mml:mi>f</mml:mi>
                <mml:mo class="MathClass-rel">|</mml:mo>
                <mml:mi>h</mml:mi>
              </mml:mrow>
              <mml:mo class="MathClass-close">)</mml:mo>
            </mml:mrow>
            <mml:mo class="MathClass-rel">=</mml:mo>
            <mml:msup>
              <mml:mrow>
                <mml:mrow>
                  <mml:mo class="MathClass-open">(</mml:mo>
                  <mml:mrow>
                    <mml:mn>1</mml:mn>
                    <mml:mo class="MathClass-bin">-</mml:mo>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>α</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mn>0</mml:mn>
                      </mml:mrow>
                    </mml:msub>
                  </mml:mrow>
                  <mml:mo class="MathClass-close">)</mml:mo>
                </mml:mrow>
              </mml:mrow>
              <mml:mrow>
                <mml:mi>n</mml:mi>
                <mml:mrow>
                  <mml:mo class="MathClass-open">(</mml:mo>
                  <mml:mrow>
                    <mml:mi>f</mml:mi>
                    <mml:mo class="MathClass-punc">,</mml:mo>
                    <mml:mi>h</mml:mi>
                  </mml:mrow>
                  <mml:mo class="MathClass-close">)</mml:mo>
                </mml:mrow>
              </mml:mrow>
            </mml:msup>
            <mml:msubsup>
              <mml:mrow>
                <mml:mi>α</mml:mi>
              </mml:mrow>
              <mml:mrow>
                <mml:mn>0</mml:mn>
              </mml:mrow>
              <mml:mrow>
                <mml:mo class="MathClass-rel">|</mml:mo>
                <mml:mi>X</mml:mi>
                <mml:mrow>
                  <mml:mo class="MathClass-open">(</mml:mo>
                  <mml:mrow>
                    <mml:mi>f</mml:mi>
                  </mml:mrow>
                  <mml:mo class="MathClass-close">)</mml:mo>
                </mml:mrow>
                <mml:mo class="MathClass-rel">|</mml:mo>
                <mml:mo class="MathClass-bin">-</mml:mo>
                <mml:mi>n</mml:mi>
                <mml:mrow>
                  <mml:mo class="MathClass-open">(</mml:mo>
                  <mml:mrow>
                    <mml:mi>f</mml:mi>
                    <mml:mo class="MathClass-punc">,</mml:mo>
                    <mml:mi>h</mml:mi>
                  </mml:mrow>
                  <mml:mo class="MathClass-close">)</mml:mo>
                </mml:mrow>
              </mml:mrow>
            </mml:msubsup>
            <mml:mo class="MathClass-punc">,</mml:mo>
          </mml:math>
        </disp-formula>
      </p>
      <p>where <italic>n</italic>(<italic>f</italic>, <italic>h</italic>) is the number of sites at which the fragment
<italic>f </italic>matches with the true haplotype <italic>h</italic>, <italic>f<sub>≤j
</sub></italic>and <italic>f<sub>&gt;j </sub></italic>represent the left and right parts of
fragment <italic>f </italic>divided at site <italic>j</italic>, and <italic>α</italic><sub>0 </sub>=
0.028 is the empirical sequence error rate computed by comparing the true haplotypes
and all the SNP fragments. We removed potential chimeric fragments with chimerity
higher than a given threshold. We recomputed the accuracies for this removed dataset
and compared them with those for the original dataset.</p>
    </sec>
  </sec>
  <sec>
    <title>Results and discussion</title>
    <sec>
      <title>Comparison of pairwise accuracies</title>
      <p>We examined whether MixSIH can extract the accurate haplotypes regions by using MC.
Figure <xref ref-type="fig" rid="F3">3</xref> shows the accuracies derived from counting the
consistent pairs. The <italic>x</italic>-axis is the number of predicted pairs (CP+IP) and
the <italic>y</italic>-axis is the precision (CP/(CP+IP)). We have also shown the accuracy
for the prediction without the haplotype assembly where the phase of each pair is
determined by majority voting of spanning fragments. Figure <xref ref-type="fig" rid="F3">3A</xref>
shows that the precisions of all the algorithms are around 0.5-0.6 at recall ~ 1.0,
indicating that there are many switch errors in the predictions and the quality of
assembled haplotypes are not much different from picking phases randomly. By
increasing the MC threshold, the precision of MixSIH improves rapidly and becomes
close to one around MC = 4 at recall 0.07. The recall of unassembled haplotypes is
about 0.005 with precision 0.93, which is 20 times smaller than the recall 0.1 of
MixSIH at the same precision. For the real dataset, the precision of the algorithms
is around 0.85 at recall ~ 1.0, which is much higher than the precision for the
simulation dataset. This is because there are many small fragment clusters for which
the correct haplotypes are easily predicted. The accuracy of MixSIH can still be
improved with precision up to 0.95 at the expense of deleting about 3/5 of weakly
supported pairs from the prediction. However, it does not reach the precision of
unassembled haplotype prediction. We discuss this issue in the next subsection.</p>
      <fig id="F3" position="float">
        <label>Figure 3</label>
        <caption>
          <p><bold>Comparison of pairwise accuracies</bold>. Precision curves based on the
consistent pair counts. The <italic>x</italic>-axis represents the number of predicted
pairs in log scale. The arrows indicate the MC thresholds. The accuracies are
computed for the simulation dataset (A), and the real dataset (B): □ no
assembly; ○ MixSIH; Δ ReFHap; + FastHare; × DGS. In the
simulation, we set <italic>M </italic>= 2000 and repeated the experiment 10 times for
each algorithm; average values are plotted.</p>
        </caption>
        <graphic xlink:href="1471-2164-14-S2-S5-3"/>
      </fig>
    </sec>
    <sec>
      <title>Effects of potential chimeric fragments</title>
      <p>Inspecting the switch errors in the prediction for the real dataset, we found that
there are potential chimeric fragments that have a considerable effect on the
pairwise accuracies. A chimeric fragment is defined as a fragment whose left and
right parts match different chromosomes very well. Such fragments can occur in fosmid
pool-based next-generation sequencing data. We show the chimerity distribution in
Additional file <xref ref-type="supplementary-material" rid="S1">1</xref>. We computed the accuracy of MixSIH for a
fragment dataset in which the fragments with chimerity higher than a given threshold
are removed. We experimented with several chimerity thresholds and we found that the
accuracy improves with decreasing chimerity thresholds and saturated at about
chimerity threshold 10, which corresponded to the case that only 1.65%
(4,482/271,184) of the fragments were removed. We show the accuracies for different
chimerity thresholds in Additional file <xref ref-type="supplementary-material" rid="S1">1</xref>. We also show
that the fragments whose chimerity is over 10 are indeed chimeric in Additional file
<xref ref-type="supplementary-material" rid="S1">1</xref>. Figure <xref ref-type="fig" rid="F4">4</xref> shows the precision
curves for the dataset of removed fragments. The accuracies are considerably higher
for this dataset, and the precision now reaches that of the unassembled prediction at
recall 0.5 with MC threshold 6.0. We also show the effects of chimeric fragments on
simulation data in Additional file <xref ref-type="supplementary-material" rid="S1">1</xref>.</p>
      <fig id="F4" position="float">
        <label>Figure 4</label>
        <caption>
          <p><bold>Effects of potential chimeric fragments</bold>. The precisions of the
algorithms for the dataset in which fragments with chimerity greater than 10
are removed. For comparison, the precisions of MixSIH for the original dataset
are also shown as diamonds.</p>
        </caption>
        <graphic xlink:href="1471-2164-14-S2-S5-4"/>
      </fig>
      <p>These results suggest that more careful data processing to avoid spurious chimeric
fragments is necessary to obtain high-quality haplotype assembly.</p>
    </sec>
    <sec>
      <title>Incorporation of the trio-based data</title>
      <p>Although the trio-based statistical phasing method can determine most of the phases
of the sites, there still exist SNP sites whose phases cannot be determined by this
method. SIH is capable of determining the phases which are not determined by the
trio-based data, and we can obtain more complete haplotypes data by combining both of
the SIH-based data and the trio-based data. To examine how many phases of the sites
can be determined anew by combining both of the SIH-based data and the trio-based
data, we devise a method that combines both information to determine the phases (see
the Additional file <xref ref-type="supplementary-material" rid="S1">1</xref>). By using this method, about 82%
(237,950/291,466) of the phases of the sites which are undetermined by trio-based
data could be determined anew and totally about 97% (1,601,381/1,654,897) of the
phases could be determined by both the methods. This result suggests that almost all
of the phases of the sites can be determined by using both of the SIH-based data and
the trio-based data.</p>
    </sec>
    <sec>
      <title>Spatial distribution of MC values</title>
      <p>Figure <xref ref-type="fig" rid="F5">5A</xref> shows an example of the spatial distribution of the
MC values for the real dataset. The regions that are densely covered tend to have
large MC values. On the other hand, the MC values are low in chromosomal regions with
sparse heterozygous sites because few fragments span two or more sites. Figure <xref ref-type="fig" rid="F5">5B</xref> shows the density plot of MC values which are converted to the
corresponding precisions using the graph of Figure <xref ref-type="fig" rid="F5">5B</xref>, and the
absolute normalized linkage disequilibrium <italic>|D</italic>'<italic>|</italic>. SIH can accurately
infer the haplotypes in many regions with low linkage disequilibrium, but there are
also regions with reduced precision and high <italic>|D</italic>'<italic>| </italic>values. This
suggests that the accuracy of predictions might be improved by using both pieces of
information.</p>
      <fig id="F5" position="float">
        <label>Figure 5</label>
        <caption>
          <p><bold>Spatial distribution of MC and LD</bold>. A. A colored density plot of the MC
values and the number of fragments. The <italic>x</italic>-axis represents the
co-ordinates of heterozygous sites. The actual locations of the sites in genome
coordinates are shown by thin black diagonal lines and the black horizontal
line represents a 10-11 megabase region of chromosome 20. The upper densities
represent the connectivity values. The lower densities represent the number of
fragments spanning the pair sites. B. A colored density plot of the precisions
(upper) and the absolute normalized linkage disequilibrium <italic>|D</italic>'<italic>|
</italic>(lower) for the same region.</p>
        </caption>
        <graphic xlink:href="1471-2164-14-S2-S5-5"/>
      </fig>
    </sec>
    <sec>
      <title>Dependency of MC values on the fragment parameters</title>
      <p>Figure <xref ref-type="fig" rid="F6">6</xref> shows the dependency of MC values on the quality of
the input dataset. In these figures, the minimal MC threshold that achieves precision
<italic>≥ </italic>0.95 (<italic>y</italic>-axis) is plotted for different fragment length
ranges [<italic>l</italic><sub>1</sub>, <italic>l</italic><sub>2</sub>] (three panels), coverages
<italic>c </italic>(three lines), and error rates <italic>e </italic>(<italic>x</italic>-axis). They show
that the MC threshold must be increased to obtain high-quality assembly for
low-coverage, highly erroneous data, while it has a minor dependence on the typical
fragment length. However, the overall scale of the MC threshold changes relatively
moderately and it is bounded above at MC = 6 for the tested cases. We also calculated
the dependency of MC values on the input dataset which include chimeric fragments and
the results were almost the same (see the Additional file <xref ref-type="supplementary-material" rid="S1">1</xref>). Hence we set the default MC threshold to 6.0 in our software.</p>
      <fig id="F6" position="float">
        <label>Figure 6</label>
        <caption>
          <p><bold>Dependency of MC values</bold>. Dependency of the lowest MC value with
precision <italic>≥ </italic>0.95 for coverage <italic>c</italic>, fragment length
[<italic>l</italic><sub>1</sub>, <italic>l</italic><sub>2</sub>], and error rate <italic>e</italic>.
The experiments were repeated 10 times, and the average values are plotted.</p>
        </caption>
        <graphic xlink:href="1471-2164-14-S2-S5-6"/>
      </fig>
    </sec>
    <sec>
      <title>Optimality of inferred parameters</title>
      <p>We use a heuristic method for parameter optimization to avoid sub-optimal solutions.
To test whether the optimized parameters actually reach the global optimum, we
compared the log likelihood of the optimized parameters with the approximate maximal
log likelihood obtained by optimizing the parameters with an initial condition in
which the optimal solution falls into the set of true haplotypes; we add one to the
Dirichlet parameters for the true phase probability: that is, <inline-formula><mml:math id="M39" name="1471-2164-14-S2-S5-i38" overflow="scroll"><mml:msub><mml:mrow><mml:mi>λ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mi>v</mml:mi></mml:mrow></mml:msub><mml:mo class="MathClass-rel">=</mml:mo><mml:msubsup><mml:mrow><mml:mi>λ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:mn>0</mml:mn></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow></mml:mrow></mml:msubsup><mml:mo class="MathClass-bin">+</mml:mo><mml:mn>1</mml:mn><mml:mspace class="tmspace" width="2.77695pt"/><mml:mstyle class="text"><mml:mtext class="textsf" mathvariant="sans-serif">if</mml:mtext></mml:mstyle><mml:mspace class="tmspace" width="2.77695pt"/><mml:mi>v</mml:mi><mml:mo class="MathClass-rel">=</mml:mo><mml:msubsup><mml:mrow><mml:mi>φ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow></mml:mrow></mml:msubsup></mml:math></inline-formula>and
<inline-formula><mml:math id="M40" name="1471-2164-14-S2-S5-i39" overflow="scroll"><mml:msub><mml:mrow><mml:mi>λ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mi>v</mml:mi></mml:mrow></mml:msub><mml:mo class="MathClass-rel">=</mml:mo><mml:msubsup><mml:mrow><mml:mi>λ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:mn>0</mml:mn></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow></mml:mrow></mml:msubsup></mml:math></inline-formula> otherwise,
where <inline-formula><mml:math id="M41" name="1471-2164-14-S2-S5-i40" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi>λ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:mn>0</mml:mn></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow></mml:mrow></mml:msubsup></mml:math></inline-formula> is
hyperparameters of the Dirichlet distribution and <inline-formula><mml:math id="M42" name="1471-2164-14-S2-S5-i41" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi>φ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow></mml:mrow></mml:msubsup></mml:math></inline-formula> is the true
phase at site <italic>j</italic>. Figure <xref ref-type="fig" rid="F7">7</xref> shows the changes of the log
likelihood for each twist operation. It also shows the connectivity values at the
sites where the parameters Λ are twisted. The log likelihood increases
monotonically and reaches the approximate maximal likelihood after 50 twist
iterations. The connectivity values also increase monotonically in most cases. The
figure implies that the parameters converge to the global optimum upon repeating the
twist operation.</p>
      <fig id="F7" position="float">
        <label>Figure 7</label>
        <caption>
          <p><bold>Optimality of inferred parameters</bold>. Increase of log likelihood values for
each iteration. The dotted line represents the approximate maximal log
likelihood; the solid line, the changes of the optimized log likelihood for
each twist operation; the broken line, the connectivity values at the positions
that the optimizing parameters are twisted.</p>
        </caption>
        <graphic xlink:href="1471-2164-14-S2-S5-7"/>
      </fig>
    </sec>
    <sec>
      <title>Comparison of running times</title>
      <p>Figure <xref ref-type="fig" rid="F8">8</xref> shows the runtimes of the test programs. Bansal
released the faster version of HapCUT recently, so we calculated the runtimes of both
latest and previous version of HapCUT. Our method applies the VBEM algorithm
repeatedly and hence is rather slow. It is comparative to HapCUT(previous versoin)
and about 10-fold slower than both ReFHap and HapCUT(latest versoin), and from
50-fold to 500-fold slower than both FastHare and DGS. Considering that NA12878 has
about 1.23 × 10<sup>5 </sup>heterozygous sites on chromosome 1, it is roughly
estimated that MixSIH takes about 15 days to finish haplotyping for the data whose
connected component includes all heterozygous sites, and MixSIH is still manageable
for such chromosome-wide data.</p>
      <fig id="F8" position="float">
        <label>Figure 8</label>
        <caption>
          <p><bold>Running times</bold>. The running times of the tested algorithms. The
<italic>x</italic>-axis is the number of sites. The <italic>y</italic>-axis is the running
time in seconds. Both are displayed on a logarithmic scale.</p>
        </caption>
        <graphic xlink:href="1471-2164-14-S2-S5-8"/>
      </fig>
    </sec>
  </sec>
  <sec sec-type="conclusions">
    <title>Conclusions</title>
    <p>With advances in sequencing technologies and experimental techniques, single individual
haplotyping (SIH) has become increasingly appealing for haplotype determination in
recent years. In this paper, we have developed a probabilistic model for SIH (MixSIH)
and defined the minimal connectivity (MC) score that can be used for extracting
accurately assembled haplotype segments. We have introduced a new accuracy measure,
based on the pairwise consistency of the inferred haplotypes, which is intuitive and
easy to calculate but nevertheless avoids some of the problems of existing accuracy
measures. By using the MC scores our algorithm can extract highly accurate haplotype
segments. We have also found evidence that there are a small number of chimeric
fragments in an existing dataset from fosmid pool-based next-generation sequencing, and
these fragments considerably reduce the quality of the assembled haplotypes. Therefore,
a better data processing method is necessary to avoid creating chimeric fragments.</p>
    <p>Our program uses only read fragment data derived from an individual. However, it is
expected that more powerful analyses could be made by combining SIH algorithms with
statistical haplotype phasing methods that use population genotype data. An interesting
possibility would be to construct a unified probabilistic model that infers the
haplotypes on the basis of both kinds of data.</p>
  </sec>
  <sec>
    <title>Abbreviations</title>
    <p>SIH: Single Individual Haplotyping; MC: Minimum connectivity.</p>
  </sec>
  <sec>
    <title>Competing interests</title>
    <p>The authors declare that they have no competing interests.</p>
  </sec>
  <sec>
    <title>Authors' contributions</title>
    <p>HM designed the probabilistic model, implemented the software, performed the analyses,
and wrote the paper. HK contributed to develop the model, designed the experiments and
wrote the paper. Both authors read and approved the final manuscript.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material content-type="local-data" id="S1">
      <caption>
        <title>Additional file 1</title>
        <p><bold>This file includes the explanation of our model, detail of the parameter
optimization and some additional analyses</bold>.</p>
      </caption>
      <media xlink:href="1471-2164-14-S2-S5-S1.pdf" mimetype="application" mime-subtype="pdf">
        <caption>
          <p>Click here for file</p>
        </caption>
      </media>
    </supplementary-material>
  </sec>
</body>
<back>
  <sec>
    <title>Acknowledgements</title>
    <p>The authors thank their research group colleagues for assistance in this study. This
study was supported by a Grant-in-Aid for Young Scientists (21700330), and a
Grant-in-Aid for Scientific Research (A) (22240031). Computations were performed
using the supercomputing facilities at the Human Genome Center, University of Tokyo.
(<ext-link ext-link-type="uri" xlink:href="http://sc.hgc.jp/shirokane.html">http://sc.hgc.jp/shirokane.html</ext-link>).</p>
  </sec>
  <sec>
    <title>Declarations</title>
    <p>The publication costs for this article were funded by a Grant-in-Aid for Young
Scientists (21700330), and a Grant-in-Aid for Scientific Research (A) (22240031).</p>
    <p>This article has been published as part of <italic>BMC Genomics </italic>Volume 14 Supplement
2, 2013: Selected articles from ISCB-Asia 2012. The full contents of the supplement
are available online at
<ext-link ext-link-type="uri" xlink:href="http://www.biomedcentral.com/bmcgenomics/supplements/14/S2">http://www.biomedcentral.com/bmcgenomics/supplements/14/S2</ext-link>.</p>
  </sec>
  <ref-list>
    <ref id="B1">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Schaid</surname>
          <given-names>DJ</given-names>
        </name>
        <article-title>Evaluating associations of haplotypes with traits</article-title>
        <source>Genet Epidemiol</source>
        <year>2004</year>
        <volume>27</volume>
        <fpage>348</fpage>
        <lpage>364</lpage>
        <pub-id pub-id-type="doi">10.1002/gepi.20037</pub-id>
        <pub-id pub-id-type="pmid">15543638</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B2">
      <mixed-citation publication-type="journal">
        <collab>The International HapMap Consortium</collab>
        <article-title>A second generation human haplotype map of over 3.1 million SNPs</article-title>
        <source>Nature</source>
        <year>2007</year>
        <volume>449</volume>
        <fpage>851</fpage>
        <lpage>861</lpage>
        <pub-id pub-id-type="doi">10.1038/nature06258</pub-id>
        <pub-id pub-id-type="pmid">17943122</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B3">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Tewhey</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Bansal</surname>
          <given-names>V</given-names>
        </name>
        <name>
          <surname>Torkamani</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Topol</surname>
          <given-names>EJ</given-names>
        </name>
        <name>
          <surname>Schork</surname>
          <given-names>NJ</given-names>
        </name>
        <article-title>The importance of phase information for human genomics</article-title>
        <source>Nat Rev Genet</source>
        <year>2011</year>
        <volume>12</volume>
        <fpage>215</fpage>
        <lpage>223</lpage>
        <pub-id pub-id-type="doi">10.1038/nrg2950</pub-id>
        <pub-id pub-id-type="pmid">21301473</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B4">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Clark</surname>
          <given-names>AG</given-names>
        </name>
        <article-title>Inference of haplotypes from PCR-amplified samples of diploid populations</article-title>
        <source>Mol Biol Evol</source>
        <year>1990</year>
        <volume>7</volume>
        <fpage>111</fpage>
        <lpage>122</lpage>
        <pub-id pub-id-type="pmid">2108305</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B5">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Excoffier</surname>
          <given-names>L</given-names>
        </name>
        <name>
          <surname>Slatkin</surname>
          <given-names>M</given-names>
        </name>
        <article-title>Maximum-likelihood estimation of molecular haplotype frequencies in a diploid
population</article-title>
        <source>Mol Biol Evol</source>
        <year>1995</year>
        <volume>12</volume>
        <fpage>921</fpage>
        <lpage>927</lpage>
        <pub-id pub-id-type="pmid">7476138</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B6">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Stephens</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Smith</surname>
          <given-names>NJ</given-names>
        </name>
        <name>
          <surname>Donnelly</surname>
          <given-names>P</given-names>
        </name>
        <article-title>A new statistical method for haplotype reconstruction from population data</article-title>
        <source>Am J Hum Genet</source>
        <year>2001</year>
        <volume>68</volume>
        <fpage>978</fpage>
        <lpage>989</lpage>
        <pub-id pub-id-type="doi">10.1086/319501</pub-id>
        <pub-id pub-id-type="pmid">11254454</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B7">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Stephens</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Donnelly</surname>
          <given-names>P</given-names>
        </name>
        <article-title>A comparison of bayesian methods for haplotype reconstruction from population
genotype data</article-title>
        <source>Am J Hum Genet</source>
        <year>2003</year>
        <volume>73</volume>
        <fpage>1162</fpage>
        <lpage>1169</lpage>
        <pub-id pub-id-type="doi">10.1086/379378</pub-id>
        <pub-id pub-id-type="pmid">14574645</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B8">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Li</surname>
          <given-names>Y</given-names>
        </name>
        <name>
          <surname>Willer</surname>
          <given-names>CJ</given-names>
        </name>
        <name>
          <surname>Ding</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Scheet</surname>
          <given-names>P</given-names>
        </name>
        <name>
          <surname>Abecasis</surname>
          <given-names>GR</given-names>
        </name>
        <article-title>MaCH: using sequence and genotype data to estimate haplotypes and unobserved
genotypes</article-title>
        <source>Genet Epidemiol</source>
        <year>2010</year>
        <volume>34</volume>
        <issue>8</issue>
        <fpage>816</fpage>
        <lpage>834</lpage>
        <pub-id pub-id-type="doi">10.1002/gepi.20533</pub-id>
        <pub-id pub-id-type="pmid">21058334</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B9">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Browning</surname>
          <given-names>SR</given-names>
        </name>
        <name>
          <surname>Browning</surname>
          <given-names>BL</given-names>
        </name>
        <article-title>Haplotype phasing: existing methods and new developments</article-title>
        <source>Nat Rev Genet</source>
        <year>2011</year>
        <volume>12</volume>
        <fpage>703</fpage>
        <lpage>714</lpage>
        <pub-id pub-id-type="pmid">21921926</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B10">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Bansal</surname>
          <given-names>V</given-names>
        </name>
        <name>
          <surname>Halpern</surname>
          <given-names>AL</given-names>
        </name>
        <name>
          <surname>Axelrod</surname>
          <given-names>N</given-names>
        </name>
        <name>
          <surname>Bafna</surname>
          <given-names>V</given-names>
        </name>
        <article-title>An MCMC algorithm for haplotype assembly from whole-genome sequence data</article-title>
        <source>Genome Res</source>
        <year>2008</year>
        <volume>18</volume>
        <fpage>1336</fpage>
        <lpage>1346</lpage>
        <pub-id pub-id-type="doi">10.1101/gr.077065.108</pub-id>
        <pub-id pub-id-type="pmid">18676820</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B11">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Bansal</surname>
          <given-names>V</given-names>
        </name>
        <name>
          <surname>Bafna</surname>
          <given-names>V</given-names>
        </name>
        <article-title>HapCUT: an efficient and accurate algorithm for the haplotype assembly problem</article-title>
        <source>Bioinformatics</source>
        <year>2008</year>
        <volume>24</volume>
        <fpage>i153</fpage>
        <lpage>159</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btn298</pub-id>
        <pub-id pub-id-type="pmid">18689818</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B12">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Chen</surname>
          <given-names>Z</given-names>
        </name>
        <name>
          <surname>Fu</surname>
          <given-names>B</given-names>
        </name>
        <name>
          <surname>Schweller</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Yang</surname>
          <given-names>B</given-names>
        </name>
        <name>
          <surname>Zhao</surname>
          <given-names>Z</given-names>
        </name>
        <name>
          <surname>Zhu</surname>
          <given-names>B</given-names>
        </name>
        <article-title>Linear time probabilistic algorithms for the singular haplotype reconstruction
problem from SNP fragments</article-title>
        <source>J Comput Biol</source>
        <year>2008</year>
        <volume>15</volume>
        <fpage>535</fpage>
        <lpage>546</lpage>
        <pub-id pub-id-type="doi">10.1089/cmb.2008.0003</pub-id>
        <pub-id pub-id-type="pmid">18549306</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B13">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Duitama</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>McEwen</surname>
          <given-names>GK</given-names>
        </name>
        <name>
          <surname>Huebsch</surname>
          <given-names>T</given-names>
        </name>
        <name>
          <surname>Palczewski</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Schulz</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Verstrepen</surname>
          <given-names>K</given-names>
        </name>
        <name>
          <surname>Suk</surname>
          <given-names>EK</given-names>
        </name>
        <name>
          <surname>Hoehe</surname>
          <given-names>MR</given-names>
        </name>
        <article-title>Fosmid-based whole genome haplotyping of a HapMap trio child: evaluation of Single
Individual Haplotyping techniques</article-title>
        <source>Nucleic Acids Res</source>
        <year>2012</year>
        <volume>40</volume>
        <fpage>2041</fpage>
        <lpage>2053</lpage>
        <pub-id pub-id-type="doi">10.1093/nar/gkr1042</pub-id>
        <pub-id pub-id-type="pmid">22102577</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B14">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Kim</surname>
          <given-names>JH</given-names>
        </name>
        <name>
          <surname>Waterman</surname>
          <given-names>MS</given-names>
        </name>
        <name>
          <surname>Li</surname>
          <given-names>LM</given-names>
        </name>
        <article-title>Diploid genome reconstruction of Ciona intestinalis and comparative analysis with
Ciona savignyi</article-title>
        <source>Genome Res</source>
        <year>2007</year>
        <volume>17</volume>
        <fpage>1101</fpage>
        <lpage>1110</lpage>
        <pub-id pub-id-type="doi">10.1101/gr.5894107</pub-id>
        <pub-id pub-id-type="pmid">17567986</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B15">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Levy</surname>
          <given-names>S</given-names>
        </name>
        <etal/>
        <article-title>The diploid genome sequence of an individual human</article-title>
        <source>PLoS Biol</source>
        <year>2007</year>
        <volume>5</volume>
        <fpage>e254</fpage>
        <pub-id pub-id-type="doi">10.1371/journal.pbio.0050254</pub-id>
        <pub-id pub-id-type="pmid">17803354</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B16">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Li</surname>
          <given-names>LM</given-names>
        </name>
        <name>
          <surname>Kim</surname>
          <given-names>JH</given-names>
        </name>
        <name>
          <surname>Waterman</surname>
          <given-names>MS</given-names>
        </name>
        <article-title>Haplotype reconstruction from SNP alignment</article-title>
        <source>J Comput Biol</source>
        <year>2004</year>
        <volume>11</volume>
        <fpage>505</fpage>
        <lpage>516</lpage>
        <pub-id pub-id-type="doi">10.1089/1066527041410454</pub-id>
        <pub-id pub-id-type="pmid">15285905</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B17">
      <mixed-citation publication-type="other">
        <name>
          <surname>Panconesi</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Sozio</surname>
          <given-names>M</given-names>
        </name>
        <article-title>Fast Hare: a fast heuristic for single individual SNP haplotype reconstruction</article-title>
        <source>WABI'04</source>
        <year>2004</year>
        <fpage>266</fpage>
        <lpage>277</lpage>
      </mixed-citation>
    </ref>
    <ref id="B18">
      <mixed-citation publication-type="journal">
        <collab>The 1000 Genomes Project Consortium</collab>
        <article-title>A map of human genome variation from population-scale sequencing</article-title>
        <source>Nature</source>
        <year>2010</year>
        <volume>467</volume>
        <fpage>1061</fpage>
        <lpage>1073</lpage>
        <pub-id pub-id-type="doi">10.1038/nature09534</pub-id>
        <pub-id pub-id-type="pmid">20981092</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B19">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Eid</surname>
          <given-names>J</given-names>
        </name>
        <etal/>
        <article-title>Real-time DNA sequencing from single polymerase molecules</article-title>
        <source>Science</source>
        <year>2009</year>
        <volume>323</volume>
        <fpage>133</fpage>
        <lpage>138</lpage>
        <pub-id pub-id-type="doi">10.1126/science.1162986</pub-id>
        <pub-id pub-id-type="pmid">19023044</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B20">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Kitzman</surname>
          <given-names>JO</given-names>
        </name>
        <name>
          <surname>Mackenzie</surname>
          <given-names>AP</given-names>
        </name>
        <name>
          <surname>Adey</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Hiatt</surname>
          <given-names>JB</given-names>
        </name>
        <name>
          <surname>Patwardhan</surname>
          <given-names>RP</given-names>
        </name>
        <name>
          <surname>Sudmant</surname>
          <given-names>PH</given-names>
        </name>
        <name>
          <surname>Ng</surname>
          <given-names>SB</given-names>
        </name>
        <name>
          <surname>Alkan</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Qiu</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Eichler</surname>
          <given-names>EE</given-names>
        </name>
        <name>
          <surname>Shendure</surname>
          <given-names>J</given-names>
        </name>
        <article-title>Haplotype-resolved genome sequencing of a Gujarati Indian individual</article-title>
        <source>Nat Biotechnol</source>
        <year>2011</year>
        <volume>29</volume>
        <fpage>59</fpage>
        <lpage>63</lpage>
        <pub-id pub-id-type="doi">10.1038/nbt.1740</pub-id>
        <pub-id pub-id-type="pmid">21170042</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B21">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Suk</surname>
          <given-names>EK</given-names>
        </name>
        <name>
          <surname>McEwen</surname>
          <given-names>GK</given-names>
        </name>
        <name>
          <surname>Duitama</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Nowick</surname>
          <given-names>K</given-names>
        </name>
        <name>
          <surname>Schulz</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Palczewski</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Schreiber</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Holloway</surname>
          <given-names>DT</given-names>
        </name>
        <name>
          <surname>McLaughlin</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Peckham</surname>
          <given-names>H</given-names>
        </name>
        <name>
          <surname>Lee</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Huebsch</surname>
          <given-names>T</given-names>
        </name>
        <name>
          <surname>Hoehe</surname>
          <given-names>MR</given-names>
        </name>
        <article-title>A comprehensively molecular haplotype-resolved genome of a European individual</article-title>
        <source>Genome Res</source>
        <year>2011</year>
        <volume>21</volume>
        <fpage>1672</fpage>
        <lpage>1685</lpage>
        <pub-id pub-id-type="doi">10.1101/gr.125047.111</pub-id>
        <pub-id pub-id-type="pmid">21813624</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B22">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Coop</surname>
          <given-names>G</given-names>
        </name>
        <name>
          <surname>Wen</surname>
          <given-names>X</given-names>
        </name>
        <name>
          <surname>Ober</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Pritchard</surname>
          <given-names>JK</given-names>
        </name>
        <name>
          <surname>Przeworski</surname>
          <given-names>M</given-names>
        </name>
        <article-title>High-resolution mapping of crossovers reveals extensive variation in fine-scale
recombination patterns among humans</article-title>
        <source>Science</source>
        <year>2008</year>
        <volume>319</volume>
        <issue>5868</issue>
        <fpage>1395</fpage>
        <lpage>1398</lpage>
        <pub-id pub-id-type="doi">10.1126/science.1151851</pub-id>
        <pub-id pub-id-type="pmid">18239090</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B23">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Dewal</surname>
          <given-names>N</given-names>
        </name>
        <name>
          <surname>Hu</surname>
          <given-names>Y</given-names>
        </name>
        <name>
          <surname>Freedman</surname>
          <given-names>ML</given-names>
        </name>
        <name>
          <surname>Laframboise</surname>
          <given-names>T</given-names>
        </name>
        <name>
          <surname>Pe'er</surname>
          <given-names>I</given-names>
        </name>
        <article-title>Calling amplified haplotypes in next generation tumor sequence data</article-title>
        <source>Genome Res</source>
        <year>2012</year>
        <volume>22</volume>
        <issue>2</issue>
        <fpage>362</fpage>
        <lpage>374</lpage>
        <pub-id pub-id-type="doi">10.1101/gr.122564.111</pub-id>
        <pub-id pub-id-type="pmid">22090379</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B24">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Kitzman</surname>
          <given-names>JO</given-names>
        </name>
        <name>
          <surname>Snyder</surname>
          <given-names>MW</given-names>
        </name>
        <name>
          <surname>Ventura</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Lewis</surname>
          <given-names>AP</given-names>
        </name>
        <name>
          <surname>Qiu</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Simmons</surname>
          <given-names>LE</given-names>
        </name>
        <name>
          <surname>Gammill</surname>
          <given-names>HS</given-names>
        </name>
        <name>
          <surname>Rubens</surname>
          <given-names>CE</given-names>
        </name>
        <name>
          <surname>Santillan</surname>
          <given-names>DA</given-names>
        </name>
        <name>
          <surname>Murray</surname>
          <given-names>JC</given-names>
        </name>
        <name>
          <surname>Tabor</surname>
          <given-names>HK</given-names>
        </name>
        <name>
          <surname>Bamshad</surname>
          <given-names>MJ</given-names>
        </name>
        <name>
          <surname>Eichler</surname>
          <given-names>EE</given-names>
        </name>
        <name>
          <surname>Shendure</surname>
          <given-names>J</given-names>
        </name>
        <article-title>Noninvasive whole-genome sequencing of a human fetus</article-title>
        <source>Sci Transl Med</source>
        <year>2012</year>
        <volume>4</volume>
        <issue>137</issue>
        <fpage>137ra76</fpage>
        <pub-id pub-id-type="doi">10.1126/scitranslmed.3004323</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B25">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Gabriel</surname>
          <given-names>SB</given-names>
        </name>
        <name>
          <surname>Schaffner</surname>
          <given-names>SF</given-names>
        </name>
        <name>
          <surname>Nguyen</surname>
          <given-names>H</given-names>
        </name>
        <name>
          <surname>Moore</surname>
          <given-names>JM</given-names>
        </name>
        <name>
          <surname>Roy</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Blumenstiel</surname>
          <given-names>B</given-names>
        </name>
        <name>
          <surname>Higgins</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>DeFelice</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Lochner</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Faggart</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Liu-Cordero</surname>
          <given-names>SN</given-names>
        </name>
        <name>
          <surname>Rotimi</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Adeyemo</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Cooper</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Ward</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Lander</surname>
          <given-names>ES</given-names>
        </name>
        <name>
          <surname>Daly</surname>
          <given-names>MJ</given-names>
        </name>
        <name>
          <surname>Altshuler</surname>
          <given-names>D</given-names>
        </name>
        <article-title>The structure of haplotype blocks in the human genome</article-title>
        <source>Science</source>
        <year>2002</year>
        <volume>296</volume>
        <issue>5576</issue>
        <fpage>2225</fpage>
        <lpage>2229</lpage>
        <pub-id pub-id-type="doi">10.1126/science.1069424</pub-id>
        <pub-id pub-id-type="pmid">12029063</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B26">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Zhang</surname>
          <given-names>K</given-names>
        </name>
        <name>
          <surname>Deng</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Chen</surname>
          <given-names>T</given-names>
        </name>
        <name>
          <surname>Waterman</surname>
          <given-names>MS</given-names>
        </name>
        <name>
          <surname>Sun</surname>
          <given-names>F</given-names>
        </name>
        <article-title>A dynamic programming algorithm for haplotype block partitioning</article-title>
        <source>Proc Natl Acad Sci USA</source>
        <year>2002</year>
        <volume>99</volume>
        <issue>11</issue>
        <fpage>7335</fpage>
        <lpage>7339</lpage>
        <pub-id pub-id-type="doi">10.1073/pnas.102186799</pub-id>
        <pub-id pub-id-type="pmid">12032283</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B27">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Anderson</surname>
          <given-names>EC</given-names>
        </name>
        <name>
          <surname>Novembre</surname>
          <given-names>J</given-names>
        </name>
        <article-title>Finding haplotype block boundaries by using the minimum-description-length
principle</article-title>
        <source>Am J Hum Genet</source>
        <year>2003</year>
        <volume>73</volume>
        <issue>2</issue>
        <fpage>336</fpage>
        <lpage>354</lpage>
        <pub-id pub-id-type="doi">10.1086/377106</pub-id>
        <pub-id pub-id-type="pmid">12858289</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B28">
      <mixed-citation publication-type="book">
        <name>
          <surname>Karp</surname>
          <given-names>RM</given-names>
        </name>
        <article-title>Reducibility among combinatorial problems</article-title>
        <source>Complexity of Computer Computation</source>
        <year>1972</year>
        <publisher-name>Plenum Press</publisher-name>
        <fpage>85</fpage>
        <lpage>103</lpage>
      </mixed-citation>
    </ref>
    <ref id="B29">
      <mixed-citation publication-type="other">
        <name>
          <surname>Attias</surname>
          <given-names>H</given-names>
        </name>
        <article-title>Inferring parameters and structure of latent variable models by variational
Bayes</article-title>
        <source>UAI'99</source>
        <year>1999</year>
        <fpage>21</fpage>
        <lpage>30</lpage>
      </mixed-citation>
    </ref>
    <ref id="B30">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Zhi</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Wu</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Liu</surname>
          <given-names>N</given-names>
        </name>
        <name>
          <surname>Zhang</surname>
          <given-names>K</given-names>
        </name>
        <article-title>Genotype calling from next-generation sequencing data using haplotype information
of reads</article-title>
        <source>Bioinformatics</source>
        <year>2012</year>
        <volume>28</volume>
        <issue>7</issue>
        <fpage>938</fpage>
        <lpage>946</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/bts047</pub-id>
        <pub-id pub-id-type="pmid">22285565</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B31">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Geraci</surname>
          <given-names>F</given-names>
        </name>
        <article-title>A comparison of several algorithms for the single individual SNP haplotyping
reconstruction problem</article-title>
        <source>Bioinformatics</source>
        <year>2010</year>
        <volume>26</volume>
        <fpage>2217</fpage>
        <lpage>2225</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btq411</pub-id>
        <pub-id pub-id-type="pmid">20624781</pub-id>
      </mixed-citation>
    </ref>
  </ref-list>
</back>
