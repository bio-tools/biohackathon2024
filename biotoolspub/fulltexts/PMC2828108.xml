<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//NLM//DTD Journal Publishing DTD v2.3 20070202//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName journalpublishing.dtd?>
<?SourceDTD.Version 2.3?>
<?ConverterInfo.XSLTName jp2nlmx2.xsl?>
<?ConverterInfo.Version 2?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-id journal-id-type="hwp">bioinfo</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">2828108</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/btp698</article-id>
    <article-id pub-id-type="publisher-id">btp698</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Original Papers</subject>
        <subj-group>
          <subject>Sequence Analysis</subject>
        </subj-group>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Fast and accurate long-read alignment with Burrows‚ÄìWheeler transform</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Li</surname>
          <given-names>Heng</given-names>
        </name>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Durbin</surname>
          <given-names>Richard</given-names>
        </name>
        <xref ref-type="corresp" rid="COR1">*</xref>
      </contrib>
    </contrib-group>
    <aff>Wellcome Trust Sanger Institute, Wellcome Genome Campus, Cambridge, CB10 1SA, UK</aff>
    <author-notes>
      <corresp id="COR1">* To whom correspondence should be addressed.</corresp>
      <fn>
        <p>Associate Editor: Dmitrij Frishman</p>
      </fn>
    </author-notes>
    <pub-date pub-type="ppub">
      <day>1</day>
      <month>3</month>
      <year>2010</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>15</day>
      <month>1</month>
      <year>2010</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>15</day>
      <month>1</month>
      <year>2010</year>
    </pub-date>
    <!-- PMC Release delay is 0 months and 0 days and was based on the
							<pub-date pub-type="epub"/>. -->
    <volume>26</volume>
    <issue>5</issue>
    <fpage>589</fpage>
    <lpage>595</lpage>
    <history>
      <date date-type="received">
        <day>19</day>
        <month>9</month>
        <year>2009</year>
      </date>
      <date date-type="rev-recd">
        <day>24</day>
        <month>11</month>
        <year>2009</year>
      </date>
      <date date-type="accepted">
        <day>16</day>
        <month>12</month>
        <year>2009</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>¬© The Author(s) 2010. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2010</copyright-year>
      <license license-type="creative-commons" xlink:href="http://creativecommons.org/licenses/by-nc/2.0/uk/">
        <license-p><!--CREATIVE COMMONS-->This is an Open Access article distributed under the terms of the Creative Commons Attribution Non-Commercial License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by-nc/2.5">http://creativecommons.org/licenses/by-nc/2.5</ext-link>), which permits unrestricted non-commercial use, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <abstract>
      <p><bold>Motivation:</bold> Many programs for aligning short sequencing reads to a reference genome have been developed in the last 2 years. Most of them are very efficient for short reads but inefficient or not applicable for reads &gt;200 bp because the algorithms are heavily and specifically tuned for short queries with low sequencing error rate. However, some sequencing platforms already produce longer reads and others are expected to become available soon. For longer reads, hashing-based software such as BLAT and SSAHA2 remain the only choices. Nonetheless, these methods are substantially slower than short-read aligners in terms of aligned bases per unit time.</p>
      <p><bold>Results:</bold> We designed and implemented a new algorithm, Burrows-Wheeler Aligner's Smith-Waterman Alignment (BWA-SW), to align long sequences up to 1 Mb against a large sequence database (e.g. the human genome) with a few gigabytes of memory. The algorithm is as accurate as SSAHA2, more accurate than BLAT, and is several to tens of times faster than both.</p>
      <p>
        <bold>Availability:</bold>
        <ext-link ext-link-type="uri" xlink:href="http://bio-bwa.sourceforge.net">http://bio-bwa.sourceforge.net</ext-link>
      </p>
      <p>
        <bold>Contact:</bold>
        <email>rd@sanger.ac.uk</email>
      </p>
    </abstract>
  </article-meta>
</front>
<body>
  <sec sec-type="intro" id="SEC1">
    <title>1 INTRODUCTION</title>
    <p>Following the development of sensitive local alignment software, such as FASTA (Pearson and Lipman, <xref ref-type="bibr" rid="B19">1988</xref>) and BLAST (Altschul <italic>et al.</italic>, <xref ref-type="bibr" rid="B1">1997</xref>) around 1990, a new generation of faster methods to find DNA sequence matches was developed since 2000, including MegaBLAST (Morgulis <italic>et al.</italic>, <xref ref-type="bibr" rid="B17">2008</xref>; Zhang <italic>et al.</italic>, <xref ref-type="bibr" rid="B23">2000</xref>), SSAHA2 (Ning <italic>et al.</italic>, <xref ref-type="bibr" rid="B18">2001</xref>), BLAT (Kent, <xref ref-type="bibr" rid="B7">2002</xref>) and PatternHunter (Ma <italic>et al.</italic>, <xref ref-type="bibr" rid="B15">2002</xref>), greatly speeding up matching capillary sequencing reads against a large reference genome. When new sequencing technologies arrived that generated millions of short (&lt;100 bp) reads, a variety of new algorithms were developed which were 10‚Äì1000 times faster, including SOAP (Li,R. <italic>et al.</italic>, <xref ref-type="bibr" rid="B13">2008</xref>), MAQ (Li,H. <italic>et al.</italic>, <xref ref-type="bibr" rid="B11">2008</xref>), Bowtie (Langmead <italic>et al.</italic>, <xref ref-type="bibr" rid="B9">2009</xref>) and BWA (Li and Durbin, <xref ref-type="bibr" rid="B10">2009</xref>). However, Roche/454 sequencing technology has already produced reads &gt;400 bp in production, Illumina gradually increases read length &gt;100 bp, and Pacific Bioscience generates 1000 bp reads in early testing (Eid <italic>et al.</italic>, <xref ref-type="bibr" rid="B4">2009</xref>). Reads coming from the new sequencing technologies are not short any more, which effectively rules out many of the new aligners exclusively designed for reads no longer than 100 bp. Efficiently aligning long reads against a long reference sequence like the human genome poses a new challenge to the development of alignment tools.</p>
    <p>Long-read alignment has different objectives from short-read alignment. First, in short-read alignment, we would usually like to align the full-length read to reduce the reference bias caused by the mismatches toward the ends of the read. Given this requirement, we can design spaced seed templates (Ma <italic>et al.</italic>, <xref ref-type="bibr" rid="B15">2002</xref>) spanning the entire read (Jiang and Wong, <xref ref-type="bibr" rid="B6">2008</xref>; Lin <italic>et al.</italic>, <xref ref-type="bibr" rid="B14">2008</xref>; Smith <italic>et al.</italic>, <xref ref-type="bibr" rid="B21">2008</xref>), or quickly filter out poor matches, for example, by applying q-gram filtration (Rumble <italic>et al.</italic>, <xref ref-type="bibr" rid="B20">2009</xref>; Weese <italic>et al.</italic>, <xref ref-type="bibr" rid="B22">2009</xref>) or by bounding the search process (Li and Durbin, <xref ref-type="bibr" rid="B10">2009</xref>), and thus accelerate the alignment. In long-read alignment, however, we would prefer to find local matches because a long read is more fragile to structural variations and misassemblies in the reference but is less affected by the mismatches close to the ends of a read. Secondly, many short-read aligners are only efficient when doing ungapped alignment or allowing limited gaps, e.g. a maximum of one gap. They cannot find more gaps or the performance quickly degrades when they are tuned for this task. Long-read aligners, however, must be permissive about alignment gaps because indels occur more frequently in long reads and may be the dominant source of sequencing errors for some technologies such as 454 and Pacific Bioscience.</p>
    <p>When considering algorithms to speed-up long-read alignment, hash table indexing as is used in most current software is not the only choice. Meek <italic>et al.</italic> (<xref ref-type="bibr" rid="B16">2003</xref>) found a Smith‚ÄìWaterman-like dynamic programming that can be applied between a query sequence and the suffix tree of the reference, effectively aligning the query against each subsequence sampled from the suffix tree via a top-down traversal. As on a suffix tree identical sequences are collapsed on a single path, time is saved by avoiding repeated alignment of identical subsequences. Lam <italic>et al.</italic> (<xref ref-type="bibr" rid="B8">2008</xref>) furthered this idea by implicitly representing the suffix tree with an FM-index (Ferragina and Manzini, <xref ref-type="bibr" rid="B5">2000</xref>), which is based on the Burrows‚ÄìWheeler Transform (BWT; Burrows and Wheeler, <xref ref-type="bibr" rid="B3">1994</xref>), to achieve a small memory footprint. Their new algorithm, BWT-SW, is able to deliver identical results to the standard Smith‚ÄìWaterman alignment, but thousands of times faster when aligning against the human genome sequence. While BWT-SW is still slower than BLAST on long query sequences, it finds all matches without heuristics. One can imagine that introducing heuristics would further accelerate BWT-SW. Our BWA-SW algorithm follows this route.</p>
    <p>To some extent, BWA-SW, as well as BWT-SW, also follows the seed-and-extend paradigm. But different from BLAT and SSAHA2, BWA-SW finds seeds by dynamic programming between two FM-indices and allows mismatches and gaps in the seeds. It extends a seed when the seed has few occurrences in the reference sequence. Speed is gained by reducing unnecessary extension for highly repetitive sequences.</p>
    <p>In this article, we will describe this new alignment algorithm, BWA-SW, for long-read alignments and evaluate its practical performance along with BLAT and SSAHA2 on both simulated and real data. We will also give a brief introduction to suffix array and FM-index, but readers are referred to Li and Durbin (<xref ref-type="bibr" rid="B10">2009</xref>) for more details.</p>
  </sec>
  <sec sec-type="methods" id="SEC2">
    <title>2 METHODS</title>
    <sec id="SEC2.1">
      <title>2.1 Overview of the BWA-SW algorithm</title>
      <p>BWA-SW builds FM-indices for both the reference and query sequence. It implicitly represents the reference sequence in a prefix trie and represents the query sequence in a prefix directed acyclic word graph (prefix DAWG; Blumer <italic>et al.</italic>, <xref ref-type="bibr" rid="B2">1985</xref>), which is transformed from the prefix trie of the query sequence (<xref ref-type="sec" rid="SEC2.3">Section 2.3</xref>). A dynamic programming can be applied between the trie and the DAWG, by traversing the reference prefix trie and the query DAWG, respectively. This dynamic programming would find all local matches if no heuristics were applied, but would be no faster than BWT-SW. In BWA-SW, we apply two heuristic rules to greatly accelerate this process. First, traversal on the query DAWG is carried in the outer loop, and therefore without finishing the dynamic programming, we know all the nodes in the reference prefix trie that match the query node with a positive score. Based on the observation that the true alignment tends to have a high alignment score, we can prune low-scoring matches at each node to restrict the dynamic programming around good matches only. The scale of dynamic programming can thus be dramatically reduced. It is possible for the true alignment to be pruned in this process, but in practice, this can be controlled by the use of heuristics and happens rarely, given long or high-quality query sequences. Secondly, BWA-SW only reports alignments largely non-overlapping on the query sequence instead of giving all the significant local alignments. It heuristically identifies and discards seeds contained in a longer alignment and thus saves computing time on unsuccessful seed extensions.</p>
    </sec>
    <sec id="SEC2.2">
      <title>2.2 Notations and definitions</title>
      <sec id="SEC2.2.1">
        <title>2.2.1 Suffix array and BWT</title>
        <p>Let Œ£={<italic>A</italic>, <italic>C</italic>, <italic>G</italic>, <italic>T</italic>} be the alphabet of nucleotides and $ be a symbol that is lexicographically smaller than all the symbols in Œ£. Given a nucleotide sequence <italic>X</italic>=<italic>a</italic><sub>1</sub>‚Ä¶<italic>a</italic><sub><italic>n</italic>‚àí1</sub> with <italic>a</italic><sub><italic>n</italic>‚àí1</sub>=$, let <italic>X</italic>[<italic>i</italic>]=<italic>a</italic><sub><italic>i</italic></sub> be the <italic>i</italic>-th symbol, <italic>X</italic>[<italic>i</italic>, <italic>j</italic>]=<italic>a</italic><sub><italic>i</italic></sub>‚Ä¶<italic>a</italic><sub><italic>j</italic></sub> a subsequence of <italic>X</italic> and <italic>X</italic><sub><italic>i</italic></sub>=<italic>X</italic>[<italic>i</italic>, <italic>n</italic>‚àí1] a suffix of <italic>X</italic>. The suffix array <italic>S</italic> of <italic>X</italic> is a permutation of integers 0,‚Ä¶, <italic>n</italic>‚àí1 such that <italic>S</italic>(<italic>i</italic>)=<italic>j</italic> if and only if <italic>X</italic><sub><italic>j</italic></sub> is the <italic>i</italic>-th lexicographically smallest suffix. The BWT of <italic>X</italic> is a permutation of <italic>X</italic>, where <italic>B</italic>[<italic>i</italic>]=$ if <italic>S</italic>(<italic>i</italic>)=0 and <italic>B</italic>[<italic>i</italic>]=<italic>X</italic>[<italic>S</italic>(<italic>i</italic>)‚àí1] otherwise.</p>
      </sec>
      <sec id="SEC2.2.2">
        <title>2.2.2 Suffix array interval</title>
        <p>Given a sequence <italic>W</italic>, the <italic>suffix array interval</italic> or <italic>SA interval</italic> <inline-formula><inline-graphic xlink:href="btp698i1.jpg"/></inline-formula> of <italic>W</italic> is defined as
<disp-formula><graphic xlink:href="btp698um1"/></disp-formula>
In particular, if <italic>W</italic> is an empty string, <underline><italic>R</italic></underline>(<italic>W</italic>)=1 and <inline-formula><inline-graphic xlink:href="btp698i2.jpg"/></inline-formula>. The set of the positions of all the occurrences of <italic>W</italic> is <inline-formula><inline-graphic xlink:href="btp698i3.jpg"/></inline-formula>.</p>
        <p>Let <italic>C</italic>(<italic>a</italic>)=#{0‚â§<italic>j</italic>‚â§<italic>n</italic>‚àí2:<italic>X</italic>[<italic>j</italic>]&lt;<italic>a</italic>} and <italic>O</italic>(<italic>a</italic>,<italic>i</italic>)=#{0‚â§<italic>j</italic>‚â§<italic>i</italic>:<italic>B</italic>[<italic>j</italic>]&lt;<italic>a</italic>}, where #{¬∑} calculates the cardinality (or size) of a set. Ferragina and Manzini (<xref ref-type="bibr" rid="B5">2000</xref>) proved that
<disp-formula><graphic xlink:href="btp698um2"/></disp-formula>
and that <inline-formula><inline-graphic xlink:href="btp698i4.jpg"/></inline-formula> if and only if <italic>aW</italic> is a substring of <italic>X</italic>.</p>
      </sec>
      <sec id="SEC2.2.3">
        <title>2.2.3 FM-index</title>
        <p>The suffix array <italic>S</italic>, array <italic>C</italic> and <italic>O</italic> suffice for the exact search of a pattern in <italic>X</italic>. FM-index (Ferragina and Manzini, <xref ref-type="bibr" rid="B5">2000</xref>) is a compressed representation of the three arrays, consisting of the compressed BWT string <italic>B</italic>, auxiliary arrays for calculating <italic>O</italic>, and part of the suffix array <italic>S</italic>. BWA-SW, however, uses a simplified FM-index where we do not compress <italic>B</italic> and store part of the occurrence array <italic>O</italic> without auxiliary data structures. The simplified version is more efficient for DNA sequences with a very small alphabet. Details on the construction are presented in our previous paper (Li and Durbin, <xref ref-type="bibr" rid="B10">2009</xref>).</p>
      </sec>
      <sec id="SEC2.2.4">
        <title>2.2.4 Alignment</title>
        <p>An <italic>alignment</italic> is a tuple (<italic>W</italic><sub>1</sub>, <italic>W</italic><sub>2</sub>, <italic>A</italic>) where <italic>W</italic><sub>1</sub> and <italic>W</italic><sub>2</sub> are two strings and <italic>A</italic> is a series of copying, substitution, insertion and deletion operations which transform <italic>W</italic><sub>2</sub> into <italic>W</italic><sub>1</sub>. Insertions and deletions are <italic>gaps</italic>. Gaps and substitutions are <italic>differences</italic>. The <italic>edit distance</italic> of the alignment equals the total number of differences in <italic>A</italic>.</p>
        <p>A score can be calculated for an alignment given a scoring system. We say <italic>W</italic><sub>1</sub> matches <italic>W</italic><sub>2</sub> if <italic>W</italic><sub>1</sub> and <italic>W</italic><sub>2</sub> can be aligned with a positive score, and in this case, we also say (<italic>W</italic><sub>1</sub>, <italic>W</italic><sub>2</sub>) is a match.</p>
        <p>A match (<italic>W</italic><sub>1</sub>, <italic>W</italic><sub>2</sub>) is said to be <italic>contained</italic> in (<italic>W</italic>‚Ä≤<sub>1</sub>, <italic>W</italic>‚Ä≤<sub>2</sub>) on the first sequence if <italic>W</italic><sub>1</sub> is a substring of <italic>W</italic>‚Ä≤<sub>1</sub>. Similarly, we can define the ‚Äòcontained‚Äô relationship between alignments (a stronger condition) and between an alignment and a match.</p>
      </sec>
    </sec>
    <sec id="SEC2.3">
      <title>2.3 Prefix trie and prefix DAWG</title>
      <p>The <italic>prefix trie</italic> of string <italic>X</italic> is a tree with each edge labeled with a symbol such that the concatenation of symbols on the path from a leaf to the root gives a unique prefix of <italic>X</italic>. The concatenation of edge symbols from a node to the root is always a substring of <italic>X</italic>, called the string represented by the node. The <italic>SA interval</italic> of a node is defined as the SA interval of the string represented by the node. Different nodes may have an identical interval, but recalling the definition of SA interval, we know that the strings represented by these nodes must be the prefixes of the same string and have different lengths.</p>
      <p>The <italic>prefix DAWG</italic>, of <italic>X</italic> is transformed from the prefix trie by collapsing nodes having an identical interval. Thus in the prefix DAWG, nodes and SA intervals have an one-to-one relationship, and a node may represent multiple substrings of <italic>X</italic>, falling in a sequence where each is a prefix of the next as is discussed in the previous paragraph. <xref ref-type="fig" rid="F1">Figure 1</xref> gives an example.
<fig id="F1" position="float"><label>Fig. 1.</label><caption><p>Prefix trie and prefix DAWG of string ‚Äò<monospace>GOOGOL</monospace>‚Äô. (<bold>A</bold>) Prefix trie. Symbol ‚Äò‚àß‚Äô marks the start of a string. The two numbers in a node gives the SA interval of the node. (<bold>B</bold>) Prefix DAWG constructed by collapsing nodes with the identical SA interval. For example, in the prefix trie, three nodes has SA interval [4, 4]. Their parents have interval [1, 2], [1, 2] and [1, 1], respectively. In the prefix DAWG, the [4, 4] node thus has parents [1, 2] and [1, 1]. Node [4, 4] represents three strings ‚Äò<monospace>OG</monospace>‚Äô, ‚Äò<monospace>OGO</monospace>‚Äô and ‚Äò<monospace>OGOL</monospace>‚Äô with the first two strings being the prefix of ‚Äò<monospace>OGOL</monospace>‚Äô. (A) is modified from <xref ref-type="fig" rid="F1">Figure 1</xref> in Li and Durbin (<xref ref-type="bibr" rid="B10">2009</xref>).</p></caption><graphic xlink:href="btp698f1"/></fig></p>
    </sec>
    <sec id="SEC2.4">
      <title>2.4 Aligning prefix trie against prefix DAWG</title>
      <p>We construct a prefix DAWG ùí¢(<italic>W</italic>) for the query sequence <italic>W</italic> and a prefix trie ùíØ(<italic>X</italic>) for the reference <italic>X</italic>. The dynamic programming for calculating the best score between <italic>W</italic> and <italic>X</italic> is as follows. Let <italic>G</italic><sub><italic>uv</italic></sub>=<italic>I</italic><sub><italic>uv</italic></sub>=<italic>D</italic><sub><italic>uv</italic></sub>=0 when <italic>u</italic> is the root of ùí¢(<italic>W</italic>) and <italic>v</italic> the root of ùíØ(<italic>X</italic>). At a node <italic>u</italic> in ùí¢(<italic>W</italic>), for each of its parent node <italic>u</italic>‚Ä≤, calculate
<disp-formula><graphic xlink:href="btp698um3"/></disp-formula>
where <italic>v</italic>‚Ä≤ is the parent of <italic>v</italic> in ùíØ(<italic>X</italic>), function <italic>S</italic>(<italic>u</italic>‚Ä≤, <italic>u</italic>; <italic>v</italic>‚Ä≤, <italic>v</italic>) gives the score between the symbol on the edge (<italic>u</italic>‚Ä≤, <italic>u</italic>) and the one on (<italic>v</italic>‚Ä≤, <italic>v</italic>), and <italic>q</italic> and <italic>r</italic> are gap open and gap extension penalties, respectively. <italic>G</italic><sub><italic>uv</italic></sub>, <italic>I</italic><sub><italic>uv</italic></sub> and <italic>D</italic><sub><italic>uv</italic></sub> are calculated with:
<disp-formula><graphic xlink:href="btp698um4"/></disp-formula>
<disp-formula><graphic xlink:href="btp698um5"/></disp-formula>
where pre(<italic>u</italic>) is the set of parent nodes of <italic>u</italic>. <italic>G</italic><sub><italic>uv</italic></sub> equals the best score between the (possibly multiple) substrings represented by <italic>u</italic> and the (one) substring represented by <italic>v</italic>. We say a node <italic>v matches u</italic> if <italic>G</italic><sub><italic>uv</italic></sub>&gt;0.</p>
      <p>The dynamic programming is performed by traversing both ùí¢(<italic>W</italic>) and ùíØ(<italic>X</italic>) in the reverse post-order (i.e. all parent nodes are visited before children) in a nested way. Noting that once <italic>u</italic> does not match <italic>v</italic>, <italic>u</italic> does not match any nodes descending from <italic>v</italic>, we only need to visit the nodes close to the root of ùíØ(<italic>X</italic>) without traversing the entire trie, which greatly reduces the number of iterations in comparison to the standard Smith‚ÄìWaterman algorithm that always goes through the entire reference sequence.</p>
    </sec>
    <sec id="SEC2.5">
      <title>2.5 Acceleration by the standard Smith‚ÄìWaterman</title>
      <p>In comparison to the standard Smith‚ÄìWaterman alignment whose time complexity is <italic>O</italic>(|<italic>X</italic>|¬∑|<italic>W</italic>|), BWA-SW has better time complexity since it is no slower than BWT-SW whose time complexity <italic>O</italic>(|<italic>X</italic>|<sup>0.628</sup>|<italic>W</italic>|) (Lam <italic>et al.</italic>, <xref ref-type="bibr" rid="B8">2008</xref>). This conclusion comes because for short sub-alignments we are considering multiple possible matches with a single <italic>uv</italic> comparison. However, the constant associated with each iteration is much larger due to the complex steps related to the traversal of prefix trie and prefix DAWG, which makes BWA-SW inefficient when we use BWA-SW to extend a unique alignment. A more efficient strategy would be to use BWA-SW to find partial matches and apply the Smith‚ÄìWaterman algorithm to extend. In dynamic programming, we know the number of partial matches being considered at any pair because this can be calculated from the size of the SA interval. When <italic>G</italic><sub><italic>uv</italic></sub> is good enough and the SA interval size of <italic>v</italic> is below a certain threshold (3 by default), we save the (<italic>u</italic>,<italic>v</italic>) pair, called a <italic>seed interval pair</italic>, and do not go deeper from the <italic>v</italic> node in ùíØ(<italic>X</italic>). By looking up the suffix array of <italic>X</italic> and <italic>W</italic>, we can derive <italic>seed matches</italic>, or simply <italic>seeds</italic>, from seed interval pairs. These seeds are then extended by the Smith‚ÄìWaterman algorithm later. If the entire query is a highly repetitive sequence, it will be aligned purely with the algorithm described in the last section without the Smith‚ÄìWaterman extension.</p>
      <p>Because we are stopping the dynamic programming early to generate seeds, the global best alignment may contain multiple seeds and in practice this will tend to be the case for long alignments. Typically for 1 kb alignments there will be 10‚Äì20 seeds. Below we will take advantage of this observation to heuristically speed up the search.</p>
      <p>BWT-SW deploys a similar strategy in performing the dynamic programming between a sequence and a prefix trie to find seed matches followed by Smith‚ÄìWaterman extension. The main difference from our algorithm is that BWT-SW initiates the Smith‚ÄìWaterman alignment once the score is high enough, regardless of the SA interval size. Sometimes a repetitive sequence may match to thousands of places in the human genome and extending partial matches each time may be slow.</p>
    </sec>
    <sec id="SEC2.6">
      <title>2.6 Heuristic accelerations</title>
      <sec id="SEC2.6.1">
        <title>2.6.1 Z-best strategy</title>
        <p>The algorithm described so far is exact in that it is able to deliver the same results as the Smith‚ÄìWaterman algorithm. Although it is much faster than the standard algorithm given a long reference sequence, it is not fast enough for aligning large-scale sequencing data. Closer investigation reveals that even for a unique 500 bp query sequence, a few million nodes in ùíØ(<italic>X</italic>) may match the query with a positive alignment score. The majority of these nodes are random matches or matches in short low-complexity regions. Visiting all of them is wasteful.</p>
        <p>To accelerate alignment, we traverse ùí¢(<italic>W</italic>) in the outer loop and ùíØ(<italic>X</italic>) in the inner loop, and at each node <italic>u</italic> in ùí¢(<italic>W</italic>) we only keep the top <italic>Z</italic> best scoring nodes in ùíØ(<italic>X</italic>) that match <italic>u</italic>, rather than keep all the matching nodes. This heuristic strategy is called <italic>Z-best</italic>. Of course, when we apply the <italic>Z</italic>-best strategy, we could miss a seed contained in the true alignment when a false match has a higher score. But if the query is nearly identical to the reference, this happens less often. In addition, if the true alignment is long and contains many seeds, the chance of all seeds being false is very small. On both simulated and real data (<xref ref-type="sec" rid="SEC3">Section 3</xref>), we find even <italic>Z</italic>=1 works well with high-quality 200 bp reads (&lt;5% sequencing error rate). Increasing <italic>Z</italic> to 10 or higher marginally improves the accuracy but greatly reduces the alignment speed.</p>
        <p>To reduce alignment errors, we also align the reverse query sequence to the reverse reference sequence, namely reverse‚Äìreverse alignment, in addition to the forward‚Äìforward alignment. Ideally, the forward‚Äìforward and the reverse‚Äìreverse alignments should yield identical outcomes, but if a seed in the true alignment has a low-scoring suffix (or prefix), the forward‚Äìforward (or reverse‚Äìreverse) alignment is likely to miss it, while combining the two rounds of alignment reduces the chance. Moreover, if the best alignment from the forward‚Äìforward alignment contains many seed matches, the chance of it being false is also small. In implementation, we do not apply the reverse‚Äìreverse alignment if the best alignment contains, by default, 5 or more seeds.</p>
      </sec>
      <sec id="SEC2.6.2">
        <title>2.6.2 Filtering seeds before the Smith‚ÄìWaterman extension</title>
        <p>Like BLAST, both BLAT and SSAHA2 report all significant alignments or typically tens of top-scoring alignments, but this is not the most desired output in read mapping. We are typically more interested in the best alignment or best few alignments, covering each region of the query sequence. For example, suppose a 1000 bp query sequence consists of a 900 bp segment from one chromosome and a 100 bp segment from another chromosome; 400 bp out of the 900 bp segment is a highly repetitive sequence. For BLAST, to know this is a chimeric read we would need to ask it to report all the alignments of the 400 bp repeat, which is costly and wasteful because in general we are not interested in alignments of short repetitive sequences contained in a longer unique sequence. On this example, a useful output would be to report one alignment each for the 900 bp and the 100 bp segment, and to indicate if the two segments have good suboptimal alignments that may render the best alignment unreliable. Such output simplifies downstream analyses and saves time on reconstructing the detailed alignments of the repetitive sequence.</p>
        <p>In BWA-SW, we say two alignments are <italic>distinct</italic> if the length of the overlapping region on the query is less than half of the length of the shorter query segment. We aim to find a set of distinct alignments which maximizes the sum of scores of each alignment in the set. This problem can be solved by dynamic programming, but as in our case a read is usually aligned entirely, a greedy approximation would work well. In the practical implementation, we sort the local alignments based on their alignment scores, scan the sorted list from the best one and keep an alignment if it is distinct from all the kept alignments with larger scores; if alignment <italic>a</italic><sub>2</sub> is rejected because it is not distinctive from <italic>a</italic><sub>1</sub>, we regard <italic>a</italic><sub>2</sub> to be a suboptimal alignment to <italic>a</italic><sub>1</sub> and use this information to approximate the mapping quality (<xref ref-type="sec" rid="SEC2.7">Section 2.7</xref>).</p>
        <p>Because we only retain alignments largely non-overlapping on the query sequence, we might as well discard seeds that do not contribute to the final alignments. Detecting such seeds can be done with another heuristic before the Smith‚ÄìWaterman extension and time spent on unnecessary extension can thus be saved. To identify these seeds, we chain seeds that are contained in a band (default band width 50 bp). If on the query sequence a short chain is fully contained in a long chain and the number of seeds in the short chain is below one-tenth of the number of seeds in the long chain, we discard all the seeds in the short chain, based on the observation that the short chain can rarely lead to a better alignment than the long chain in this case. Unlike the <italic>Z</italic>-best strategy, this heuristic does not have a noticeable effect on alignment accuracy. On 1000 10 kb simulated data, it halves the running time with no reduction in accuracy.</p>
      </sec>
    </sec>
    <sec id="SEC2.7">
      <title>2.7 Approximating mapping quality</title>
      <p>Li,H. <italic>et al.</italic> (<xref ref-type="bibr" rid="B11">2008</xref>) introduced the concept of mapping quality to estimate the probability of a query sequence being placed at a wrong position. If an alignment algorithm guarantees to find all local alignments, mapping quality is determined by these local alignments only. However, as BWA-SW deploys heuristic rules, the chance of producing a wrong alignment is also related to the heuristics. To estimate the mapping quality of a BWA-SW alignment, we fit an empirical formula: 250¬∑<italic>c</italic><sub>1</sub>¬∑<italic>c</italic><sub>2</sub>¬∑(<italic>S</italic><sub>1</sub>‚àí<italic>S</italic><sub>2</sub>)/<italic>S</italic><sub>1</sub>, where <italic>S</italic><sub>1</sub> is the score of the best alignment, <italic>S</italic><sub>2</sub> the score of the second best alignment, <italic>c</italic><sub>1</sub> equals 1 if the alignment covers more than four seeds or 0.5 otherwise, and <italic>c</italic><sub>2</sub> equals to 1 if the best alignment is found by both forward‚Äìforward and reverse‚Äìreverse alignments or 0.2 otherwise.</p>
    </sec>
  </sec>
  <sec sec-type="results" id="SEC3">
    <title>3 RESULTS</title>
    <sec id="SEC3.1">
      <title>3.1 Implementation</title>
      <p>The BWA-SW algorithm is implemented as a component of the BWA program (Li and Durbin, <xref ref-type="bibr" rid="B10">2009</xref>), which is distributed under the GNU general public license (GPL). The implementation takes a BWA index and a query FASTA or FASTQ file as input and outputs the alignment in the SAM format (Li <italic>et al.</italic>, <xref ref-type="bibr" rid="B12">2009</xref>). The query file typically contain many sequences (reads). We process each query sequence in turn, using multiple threads if applicable. Memory usage is dominated by the FM-index, about 3.7 GB for the human genome. Memory required for each query is roughly proportional to the sequence length. On typical sequencing reads, the total memory is &lt;4 GB; on one query sequence with 1 million base pairs (Mbp), the peak memory is 6.4 GB in total.</p>
      <p>In the implementation, we try to automatically adjust parameters based on the read lengths and sequencing error rates to make the default settings work well for inputs of different characteristics. This behavior is convenient to users who are not familiar with the algorithm and helps performance given the reads of mixed lengths and error rates.</p>
    </sec>
    <sec id="SEC3.2">
      <title>3.2 Evaluation on simulated data</title>
      <p>On simulated data, we know the correct chromosomal coordinates from the alignment and the evaluation is straightforward.</p>
      <sec id="SEC3.2.1">
        <title>3.2.1 Overall performance</title>
        <p><xref ref-type="table" rid="T1">Table 1</xref> shows the CPU time, fraction of confidently aligned reads and alignment error rates for BLAT (v34), BWA-SW (version 0.5.3) and SSAHA2 (version 2.4) given different read lengths and error rates. Unless necessary, we tried to use the default command-line options of each aligner. Fine tuning the options based on the characteristics of the input data may yield better performance.
<table-wrap id="T1" position="float"><label>Table 1.</label><caption><p>Evaluation on simulated data</p></caption><table frame="hsides" rules="groups"><thead align="left"><tr><th align="left" rowspan="1" colspan="1">Program</th><th align="left" rowspan="1" colspan="1">Metrics</th><th align="left" colspan="3" rowspan="1">100 bp<hr/></th><th align="left" colspan="3" rowspan="1">200 bp<hr/></th><th align="left" colspan="3" rowspan="1">500 bp<hr/></th><th align="left" colspan="3" rowspan="1">1000 bp<hr/></th><th align="left" colspan="3" rowspan="1">10 000 bp<hr/></th></tr><tr><th rowspan="1" colspan="1"/><th rowspan="1" colspan="1"/><th align="left" rowspan="1" colspan="1">2%</th><th align="left" rowspan="1" colspan="1">5%</th><th align="left" rowspan="1" colspan="1">10%</th><th align="left" rowspan="1" colspan="1">2%</th><th align="left" rowspan="1" colspan="1">5%</th><th align="left" rowspan="1" colspan="1">10%</th><th align="left" rowspan="1" colspan="1">2%</th><th align="left" rowspan="1" colspan="1">5%</th><th align="left" rowspan="1" colspan="1">10%</th><th align="left" rowspan="1" colspan="1">2%</th><th align="left" rowspan="1" colspan="1">5%</th><th align="left" rowspan="1" colspan="1">10%</th><th align="left" rowspan="1" colspan="1">2%</th><th align="left" rowspan="1" colspan="1">5%</th><th align="left" rowspan="1" colspan="1">10%</th></tr></thead><tbody align="left"><tr><td align="left" rowspan="1" colspan="1">BLAT</td><td align="left" rowspan="1" colspan="1">CPU sec</td><td align="left" rowspan="1" colspan="1">685</td><td align="left" rowspan="1" colspan="1">577</td><td align="left" rowspan="1" colspan="1">559</td><td align="left" rowspan="1" colspan="1">819</td><td align="left" rowspan="1" colspan="1">538</td><td align="left" rowspan="1" colspan="1">486</td><td align="left" rowspan="1" colspan="1">1078</td><td align="left" rowspan="1" colspan="1">699</td><td align="left" rowspan="1" colspan="1">512</td><td align="left" rowspan="1" colspan="1">1315</td><td align="left" rowspan="1" colspan="1">862</td><td align="left" rowspan="1" colspan="1">599</td><td align="left" rowspan="1" colspan="1">2628</td><td align="left" rowspan="1" colspan="1">1742</td><td align="left" rowspan="1" colspan="1">710</td></tr><tr><td rowspan="1" colspan="1"/><td align="left" rowspan="1" colspan="1">Q20%</td><td align="left" rowspan="1" colspan="1">68.7</td><td align="left" rowspan="1" colspan="1">25.5</td><td align="left" rowspan="1" colspan="1">3.0</td><td align="left" rowspan="1" colspan="1">92.0</td><td align="left" rowspan="1" colspan="1">52.9</td><td align="left" rowspan="1" colspan="1">7.8</td><td align="left" rowspan="1" colspan="1">97.1</td><td align="left" rowspan="1" colspan="1">86.3</td><td align="left" rowspan="1" colspan="1">21.4</td><td align="left" rowspan="1" colspan="1">97.7</td><td align="left" rowspan="1" colspan="1">96.4</td><td align="left" rowspan="1" colspan="1">39.0</td><td align="left" rowspan="1" colspan="1">98.4</td><td align="left" rowspan="1" colspan="1">99.0</td><td align="left" rowspan="1" colspan="1">94.0</td></tr><tr><td rowspan="1" colspan="1"/><td align="left" rowspan="1" colspan="1">errAln%</td><td align="left" rowspan="1" colspan="1">0.99</td><td align="left" rowspan="1" colspan="1">2.48</td><td align="left" rowspan="1" colspan="1">5.47</td><td align="left" rowspan="1" colspan="1">0.55</td><td align="left" rowspan="1" colspan="1">1.72</td><td align="left" rowspan="1" colspan="1">4.55</td><td align="left" rowspan="1" colspan="1">0.17</td><td align="left" rowspan="1" colspan="1">1.12</td><td align="left" rowspan="1" colspan="1">4.41</td><td align="left" rowspan="1" colspan="1">0.01</td><td align="left" rowspan="1" colspan="1">0.52</td><td align="left" rowspan="1" colspan="1">3.98</td><td align="left" rowspan="1" colspan="1">0.00</td><td align="left" rowspan="1" colspan="1">0.00</td><td align="left" rowspan="1" colspan="1">1.28</td></tr><tr><td align="left" rowspan="1" colspan="1">BWA-SW</td><td align="left" rowspan="1" colspan="1">CPU sec</td><td align="left" rowspan="1" colspan="1">165</td><td align="left" rowspan="1" colspan="1">125</td><td align="left" rowspan="1" colspan="1">84</td><td align="left" rowspan="1" colspan="1">222</td><td align="left" rowspan="1" colspan="1">168</td><td align="left" rowspan="1" colspan="1">118</td><td align="left" rowspan="1" colspan="1">249</td><td align="left" rowspan="1" colspan="1">172</td><td align="left" rowspan="1" colspan="1">152</td><td align="left" rowspan="1" colspan="1">234</td><td align="left" rowspan="1" colspan="1">168</td><td align="left" rowspan="1" colspan="1">150</td><td align="left" rowspan="1" colspan="1">158</td><td align="left" rowspan="1" colspan="1">134</td><td align="left" rowspan="1" colspan="1">120</td></tr><tr><td rowspan="1" colspan="1"/><td align="left" rowspan="1" colspan="1">Q20%</td><td align="left" rowspan="1" colspan="1">85.1</td><td align="left" rowspan="1" colspan="1">62.2</td><td align="left" rowspan="1" colspan="1">19.8</td><td align="left" rowspan="1" colspan="1">93.8</td><td align="left" rowspan="1" colspan="1">88.7</td><td align="left" rowspan="1" colspan="1">49.7</td><td align="left" rowspan="1" colspan="1">96.1</td><td align="left" rowspan="1" colspan="1">95.5</td><td align="left" rowspan="1" colspan="1">85.1</td><td align="left" rowspan="1" colspan="1">96.9</td><td align="left" rowspan="1" colspan="1">96.5</td><td align="left" rowspan="1" colspan="1">95.0</td><td align="left" rowspan="1" colspan="1">98.4</td><td align="left" rowspan="1" colspan="1">98.5</td><td align="left" rowspan="1" colspan="1">98.1</td></tr><tr><td rowspan="1" colspan="1"/><td align="left" rowspan="1" colspan="1">errAln%</td><td align="left" rowspan="1" colspan="1">0.01</td><td align="left" rowspan="1" colspan="1">0.05</td><td align="left" rowspan="1" colspan="1">0.17</td><td align="left" rowspan="1" colspan="1">0.00</td><td align="left" rowspan="1" colspan="1">0.02</td><td align="left" rowspan="1" colspan="1">0.13</td><td align="left" rowspan="1" colspan="1">0.00</td><td align="left" rowspan="1" colspan="1">0.00</td><td align="left" rowspan="1" colspan="1">0.04</td><td align="left" rowspan="1" colspan="1">0.00</td><td align="left" rowspan="1" colspan="1">0.00</td><td align="left" rowspan="1" colspan="1">0.00</td><td align="left" rowspan="1" colspan="1">0.00</td><td align="left" rowspan="1" colspan="1">0.00</td><td align="left" rowspan="1" colspan="1">0.00</td></tr><tr><td align="left" rowspan="1" colspan="1">SSAHA2</td><td align="left" rowspan="1" colspan="1">CPU sec</td><td align="left" rowspan="1" colspan="1">4872</td><td align="left" rowspan="1" colspan="1">7962</td><td align="left" rowspan="1" colspan="1">9345</td><td align="left" rowspan="1" colspan="1">1932</td><td align="left" rowspan="1" colspan="1">2236</td><td align="left" rowspan="1" colspan="1">5252</td><td align="left" rowspan="1" colspan="1">3311</td><td align="left" rowspan="1" colspan="1">8213</td><td align="left" rowspan="1" colspan="1">6863</td><td align="left" rowspan="1" colspan="1">1554</td><td align="left" rowspan="1" colspan="1">1583</td><td align="left" rowspan="1" colspan="1">3113</td><td align="left" rowspan="1" colspan="1">‚Äì</td><td align="left" rowspan="1" colspan="1">‚Äì</td><td align="left" rowspan="1" colspan="1">‚Äì</td></tr><tr><td rowspan="1" colspan="1"/><td align="left" rowspan="1" colspan="1">Q20%</td><td align="left" rowspan="1" colspan="1">85.5</td><td align="left" rowspan="1" colspan="1">83.8</td><td align="left" rowspan="1" colspan="1">78.2</td><td align="left" rowspan="1" colspan="1">93.4</td><td align="left" rowspan="1" colspan="1">93.1</td><td align="left" rowspan="1" colspan="1">91.9</td><td align="left" rowspan="1" colspan="1">96.6</td><td align="left" rowspan="1" colspan="1">96.5</td><td align="left" rowspan="1" colspan="1">96.1</td><td align="left" rowspan="1" colspan="1">97.7</td><td align="left" rowspan="1" colspan="1">97.6</td><td align="left" rowspan="1" colspan="1">97.4</td><td align="left" rowspan="1" colspan="1">‚Äì</td><td align="left" rowspan="1" colspan="1">‚Äì</td><td align="left" rowspan="1" colspan="1">‚Äì</td></tr><tr><td rowspan="1" colspan="1"/><td align="left" rowspan="1" colspan="1">errAln%</td><td align="left" rowspan="1" colspan="1">0.00</td><td align="left" rowspan="1" colspan="1">0.01</td><td align="left" rowspan="1" colspan="1">0.19</td><td align="left" rowspan="1" colspan="1">0.01</td><td align="left" rowspan="1" colspan="1">0.00</td><td align="left" rowspan="1" colspan="1">0.01</td><td align="left" rowspan="1" colspan="1">0.00</td><td align="left" rowspan="1" colspan="1">0.01</td><td align="left" rowspan="1" colspan="1">0.04</td><td align="left" rowspan="1" colspan="1">0.00</td><td align="left" rowspan="1" colspan="1">0.00</td><td align="left" rowspan="1" colspan="1">0.00</td><td align="left" rowspan="1" colspan="1">‚Äì</td><td align="left" rowspan="1" colspan="1">‚Äì</td><td align="left" rowspan="1" colspan="1">‚Äì</td></tr></tbody></table><table-wrap-foot><fn><p>Approximately 10 000 000 bp data of different read lengths and error rates are simulated from the human genome. Twenty percent of errors are indel errors with the indel length drawn from a geometric distribution (density: 0.7¬∑0.3<sup><italic>l</italic>‚àí1</sup>). These simulated reads are aligned back to the human genome with BLAT (option -fastMap), BWA-SW and SSAHA2 (option ‚àí454 for 100 and 200 bp reads), respectively. The aligned coordinates are then compared with the simulated coordinates to find alignment errors. In each cell in this table, the three numbers are the CPU seconds on a single-core of an Intel E5420 2.5 GHz CPU, percent alignments with mapping quality greater than or equal to 20 (Q20), and percent wrong alignments out of Q20 alignments. SSAHA2 and BWA-SW report mapping quality; BLAT mapping quality is estimated as 250 times the difference of the best and second best alignment scores divided by the best alignment score (essentially the same calculation as the one for BWA-SW).</p></fn></table-wrap-foot></table-wrap>
</p>
        <p>From <xref ref-type="table" rid="T1">Table 1</xref>, we can see that BWA-SW is clearly the fastest, several times faster than BLAT and SSAHA2 on all inputs, and its speed is not sensitive to the read length or error rates. The accuracy of BWA-SW is comparable with SSAHA2 when the query is long or has low error rate. Given short and error-prone reads, SSAHA2 is more accurate, although it has to spend more time on aligning such reads. SSAHA2 is not tested on the 10 kb reads because it is not designed for this task initially and thus does not perform well. BLAT with the -fastMap option is faster than SSAHA2, but less accurate. Under the default option, BLAT is several to tens of times slower than SSAHA2. The accuracy is higher in comparison to the -fastMap mode, but still lower than that of BWA-SW in general (data not shown).</p>
        <p>On memory, both BWA-SW and BLAT uses ‚àº4 GB memory. SSAHA2 uses 2.4 GB for ‚â•500 bp reads with the default option, and 5.3 GB for shorter reads with the ‚àí454 option which increases the number of seed sequences stored in the hash table and increases the memory as a result. In addition, BWA-SW supports multi-threading and thus may take less memory per CPU core if it is run on a multi-core computer. SSAHA2 and BLAT do not support multi-threading at present.</p>
      </sec>
      <sec id="SEC3.2.2">
        <title>3.2.2 Chimera detection</title>
        <p>We first study the behavior of each aligner given a chimeric read. To do so, we fabricated two chimeric reads with both consisting of one 1000 bp piece from one chromosomal position and one 300 bp piece from another position. The main difference between the two reads is that the 1000 bp piece in the second read has a ‚àº750 bp repetitive sequence, while the first read is highly unique. When we align the two chimeric reads to the human genome, BWA-SW reports four alignments, one for each piece, as is desired. The latest SSAHA2 fails to find the alignment of the 300 bp pieces in both reads, although it is able to find the alignments if we align the 300 bp piece as an individual read. An older version (1.0.9) is able to align the 300 bp piece in the first read by default, but for the second read, we need to switch to a more thorough but much slower configuration that reports all the hits to the 750 bp repeat. BLAT with -fastMap does not find the alignment of the 300 bp piece for the second read. On the two examples, only BWA-SW has sufficient power to detect chimera.</p>
        <p>Furthermore, BWA-SW rarely produces high-quality false chimeric alignments. For example, given the 10 000 1 kb reads with 10% errors but without chimera in simulation, BWA-SW predicts 18 chimeric reads. The mapping quality of the wrongly aligned pieces on these reads is only 2.4 (maximum 11), implying that BWA-SW is aware that these chimera are unreliable. As is expected, BWA-SW produces fewer false chimeric reads given lower base errors.</p>
      </sec>
    </sec>
    <sec id="SEC3.3">
      <title>3.3 Evaluation on real data</title>
      <p>Evaluation on real data is complicated by the lack of a ground truth. However, it is still possible to evaluate the relative accuracy by comparing the results from two aligners using the principle that the true alignment tends to have a considerably higher alignment score, because most errors arise from failing to find a seed.</p>
      <p>Suppose we align a read using two aligners <italic>A</italic> and <italic>B</italic> and get different results. If both <italic>A</italic> and <italic>B</italic> give low mapping qualities, the alignment is ambiguous and it does not matter if either alignment is wrong. If <italic>A</italic> gives high mapping quality and the <italic>A</italic> alignment score is worse than <italic>B</italic>, <italic>A</italic> alignment is probably wrong; even if <italic>A</italic> alignment score is just a little better than <italic>B</italic>, <italic>A</italic> alignment is not reliable and the high mapping quality given by <italic>A</italic> is still questionable. In practice, defining ‚Äòa little better‚Äô alignment score requires to set a arbitrary threshold on the score difference and therefore this evaluation method is approximate.</p>
      <p><xref ref-type="table" rid="T2">Table 2</xref> gives a summary of 454 reads which are mapped by only one aligner or mapped to different places, and are assigned a mapping quality greater or equal to 20 by either BWA-SW or SSAHA2. We can see that BWA-SW tends to miss short alignments with high error rates (946 of them), which agrees with the evaluation on simulated data. SSAHA2 misses alignments for a different reason. On 1188 reads, SSAHA2 produces obviously wrong alignments. It is aware that these alignments are wrong by assigning low mapping quality, but the true alignments are missed anyway.
<table-wrap id="T2" position="float"><label>Table 2.</label><caption><p>Summary of alignments inconsistent between the BWA-SW and SSAHA2 on real data</p></caption><table frame="hsides" rules="groups"><thead align="left"><tr><th align="left" rowspan="1" colspan="1">Condition</th><th align="left" rowspan="1" colspan="1">Count</th><th align="left" colspan="3" rowspan="1">BWA-SW<hr/></th><th align="left" colspan="3" rowspan="1">SSAHA2<hr/></th></tr><tr><th rowspan="1" colspan="1"/><th rowspan="1" colspan="1"/><th align="left" rowspan="1" colspan="1">avgLen</th><th align="left" rowspan="1" colspan="1">avgDiff</th><th align="left" rowspan="1" colspan="1">avgMapQ</th><th align="left" rowspan="1" colspan="1">avgLen</th><th align="left" rowspan="1" colspan="1">avgDiff</th><th align="left" rowspan="1" colspan="1">avgMapQ</th></tr></thead><tbody align="left"><tr><td align="left" rowspan="1" colspan="1">BWA-SW‚â•20; SSAHA2 unmapped</td><td align="left" rowspan="1" colspan="1">0</td><td align="left" rowspan="1" colspan="1">‚Äì</td><td align="left" rowspan="1" colspan="1">‚Äì</td><td align="left" rowspan="1" colspan="1">‚Äì</td><td align="left" rowspan="1" colspan="1">‚Äì</td><td align="left" rowspan="1" colspan="1">‚Äì</td><td align="left" rowspan="1" colspan="1">‚Äì</td></tr><tr><td align="left" rowspan="1" colspan="1">BWA-SW‚â•20 plausible; SSAHA2&lt;20</td><td align="left" rowspan="1" colspan="1">1188</td><td align="left" rowspan="1" colspan="1">398.2</td><td align="left" rowspan="1" colspan="1">1.3%</td><td align="left" rowspan="1" colspan="1">178.4</td><td align="left" rowspan="1" colspan="1">198.3</td><td align="left" rowspan="1" colspan="1">13.1%</td><td align="left" rowspan="1" colspan="1">3.9</td></tr><tr><td align="left" rowspan="1" colspan="1">BWA-SW‚â•20 questionable</td><td align="left" rowspan="1" colspan="1">40</td><td align="left" rowspan="1" colspan="1">183.0</td><td align="left" rowspan="1" colspan="1">7.8%</td><td align="left" rowspan="1" colspan="1">41.2</td><td align="left" rowspan="1" colspan="1">280.3</td><td align="left" rowspan="1" colspan="1">9.4%</td><td align="left" rowspan="1" colspan="1">2.4</td></tr><tr><td align="left" rowspan="1" colspan="1">SSAHA2‚â•20; BWA-SW unmapped</td><td align="left" rowspan="1" colspan="1">946</td><td align="left" rowspan="1" colspan="1">‚Äì</td><td align="left" rowspan="1" colspan="1">‚Äì</td><td align="left" rowspan="1" colspan="1">‚Äì</td><td align="left" rowspan="1" colspan="1">75.4</td><td align="left" rowspan="1" colspan="1">6.3%</td><td align="left" rowspan="1" colspan="1">51.2</td></tr><tr><td align="left" rowspan="1" colspan="1">SSAHA2‚â•20 plausible; BWA-SW&lt;20</td><td align="left" rowspan="1" colspan="1">47</td><td align="left" rowspan="1" colspan="1">129.0</td><td align="left" rowspan="1" colspan="1">9.3%</td><td align="left" rowspan="1" colspan="1">2.5</td><td align="left" rowspan="1" colspan="1">200.5</td><td align="left" rowspan="1" colspan="1">8.8%</td><td align="left" rowspan="1" colspan="1">34.4</td></tr><tr><td align="left" rowspan="1" colspan="1">SSAHA2‚â•20 questionable</td><td align="left" rowspan="1" colspan="1">185</td><td align="left" rowspan="1" colspan="1">400.2</td><td align="left" rowspan="1" colspan="1">1.7%</td><td align="left" rowspan="1" colspan="1">13.4</td><td align="left" rowspan="1" colspan="1">399.2</td><td align="left" rowspan="1" colspan="1">2.9%</td><td align="left" rowspan="1" colspan="1">216.4</td></tr></tbody></table><table-wrap-foot><fn><p>A total of 137 670 454 reads uniformly selected from <monospace>SRR003161</monospace> were mapped against the human genome with BWA-SW and SSAHA2, respectively. A read is said to be aligned inconsistently if the leftmost coordinates of the BWA-SW and SSAHA2 alignment differs by over 355 bp, the average read length. A score, which equals to the number of matches minus three multiplied by the number of differences (mismatches and gaps) in the aligned region, is calculated for each alignment. A BWA-SW alignment is said to be <italic>plausible</italic> if the score derived from the BWA-SW alignment minus the one derived from the SSAHA2 alignment of the same read is greater than or equal to 20 (i.e. the BWA-SW alignment is sufficiently better); otherwise the BWA-SW alignment is said to be <italic>questionable</italic>. Plausible and questionable SSAHA2 alignments are defined in a similar manner. In the table, ‚ÄòBWA-SW‚â•20‚Äô denotes the BWA-SW alignments with mapping quality higher than 20. In all, BWA-SW misses 993 (=946 + 47) alignments which SSAHA2 aligns well, while SSAHA2 misses 1188; 40 BWA-SW Q20 alignments and 185 SSAHA2 Q20 alignments are possibly wrong.</p></fn></table-wrap-foot></table-wrap>
</p>
      <p>For both aligners, most wrong alignments are caused by overlooking alignments with a similar score to the best reported alignment. For example, SSAHA2 aligns read <monospace>SRR003161.1261578</monospace> to X chromosome with mapping quality 244 and BWA-SW aligns it to chromosome 2 with identical alignment length and edit distance. The existence of two best scoring alignments means the read cannot be uniquely placed and a mapping quality as high as 244 is inaccurate. SSAHA2 gives this high mapping quality probably because it overlooks the match on chromosome 2. And in this specific example, BWA-SW properly gives a mapping quality zero, although it may overlook alternative matches in other examples.</p>
      <p>On simulated 100 and 200 bp reads, SSAHA2 with the ‚àí454 option delivers better alignments than BWA-SW. On this real dataset, BWA-SW is more accurate possibly because the average read length is relatively long (355 bp). To confirm this speculation, we compared the two aligners on 99 958 reads from run <monospace>SRR002644</monospace> with average read length 206 bp. This time BWA-SW misses 1092 SSAHA2 Q20 alignments and produces 39 questionable alignments; SSAHA2 misses 325 and produces 10 questionable ones. SSAHA2 is more accurate on this shorter dataset, although it is nine times slower than BWA-SW and uses 40% more memory.</p>
    </sec>
  </sec>
  <sec sec-type="discussion" id="SEC4">
    <title>4 DISCUSSION</title>
    <p>BWA-SW is an efficient algorithm for aligning a query sequence of a few hundred base pairs or more against a long reference genome. Its sensitivity and specificity tend to be higher given a long query or a query with low error rate, and on such query sequences, the accuracy of BWA-SW is comparable with the most accurate aligner so far. Furthermore, BWA-SW is able to detect chimera, potentially caused by structural variations or reference misassemblies, which may pose a challenge to BLAT and SSAHA2.</p>
    <p>BWA-SW, BLAT and SSAHA2 all follow the seed-and-extend paradigm. The major difference comes from the seeding strategy. BLAT and SSAHA2 identify short exact matches as seeds, typically of length 11 or 12 bp. For <italic>k</italic>-mer seeding between two sequences of length <italic>L</italic> and <italic>l</italic>, respectively, the expected number of seeds is <italic>L</italic>¬∑<italic>l</italic>/4<sup><italic>k</italic></sup>, or of the order of 10<sup>5</sup> for alignment against the human genome. Extending these seeds each with the Smith‚ÄìWaterman algorithm is expensive. To reduce unnecessary seed extension, both BLAT and SSAHA2 use non-overlapping seeds by default and require multiple seed matches, which should work well for random sequences, but still involves many seed extensions in highly repetitive regions. BWA-SW resolves this issue by using a few long gapped seeds in unique regions. On real biological data, it saves many unnecessary seed extensions and leads to a better overall performance. However, to reduce time when identifying long seeds, BWA-SW only maintains a very small fraction of the dynamic programming matrix, which may miss all seeds for true matches. This heuristic is the major source of alignment errors especially for short queries when there are only few valid unique seeds between the sequences to be aligned. On long alignments, fortunately, the chance of missing all seeds is small. We have shown BWA-SW works equally well as SSAHA2.</p>
    <p>BWA-SW differs from BWT-SW in several aspects. First of all, BWT-SW guarantees to find all local matches, whereas BWA-SW is a heuristic algorithm which may miss true hits but is much faster. Secondly, BWA-SW aligns two FM-indices while BWT-SW aligns one sequence and a FM-index. Building a prefix DAWG for the query sequences potentially helps to avoid repeatedly aligning identical substrings in the query, and thus improves the theoretical time complexity. Thirdly, BWA-SW traverses the reference prefix trie in the inner loop while BWT-SW loops through the query sequence in the inner loop. Without heuristics, the BWA-SW approach would hurt performance because we have to trade speed for memory in traversing the reference prefix trie, and it would be more efficient to traverse it in the outer loop. Nonetheless, applying the <italic>Z</italic>-best strategy requires to know the top-scoring reference nodes matching a query substring without finishing the dynamic programming and thus only works when the reference is traversed in the inner loop. Fourthly, BWA-SW only reports alignments largely non-overlapping on the query sequence, while BWT-SW, like BLAST, reports all statistically significant alignments. BWA-SW retains key information of alignments and generates much smaller and more convenient output. For BWT-SW, end users usually need to post-process the results to filter out many alignments of little interest to them. In all, BWA-SW is tuned toward practical usefulness given large-scale real data.</p>
    <p>The high speed of BWA-SW largely comes from two strategies: the use of FM-indices and the suppression of short repetitive matches contained in a better match. While the first strategy is not applicable to hash table-based algorithms such as SSAHA2 and BLAT, the second strategy could be implemented in such programs and may substantially accelerate them by saving much time on the construction of repetitive alignments. And although the use of BWT reduces unnecessary alignments in repeats, each BWT operation comes with a large constant in comparison with a hash table look up. It is still possible that hash table-based algorithms could be faster than BWA-SW if they incorporated some of these features.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material id="PMC_1" content-type="local-data">
      <caption>
        <title>[Supplementary Data]</title>
      </caption>
      <media mimetype="text" mime-subtype="html" xlink:href="btp698_index.html"/>
      <media xlink:role="associated-file" mimetype="application" mime-subtype="ps" xlink:href="btp698_bioinf-2009-1485-File001.ps"/>
    </supplementary-material>
  </sec>
</body>
<back>
  <ack>
    <title>ACKNOWLEDGEMENTS</title>
    <p>We are grateful to Zemin Ning for his helpful comments on the SSAHA2 algorithm, and to Kimmo Palin for providing the literature on DAWG.</p>
    <p><italic>Funding</italic>: Wellcome Trust 077192/Z/05/Z.</p>
    <p><italic>Conflict of Interest</italic>: none declared.</p>
  </ack>
  <ref-list>
    <title>REFERENCES</title>
    <ref id="B1">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Altschul</surname>
            <given-names>SF</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Gapped BLAST and PSI-BLAST: a new generation of protein database search programs</article-title>
        <source>Nucleic Acids Res.</source>
        <year>1997</year>
        <volume>25</volume>
        <fpage>3389</fpage>
        <lpage>3402</lpage>
        <pub-id pub-id-type="pmid">9254694</pub-id>
      </element-citation>
    </ref>
    <ref id="B2">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Blumer</surname>
            <given-names>A</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>The smallest automaton recognizing the subwords of a text</article-title>
        <source>Theor. Comput. Sci.</source>
        <year>1985</year>
        <volume>40</volume>
        <fpage>31</fpage>
        <lpage>55</lpage>
      </element-citation>
    </ref>
    <ref id="B3">
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Burrows</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Wheeler</surname>
            <given-names>DJ</given-names>
          </name>
        </person-group>
        <article-title>A block-sorting lossless data compression algorithm</article-title>
        <source>Technical report 124</source>
        <year>1994</year>
        <publisher-loc>Palo Alto, CA</publisher-loc>
        <publisher-name>Digital Equipment Corporation</publisher-name>
      </element-citation>
    </ref>
    <ref id="B4">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Eid</surname>
            <given-names>J</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Real-time DNA sequencing from single polymerase molecules</article-title>
        <source>Science</source>
        <year>2009</year>
        <volume>323</volume>
        <fpage>133</fpage>
        <lpage>138</lpage>
        <pub-id pub-id-type="pmid">19023044</pub-id>
      </element-citation>
    </ref>
    <ref id="B5">
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Ferragina</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Manzini</surname>
            <given-names>G</given-names>
          </name>
        </person-group>
        <article-title>Opportunistic data structures with applications</article-title>
        <source>Proceedings of the 41st Symposium on Foundations of Computer Science (FOCS 2000)</source>
        <year>2000</year>
        <publisher-loc>Redondo Beach, CA, USA</publisher-loc>
        <fpage>390</fpage>
        <lpage>398</lpage>
      </element-citation>
    </ref>
    <ref id="B6">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Jiang</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Wong</surname>
            <given-names>WH</given-names>
          </name>
        </person-group>
        <article-title>SeqMap: mapping massive amount of oligonucleotides to the genome</article-title>
        <source>Bioinformatics</source>
        <year>2008</year>
        <volume>24</volume>
        <fpage>2395</fpage>
        <lpage>2396</lpage>
        <pub-id pub-id-type="pmid">18697769</pub-id>
      </element-citation>
    </ref>
    <ref id="B7">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Kent</surname>
            <given-names>WJ</given-names>
          </name>
        </person-group>
        <article-title>BLAT‚Äìthe BLAST-like alignment tool</article-title>
        <source>Genome Res.</source>
        <year>2002</year>
        <volume>12</volume>
        <fpage>656</fpage>
        <lpage>664</lpage>
        <pub-id pub-id-type="pmid">11932250</pub-id>
      </element-citation>
    </ref>
    <ref id="B8">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Lam</surname>
            <given-names>TW</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Compressed indexing and local alignment of DNA</article-title>
        <source>Bioinformatics</source>
        <year>2008</year>
        <volume>24</volume>
        <fpage>791</fpage>
        <lpage>797</lpage>
        <pub-id pub-id-type="pmid">18227115</pub-id>
      </element-citation>
    </ref>
    <ref id="B9">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Langmead</surname>
            <given-names>B</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Ultrafast and memory-efficient alignment of short DNA sequences to the human genome</article-title>
        <source>Genome Biol.</source>
        <year>2009</year>
        <volume>10</volume>
        <fpage>R25</fpage>
        <pub-id pub-id-type="pmid">19261174</pub-id>
      </element-citation>
    </ref>
    <ref id="B10">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Li</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Durbin</surname>
            <given-names>R</given-names>
          </name>
        </person-group>
        <article-title>Fast and accurate short read alignment with Burrows-Wheeler transform</article-title>
        <source>Bioinformatics</source>
        <year>2009</year>
        <volume>25</volume>
        <fpage>1754</fpage>
        <lpage>1760</lpage>
        <pub-id pub-id-type="pmid">19451168</pub-id>
      </element-citation>
    </ref>
    <ref id="B11">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Li</surname>
            <given-names>H</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Mapping short DNA sequencing reads and calling variants using mapping quality scores</article-title>
        <source>Genome Res.</source>
        <year>2008</year>
        <volume>18</volume>
        <fpage>1851</fpage>
        <lpage>1858</lpage>
        <pub-id pub-id-type="pmid">18714091</pub-id>
      </element-citation>
    </ref>
    <ref id="B12">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Li</surname>
            <given-names>H</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>The Sequence Alignment/Map format and SAMtools</article-title>
        <source>Bioinformatics</source>
        <year>2009</year>
        <volume>25</volume>
        <fpage>2078</fpage>
        <lpage>2079</lpage>
        <pub-id pub-id-type="pmid">19505943</pub-id>
      </element-citation>
    </ref>
    <ref id="B13">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Li</surname>
            <given-names>R</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>SOAP: short oligonucleotide alignment program</article-title>
        <source>Bioinformatics</source>
        <year>2008</year>
        <volume>24</volume>
        <fpage>713</fpage>
        <lpage>714</lpage>
        <pub-id pub-id-type="pmid">18227114</pub-id>
      </element-citation>
    </ref>
    <ref id="B14">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Lin</surname>
            <given-names>H</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Zoom! zillions of oligos mapped</article-title>
        <source>Bioinformatics</source>
        <year>2008</year>
        <volume>24</volume>
        <fpage>2431</fpage>
        <lpage>2437</lpage>
        <pub-id pub-id-type="pmid">18684737</pub-id>
      </element-citation>
    </ref>
    <ref id="B15">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Ma</surname>
            <given-names>B</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>PatternHunter: faster and more sensitive homology search</article-title>
        <source>Bioinformatics</source>
        <year>2002</year>
        <volume>18</volume>
        <fpage>440</fpage>
        <lpage>445</lpage>
        <pub-id pub-id-type="pmid">11934743</pub-id>
      </element-citation>
    </ref>
    <ref id="B16">
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Meek</surname>
            <given-names>C</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>OASIS: an online and accurate technique for local-alignment searches on biological sequences</article-title>
        <source>Proceedings of 29th International Conference on Very Large Data Bases (VLDB 2003)</source>
        <year>2003</year>
        <publisher-loc>Berlin, Germany</publisher-loc>
        <fpage>910</fpage>
        <lpage>921</lpage>
      </element-citation>
    </ref>
    <ref id="B17">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Morgulis</surname>
            <given-names>A</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Database indexing for production megablast searches</article-title>
        <source>Bioinformatics</source>
        <year>2008</year>
        <volume>24</volume>
        <fpage>1757</fpage>
        <lpage>1764</lpage>
        <pub-id pub-id-type="pmid">18567917</pub-id>
      </element-citation>
    </ref>
    <ref id="B18">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Ning</surname>
            <given-names>Z</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>SSAHA: a fast search method for large DNA databases</article-title>
        <source>Genome Res.</source>
        <year>2001</year>
        <volume>11</volume>
        <fpage>1725</fpage>
        <lpage>1729</lpage>
        <pub-id pub-id-type="pmid">11591649</pub-id>
      </element-citation>
    </ref>
    <ref id="B19">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Pearson</surname>
            <given-names>WR</given-names>
          </name>
          <name>
            <surname>Lipman</surname>
            <given-names>DJ</given-names>
          </name>
        </person-group>
        <article-title>Improved tools for biological sequence comparison</article-title>
        <source>Proc. Natl Acad. Sci. USA</source>
        <year>1988</year>
        <volume>85</volume>
        <fpage>2444</fpage>
        <lpage>2448</lpage>
        <pub-id pub-id-type="pmid">3162770</pub-id>
      </element-citation>
    </ref>
    <ref id="B20">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Rumble</surname>
            <given-names>SM</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>SHRiMP: accurate mapping of short color-space reads</article-title>
        <source>PLoS Comput. Biol.</source>
        <year>2009</year>
        <volume>5</volume>
        <fpage>e1000386</fpage>
        <pub-id pub-id-type="pmid">19461883</pub-id>
      </element-citation>
    </ref>
    <ref id="B21">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Smith</surname>
            <given-names>AD</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Using quality scores and longer reads improves accuracy of Solexa read mapping</article-title>
        <source>BMC Bioinformatics</source>
        <year>2008</year>
        <volume>9</volume>
        <fpage>128</fpage>
        <pub-id pub-id-type="pmid">18307793</pub-id>
      </element-citation>
    </ref>
    <ref id="B22">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Weese</surname>
            <given-names>D</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>RazerS‚Äìfast read mapping with sensitivity control</article-title>
        <source>Genome Res.</source>
        <year>2009</year>
        <volume>19</volume>
        <fpage>1646</fpage>
        <lpage>1654</lpage>
        <pub-id pub-id-type="pmid">19592482</pub-id>
      </element-citation>
    </ref>
    <ref id="B23">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Zhang</surname>
            <given-names>Z</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>A greedy algorithm for aligning DNA sequences</article-title>
        <source>J. Comput. Biol.</source>
        <year>2000</year>
        <volume>7</volume>
        <fpage>203</fpage>
        <lpage>214</lpage>
        <pub-id pub-id-type="pmid">10890397</pub-id>
      </element-citation>
    </ref>
  </ref-list>
</back>
