<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.2 20190208//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 1.2?>
<?ConverterInfo.XSLTName jats2jats3.xsl?>
<?ConverterInfo.Version 1?>
<?properties open_access?>
<processing-meta base-tagset="archiving" mathml-version="3.0" table-model="xhtml" tagset-family="jats">
  <restricted-by>pmc</restricted-by>
</processing-meta>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">8098024</article-id>
    <article-id pub-id-type="pmid">33305310</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/btaa906</article-id>
    <article-id pub-id-type="publisher-id">btaa906</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Original Papers</subject>
        <subj-group subj-group-type="category-toc-heading">
          <subject>Systems Biology</subject>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="category-taxonomy-collection">
        <subject>AcademicSubjects/SCI01060</subject>
      </subj-group>
      <subj-group subj-group-type="category-taxonomy-collection">
        <subject>AcademicSubjects/SCI01060</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Leveraging heterogeneous network embedding for metabolic pathway prediction</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>M A Basher</surname>
          <given-names>Abdur Rahman</given-names>
        </name>
        <aff><institution>Graduate Program in Bioinformatics, University of British Columbia</institution>, Vancouver, BC V6T 1Z3, <country country="CA">Canada</country></aff>
      </contrib>
      <contrib contrib-type="author" corresp="yes">
        <name>
          <surname>Hallam</surname>
          <given-names>Steven J</given-names>
        </name>
        <xref rid="btaa906-cor1" ref-type="corresp"/>
        <aff><institution>Graduate Program in Bioinformatics, University of British Columbia</institution>, Vancouver, BC V6T 1Z3, <country country="CA">Canada</country></aff>
        <aff><institution>Department of Microbiology &amp; Immunology, University of British Columbia</institution>, Vancouver, BC V6T 1Z3, <country country="CA">Canada</country></aff>
        <aff><institution>Genome Science and Technology Program, University of British Columbia</institution>, Vancouver, BC V6T 1Z3, <country country="CA">Canada</country></aff>
        <aff><institution>Life Sciences Institute, University of British Columbia</institution>, Vancouver, BC V6T 1Z3, <country country="CA">Canada</country></aff>
        <aff><institution>ECOSCOPE Training Program, University of British Columbia</institution>, Vancouver, BC V6T 1Z3, <country country="CA">Canada</country></aff>
        <!--shallam@mail.ubc.ca-->
      </contrib>
    </contrib-group>
    <contrib-group>
      <contrib contrib-type="editor">
        <name>
          <surname>Lenore</surname>
          <given-names>Cowen</given-names>
        </name>
        <role>Associate Editor</role>
      </contrib>
    </contrib-group>
    <author-notes>
      <corresp id="btaa906-cor1">To whom correspondence should be addressed. <email>shallam@mail.ubc.ca</email></corresp>
    </author-notes>
    <pub-date pub-type="collection">
      <day>15</day>
      <month>3</month>
      <year>2021</year>
    </pub-date>
    <pub-date pub-type="epub" iso-8601-date="2020-10-20">
      <day>20</day>
      <month>10</month>
      <year>2020</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>20</day>
      <month>10</month>
      <year>2020</year>
    </pub-date>
    <volume>37</volume>
    <issue>6</issue>
    <fpage>822</fpage>
    <lpage>829</lpage>
    <history>
      <date date-type="received">
        <day>24</day>
        <month>3</month>
        <year>2020</year>
      </date>
      <date date-type="rev-recd">
        <day>03</day>
        <month>10</month>
        <year>2020</year>
      </date>
      <date date-type="editorial-decision">
        <day>07</day>
        <month>10</month>
        <year>2020</year>
      </date>
      <date date-type="accepted">
        <day>08</day>
        <month>10</month>
        <year>2020</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© The Author(s) 2020. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2020</copyright-year>
      <license>
        <ali:license_ref xmlns:ali="http://www.niso.org/schemas/ali/1.0/" specific-use="textmining" content-type="ccbynclicense">https://creativecommons.org/licenses/by-nc/4.0/</ali:license_ref>
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution Non-Commercial License (<ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/licenses/by-nc/4.0/">http://creativecommons.org/licenses/by-nc/4.0/</ext-link>), which permits non-commercial re-use, distribution, and reproduction in any medium, provided the original work is properly cited. For commercial re-use, please contact journals.permissions@oup.com</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="btaa906.pdf"/>
    <abstract>
      <title>Abstract</title>
      <sec id="s1">
        <title>Motivation</title>
        <p>Metabolic pathway reconstruction from genomic sequence information is a key step in predicting regulatory and functional potential of cells at the individual, population and community levels of organization. Although the most common methods for metabolic pathway reconstruction are gene-centric e.g. mapping annotated proteins onto known pathways using a reference database, pathway-centric methods based on heuristics or machine learning to infer pathway presence provide a powerful engine for hypothesis generation in biological systems. Such methods rely on rule sets or rich feature information that may not be known or readily accessible.</p>
      </sec>
      <sec id="s2">
        <title>Results</title>
        <p>Here, we present pathway2vec, a software package consisting of six representational learning modules used to automatically generate features for pathway inference. Specifically, we build a three-layered network composed of compounds, enzymes and pathways, where nodes within a layer manifest inter-interactions and nodes between layers manifest betweenness interactions. This layered architecture captures relevant relationships used to learn a neural embedding-based low-dimensional space of metabolic features. We benchmark pathway2vec performance based on node-clustering, embedding visualization and pathway prediction using MetaCyc as a trusted source. In the pathway prediction task, results indicate that it is possible to leverage embeddings to improve prediction outcomes.</p>
      </sec>
      <sec id="s3">
        <title>Availability and implementation</title>
        <p>The software package and installation instructions are published on <ext-link xlink:href="http://github.com/pathway2vec" ext-link-type="uri">http://github.com/pathway2vec</ext-link>.</p>
      </sec>
      <sec id="s5">
        <title>Supplementary information</title>
        <p><xref rid="sup1" ref-type="supplementary-material">Supplementary data</xref> are available at <italic toggle="yes">Bioinformatics</italic> online.</p>
      </sec>
    </abstract>
    <funding-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>Genome Canada</institution>
            <institution-id institution-id-type="DOI">10.13039/100008762</institution-id>
          </institution-wrap>
        </funding-source>
      </award-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>Genome British Columbia</institution>
            <institution-id institution-id-type="DOI">10.13039/501100000233</institution-id>
          </institution-wrap>
        </funding-source>
      </award-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>Natural Sciences and Engineering Research Council</institution>
          </institution-wrap>
        </funding-source>
      </award-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>Compute/Calcul Canada</institution>
          </institution-wrap>
        </funding-source>
      </award-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>UBC four-year doctoral fellowship</institution>
          </institution-wrap>
        </funding-source>
        <award-id>4YF</award-id>
      </award-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>UBC Graduate Program in Bioinformatics</institution>
          </institution-wrap>
        </funding-source>
      </award-group>
    </funding-group>
    <counts>
      <page-count count="8"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec>
    <title>1 Introduction</title>
    <p>Metabolic pathway reconstruction from genomic sequence information is a key step in predicting regulatory and functional potential of cells at the individual, population and community levels of organization (<xref rid="btaa906-B2" ref-type="bibr">Abubucker <italic toggle="yes">et al.</italic>, 2012</xref>). Exponential advances in sequencing throughput continue to lower the cost of data generation with concomitant increases in data volume and complexity (<xref rid="btaa906-B4" ref-type="bibr">Ansorge, 2009</xref>). Resulting datasets create new opportunities for metabolic reconstruction within biological systems that require the development of new computational tools and approaches that scale with data volume and complexity. Although the most common methods for metabolic pathway reconstruction are gene-centric e.g. mapping annotated proteins onto known pathways using a reference database based on sequence homology, heuristic or rule-based methods for pathway-centric inference including PathoLogic (<xref rid="btaa906-B21" ref-type="bibr">Karp <italic toggle="yes">et al.</italic>, 2016</xref>) and MinPath (<xref rid="btaa906-B35" ref-type="bibr">Ye and Doak, 2009</xref>) have become increasingly used to generate hypotheses and build quantitative models. For example, Pathologic generates pathway genome databases (PGDBs) that can be refined based on experimental validation e.g. EcoCyc (<xref rid="btaa906-B22" ref-type="bibr">Karp <italic toggle="yes">et al.</italic>, 2018</xref>) and stored in repositories e.g. BioCyc (<xref rid="btaa906-B8" ref-type="bibr">Caspi <italic toggle="yes">et al.</italic>, 2016a</xref>) for community access and use in flux balance analysis.</p>
    <p>The development of accurate and flexible rule sets for pathway prediction remains a challenging enterprise informed by expert curators incorporating thermodynamic, kinetic and structural information for validation (<xref rid="btaa906-B33" ref-type="bibr">Toubiana <italic toggle="yes">et al.</italic>, 2019</xref>). Updating these rule sets as new organisms or pathways are described and validated can be cumbersome and out of phase with current user needs. This has led to the consideration of machine-learning (ML) approaches for pathway prediction based on rich feature information. <xref rid="btaa906-B11" ref-type="bibr">Dale <italic toggle="yes">et al.</italic> (2010)</xref> conducted a seminal study comparing the performance of Pathologic to different types of supervised ML algorithms (naive Bayes, <italic toggle="yes">k</italic>-nearest neighbors, decision trees and logistic regression), converting rules into features, defining new features and evaluating on experimentally validated pathways from six highly curated organisms in the BioCyc collection randomly divided into training and test sets. Resulting performance metrics indicated that generic ML methods equaled and, in some cases, exceeded performance of Pathologic with the benefit of probability estimation for pathway presence and increased flexibility and transparency of use.</p>
    <p>Despite the potential benefits of adopting ML methods for pathway prediction from genomic sequence information, Pathologic remains the primary inference engine of Pathway Tools (<xref rid="btaa906-B21" ref-type="bibr">Karp <italic toggle="yes">et al.</italic>, 2016</xref>), and alternative methods for pathway-centric inference expanding on the generic methods described above remain nascent. Several of these methods incorporate metabolite information to improve pathway inference and reaction rules to infer metabolic pathways (<xref rid="btaa906-B7" ref-type="bibr">Carbonell <italic toggle="yes">et al.</italic>, 2018</xref>; <xref rid="btaa906-B32" ref-type="bibr">Tabei <italic toggle="yes">et al.</italic>, 2016</xref>; <xref rid="btaa906-B33" ref-type="bibr">Toubiana <italic toggle="yes">et al.</italic>, 2019</xref>). Other methods including BiomeNet (<xref rid="btaa906-B29" ref-type="bibr">Shafiei <italic toggle="yes">et al.</italic>, 2014</xref>) and MetaNetSim (<xref rid="btaa906-B19" ref-type="bibr">Jiao <italic toggle="yes">et al.</italic>, 2013</xref>) dispense with pathways all together and model reaction networks based on enzyme abundance information. Recently, M.A. <xref rid="btaa906-B6" ref-type="bibr">Basher</xref><xref rid="btaa906-B6" ref-type="bibr"><italic toggle="yes">et al.</italic> (2020)</xref> implemented a multi-label classification approach to predict metabolic pathways for organismal and multi-organismal genomes e.g. microbiomes. One of the primary challenges encountered in developing mlLGPR related to engineering reliable features representing heterogeneous and degenerate functions within multi-organismal datasets (<xref rid="btaa906-B23" ref-type="bibr">Lawson <italic toggle="yes">et al.</italic>, 2019</xref>).</p>
    <p>Advances in representational learning have led to the development of scalable methods for engineering features from graphical networks e.g. networks composed of multiple nodes including information systems or social networks (<xref rid="btaa906-B12" ref-type="bibr">Dong <italic toggle="yes">et al.</italic>, 2017</xref>; <xref rid="btaa906-B16" ref-type="bibr">Grover and Leskovec, 2016</xref>; <xref rid="btaa906-B28" ref-type="bibr">Perozzi <italic toggle="yes">et al.</italic>, 2014</xref>). These approaches learn feature vectors for nodes in a network by solving an optimization problem in an unsupervised manner, using random walks followed by Skip-Gram extraction of low-dimensional latent continuous features, known as <italic toggle="yes">embeddings</italic> (<xref rid="btaa906-B25" ref-type="bibr">Mikolov <italic toggle="yes">et al.</italic>, 2013</xref>). Here, we present pathway2vec, a software package incorporating multiple <italic toggle="yes">random walks-based</italic> algorithms for representational learning used to automatically generate feature representations of metabolic pathways, which are decomposed into three interacting layers: compounds, enzymes and pathways, where each layer consists of associated nodes. A Skip-Gram model is applied to extract embeddings for each node, encoding smooth decision boundaries between groups of nodes in that graph. Nodes within a layer manifest inter-interactions and nodes between layers manifest betweenness interactions resulting in a multi-layer heterogeneous information network (<xref rid="btaa906-B30" ref-type="bibr">Shi <italic toggle="yes">et al.</italic>, 2017</xref>). This layered architecture captures relevant relationships used to learn a neural embedding-based low-dimensional space of metabolic features (<xref rid="btaa906-F1" ref-type="fig">Fig. 1</xref>).</p>
    <fig position="float" id="btaa906-F1">
      <label>Fig. 1.</label>
      <caption>
        <p>Three interacting metabolic pathways (<bold>a</bold>), depicted as a cloud glyph, where each pathway is comprised of compounds (green) and enzymes (red). Interacting compound, enzyme and pathway components are transformed into a multi-layer heterogeneous information network (<bold>b</bold>)</p>
      </caption>
      <graphic xlink:href="btaa906f1" position="float"/>
    </fig>
    <p>In addition to implementing several published random walk methods, we developed unit-ci<underline>r</underline>cle based j<underline>u</underline>mp and <underline>st</underline>ay random walk (RUST), adopting a unit-circle equation to sample node pairs that generalize previous random walk methods (<xref rid="btaa906-B12" ref-type="bibr">Dong <italic toggle="yes">et al.</italic>, 2017</xref>; <xref rid="btaa906-B16" ref-type="bibr">Grover and Leskovec, 2016</xref>; <xref rid="btaa906-B18" ref-type="bibr">Hussein <italic toggle="yes">et al.</italic>, 2018</xref>). The modules in pathway2vec were benchmarked based on node-clustering, embedding visualization and pathway prediction. In the case of pathway prediction, pathway2vec modules provided a viable adjunct or alternative to manually curated feature sets used in ML-based metabolic pathway reconstruction from genomic sequence information at different levels of complexity and completion. The distinctness of this work lies in decomposing pathway into components, so various graph-learning methods can be applied to automatically extract semantic features of metabolic pathways, and to incorporate the learned embeddings for pathway inference.</p>
  </sec>
  <sec>
    <title>2 Definitions and problem statement</title>
    <p>In this section, we formulate the problem of metabolic features engineering using a heterogeneous information network. Throughout the article, all vectors are column vectors denoted by boldface lowercase letters (e.g. <bold>x</bold>) while matrices are represented by boldface uppercase letters (e.g. <bold>X</bold>). The <inline-formula id="IE1"><mml:math id="IM1" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="bold">X</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> matrix denotes the <italic toggle="yes">i</italic>-th row of <inline-formula id="IE89"><mml:math id="IM2" display="inline" overflow="scroll"><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>X</mml:mi></mml:mstyle></mml:math></inline-formula> and <inline-formula id="IE90"><mml:math id="IM3" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>X</mml:mi></mml:mstyle></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> denotes the <inline-formula id="IE91"><mml:math id="IM4" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>-th element of <bold>X</bold>. A subscript character to a vector, <inline-formula id="IE2"><mml:math id="IM5" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, denotes an <italic toggle="yes">i</italic>-th cell of <bold>x</bold>. Occasional superscript, <inline-formula id="IE3"><mml:math id="IM6" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula>, suggests an index to a sample, position, or current epoch during learning period. We use calligraphic letters to represent sets (e.g. <inline-formula id="IE4"><mml:math id="IM7" display="inline" overflow="scroll"><mml:mi mathvariant="script">E</mml:mi></mml:math></inline-formula>) while we use the notation <inline-formula id="IE5"><mml:math id="IM8" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:mo>.</mml:mo><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula> to denote the cardinality of a given set.<statement id="mthst1"><label>Definition 2.1.</label><p><bold>Multi-label Pathway Dataset</bold> (<xref rid="btaa906-B6" ref-type="bibr">M.A.Basher</xref><xref rid="btaa906-B6" ref-type="bibr"><italic toggle="yes">et al.</italic>, 2020</xref>). A pathway dataset is characterized by <inline-formula id="IE6"><mml:math id="IM9" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="script">S</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="bold">y</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>:</mml:mo><mml:mn>1</mml:mn><mml:mo>&lt;</mml:mo><mml:mi>i</mml:mi><mml:mo>⩽</mml:mo><mml:mi>n</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> consisting of <italic toggle="yes">n</italic> examples, where <inline-formula id="IE7"><mml:math id="IM10" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> is a vector indicating abundance information for each enzymatic reaction denoted by <italic toggle="yes">z</italic>, which is an element of a set <inline-formula id="IE8"><mml:math id="IM11" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="script">Z</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>, having r possible reactions. The abundance of an enzymatic reaction for a given example <italic toggle="yes">i</italic>, say <inline-formula id="IE9"><mml:math id="IM12" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mi>l</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula>, is defined as <inline-formula id="IE10"><mml:math id="IM13" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mi>l</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:mo>≥</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. The class label <inline-formula id="IE11"><mml:math id="IM14" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="bold">y</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mn>1</mml:mn><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>t</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo stretchy="false">]</mml:mo><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:mrow><mml:mi>t</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula> is a pathway label vector of size <italic toggle="yes">t</italic> representing the total number of pathways obtained from a trusted source of experimentally validated metabolic pathways <inline-formula id="IE12"><mml:math id="IM15" display="inline" overflow="scroll"><mml:mi mathvariant="script">Y</mml:mi></mml:math></inline-formula>. The matrix form of <inline-formula id="IE13"><mml:math id="IM16" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE14"><mml:math id="IM17" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="bold">y</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> are symbolized as <bold>X</bold> and <bold>Y</bold>, respectively.</p></statement></p>
    <p>Both <inline-formula id="IE15"><mml:math id="IM18" display="inline" overflow="scroll"><mml:mi mathvariant="script">Z</mml:mi></mml:math></inline-formula> and <inline-formula id="IE16"><mml:math id="IM19" display="inline" overflow="scroll"><mml:mi mathvariant="script">Y</mml:mi></mml:math></inline-formula> are derived from trusted sources, such as KEGG (<xref rid="btaa906-B20" ref-type="bibr">Kanehisa <italic toggle="yes">et al.</italic>, 2017</xref>) or MetaCyc (<xref rid="btaa906-B9" ref-type="bibr">Caspi <italic toggle="yes">et al.</italic>, 2016b</xref>). We assume that there is a numerical representation behind every instance and label.</p>
    <p>The pathway inference task can be formulated as retrieving a set of pathway labels for an example <italic toggle="yes">i</italic> given features learned according to a <italic toggle="yes">heterogeneous information network</italic> defined as:<statement id="mthst2"><label>Definition 2.2.</label><p><bold>Heterogeneous Information Network.</bold> A heterogeneous information network is defined as a graph <inline-formula id="IE17"><mml:math id="IM20" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="script">G</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">V</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="script">E</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, where <inline-formula id="IE18"><mml:math id="IM21" display="inline" overflow="scroll"><mml:mi mathvariant="script">V</mml:mi></mml:math></inline-formula> and <inline-formula id="IE19"><mml:math id="IM22" display="inline" overflow="scroll"><mml:mi mathvariant="script">E</mml:mi></mml:math></inline-formula> denote to the set of nodes and edges (either directed or undirected), respectively (<xref rid="btaa906-B31" ref-type="bibr">Sun <italic toggle="yes">et al.</italic>, 2011</xref>). Each <inline-formula id="IE20"><mml:math id="IM23" display="inline" overflow="scroll"><mml:mrow><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">V</mml:mi></mml:mrow></mml:math></inline-formula> is associated with an object type mapping function <inline-formula id="IE21"><mml:math id="IM24" display="inline" overflow="scroll"><mml:mrow><mml:mo>ϕ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>:</mml:mo><mml:mi mathvariant="script">V</mml:mi><mml:mo>→</mml:mo><mml:mi mathvariant="script">O</mml:mi></mml:mrow></mml:math></inline-formula>, where <inline-formula id="IE22"><mml:math id="IM25" display="inline" overflow="scroll"><mml:mi mathvariant="script">O</mml:mi></mml:math></inline-formula> represents a set of object types. Each edge <inline-formula id="IE23"><mml:math id="IM26" display="inline" overflow="scroll"><mml:mrow><mml:mi>e</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">E</mml:mi><mml:mo>⊆</mml:mo><mml:mi mathvariant="script">V</mml:mi><mml:mo>×</mml:mo><mml:mi mathvariant="script">V</mml:mi></mml:mrow></mml:math></inline-formula> includes multiple types of links, and is associated with a link type mapping function <inline-formula id="IE24"><mml:math id="IM27" display="inline" overflow="scroll"><mml:mrow><mml:mo>ϕ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>e</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>:</mml:mo><mml:mi mathvariant="script">E</mml:mi><mml:mo>→</mml:mo><mml:mi mathvariant="script">R</mml:mi></mml:mrow></mml:math></inline-formula>, where <inline-formula id="IE25"><mml:math id="IM28" display="inline" overflow="scroll"><mml:mi mathvariant="script">R</mml:mi></mml:math></inline-formula> represents a set of relation types. In particular, when <inline-formula id="IE26"><mml:math id="IM29" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:mi mathvariant="script">O</mml:mi><mml:mo>|</mml:mo><mml:mo>+</mml:mo><mml:mo>|</mml:mo><mml:mi mathvariant="script">R</mml:mi><mml:mo>|</mml:mo><mml:mo>&gt;</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inline-formula>, the graph is referred to as a heterogeneous information network.</p></statement></p>
    <p>In heterogeneous information networks, both object types and relationship types are explicitly segregated. For the undirected edges, notice that if a relation exists from a type <inline-formula id="IE27"><mml:math id="IM30" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>O</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mo>∈</mml:mo><mml:mi mathvariant="script">O</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> to a type <inline-formula id="IE28"><mml:math id="IM31" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>O</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mo>∈</mml:mo><mml:mi mathvariant="script">O</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, denoted as <inline-formula id="IE29"><mml:math id="IM32" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>O</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mi>R</mml:mi><mml:msub><mml:mrow><mml:mi>O</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE30"><mml:math id="IM33" display="inline" overflow="scroll"><mml:mrow><mml:mi>R</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">R</mml:mi></mml:mrow></mml:math></inline-formula>, the inverse relation <inline-formula id="IE31"><mml:math id="IM34" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> holds naturally for <inline-formula id="IE32"><mml:math id="IM35" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>O</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:msup><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:msub><mml:mrow><mml:mi>O</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>. However, in many circumstances, <italic toggle="yes">R</italic> and its inverse <inline-formula id="IE33"><mml:math id="IM36" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> are not equal, unless the two objects are in the same domain, and <italic toggle="yes">R</italic> is symmetric. In addition, the network may be weighted where each edge <inline-formula id="IE34"><mml:math id="IM37" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, of nodes <italic toggle="yes">i</italic> and <italic toggle="yes">j</italic>, is associated with a weight of type <italic toggle="yes">R</italic>. The linkage type of an edge automatically defines the node types of its end points. The graph articulated in this article is considered directed and weighted (in some cases), but for simplification is converted to an undirected network by simply treating edges as symmetric links.<statement id="mthst3"><label>Example 2.1.</label><p>MetaCyc can be abstracted as a heterogeneous information network, in <xref rid="btaa906-F1" ref-type="fig">Figure 1b</xref>, which contains three types of objects, namely compounds (C), enzymes (Z) and pathways (T). There exist different types of links between objects representing semantic relationships e.g. ‘<italic toggle="yes">composed</italic> of’ and ‘<italic toggle="yes">involved in</italic>’, relationships between pathways and compounds or relations between enzymes and compounds e.g. ‘<italic toggle="yes">transform</italic>’ and ‘<italic toggle="yes">transformed by</italic>’. An enzyme may be mapped to a numerical category, known as an enzyme commission number (EC) based on the chemical reaction it catalyzes.</p><p>Two objects within heterogeneous information networks describe meta-level relationships referred to as <italic toggle="yes">meta-paths</italic> (<xref rid="btaa906-B31" ref-type="bibr">Sun <italic toggle="yes">et al.</italic>, 2011</xref>).</p></statement><statement id="mthst4"><label>Definition 2.3.</label><p><bold>Meta-Path.</bold> A meta-path <inline-formula id="IE35"><mml:math id="IM38" display="inline" overflow="scroll"><mml:mrow><mml:mi>P</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">P</mml:mi></mml:mrow></mml:math></inline-formula> is a path over <inline-formula id="IE36"><mml:math id="IM39" display="inline" overflow="scroll"><mml:mi mathvariant="script">G</mml:mi></mml:math></inline-formula> in the form of <inline-formula id="IE37"><mml:math id="IM40" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>O</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mrow><mml:mover><mml:mo>→</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:mover></mml:mrow><mml:msub><mml:mrow><mml:mi>O</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mrow><mml:mover><mml:mo>→</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mover></mml:mrow><mml:msub><mml:mrow><mml:mi>O</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mrow><mml:mover><mml:mo>→</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:mover></mml:mrow><mml:mo>…</mml:mo><mml:mrow><mml:mover><mml:mo>→</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mover></mml:mrow><mml:msub><mml:mrow><mml:mi>O</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, which defines an aggregation of relationships <inline-formula id="IE38"><mml:math id="IM41" display="inline" overflow="scroll"><mml:mrow><mml:mi>U</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>°</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>°</mml:mo><mml:mo>…</mml:mo><mml:mo>°</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> between type <italic toggle="yes">O</italic><sub>1</sub> and <inline-formula id="IE39"><mml:math id="IM42" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>O</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, where <inline-formula id="IE40"><mml:math id="IM43" display="inline" overflow="scroll"><mml:mo>°</mml:mo></mml:math></inline-formula> denotes the composition operator on relationships and <inline-formula id="IE41"><mml:math id="IM44" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>O</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:mi mathvariant="script">O</mml:mi></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE42"><mml:math id="IM45" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:mi mathvariant="script">R</mml:mi></mml:mrow></mml:math></inline-formula> are object and relation type, respectively.</p></statement><statement id="mthst5"><label>Example 2.2.</label><p>MetaCyc contains multiple meta-paths conveying different semantics. For example, a meta-path ‘ZCZ’ represents the co-catalyst relationships on a compound (C) between two enzymatic reactions (Z), and ‘ZCTCZ’ may indicate a meta-path that requires two enzymatic reactions (Z) transforming two compounds (C) within a pathway (T). Another important meta-path to consider is ‘CZC’, which implies ‘C + Z <inline-formula id="IE43"><mml:math id="IM46" display="inline" overflow="scroll"><mml:mo>⇒</mml:mo></mml:math></inline-formula> C’ transformation relationship.</p></statement></p>
    <p><bold><underline>Problem Statement</underline>. Metabolic Pathway Prediction.</bold> Given three inputs: (i) a heterogeneous information network <inline-formula id="IE44"><mml:math id="IM47" display="inline" overflow="scroll"><mml:mi mathvariant="script">G</mml:mi></mml:math></inline-formula>, (ii) a dataset <inline-formula id="IE45"><mml:math id="IM48" display="inline" overflow="scroll"><mml:mi mathvariant="script">S</mml:mi></mml:math></inline-formula> and (iii) an optional set of meta-paths <inline-formula id="IE46"><mml:math id="IM49" display="inline" overflow="scroll"><mml:mi mathvariant="script">P</mml:mi></mml:math></inline-formula>, the goal is to automatically resolve node embeddings such that leveraging the features will effectively improve pathway prediction for a hitherto unseen instance <inline-formula id="IE47"><mml:math id="IM50" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula>.</p>
  </sec>
  <sec>
    <title>3 The pathway2vec framework</title>
    <p>The pathway2vec framework is composed of five modules: (i) node2vec (<xref rid="btaa906-B16" ref-type="bibr">Grover and Leskovec, 2016</xref>), (ii) metapath2vec (<xref rid="btaa906-B12" ref-type="bibr">Dong <italic toggle="yes">et al.</italic>, 2017</xref>), (iii) metapath2vec++ (<xref rid="btaa906-B12" ref-type="bibr">Dong <italic toggle="yes">et al.</italic>, 2017</xref>), (iv) JUST (<xref rid="btaa906-B18" ref-type="bibr">Hussein <italic toggle="yes">et al.</italic>, 2018</xref>) and (v) RUST (this work), where each module contains a random walk modeling and node representation step. A graphical representation of the pathway2vec framework is depicted in <xref rid="btaa906-F2" ref-type="fig">Figure 2</xref>.</p>
    <p>
      <disp-quote content-type="extract">
        <p><bold>C1. Random Walks.</bold> In this step, a sequence of random walks over an input graph (whether heterogeneous or homogeneous) is generated based on the selected model (see Section 3.1).</p>
        <p><bold>C2. Learning Node Representation.</bold> Resulting walks are fed into the Skip-Gram model to learn node embeddings (<xref rid="btaa906-B12" ref-type="bibr">Dong <italic toggle="yes">et al.</italic>, 2017</xref>; <xref rid="btaa906-B15" ref-type="bibr">Fu <italic toggle="yes">et al.</italic>, 2017</xref>; <xref rid="btaa906-B16" ref-type="bibr">Grover and Leskovec, 2016</xref>; <xref rid="btaa906-B25" ref-type="bibr">Mikolov <italic toggle="yes">et al.</italic>, 2013</xref>). An embedding is a low-dimensional latent continuous feature for each node in <inline-formula id="IE49"><mml:math id="IM51" display="inline" overflow="scroll"><mml:mi mathvariant="script">G</mml:mi></mml:math></inline-formula>, which encodes smooth decision boundaries between groups or communities within a graph. Details are provided in Section 3.2.</p>
      </disp-quote>
    </p>
    <fig position="float" id="btaa906-F2">
      <label>Fig. 2.</label>
      <caption>
        <p>Graphical representation of pathway2vec framework. Main components: (<bold>a</bold>) a multi-layer heterogeneous information network composed from MetaCyc, showing meta-level interactions among compounds, enzymes and pathways, (<bold>b</bold>) four random walks and (<bold>c</bold>) two representational learning models: traditional Skip-Gram (top) and Skip-Gram by normalizing domain types (bottom). In the subfigure (a), the highlighted network neighbors of T<sub>1</sub> (nitrifier denitrification) indicate this pathway interacts directly with T<sub>2</sub> [nitrogen fixation I (ferredoxin)] and indirectly to T<sub>3</sub> [nitrate reduction I (denitrification)] by second-order with relationships to several compounds, including nitric oxide (C<sub>3</sub>) and nitrite (C<sub>4</sub>) converted by enzymes represented by the EC numbers (Z<sub>2</sub>: EC 1.7.2.6, Z<sub>3</sub>: EC 1.7.2.1 and Z<sub>4</sub>: EC 1.7.2.5). The black colored nodes in subfigure (b) indicate the current position of the walkers and red links suggest the next possible nodes to sample while black links indicate route taken by a walker to reach the current node. node2vec is parameterized by local search <italic toggle="yes">s</italic> and in–out <italic toggle="yes">h</italic> hyperparameters. These two hyperparameters constitute a unit circle, i.e. <inline-formula id="IE48"><mml:math id="IM52" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo>+</mml:mo><mml:msup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>, for RUST. <italic toggle="yes">M</italic> stores previously visited node types, which is 2 and only applied for JUST and RUST. <italic toggle="yes">c</italic> is number of nodes of the same domain type as the current node, which is 3 and is associated with JUST. For metapath2vec, a walker requires a prespecified scheme, which is set to ‘ZCTCZ’. The normalized Skip-Gram in the subfigure (c) bottom is simply trained based on the domain type, in contrast to the traditional Skip-Gram model. More information related to both learning strategies is provided in Section 3.2. Zoom for readability</p>
      </caption>
      <graphic xlink:href="btaa906f2" position="float"/>
    </fig>
    <sec>
      <title>3.1 Random walks</title>
      <p>To capture meaningful graph relationships, existing techniques, such as DeepWalk (<xref rid="btaa906-B28" ref-type="bibr">Perozzi <italic toggle="yes">et al.</italic>, 2014</xref>), design simple but effective algorithms based on random walks for representational learning of features. However, DeepWalk does not address in-depth and in-breadth graph exploration. Therefore, node2vec (<xref rid="btaa906-B16" ref-type="bibr">Grover and Leskovec, 2016</xref>) was developed to traverse local and global graph structures based on the principles of: (i) homophily (<xref rid="btaa906-B14" ref-type="bibr">Fortunato, 2010</xref>; <xref rid="btaa906-B26" ref-type="bibr">Newman, 2006</xref>) where interconnected nodes form a community of correlated attributes and (ii) structural equivalence (<xref rid="btaa906-B17" ref-type="bibr">Henderson <italic toggle="yes">et al.</italic>, 2012</xref>), where nodes having similar structural roles in a graph should be close to one another. node2vec simulates a second-order random walk, where the next node is sampled conditioned on the previous and the current node in a walk. For this, two hyperparameters are adjusted, <inline-formula id="IE50"><mml:math id="IM53" display="inline" overflow="scroll"><mml:mrow><mml:mi>s</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:mo>&gt;</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> that extracts local information of a graph, and <inline-formula id="IE51"><mml:math id="IM54" display="inline" overflow="scroll"><mml:mrow><mml:mi>h</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:mo>&gt;</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> that enables local and global traversals by moving deep in a graph or walking within the vicinity of the current node. This method is illustrated in <xref rid="btaa906-F2" ref-type="fig">Figure 2b</xref> top.</p>
      <p>First-order and second-order random walks were initially proposed for homogeneous graphs, but can be readily extended to heterogeneous information networks. <xref rid="btaa906-B31" ref-type="bibr">Sun <italic toggle="yes">et al.</italic> (2011)</xref> have observed that random walks can suffer from implicit bias due to initial node selection or the presence of a small set of dominant node types skewing results toward a subset of interconnected nodes. metapath2vec was developed (<xref rid="btaa906-B12" ref-type="bibr">Dong <italic toggle="yes">et al.</italic>, 2017</xref>) to resolve implicit bias in graph traversal to characterize semantic associations embodied between different types of nodes according to a certain path definition. This method is illustrated in <xref rid="btaa906-F2" ref-type="fig">Figure 2b</xref> bottom.</p>
      <p>metapath2vec overcomes the limitation of node2vec by enabling to extract semantical representations over heterogeneous graph. However, the use of meta-paths requires either prior domain-specific knowledge to recover semantic associations of HIN according to a certain path definition. As a result, groups of vertices with the heterogeneous information network may not be visited or revisited multiple times. This limitation was partially addressed by leveraging multiple path schemes (<xref rid="btaa906-B15" ref-type="bibr">Fu <italic toggle="yes">et al.</italic>, 2017</xref>) to guide random walks based on a meta-path length parameter. <xref rid="btaa906-B18" ref-type="bibr">Hussein <italic toggle="yes">et al.</italic> (2018)</xref> developed the Jump and Stay (JUST) heterogeneous graph embedding method using random walks as an alternative to meta-paths. JUST randomly selects the next node in a walk from either the same node type or from different node types using an exponential decay function and a tuning parameter based on two history records: (i) <italic toggle="yes">c</italic> corresponding the number of nodes consecutively visited in the same domain as the current node and (ii) a queue <italic toggle="yes">M</italic> of size <italic toggle="yes">m</italic> storing the previously visited node types. This method is illustrated in <xref rid="btaa906-F2" ref-type="fig">Figure 2b</xref> second from top.</p>
      <fig position="float" id="btaa906-F3">
        <label>Fig. 3.</label>
        <caption>
          <p>An illustrative example showing the selection of the next node for both JUST and RUST on HIN extracted from MetaCyc. The walker is currently stationed at <italic toggle="yes">C</italic><sub>3</sub> arriving from node <italic toggle="yes">C</italic><sub>2</sub> (indicated by black colored link), where <italic toggle="yes">M</italic> stores two previously visited node types and <italic toggle="yes">c</italic> (for JUST) holds three consecutive nodes that are of the same domain as <italic toggle="yes">C</italic><sub>3</sub>. As can be seen JUST would prefer selecting the next node of type pathway while RUST may prefer returning to <italic toggle="yes">C</italic><sub>2</sub> than jumping to <italic toggle="yes">T</italic><sub>1</sub> or <italic toggle="yes">T</italic><sub>2</sub>, as indicated by red edges, because <italic toggle="yes">s</italic> &lt;<italic toggle="yes"> h</italic> represented by an ellipsis glyph</p>
        </caption>
        <graphic xlink:href="btaa906f3" position="float"/>
      </fig>
      <p>However, in order to balance the node distribution over multiple node types, JUST constrains the number of memorized domains <italic toggle="yes">m</italic> to be within the range of <inline-formula id="IE52"><mml:math id="IM55" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>|</mml:mo><mml:mi mathvariant="script">O</mml:mi><mml:mo>|</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="double-struck">Z</mml:mi></mml:mrow><mml:mrow><mml:mo>&gt;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>. This can misrepresent graph structure in two ways: (i) explorations within domain because the last visited consecutive <italic toggle="yes">c</italic> nodes may enforce sampling from another domain, or (ii) jumping deep toward nodes from other domains because <italic toggle="yes">M</italic> is constrained. To alleviate these problems, we develop a novel random walk algorithm, RUST, adopting a unit-circle equation to sample node pairs that generalize previous representational learning methods, as illustrated in <xref rid="btaa906-F2" ref-type="fig">Figure 2b</xref> second from bottom. The two hyperparameters <italic toggle="yes">s</italic> and <italic toggle="yes">h</italic> constitute a unit circle, i.e. <inline-formula id="IE53"><mml:math id="IM56" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo>+</mml:mo><mml:msup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>, where <inline-formula id="IE54"><mml:math id="IM57" display="inline" overflow="scroll"><mml:mrow><mml:mi>h</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> indicates how much exploration is needed within a domain while <inline-formula id="IE55"><mml:math id="IM58" display="inline" overflow="scroll"><mml:mrow><mml:mi>s</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> defines the in-depth search toward other domains such that <italic toggle="yes">s</italic> &gt;<italic toggle="yes"> h</italic> encourages the walk to explore more domains and vice versa. Consequently, RUST blends both semantic associations and local/global structural information for generating walks without restricting domain size <italic toggle="yes">m</italic> in <italic toggle="yes">M</italic>.</p>
      <p>To better illustrate the effect of <italic toggle="yes">s</italic> and <italic toggle="yes">h</italic> on RUST, consider an example in <xref rid="btaa906-F3" ref-type="fig">Figure 3</xref>, where the walkers in JUST and RUST are currently stationed at <italic toggle="yes">C</italic><sub>3</sub> of compound type. While JUST enforces its walker to jump toward pathway domain, because of the combined effect of <italic toggle="yes">c</italic> that holds three consecutive nodes of compound type and <italic toggle="yes">M</italic> that is currently storing EC and compound types, RUST may prefer returning to <italic toggle="yes">C</italic><sub>2</sub> (no links exist to <italic toggle="yes">C</italic><sub>4</sub>) than jumping to <italic toggle="yes">T</italic><sub>1</sub> or <italic toggle="yes">T</italic><sub>2</sub>. This is because <italic toggle="yes">s</italic> &lt;<italic toggle="yes"> h</italic> promotes exploration within the same domain as <italic toggle="yes">C</italic><sub>3</sub>. If, however, <italic toggle="yes">s</italic> &gt;<italic toggle="yes"> h</italic> then RUST will perform in-depth search by selecting a node of type pathway. For formal definitions about the discussed random walks, see Supplementary Section S1.</p>
    </sec>
    <sec>
      <title>3.2 Learning latent embedding in graph</title>
      <p>Random walks <inline-formula id="IE56"><mml:math id="IM59" display="inline" overflow="scroll"><mml:mi mathvariant="script">W</mml:mi></mml:math></inline-formula> generated using node2vec, metapath2vec, JUST and RUST are fed into the Skip-Gram model to learn node embeddings (<xref rid="btaa906-B25" ref-type="bibr">Mikolov <italic toggle="yes">et al.</italic>, 2013</xref>). The Skip-Gram model exploits context information defined as a fixed number of nodes surrounding a target node. The model attempts to maximize co-occurrence probability among a pair of nodes identified within a given window of size <italic toggle="yes">q</italic> in <inline-formula id="IE57"><mml:math id="IM60" display="inline" overflow="scroll"><mml:mi mathvariant="script">W</mml:mi></mml:math></inline-formula> based on log-likelihood: 
<disp-formula id="E1"><label>(1)</label><mml:math id="M1" display="block" overflow="scroll"><mml:mrow><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>l</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">W</mml:mi></mml:mrow></mml:munder><mml:mrow><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>∈</mml:mo><mml:mi>l</mml:mi></mml:mrow></mml:munder><mml:mrow><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mo>−</mml:mo><mml:mi>q</mml:mi><mml:mo>≤</mml:mo><mml:mi>k</mml:mi><mml:mo>≤</mml:mo><mml:mi>q</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>≠</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:munder><mml:mrow><mml:mo> </mml:mo><mml:mtext>log</mml:mtext><mml:mo> </mml:mo></mml:mrow></mml:mrow></mml:mrow><mml:mi>p</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>+</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msup><mml:mo>|</mml:mo><mml:msup><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>where <inline-formula id="IE58"><mml:math id="IM61" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>−</mml:mo><mml:mi>c</mml:mi></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>+</mml:mo><mml:mi>c</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> are the context neighbor nodes of node <italic toggle="yes">v<sup>j</sup></italic> and <inline-formula id="IE59"><mml:math id="IM62" display="inline" overflow="scroll"><mml:mrow><mml:mi>p</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>+</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msup><mml:mo>|</mml:mo><mml:msup><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> defines the conditional probability of having context nodes given the node <italic toggle="yes">v<sup>j</sup></italic>. The <inline-formula id="IE60"><mml:math id="IM63" display="inline" overflow="scroll"><mml:mrow><mml:mi>p</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>+</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msup><mml:mo>|</mml:mo><mml:msup><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is the commonly used softmax function, i.e <inline-formula id="IE61"><mml:math id="IM64" display="inline" overflow="scroll"><mml:mrow><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="bold">D</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>+</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:msub><mml:mo>.</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold">D</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msup></mml:mrow></mml:msub></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">V</mml:mi></mml:mrow></mml:munder><mml:mrow><mml:msup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="bold">D</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msup></mml:mrow></mml:msub><mml:mo>.</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold">D</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msup></mml:mrow></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:mrow></mml:mfrac></mml:mrow></mml:math></inline-formula>, where <inline-formula id="IE62"><mml:math id="IM65" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="bold">D</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mi>V</mml:mi><mml:mo>|</mml:mo><mml:mo>×</mml:mo><mml:mi>d</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> stores the embeddings of all nodes and <inline-formula id="IE63"><mml:math id="IM66" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="bold">D</mml:mi></mml:mrow><mml:mi>v</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> is the <italic toggle="yes">v</italic>-th row corresponding to the embedding vector for node <italic toggle="yes">v</italic>. In practice, the vocabulary of nodes may be very large, which intensifies the computation of <inline-formula id="IE64"><mml:math id="IM67" display="inline" overflow="scroll"><mml:mrow><mml:mi>p</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>+</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msup><mml:mo>|</mml:mo><mml:msup><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. The Skip-Gram model uses negative sampling, which randomly selects a small set of nodes <italic toggle="yes">N</italic> that are not in the context to reduce computational complexity. This idea represented in updated <xref rid="E1" ref-type="disp-formula">Equation (1)</xref> is implemented in node2vec, metapath2vec, JUST and RUST according to: 
<disp-formula id="E2"><label>(2)</label><mml:math id="M2" display="block" overflow="scroll"><mml:mtable><mml:mtr><mml:mtd><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>l</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">W</mml:mi></mml:mrow><mml:mrow/></mml:munderover><mml:mrow><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>∈</mml:mo><mml:mi>l</mml:mi></mml:mrow></mml:munder><mml:mrow><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mo>−</mml:mo><mml:mi>q</mml:mi><mml:mo>≤</mml:mo><mml:mi>k</mml:mi><mml:mo>≤</mml:mo><mml:mi>q</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>≠</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:munder><mml:mo stretchy="false">(</mml:mo></mml:mrow></mml:mrow><mml:mo> </mml:mo><mml:mtext>log</mml:mtext><mml:mo> </mml:mo><mml:mo>σ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold">D</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>+</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:msub><mml:mo>.</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold">D</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msup></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>u</mml:mi><mml:mo>∈</mml:mo><mml:mi>N</mml:mi><mml:mo>∧</mml:mo><mml:mi>u</mml:mi><mml:mo>∉</mml:mo><mml:mi mathvariant="script">N</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:munder><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="double-struck">E</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi>u</mml:mi></mml:msup></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mtext>log</mml:mtext><mml:mo> </mml:mo><mml:mi>p</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi>u</mml:mi></mml:msup><mml:mo>|</mml:mo><mml:msup><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula>where <inline-formula id="IE65"><mml:math id="IM68" display="inline" overflow="scroll"><mml:mrow><mml:mo>σ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:msup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mi>v</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfrac></mml:mrow></mml:math></inline-formula> is the sigmoid function.</p>
      <p>In addition to the equation above, Dong and colleagues proposed a normalized version of metapath2vec, called metapath2vec++, where the domain type of the context node is considered in calculating the probability <inline-formula id="IE66"><mml:math id="IM69" display="inline" overflow="scroll"><mml:mrow><mml:mi>p</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>+</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msup><mml:mo>|</mml:mo><mml:msup><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, resulting in the following objective formula: 
<disp-formula id="E3"><label>(3)</label><mml:math id="M3" display="block" overflow="scroll"><mml:mtable><mml:mtr><mml:mtd><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>l</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">W</mml:mi></mml:mrow></mml:munder><mml:mrow><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>∈</mml:mo><mml:mi>l</mml:mi></mml:mrow></mml:munder><mml:mrow><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mo>−</mml:mo><mml:mi>q</mml:mi><mml:mo>≤</mml:mo><mml:mi>k</mml:mi><mml:mo>≤</mml:mo><mml:mi>q</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>≠</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:munder><mml:mo stretchy="false">(</mml:mo></mml:mrow></mml:mrow><mml:mo> </mml:mo><mml:mtext>log</mml:mtext><mml:mo> </mml:mo><mml:mo>σ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold">D</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>+</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:msub><mml:mo>.</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold">D</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msup></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mo>+</mml:mo><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>u</mml:mi><mml:mo>∈</mml:mo><mml:mi>N</mml:mi><mml:mo>∧</mml:mo><mml:mi>u</mml:mi><mml:mo>∉</mml:mo><mml:mi mathvariant="script">N</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∧</mml:mo><mml:mo>ϕ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi>u</mml:mi></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo>ϕ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>+</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:munder><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="double-struck">E</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi>u</mml:mi></mml:msup></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mtext>log</mml:mtext><mml:mo> </mml:mo><mml:mi>p</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi>u</mml:mi></mml:msup><mml:mo>|</mml:mo><mml:msup><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula>where <inline-formula id="IE67"><mml:math id="IM70" display="inline" overflow="scroll"><mml:mrow><mml:mo>ϕ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi>u</mml:mi></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo>ϕ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>+</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> suggests that the negative nodes are of the same type as the context node <inline-formula id="IE68"><mml:math id="IM71" display="inline" overflow="scroll"><mml:mrow><mml:mo>ϕ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>+</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. The above formula is also applied for RUST, and we refer it to RUST-norm. Through iterative update over all the context nodes, whether using <xref rid="E2" ref-type="disp-formula">Equation (2)</xref> or (3), for each walk in <inline-formula id="IE69"><mml:math id="IM72" display="inline" overflow="scroll"><mml:mi mathvariant="script">W</mml:mi></mml:math></inline-formula>, the learned features are expected to capture semantic and structural contents of a graph useful for pathway inference.</p>
    </sec>
  </sec>
  <sec>
    <title>4 Predicting pathways</title>
    <p>For pathway inference, the learned EC embedding vectors are concatenated into each example <italic toggle="yes">i</italic> according to: 
<disp-formula id="E4"><label>(4)</label><mml:math id="M4" display="block" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="bold">x</mml:mi><mml:mo stretchy="true">˜</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:mo>⊕</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mi>r</mml:mi></mml:mfrac><mml:msup><mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:msub><mml:mrow><mml:mi mathvariant="bold">D</mml:mi></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mo>:</mml:mo><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">Z</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>where ⊕ denotes the vector concatenation operation, <inline-formula id="IE70"><mml:math id="IM73" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="bold">D</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mi>V</mml:mi><mml:mo>|</mml:mo><mml:mo>×</mml:mo><mml:mi>d</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> stores the embeddings of all nodes and <inline-formula id="IE71"><mml:math id="IM74" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="bold">D</mml:mi></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mo>:</mml:mo><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">Z</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> indicates feature vectors for <italic toggle="yes">r</italic> enzymatic reactions. By incorporating enzymatic reaction features into <inline-formula id="IE72"><mml:math id="IM75" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula>, the dimension size is extended to <italic toggle="yes">r</italic> +<italic toggle="yes"> d</italic>, where <italic toggle="yes">r</italic> is the enzyme vector size while <italic toggle="yes">d</italic> corresponds to embeddings size. This modified version of <inline-formula id="IE73"><mml:math id="IM76" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> is denoted by <inline-formula id="IE74"><mml:math id="IM77" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="bold">x</mml:mi><mml:mo stretchy="false">˜</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula>, which then can be used by an appropriate ML algorithm, such as mlLGPR (<xref rid="btaa906-B6" ref-type="bibr">M.A.Basher</xref><xref rid="btaa906-B6" ref-type="bibr"><italic toggle="yes">et al.</italic>, 2020</xref>), to train and infer a set of metabolic pathways from enzymatic reactions.</p>
  </sec>
  <sec>
    <title>5 Experimental setup</title>
    <p>In this section, we explain the experimental settings and outline materials used to evaluate the performance of pathway2vec modules that were written in Python v3 and trained using tensorflow v1.10 (<xref rid="btaa906-B1" ref-type="bibr">Abadi <italic toggle="yes">et al.</italic>, 2016</xref>). Unless otherwise specified all tests were conducted on a Linux server using 10 cores of Intel Xeon CPU E5-2650.</p>
    <sec>
      <title>5.1 Preprocessing MetaCyc</title>
      <p>We constructed three hierarchical layers of HIN using MetaCyc v21 (<xref rid="btaa906-B9" ref-type="bibr">Caspi <italic toggle="yes">et al.</italic>, 2016b</xref>), according to: EC (bottom-layer), compound (mid-layer) and pathway (top-layer) as in <xref rid="btaa906-F2" ref-type="fig">Figure 2a</xref>. Relationships among these layers establish inter-interactions and betweenness interactions. Three inter-interactions were built: (i) ECs interactions that were collected-based shared metabolites, e.g. if a compound is engaged in two ECs then the two ECs were considered connected; (ii) compounds interactions that were processed based on shared reactions, e.g. if any two compounds constituting substrate and product of an engaged enzymatic reaction they would be linked; and (iii) pathways interactions that were constructed based on shared metabolites, e.g. if any product in one pathway is being consumed by another then these two pathways were linked. With regard to betweenness interactions, we considered two forms: (i) EC-compound interaction if any enzyme (represented by an EC number) engages in any compound then nodes of both types were linked and (ii) compound-pathway interaction if any compound involves in any pathway then those nodes were considered related. After building multi-layer HIN, we applied different configurations, as summarized in <xref rid="btaa906-T1" ref-type="table">Table 1</xref>, to explore relationship between different graph types and the quality of generated walks and embeddings.</p>
      <table-wrap position="float" id="btaa906-T1">
        <label>Table 1.</label>
        <caption>
          <p>Different configurations of compound, enzyme (EC) and pathway objects extracted from the MetaCyc database: (i) full content (MetaCyc), (ii) reduced content based on trimming nodes below two links (MetaCyc r), (iii) links among enzymatic reactions are removed, following graph independence assumption (MetaCyc uec) and (iv) combination of unconnected enzymatic reactions and trimmed nodes (MetaCyc uec + r)</p>
        </caption>
        <table frame="hsides" rules="groups">
          <colgroup span="1">
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="center" span="1"/>
          </colgroup>
          <thead>
            <tr>
              <th rowspan="1" colspan="1">Database</th>
              <th rowspan="1" colspan="1"># EC</th>
              <th rowspan="1" colspan="1"># Compound</th>
              <th rowspan="1" colspan="1"># Pathway</th>
              <th rowspan="1" colspan="1">
                <inline-formula id="IE75">
                  <mml:math id="IM78" display="inline" overflow="scroll">
                    <mml:mrow>
                      <mml:mo>|</mml:mo>
                      <mml:mi mathvariant="script">V</mml:mi>
                      <mml:mo>|</mml:mo>
                    </mml:mrow>
                  </mml:math>
                </inline-formula>
              </th>
              <th rowspan="1" colspan="1">
                <inline-formula id="IE76">
                  <mml:math id="IM79" display="inline" overflow="scroll">
                    <mml:mrow>
                      <mml:mo>|</mml:mo>
                      <mml:mi mathvariant="script">E</mml:mi>
                      <mml:mo>|</mml:mo>
                    </mml:mrow>
                  </mml:math>
                </inline-formula>
              </th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="1" colspan="1">MetaCyc</td>
              <td rowspan="1" colspan="1">6378</td>
              <td rowspan="1" colspan="1">13 689</td>
              <td rowspan="1" colspan="1">2526</td>
              <td rowspan="1" colspan="1">22 593</td>
              <td rowspan="1" colspan="1">37 631</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">MetaCyc (r)</td>
              <td rowspan="1" colspan="1">3606</td>
              <td rowspan="1" colspan="1">6469</td>
              <td rowspan="1" colspan="1">2467</td>
              <td rowspan="1" colspan="1">12 542</td>
              <td rowspan="1" colspan="1">37 631</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">MetaCyc (uec)</td>
              <td rowspan="1" colspan="1">6378</td>
              <td rowspan="1" colspan="1">13 689</td>
              <td rowspan="1" colspan="1">2526</td>
              <td rowspan="1" colspan="1">22 593</td>
              <td rowspan="1" colspan="1">33 353</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">MetaCyc (uec + r)</td>
              <td rowspan="1" colspan="1">3229</td>
              <td rowspan="1" colspan="1">6469</td>
              <td rowspan="1" colspan="1">2467</td>
              <td rowspan="1" colspan="1">12 165</td>
              <td rowspan="1" colspan="1">33 353</td>
            </tr>
          </tbody>
        </table>
      </table-wrap>
    </sec>
    <sec>
      <title>5.2 Parameter settings</title>
      <p>Parameterization for the other random walk methods can be found in <xref rid="btaa906-B12" ref-type="bibr">Dong <italic toggle="yes">et al.</italic> (2017)</xref>, <xref rid="btaa906-B16" ref-type="bibr">Grover and Leskovec (2016)</xref> and <xref rid="btaa906-B18" ref-type="bibr">Hussein <italic toggle="yes">et al.</italic> (2018)</xref>. For training, we randomly initialized model parameters with a truncated Gaussian distribution, and set the learning rate to 0.01, the batch size to 100 and the number of epochs to 10. Unless otherwise indicated, for each module, the number of sampled path instances is <italic toggle="yes">K</italic> = 100, the walk length is <italic toggle="yes">l</italic> = 100, the embedding dimension size is <italic toggle="yes">d</italic> = 128, the neighborhood size is 5, the size of negative samples is 5 and the number of memorized domain <italic toggle="yes">m</italic> for JUST and RUST are 2 and 3, respectively. The explore and the in–out hyperparameters for node2vec and RUST are <italic toggle="yes">h</italic> = 0.7 (or <italic toggle="yes">h</italic> = 0.55) and <italic toggle="yes">s</italic> = 0.7 (or <italic toggle="yes">s</italic> = 0.84), respectively, using the uec configuration. For metapath2vec and metapath2vec++, we applied the meta-path scheme ‘ZCTCZ’ to guide random walks. For brevity, we denote node2vec, metapath2vec, metapath2vec++, JUST, RUST and RUST-norm as n2v, m2v, cm2v, jt, rt and crt, respectively.</p>
    </sec>
  </sec>
  <sec>
    <title>6 Experimental results and discussion</title>
    <p>In this section, we first evaluate parameter sensitivity of RUST prior to benchmarking the four random walk algorithms, jointly with the two learning methods, based on node-clustering, embedding visualization and pathway prediction.</p>
    <sec>
      <title>6.1 Parameter sensitivity of RUST</title>
      <sec>
        <label>6.1.1</label>
        <title>Experimental setup</title>
        <p>In this section, the effect of different hyperparameter settings in RUST on the quality of learned nodes embeddings is described. Since the hyperparameter space involved in RUST, is infinite, exhaustive searches for optimal settings are prohibitive. Therefore, settings were sub-selected to determine RUST performance. Specifically, the effects of the dimensions <inline-formula id="IE77"><mml:math id="IM80" display="inline" overflow="scroll"><mml:mrow><mml:mi>d</mml:mi><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mn>30</mml:mn><mml:mo>,</mml:mo><mml:mn>50</mml:mn><mml:mo>,</mml:mo><mml:mn>80</mml:mn><mml:mo>,</mml:mo><mml:mn>100</mml:mn><mml:mo>,</mml:mo><mml:mn>128</mml:mn><mml:mo>,</mml:mo><mml:mn>150</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>, the neighborhood size <inline-formula id="IE78"><mml:math id="IM81" display="inline" overflow="scroll"><mml:mrow><mml:mi>q</mml:mi><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mn>3</mml:mn><mml:mo>,</mml:mo><mml:mn>5</mml:mn><mml:mo>,</mml:mo><mml:mn>7</mml:mn><mml:mo>,</mml:mo><mml:mn>9</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>, the memorized domains <inline-formula id="IE79"><mml:math id="IM82" display="inline" overflow="scroll"><mml:mrow><mml:mi>m</mml:mi><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mn>3</mml:mn><mml:mo>,</mml:mo><mml:mn>5</mml:mn><mml:mo>,</mml:mo><mml:mn>7</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> and the two hyperparameters <italic toggle="yes">s</italic> and <italic toggle="yes">h</italic> (<inline-formula id="IE80"><mml:math id="IM83" display="inline" overflow="scroll"><mml:mrow><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mn>0.55</mml:mn><mml:mo>,</mml:mo><mml:mn>0.71</mml:mn><mml:mo>,</mml:mo><mml:mn>0.84</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>) were evaluated based on Normalized Mutual Information (NMI) scores, after 10 trials. The NMI produces scores between 0, indicating no mutual information exists, and 1, indicating node clusters (feature groups) are perfectly correlated based on class information: enzyme, compound and pathway. Clustering was performed using the <italic toggle="yes">k</italic>-means algorithm (<xref rid="btaa906-B5" ref-type="bibr">Arthur and Vassilvitskii, 2007</xref>) to group data based on the learned representations from RUST as described in <xref rid="btaa906-B12" ref-type="bibr">Dong <italic toggle="yes">et al.</italic> (2017)</xref> and <xref rid="btaa906-B18" ref-type="bibr">Hussein <italic toggle="yes">et al.</italic> (2018)</xref>. Random walks <inline-formula id="IE81"><mml:math id="IM84" display="inline" overflow="scroll"><mml:mi mathvariant="script">W</mml:mi></mml:math></inline-formula> were generated using MetaCyc with uec option for RUST test parameters.</p>
      </sec>
      <sec>
        <label>6.1.2</label>
        <title>Experimental results</title>
        <p><xref rid="sup1" ref-type="supplementary-material">Supplementary Figure S1a</xref> indicates that RUST performance tends to saturate when the memorized domains are concentrated around <italic toggle="yes">m</italic> = 5 and <italic toggle="yes">h</italic> = 0.55, indicating a preference to explore more domain types. By fixing <italic toggle="yes">m</italic> = 3 and <italic toggle="yes">h</italic> = 0.55, the optimal results of NMI score w.r.t. the number of embedding dimensionality was found to be at 80 and 128 (<xref rid="sup1" ref-type="supplementary-material">Supplementary Fig. S1b</xref>). Beyond this value RUST performance deteriorated. A similar trend was also observed when the context neighborhood size was increased beyond <italic toggle="yes">q</italic> &gt; 5 (<xref rid="sup1" ref-type="supplementary-material">Supplementary Fig. S1c</xref>). Based on these observations, the following settings <italic toggle="yes">m</italic> = 3, <italic toggle="yes">h</italic> = 0.55, <italic toggle="yes">d</italic> = 80 or <italic toggle="yes">d</italic> = 128 and <italic toggle="yes">q</italic> = 5 provide the most efficient and accurate clustering outcomes using MetaCyc with uec option. For comparative purposes, we set <italic toggle="yes">d</italic> = 128.</p>
      </sec>
    </sec>
    <sec>
      <title>6.2 Node clustering</title>
      <sec>
        <label>6.2.1</label>
        <title>Experimental setup</title>
        <p>The performance of different random walk methods was tested in relation to node-clustering using NMI after 10 trials and the hyperparameters described above on all MetaCyc graph types depicted in <xref rid="btaa906-T1" ref-type="table">Table 1</xref>. Clustering was performed using the <italic toggle="yes">k</italic>-means algorithm to group homogeneous nodes based on the embeddings learned by each method.</p>
      </sec>
      <sec>
        <label>6.2.2</label>
        <title>Experimental results</title>
        <p><xref rid="sup1" ref-type="supplementary-material">Supplementary Figure S2</xref> indicates node-clustering results for node2vec, metapath2vec, JUST and RUST. node2vec, JUST and RUST exhibited similar performance across all configurations, indicating that these methods are less likely to extract semantic knowledge, characterizing node domains, from MetaCyc. However, RUST performed optimally better than node2vec and JUST in learning representations. In the case of metapath2vec, the random walk follows a predefined meta-path scheme, capturing the necessary relational knowledge for defining node types. For example, <italic toggle="yes">nitrogenase</italic> (EC-1.18.6.1), which reduces <italic toggle="yes">nitrogen</italic> gas into <italic toggle="yes">ammonium</italic>, is exclusively linked to the <italic toggle="yes">nitrogen fixation I (ferredoxin)</italic> pathway (<xref rid="btaa906-B13" ref-type="bibr">Eady, 1996</xref>). Without a predefined relation, a walker may explore more local/global structure of <inline-formula id="IE82"><mml:math id="IM85" display="inline" overflow="scroll"><mml:mi mathvariant="script">G</mml:mi></mml:math></inline-formula>, hence, become less efficient in exploiting relations between these two nodes. Among the four walks, only metapath2vec is able to accurately group those nodes, according to their classes. Despite the advantages of metapath2vec, it is biased to a scheme, as described in <xref rid="btaa906-B18" ref-type="bibr">Hussein <italic toggle="yes">et al.</italic> (2018)</xref>, which is explicitly observed for the case of ‘uec+r’ (<xref rid="sup1" ref-type="supplementary-material">Supplementary Fig. S2d</xref>). Under these conditions, both isolated nodes and links among ECs are discarded, resulting in a reduced number of nodes that are more easily traversed by a meta-path walker. metapath2vec++ exhibited trends similar to metapath2vec because they share the same walks. However, metapath2vec++ is trained using normalized Skip-Gram. Therefore, it is expected to achieve good NMI scores, yielding over 0.41 on uec+full content (in <xref rid="sup1" ref-type="supplementary-material">Supplementary Fig. S3</xref>), which is also similar to RUST-norm NMI score (<inline-formula id="IE83"><mml:math id="IM86" display="inline" overflow="scroll"><mml:mrow><mml:mo>∼</mml:mo><mml:mn>0.38</mml:mn></mml:mrow></mml:math></inline-formula>). This is interesting because RUST-norm employs RUST-based walks, but the embeddings are learned using normalized Skip-Gram.</p>
        <p>Taken together, these results indicate that node2vec, JUST and RUST-based walks are effective for analyzing graph structure while metapath2vec can learn good embeddings. However, RUST strikes a balance between the two proprieties through proper adjustments of <italic toggle="yes">m</italic> and the two unit-circle hyperparameters. Regarding the MetaCyc type, we recommend ‘uec’ because the associations among ECs are captured at the pathway level. The trimmed graph is contraindicated, because it eliminates many isolated, but important pathways and ECs.</p>
      </sec>
    </sec>
    <sec>
      <title>6.3 Manifold visualization</title>
      <sec>
        <label>6.3.1</label>
        <title>Experimental setup</title>
        <p>In this section, learned high dimensional embeddings were visualized by projecting them onto a 2D space using two case studies. The first case examines the quality of learned nodes embeddings according to the generated random walks an approach commonly sought in most graph-learning embedding techniques (<xref rid="btaa906-B16" ref-type="bibr">Grover and Leskovec, 2016</xref>; <xref rid="btaa906-B34" ref-type="bibr">Wang <italic toggle="yes">et al.</italic>, 2016</xref>). We posit that a good representational learning method defines clear boundaries for nodes of the same type. For illustrative purposes, nodes corresponding to nitrogen metabolism were selected. The second case examines the limitations of meta-path-based random walks, extending our discussions in Section 6.2. For illustrative purposes, we focus on the pathway layer in <xref rid="btaa906-F2" ref-type="fig">Figure 2a</xref> and consider representation of pathways having no enzymatic reactions. For visualization, we use UMAP, a.k.a. uniform manifold approximation and projection (<xref rid="btaa906-B24" ref-type="bibr">McInnes <italic toggle="yes">et al.</italic>, 2018</xref>) using 1000 epochs with the remaining settings set to default values.</p>
      </sec>
      <sec>
        <label>6.3.2</label>
        <title>Experimental results</title>
        <p><xref rid="btaa906-F4" ref-type="fig">Figure 4</xref> visualizes 2D UMAP projections of the 128-dimension embeddings, trained under uec+full setting depicting 185 nodes related to nitrogen metabolism in MetaCyc. Each point denotes a node in HIN and each color indicates the node type. node2vec (<xref rid="btaa906-F4" ref-type="fig">Fig. 4a</xref>), JUST (<xref rid="btaa906-F4" ref-type="fig">Fig. 4c</xref>) and RUST (<xref rid="btaa906-F4" ref-type="fig">Fig. 4d</xref>) appear to be less than optimal in extracting walks that preserve three layer relational knowledge e.g. nodes belonging to different types form unclear boundaries and diffuse clusters. In the cases of metapath2vec (<xref rid="btaa906-F4" ref-type="fig">Fig. 4b</xref>), metapath2vec++ (<xref rid="btaa906-F4" ref-type="fig">Fig. 4f</xref>) and RUST-norm (<xref rid="btaa906-F4" ref-type="fig">Fig. 4f</xref>), nodes of the same color are more optimally portrayed. In the second use case, 80 pathways were identified, having no enzymatic reactions, with their 109 pathway neighbors, as shown in <xref rid="sup1" ref-type="supplementary-material">Supplementary Figure S4a</xref>. From <xref rid="sup1" ref-type="supplementary-material">Supplementary Figure S4</xref>, we observe that, in contrast to node2vec, JUST, RUST and RUST-norm, pathway nodes are skewed incorrectly in both metapath2vec and metapath2vec++ and with lesser degree. This demonstrates the rigidness of meta-path-based methods that follow a defined scheme that limits their capacity to exploit local structure in learning embeddings. Interestingly, RUST-norm, based on RUST walks, is the only method that combines structural and semantic information as indicated in <xref rid="sup1" ref-type="supplementary-material">Supplementary Figure S4g</xref> and f, respectively. Taken together, these results indicate that RUST-based walks with training using <xref rid="E3" ref-type="disp-formula">Equation (3)</xref> provide efficient embeddings, consistent with node-clustering observations.</p>
        <fig position="float" id="btaa906-F4">
          <label>Fig. 4.</label>
          <caption>
            <p>The 2D UMAP projections of the 128-dimension embeddings, trained under uec+full setting depicting 185 nodes related to nitrogen metabolism. Node color indicates the category of the node type, where red indicates enzymatic reactions, green indicates compounds and blue is reserved for metabolic pathways</p>
          </caption>
          <graphic xlink:href="btaa906f4" position="float"/>
        </fig>
      </sec>
    </sec>
    <sec>
      <title>6.4 Metabolic pathway prediction</title>
      <sec>
        <label>6.4.1</label>
        <title>Experimental setup</title>
        <p>In this section, the effectiveness of the learned embeddings from pathway2vec modules is determined across different pathway inference methods including MinPath v1.2 (<xref rid="btaa906-B35" ref-type="bibr">Ye and Doak, 2009</xref>), PathoLogic v21 (<xref rid="btaa906-B21" ref-type="bibr">Karp <italic toggle="yes">et al.</italic>, 2016</xref>) and mlLGPR-elastic net (EN) (<xref rid="btaa906-B6" ref-type="bibr">M.A.Basher</xref><xref rid="btaa906-B6" ref-type="bibr"><italic toggle="yes">et al.</italic>, 2020</xref>). In contrast to previous multi-label classification methods (<xref rid="btaa906-B16" ref-type="bibr">Grover and Leskovec, 2016</xref>; <xref rid="btaa906-B18" ref-type="bibr">Hussein <italic toggle="yes">et al.</italic>, 2018</xref>; <xref rid="btaa906-B28" ref-type="bibr">Perozzi <italic toggle="yes">et al.</italic>, 2014</xref>), where the goal is to predict the most probable label set for nodes, we leverage the learned vectors and the multi-label dataset, according to <xref rid="E4" ref-type="disp-formula">Equation (4)</xref>. Pathway prediction with mlLGPR-EN used the default hyperparameter settings, after concatenating features from each learning method, to train on BioCyc [v20.5 tier (T) T2 &amp; T3] (<xref rid="btaa906-B8" ref-type="bibr">Caspi <italic toggle="yes">et al.</italic>, 2016a</xref>) consisting of 9255 PGDBs with 1463 distinct pathway labels (see Supplementary Section S5). Results are reported on T1 golden datasets including EcoCyc, HumanCyc, AraCyc, YeastCyc, LeishCyc and TrypanoCyc. Four evaluation metrics are used to report performance scores after three repeated trials: <italic toggle="yes">Hamming loss</italic>, <italic toggle="yes">micro precision</italic>, <italic toggle="yes">micro recall</italic> and <italic toggle="yes">micro F1 score</italic>.</p>
      </sec>
      <sec>
        <label>6.4.2</label>
        <title>Experimental results</title>
        <p><xref rid="btaa906-T2" ref-type="table">Table 2</xref> shows micro <italic toggle="yes">F</italic>1 scores for each pathway predictor. Numbers in boldface represent the best performance score in each column while the underlined text indicates the best performance among the embedding methods. From the results, all variations of embedding methods tended to perform better than MinPath across the four T1 golden datasets (EcoCyc, YeastCyc, LeishCyc and TrypanoCyc). With the exception of EcoCyc, the performance of embeddings resulted in less optimal micro <italic toggle="yes">F</italic>1 scores than PathoLogic or mlLGPR. In the case of mlLGPR, embeddings were trained on &lt;1470 pathways, potentially obscuring the actual benefits of the learned features. Taken together, different pathway2vec modules performed similar to one another indicating that embeddings are potential alternatives to the pathway and reaction evidence features used in <xref rid="btaa906-B6" ref-type="bibr">M.A.Basher</xref><xref rid="btaa906-B6" ref-type="bibr"><italic toggle="yes">et al.</italic> (2020)</xref>. Since RUST-norm is based on RUST walks that perform local and global graph structure exploration (Section 6.2) while generating meaningful semantic representation (Section 6.3), we suggest that users adopt RUST-norm. Full results are provided in Supplementary Section S6.</p>
        <table-wrap position="float" id="btaa906-T2">
          <label>Table 2.</label>
          <caption>
            <p>Micro <italic toggle="yes">F</italic>1 scores of each comparing algorithm on six benchmark datasets</p>
          </caption>
          <table frame="hsides" rules="groups">
            <colgroup span="1">
              <col valign="top" align="left" span="1"/>
              <col valign="top" align="char" char="." span="1"/>
              <col valign="top" align="char" char="." span="1"/>
              <col valign="top" align="char" char="." span="1"/>
              <col valign="top" align="char" char="." span="1"/>
              <col valign="top" align="char" char="." span="1"/>
              <col valign="top" align="char" char="." span="1"/>
            </colgroup>
            <thead>
              <tr>
                <th rowspan="1" colspan="1">Methods</th>
                <th colspan="6" align="center" rowspan="1">Micro <italic toggle="yes">F</italic>1 score ↑<hr/></th>
              </tr>
              <tr>
                <th rowspan="1" colspan="1"/>
                <th rowspan="1" colspan="1">EcoCyc</th>
                <th rowspan="1" colspan="1">HumanCyc</th>
                <th rowspan="1" colspan="1">AraCyc</th>
                <th rowspan="1" colspan="1">YeastCyc</th>
                <th rowspan="1" colspan="1">LeishCyc</th>
                <th rowspan="1" colspan="1">TrypanoCyc</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td rowspan="1" colspan="1">PathoLogic</td>
                <td rowspan="1" colspan="1">0.7631</td>
                <td rowspan="1" colspan="1">0.7460</td>
                <td rowspan="1" colspan="1">0.7093</td>
                <td rowspan="1" colspan="1">
                  <bold>0.7890</bold>
                </td>
                <td rowspan="1" colspan="1">0.6109</td>
                <td rowspan="1" colspan="1">0.6447</td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">MinPath</td>
                <td rowspan="1" colspan="1">0.5161</td>
                <td rowspan="1" colspan="1">0.4589</td>
                <td rowspan="1" colspan="1">0.5489</td>
                <td rowspan="1" colspan="1">0.4221</td>
                <td rowspan="1" colspan="1">0.2990</td>
                <td rowspan="1" colspan="1">0.3511</td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">mlLGPR</td>
                <td rowspan="1" colspan="1">0.7275</td>
                <td rowspan="1" colspan="1">
                  <bold>0.7468</bold>
                </td>
                <td rowspan="1" colspan="1">
                  <bold>0.7343</bold>
                </td>
                <td rowspan="1" colspan="1">0.7392</td>
                <td rowspan="1" colspan="1">
                  <bold>0.6220</bold>
                </td>
                <td rowspan="1" colspan="1">
                  <bold>0.6768</bold>
                </td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">mlLGPR+n2v</td>
                <td rowspan="1" colspan="1">0.7614</td>
                <td rowspan="1" colspan="1">0.3857</td>
                <td rowspan="1" colspan="1">0.3938</td>
                <td rowspan="1" colspan="1">0.4457</td>
                <td rowspan="1" colspan="1">0.4780</td>
                <td rowspan="1" colspan="1">0.4548</td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">mlLGPR+m2v</td>
                <td rowspan="1" colspan="1">0.7638</td>
                <td rowspan="1" colspan="1">0.3883</td>
                <td rowspan="1" colspan="1">0.3768</td>
                <td rowspan="1" colspan="1">0.4642</td>
                <td rowspan="1" colspan="1">0.4851</td>
                <td rowspan="1" colspan="1">0.4293</td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">mlLGPR+cm2v</td>
                <td rowspan="1" colspan="1">0.7508</td>
                <td rowspan="1" colspan="1">0.3783</td>
                <td rowspan="1" colspan="1">0.3939</td>
                <td rowspan="1" colspan="1">0.4598</td>
                <td rowspan="1" colspan="1">0.4700</td>
                <td rowspan="1" colspan="1">
                  <underline>0.4697</underline>
                </td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">mlLGPR+jt</td>
                <td rowspan="1" colspan="1">0.7640</td>
                <td rowspan="1" colspan="1">0.3783</td>
                <td rowspan="1" colspan="1">0.3860</td>
                <td rowspan="1" colspan="1">
                  <underline>0.4726</underline>
                </td>
                <td rowspan="1" colspan="1">0.4528</td>
                <td rowspan="1" colspan="1">0.4515</td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">mlLGPR+rt</td>
                <td rowspan="1" colspan="1">0.7651</td>
                <td rowspan="1" colspan="1">
                  <underline>0.4076</underline>
                </td>
                <td rowspan="1" colspan="1">0.3883</td>
                <td rowspan="1" colspan="1">0.4633</td>
                <td rowspan="1" colspan="1">
                  <underline>0.4857</underline>
                </td>
                <td rowspan="1" colspan="1">0.4680</td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">mlLGPR+crt</td>
                <td rowspan="1" colspan="1">
                  <bold>
                    <underline>0.7682</underline>
                  </bold>
                </td>
                <td rowspan="1" colspan="1">0.3654</td>
                <td rowspan="1" colspan="1">
                  <underline>0.4052</underline>
                </td>
                <td rowspan="1" colspan="1">0.4451</td>
                <td rowspan="1" colspan="1">0.4585</td>
                <td rowspan="1" colspan="1">0.4653</td>
              </tr>
            </tbody>
          </table>
        </table-wrap>
      </sec>
    </sec>
  </sec>
  <sec>
    <title>7 Conclusion</title>
    <p>We have developed the pathway2vec package for learning features relevant to metabolic pathway prediction from genomic sequence information. The software package consists of six representational learning modules used to automatically generate features for pathway inference. Metabolic feature representations were decomposed into three interacting layers: compounds, enzymes and pathways, where each layer consists of associated nodes. A Skip-Gram model was applied to extract embeddings for each node encoding smooth decision boundaries between groups of nodes in a graph resulting in a multi-layer heterogeneous information network for metabolic interactions within and between layers. Three extensive empirical studies were conducted to benchmark pathway2vec, indicating that the representational learning approach is a promising adjunct or alternative to features engineering based on manual curation. At the same time, we introduced RUST, a novel and flexible random walk method that uses unit-circle and domain size hyperparameters to exploit local/global structure while absorbing semantic information from both homogeneous and heterogeneous graphs. Looking forward, we intend to leverage embeddings and graph structure on more complex community-level metabolic pathway prediction problems. Because random walk-based methods depend on many hyperparameters (e.g. the length of a random walk) that must be tuned, and many walks that must be generated, we are exploring alternative graph convolutional neural networks to reduce computational complexity. Such methods aggregate feature information based on node co-occurrences patterns automatically without dependence on hyperparameter settings (<xref rid="btaa906-B3" ref-type="bibr">Abu-El-Haija <italic toggle="yes">et al.</italic>, 2018</xref>; <xref rid="btaa906-B10" ref-type="bibr">Cohen <italic toggle="yes">et al.</italic>, 2019</xref>; <xref rid="btaa906-B27" ref-type="bibr">Pei <italic toggle="yes">et al.</italic>, 2020</xref>).</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material id="sup1" position="float" content-type="local-data">
      <label>btaa906_Supplementary_Data</label>
      <media xlink:href="btaa906_supplementary_data.pdf">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
  </sec>
</body>
<back>
  <ack id="ack1">
    <title>Acknowledgements</title>
    <p>We would like to thank Connor Morgan-Lang, Julia Glinos, Kishori Konwar and Aria Hahn for lucid discussions on the function of the pathway2vec framework, Ryan MacLaughlin for his participation in preliminary performance evaluations and all members of the Hallam Lab for helpful comments along the way.</p>
    <sec>
      <title>Funding</title>
      <p>This work was performed under the auspices of Genome Canada, Genome British Columbia, the Natural Sciences and Engineering Research Council (NSERC) of Canada, and Compute/Calcul Canada. A.R.M.A.B was supported by a UBC four-year doctoral fellowship (4YF) administered through the UBC Graduate Program in Bioinformatics.</p>
      <p><italic toggle="yes">Conflict of Interest</italic>: S.J.H. is a co-founder of Koonkie Inc., a bioinformatics consulting company that designs and provides scalable algorithmic and data analytics solutions in the cloud.</p>
    </sec>
  </ack>
  <ref-list id="ref1">
    <title>References</title>
    <ref id="btaa906-B1">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Abadi</surname>
 <given-names>M.</given-names></string-name></person-group>
 <etal>et al</etal> (<year>2016</year>) Tensorflow: a system for large-scale machine learning. In: <source>12th {USENIX} Symposium on Operating Systems Design and Implementation ({OSDI} 16)</source>. pp. <fpage>265</fpage>–<lpage>283</lpage>. Savannah, GA, USA.</mixed-citation>
    </ref>
    <ref id="btaa906-B2">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Abubucker</surname>
 <given-names>S.</given-names></string-name></person-group>
 <etal>et al</etal> (<year>2012</year>) 
<article-title>Metabolic reconstruction for metagenomic data and its application to the human microbiome</article-title>. <source>PLoS Comput. Biol</source>., <volume>8</volume>, <fpage>e1002358</fpage>.<pub-id pub-id-type="pmid">22719234</pub-id></mixed-citation>
    </ref>
    <ref id="btaa906-B3">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Abu-El-Haija</surname>
 <given-names>S.</given-names></string-name></person-group>
 <etal>et al</etal> (<year>2018</year>) Watch your step: learning node embeddings via graph attention. In: <source>Advances in Neural Information Processing Systems</source>. pp. <fpage>9180</fpage>–<lpage>9190</lpage>. Montreal, Canada.</mixed-citation>
    </ref>
    <ref id="btaa906-B4">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Ansorge</surname>
 <given-names>W.J.</given-names></string-name></person-group> (<year>2009</year>) 
<article-title>Next-generation DNA sequencing techniques</article-title>. <source>N. Biotechnol</source>., <volume>25</volume>, <fpage>195</fpage>–<lpage>203</lpage>.<pub-id pub-id-type="pmid">19429539</pub-id></mixed-citation>
    </ref>
    <ref id="btaa906-B5">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Arthur</surname>
 <given-names>D.</given-names></string-name>, <string-name><surname>Vassilvitskii</surname><given-names>S.</given-names></string-name></person-group> (<year>2007</year>) k-means++: the advantages of careful seeding. In: <source>Proceedings of the Eighteenth Annual ACM-SIAM Symposium on Discrete Algorithms</source>. pp. <fpage>1027</fpage>–<lpage>1035</lpage>. 
<publisher-name>Society for Industrial and Applied Mathematics</publisher-name>. New Orleans, Louisiana, USA.</mixed-citation>
    </ref>
    <ref id="btaa906-B7">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Carbonell</surname>
 <given-names>P.</given-names></string-name></person-group>
 <etal>et al</etal> (<year>2018</year>) 
<article-title>Selenzyme: enzyme selection tool for pathway design</article-title>. <source>Bioinformatics</source>, <volume>34</volume>, <fpage>2153</fpage>–<lpage>2154</lpage>.<pub-id pub-id-type="pmid">29425325</pub-id></mixed-citation>
    </ref>
    <ref id="btaa906-B8">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Caspi</surname>
 <given-names>R.</given-names></string-name></person-group>
 <etal>et al</etal> (<year>2016</year>a) 
<article-title>BioCyc: online resource for genome and metabolic pathway analysis</article-title>. <source>FASEB J</source>., <volume>30</volume>, <fpage>lb192</fpage>.</mixed-citation>
    </ref>
    <ref id="btaa906-B9">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Caspi</surname>
 <given-names>R.</given-names></string-name></person-group>
 <etal>et al</etal> (<year>2016</year>b) 
<article-title>The metaCyc database of metabolic pathways and enzymes and the BioCyc collection of pathway/genome databases</article-title>. <source>Nucleic Acids Res</source>., <volume>44</volume>, <fpage>D471</fpage>–<lpage>D480</lpage>.<pub-id pub-id-type="pmid">26527732</pub-id></mixed-citation>
    </ref>
    <ref id="btaa906-B10">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Cohen</surname>
 <given-names>T.</given-names></string-name></person-group>
 <etal>et al</etal> (<year>2019</year>) Gauge equivariant convolutional networks and the icosahedral CNN. In: <source>International Conference on Machine Learning</source>. pp. <fpage>1321</fpage>–<lpage>1330</lpage>. Long Beach, California, USA.</mixed-citation>
    </ref>
    <ref id="btaa906-B11">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Dale</surname>
 <given-names>J.M.</given-names></string-name></person-group>
 <etal>et al</etal> (<year>2010</year>) 
<article-title>Machine learning methods for metabolic pathway prediction</article-title>. <source>BMC Bioinformatics</source>, <volume>11</volume>, <fpage>15</fpage>.<pub-id pub-id-type="pmid">20064214</pub-id></mixed-citation>
    </ref>
    <ref id="btaa906-B12">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Dong</surname>
 <given-names>Y.</given-names></string-name></person-group>
 <etal>et al</etal> (<year>2017</year>) metapath2vec: scalable representation learning for heterogeneous networks. In: <source>Proceedings of the 23rd ACM SIGKDD International Conference on Knowledge Discovery and Data Mining</source>. pp. <fpage>135</fpage>–<lpage>144</lpage>. 
<publisher-name>ACM</publisher-name>. Halifax, NS, Canada.</mixed-citation>
    </ref>
    <ref id="btaa906-B13">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Eady</surname>
 <given-names>R.R.</given-names></string-name></person-group> (<year>1996</year>) 
<article-title>Structure- function relationships of alternative nitrogenases</article-title>. <source>Chem. Rev</source>., <volume>96</volume>, <fpage>3013</fpage>–<lpage>3030</lpage>.<pub-id pub-id-type="pmid">11848850</pub-id></mixed-citation>
    </ref>
    <ref id="btaa906-B14">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Fortunato</surname>
 <given-names>S.</given-names></string-name></person-group> (<year>2010</year>) 
<article-title>Community detection in graphs</article-title>. <source>Phys. Rep</source>., <volume>486</volume>, <fpage>75</fpage>–<lpage>174</lpage>.</mixed-citation>
    </ref>
    <ref id="btaa906-B15">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Fu</surname>
 <given-names>T-y.</given-names></string-name></person-group>
 <etal>et al</etal> (<year>2017</year>) HIN2Vec: explore meta-paths in heterogeneous information networks for representation learning. In: <source>Proceedings of the 2017 ACM on Conference on Information and Knowledge Management</source>. pp. <fpage>1797</fpage>–<lpage>1806</lpage>. 
<publisher-name>ACM</publisher-name>. Singapore.</mixed-citation>
    </ref>
    <ref id="btaa906-B16">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Grover</surname>
 <given-names>A.</given-names></string-name>, <string-name><surname>Leskovec</surname><given-names>J.</given-names></string-name></person-group> (<year>2016</year>) node2vec: scalable feature learning for networks. In: <source>Proceedings of the 22nd ACM SIGKDD International Conference on Knowledge Discovery and Data Mining</source>. pp. <fpage>855</fpage>–<lpage>864</lpage>. 
<publisher-loc>ACM</publisher-loc>. San Francisco, CA, USA.</mixed-citation>
    </ref>
    <ref id="btaa906-B17">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Henderson</surname>
 <given-names>K.</given-names></string-name></person-group>
 <etal>et al</etal> (<year>2012</year>) RolX: structural role extraction &amp; mining in large graphs. In: <source>Proceedings of the 18th ACM SIGKDD International Conference on Knowledge Discovery and Data Mining</source>. pp. <fpage>1231</fpage>–<lpage>1239</lpage>. 
<publisher-name>ACM</publisher-name>. Beijing, China.</mixed-citation>
    </ref>
    <ref id="btaa906-B18">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Hussein</surname>
 <given-names>R.</given-names></string-name></person-group>
 <etal>et al</etal> (<year>2018</year>) Are meta-paths necessary? Revisiting heterogeneous graph embeddings. In: <source>Proceedings of the 27th ACM International Conference on Information and Knowledge Management</source>. pp. <fpage>437</fpage>–<lpage>446</lpage>. 
<publisher-name>ACM</publisher-name>. Torino, Italy.</mixed-citation>
    </ref>
    <ref id="btaa906-B19">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Jiao</surname>
 <given-names>D.</given-names></string-name></person-group>
 <etal>et al</etal> (<year>2013</year>) 
<article-title>Probabilistic inference of biochemical reactions in microbial communities from metagenomic sequences</article-title>. <source>PLoS Comput. Biol</source>., <volume>9</volume>, <fpage>e1002981</fpage>.<pub-id pub-id-type="pmid">23555216</pub-id></mixed-citation>
    </ref>
    <ref id="btaa906-B20">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Kanehisa</surname>
 <given-names>M.</given-names></string-name></person-group>
 <etal>et al</etal> (<year>2017</year>) 
<article-title>KEGG: new perspectives on genomes, pathways, diseases and drugs</article-title>. <source>Nucleic Acids Res</source>., <volume>45</volume>, <fpage>D353</fpage>–<lpage>D361</lpage>.<pub-id pub-id-type="pmid">27899662</pub-id></mixed-citation>
    </ref>
    <ref id="btaa906-B21">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Karp</surname>
 <given-names>P.D.</given-names></string-name></person-group>
 <etal>et al</etal> (<year>2016</year>) 
<article-title>Pathway tools version 19.0 update: software for pathway/genome informatics and systems biology</article-title>. <source>Brief. Bioinform</source>., <volume>17</volume>, <fpage>877</fpage>–<lpage>890</lpage>.<pub-id pub-id-type="pmid">26454094</pub-id></mixed-citation>
    </ref>
    <ref id="btaa906-B22">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Karp</surname>
 <given-names>P.D.</given-names></string-name></person-group>
 <etal>et al</etal> (<year>2018</year>) 
<article-title>The EcoCyc Database</article-title>. <source>EcoSal Plus</source>, <volume>8</volume>. pp. <fpage>1</fpage>–<lpage>19</lpage>.</mixed-citation>
    </ref>
    <ref id="btaa906-B23">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Lawson</surname>
 <given-names>C.E.</given-names></string-name></person-group>
 <etal>et al</etal> (<year>2019</year>) 
<article-title>Common principles and best practices for engineering microbiomes</article-title>. <source>Nat. Rev. Microbiol</source>., <volume>17</volume>, <fpage>725</fpage>–<lpage>741</lpage>.<pub-id pub-id-type="pmid">31548653</pub-id></mixed-citation>
    </ref>
    <ref id="btaa906-B6">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>M.A.Basher</surname>
 <given-names>A.R.</given-names></string-name></person-group>
 <etal>et al</etal> (<year>2020</year>) 
<article-title>Metabolic pathway inference using multi-label classification with rich pathway features</article-title>. <source>PLoS Comput. Biol</source>., <volume>16</volume>, <fpage>e1008174</fpage>.<pub-id pub-id-type="pmid">33001968</pub-id></mixed-citation>
    </ref>
    <ref id="btaa906-B24">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>McInnes</surname>
 <given-names>L.</given-names></string-name></person-group>
 <etal>et al</etal> (<year>2018</year>) 
<article-title>UMAP: uniform manifold approximation and projection</article-title>. <source>J. Open Source Softw</source>., <volume>3</volume>, <fpage>861</fpage>.</mixed-citation>
    </ref>
    <ref id="btaa906-B25">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Mikolov</surname>
 <given-names>T.</given-names></string-name></person-group>
 <etal>et al</etal> (<year>2013</year>) Distributed representations of words and phrases and their compositionality. In: <source>Advances in Neural Information Processing Systems</source>. pp. <fpage>3111</fpage>–<lpage>3119</lpage>. Lake Tahoe, Nevada, USA.</mixed-citation>
    </ref>
    <ref id="btaa906-B26">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Newman</surname>
 <given-names>M.E.</given-names></string-name></person-group> (<year>2006</year>) 
<article-title>Modularity and community structure in networks</article-title>. <source>Proc. Natl. Acad. Sci. USA</source>, <volume>103</volume>, <fpage>8577</fpage>–<lpage>8582</lpage>.<pub-id pub-id-type="pmid">16723398</pub-id></mixed-citation>
    </ref>
    <ref id="btaa906-B27">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Pei</surname>
 <given-names>H.</given-names></string-name></person-group>
 <etal>et al</etal> (<year>2020</year>) 
<article-title>Geom-GCN: geometric graph convolutional networks</article-title>. <source>In International Conference on Learning Representations, Addis Ababa, Ethiopia.</source></mixed-citation>
    </ref>
    <ref id="btaa906-B28">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Perozzi</surname>
 <given-names>B.</given-names></string-name></person-group>
 <etal>et al</etal> (<year>2014</year>) DeepWalk: online learning of social representations. In: <source>Proceedings of the 20th ACM SIGKDD International Conference on Knowledge Discovery and Data Mining</source><italic toggle="yes">.</italic> pp. <fpage>701</fpage>–<lpage>710</lpage>. 
<publisher-name>ACM</publisher-name>. NY, USA.</mixed-citation>
    </ref>
    <ref id="btaa906-B29">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Shafiei</surname>
 <given-names>M.</given-names></string-name></person-group>
 <etal>et al</etal> (<year>2014</year>) 
<article-title>BiomeNet: a Bayesian model for inference of metabolic divergence among microbial communities</article-title>. <source>PLoS Comput. Biol</source>., <volume>10</volume>, <fpage>e1003918</fpage>.<pub-id pub-id-type="pmid">25412107</pub-id></mixed-citation>
    </ref>
    <ref id="btaa906-B30">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Shi</surname>
 <given-names>C.</given-names></string-name></person-group>
 <etal>et al</etal> (<year>2017</year>) 
<article-title>A survey of heterogeneous information network analysis</article-title>. <source>IEEE Trans. Knowl. Data Eng</source>., <volume>29</volume>, <fpage>17</fpage>–<lpage>37</lpage>.</mixed-citation>
    </ref>
    <ref id="btaa906-B31">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Sun</surname>
 <given-names>Y.</given-names></string-name></person-group>
 <etal>et al</etal> (<year>2011</year>) 
<article-title>PathSim: meta path-based top-K similarity search in heterogeneous information networks</article-title>. <source>Proc. VLDB Endow</source>., <volume>4</volume>, <fpage>992</fpage>–<lpage>1003</lpage>.</mixed-citation>
    </ref>
    <ref id="btaa906-B32">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Tabei</surname>
 <given-names>Y.</given-names></string-name></person-group>
 <etal>et al</etal> (<year>2016</year>) 
<article-title>Simultaneous prediction of enzyme orthologs from chemical transformation patterns for de novo metabolic pathway reconstruction</article-title>. <source>Bioinformatics</source>, <volume>32</volume>, <fpage>i278</fpage>–<lpage>i287</lpage>.<pub-id pub-id-type="pmid">27307627</pub-id></mixed-citation>
    </ref>
    <ref id="btaa906-B33">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Toubiana</surname>
 <given-names>D.</given-names></string-name></person-group>
 <etal>et al</etal> (<year>2019</year>) 
<article-title>Combined network analysis and machine learning allows the prediction of metabolic pathways from tomato metabolomics data</article-title>. <source>Commun. Biol</source>., <volume>2</volume>, <fpage>214</fpage>.<pub-id pub-id-type="pmid">31240252</pub-id></mixed-citation>
    </ref>
    <ref id="btaa906-B34">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Wang</surname>
 <given-names>D.</given-names></string-name></person-group>
 <etal>et al</etal> (<year>2016</year>) Structural deep network embedding. In: <source>Proceedings of the 22nd ACM SIGKDD International Conference on Knowledge Discovery and Data Mining</source>. pp. <fpage>1225</fpage>–<lpage>1234</lpage>. 
<publisher-name>ACM</publisher-name>. San Francisco, CA, USA.</mixed-citation>
    </ref>
    <ref id="btaa906-B35">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Ye</surname>
 <given-names>Y.</given-names></string-name>, <string-name><surname>Doak</surname><given-names>T.G.</given-names></string-name></person-group> (<year>2009</year>) 
<article-title>A parsimony approach to biological pathway reconstruction/inference for genomes and metagenomes</article-title>. <source>PLoS Comput. Biol</source>., <volume>5</volume>, <fpage>e1000465</fpage>.<pub-id pub-id-type="pmid">19680427</pub-id></mixed-citation>
    </ref>
  </ref-list>
</back>
