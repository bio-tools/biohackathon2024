<?DTDIdentifier.IdentifierValue article.dtd?>
<?DTDIdentifier.IdentifierType system?>
<?SourceDTD.DTDName article.dtd?>
<?SourceDTD.Version 1.0?>
<?ConverterInfo.XSLTName bmc2nlmx2.xsl?>
<?ConverterInfo.Version 2?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Genome Biol</journal-id>
    <journal-title-group>
      <journal-title>Genome Biology</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1465-6906</issn>
    <issn pub-type="epub">1465-6914</issn>
    <publisher>
      <publisher-name>BioMed Central</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">3156955</article-id>
    <article-id pub-id-type="publisher-id">gb-2010-11-11-r116</article-id>
    <article-id pub-id-type="pmid">21114842</article-id>
    <article-id pub-id-type="doi">10.1186/gb-2010-11-11-r116</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Software</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Quake: quality-aware detection and correction of sequencing errors</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" corresp="yes" id="A1">
        <name>
          <surname>Kelley</surname>
          <given-names>David R</given-names>
        </name>
        <xref ref-type="aff" rid="I1">1</xref>
        <email>dakelley@umiacs.umd.edu</email>
      </contrib>
      <contrib contrib-type="author" id="A2">
        <name>
          <surname>Schatz</surname>
          <given-names>Michael C</given-names>
        </name>
        <xref ref-type="aff" rid="I2">2</xref>
        <email>mschatz@cshl.edu</email>
      </contrib>
      <contrib contrib-type="author" id="A3">
        <name>
          <surname>Salzberg</surname>
          <given-names>Steven L</given-names>
        </name>
        <xref ref-type="aff" rid="I1">1</xref>
        <email>salzberg@umiacs.umd.edu</email>
      </contrib>
    </contrib-group>
    <aff id="I1"><label>1</label>Center for Bioinformatics and Computational Biology, Institute for Advanced Computer Studies, and Department of Computer Science, University of Maryland, College Park, MD 20742, USA</aff>
    <aff id="I2"><label>2</label>Simons Center for Quantitative Biology, Cold Spring Harbor Laboratory, 1 Bungtown Road, Cold Spring Harbor, NY 11724, USA</aff>
    <pub-date pub-type="ppub">
      <year>2010</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>29</day>
      <month>11</month>
      <year>2010</year>
    </pub-date>
    <volume>11</volume>
    <issue>11</issue>
    <fpage>R116</fpage>
    <lpage>R116</lpage>
    <history>
      <date date-type="received">
        <day>7</day>
        <month>9</month>
        <year>2010</year>
      </date>
      <date date-type="rev-recd">
        <day>20</day>
        <month>10</month>
        <year>2010</year>
      </date>
      <date date-type="accepted">
        <day>29</day>
        <month>11</month>
        <year>2010</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>Copyright ©2010 Kelley et al.; licensee BioMed Central Ltd.</copyright-statement>
      <copyright-year>2010</copyright-year>
      <copyright-holder>Kelley et al.; licensee BioMed Central Ltd.</copyright-holder>
      <license license-type="open-access">
        <license-p>This is an open access article distributed under the terms of the Creative Commons Attribution License (&lt;url&gt;http://creativecommons.org/licenses/by/2.0&lt;/url&gt;), which permits unrestricted use, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="http://genomebiology.com/2010/11/11/R116"/>
    <abstract>
      <p>We introduce Quake, a program to detect and correct errors in DNA sequencing reads. Using a maximum likelihood approach incorporating quality values and nucleotide specific miscall rates, Quake achieves the highest accuracy on realistically simulated reads. We further demonstrate substantial improvements in <italic>de novo </italic>assembly and SNP detection after using Quake. Quake can be used for any size project, including more than one billion human reads, and is freely available as open source software from <ext-link ext-link-type="uri" xlink:href="http://www.cbcb.umd.edu/software/quake">http://www.cbcb.umd.edu/software/quake</ext-link>.</p>
    </abstract>
  </article-meta>
</front>
<body>
  <sec>
    <title>Rationale</title>
    <p>Massively parallel DNA sequencing has become a prominent tool in biological research [<xref ref-type="bibr" rid="B1">1</xref>,<xref ref-type="bibr" rid="B2">2</xref>]. The high-throughput and low cost of second-generation sequencing technologies has allowed researchers to address an ever-larger set of biological and biomedical problems. For example, the 1000 Genomes Project is using sequencing to discover all common variations in the human genome [<xref ref-type="bibr" rid="B3">3</xref>]. The Genome 10K Project plans to sequence and assemble the genomes of 10,000 vertebrate species [<xref ref-type="bibr" rid="B4">4</xref>]. Sequencing is now being applied to a wide variety of tumor samples in an effort to identify mutations associated with cancer [<xref ref-type="bibr" rid="B5">5</xref>,<xref ref-type="bibr" rid="B6">6</xref>]. Common to all of these projects is the paramount need to accurately sequence the sample DNA.</p>
    <p>DNA sequence reads from Illumina sequencers, one of the most successful of the second-generation technologies, range from 35 to 125 bp in length. Although sequence fidelity is high, the primary errors are substitution errors, at rates of 0.5-2.5% (as we show in our experiments), with errors rising in frequency at the 3' ends of reads. Sequencing errors complicate analysis, which normally requires that reads be aligned to each other (for genome assembly) or to a reference genome (for detection of mutations). Mistakes during the overlap computation in genome assembly are costly: missed overlaps may leave gaps in the assembly, while false overlaps may create ambiguous paths or improperly connect remote regions of the genome [<xref ref-type="bibr" rid="B7">7</xref>]. In genome re-sequencing projects, reads are aligned to a reference genome, usually allowing for a fixed number of mismatches due to either SNPs or sequencing errors [<xref ref-type="bibr" rid="B8">8</xref>]. In most cases, the reference genome and the genome being newly sequenced will differ, sometimes substantially. Variable regions are more difficult to align because mismatches from both polymorphisms and sequencing errors occur, but if errors can be eliminated, more reads will align and the sensitivity for variant detection will improve.</p>
    <p>Fortunately, the low cost of second-generation sequencing makes it possible to obtain highly redundant coverage of a genome, which can be used to correct sequencing errors in the reads before assembly or alignment. Various methods have been proposed to use this redundancy for error correction; for example, the EULER assembler [<xref ref-type="bibr" rid="B9">9</xref>] counts the number of appearances of each oligonucleotide of size <italic>k </italic>(hereafter referred to as <italic>k</italic>-mers) in the reads. For sufficiently large <italic>k</italic>, almost all single-base errors alter <italic>k</italic>-mers overlapping the error to versions that do not exist in the genome. Therefore, <italic>k</italic>-mers with low coverage, particularly those occurring just once or twice, usually represent sequencing errors. For the purpose of our discussion, we will refer to high coverage <italic>k</italic>-mers as <italic>trusted</italic>, because they are highly likely to occur in the genome, and low coverage <italic>k</italic>-mers as <italic>untrusted</italic>. Based on this principle, we can identify reads containing untrusted <italic>k</italic>-mers and either correct them so that all <italic>k</italic>-mers are trusted or simply discard them. The latest instance of EULER determines a coverage cutoff to separate low and high coverage <italic>k</italic>-mers using a mixture model of Poisson (low) and Gaussian (high) distributions, and corrects reads with low coverage <italic>k</italic>-mers by making nucleotide edits to the read that reduce the number of low coverage <italic>k</italic>-mers until all <italic>k</italic>-mers in the read have high coverage [<xref ref-type="bibr" rid="B10">10</xref>]. A number of related methods have been proposed to perform this error correction step, all guided by the goal of finding the minimum number of single base edits (edit distance) to the read that make all <italic>k</italic>-mers trusted [<xref ref-type="bibr" rid="B11">11</xref>-<xref ref-type="bibr" rid="B14">14</xref>].</p>
    <p>In addition, a few alternative approaches to error correction should be mentioned. Past methods intended for Sanger sequencing involve multiple sequence alignments of reads rendering them infeasible for short read datasets [<xref ref-type="bibr" rid="B15">15</xref>-<xref ref-type="bibr" rid="B17">17</xref>]. More recently, a generalized suffix tree of the reads was shown to be an effective data structure for detecting and correcting errors in short reads [<xref ref-type="bibr" rid="B18">18</xref>,<xref ref-type="bibr" rid="B19">19</xref>]. De Bruijn graph-based short read assemblers [<xref ref-type="bibr" rid="B10">10</xref>,<xref ref-type="bibr" rid="B11">11</xref>,<xref ref-type="bibr" rid="B13">13</xref>,<xref ref-type="bibr" rid="B20">20</xref>,<xref ref-type="bibr" rid="B21">21</xref>] perform substantial error correction of reads in the de Bruijn graph. For example, short dead end paths are indicative of a sequencing error at the end of a read and can be removed, and 'bubbles' where a low coverage path briefly diverges from and then reconnects to high coverage nodes are indicative of sequencing errors at the middle of a read and can be merged. Finally, a number of methods have been proposed to cluster reads and implicitly correct sequencing errors in data where the targets vary in abundance such as sequencing of small RNAs or 16 s rRNA [<xref ref-type="bibr" rid="B22">22</xref>-<xref ref-type="bibr" rid="B25">25</xref>].</p>
    <p>Although methods that search for the correct read based on minimizing edit distance will mostly make the proper corrections, edit distance is an incomplete measure of relatedness. First, each position in a sequencing read is assigned a quality value, which defines the probability that the basecall represents the true base. Though questions have been raised about the degree to which quality values exactly define the probability of error [<xref ref-type="bibr" rid="B26">26</xref>], newer methods for assigning them to base calls demonstrate substantial improvements [<xref ref-type="bibr" rid="B27">27</xref>-<xref ref-type="bibr" rid="B31">31</xref>], and for our purpose of error correction, the quality values can be useful even if they only rank one base as more likely to be an error as another. We should prefer to edit a read at these lower quality bases where errors are more likely, but edit distance treats all bases the same regardless of quality. Furthermore, specifics of the Illumina technology cause certain miscalls to be more likely than others. For example, bases are called by analysis of fluorescent output from base-incorporating chemical reactions, and A and C share a red detection laser while G and T share a green detection laser. Thus, A and C are more likely to be mistaken for each other than for G or T [<xref ref-type="bibr" rid="B26">26</xref>]. Edit distance treats all error substitutions as equally likely.</p>
    <p>In this paper, we introduce a new algorithm called Quake to correct substitution errors in sets of DNA sequencing reads produced as part of &gt;15× coverage sequencing projects, which has become commonplace thanks to the efficiency of second-generation sequencing technologies. Quake uses the <italic>k</italic>-mer coverage framework, but incorporates quality values and rates of specific miscalls computed from each sequencing project. In addition, Quake incorporates a new method to choose an appropriate coverage cutoff between trusted <italic>k</italic>-mers (those that are truly part of the genome) and erroneous <italic>k</italic>-mers based on weighting <italic>k</italic>-mer counts in the reads using the quality values assigned to each base. On simulated data using quality values from real reads, Quake is more accurate than previous methods, especially with relatively long Illumina reads. Correcting reads guided by edit distance alone, without the use of quality values, results in many more improperly corrected reads. These reads are then chimeric, containing sequence from two distinct areas of the genome, which can be a major problem for assembly software.</p>
    <p>Finally, we explore the impact of error correction with Quake on two important bioinformatics applications - <italic>de novo </italic>assembly and detection of variations with respect to a reference genome. Even a sophisticated assembler such as Velvet [<xref ref-type="bibr" rid="B20">20</xref>], which performs its own error correction using the assembly graph, benefits from pre-processing the reads with Quake. SOAPdenovo [<xref ref-type="bibr" rid="B13">13</xref>], a parallel assembler capable of assembling mammalian-size datasets, also produces better assemblies after error correction. For variant detection, correcting errors before mapping reads to a reference genome results in more reads aligned to SNP locations and more SNPs discovered. Note that Quake and other correction methods that rely on coverage of <italic>k</italic>-mers are inappropriate for applications where low coverage does not necessary implicate a sequencing error such as metagenomics, RNA-Seq, and ChIP-Seq.</p>
    <p>Quake is freely available as open source software from our website [<xref ref-type="bibr" rid="B32">32</xref>] under the Perl Artistic License [<xref ref-type="bibr" rid="B33">33</xref>].</p>
  </sec>
  <sec>
    <title>Results and discussion</title>
    <sec>
      <title>Accuracy</title>
      <p>The two goals of error correction are to cleanly separate reads with errors from reads without errors and to properly correct the reads with errors. To assess Quake's ability to accurately complete these tasks, we simulated sequencing reads with errors from finished genomes (using an approach comparable to the 'Maq simulate' program [<xref ref-type="bibr" rid="B34">34</xref>]) and compared Quake's corrections to the true reference. For each dataset, we categorized reads and their corrections into four outcomes. As positive outcomes, we counted the number of reads that were properly corrected to their original state or trimmed such that no errors remained. As negative outcomes, we counted the number of reads mis-corrected producing a false sequence or left uncorrected even though they contained errors. Reads were simulated by choosing a position in the reference genome, using the quality values from an actual Illumina sequencing read, and changing the nucleotides according to the probabilities defined by those quality values. Dohm <italic>et al</italic>. measured the bias in Illumina specific nucleotide to nucleotide miscall rates by sequencing reads from <italic>Helicobacter acinonychis </italic>and <italic>Beta vulgaris</italic>, aligning them to high quality reference genomes, and counting the number of each type of mismatch in the alignments [<xref ref-type="bibr" rid="B26">26</xref>]. At simulated errors, we changed the nucleotide according to these frequencies.</p>
      <p>To compare Quake's accuracy to that of previous error correction programs, we corrected the reads using EULER [<xref ref-type="bibr" rid="B10">10</xref>], Shrec [<xref ref-type="bibr" rid="B18">18</xref>], and SOAPdenovo [<xref ref-type="bibr" rid="B13">13</xref>] on a four core 2.4 GHz AMD Opteron machine. Quake and the other <italic>k</italic>-mer based correction tools used <italic>k </italic>= 15. SOAPdenovo's error correction module does not contain a method to choose the cutoff between trusted and untrusted <italic>k</italic>-mers, so we tried a few appropriate values and report the best results. We similarly tried multiple values for Shrec's strictness parameter that is used to help differentiate true and error reads via coverage. These are very sensitive parameters, and leaving them to the user is a critical limitation of these programs. Alternatively, EULER and Quake determine their parameters automatically using the data.</p>
      <p>Table <xref ref-type="table" rid="T1">1</xref> displays the average of the accuracy statistics after five iterations of simulated 36 bp reads to 40× coverage (5.5 M reads) from <italic>E. coli </italic>536 [GenBank: <ext-link ext-link-type="gen" xlink:href="NC_008253">NC_008253</ext-link>]. Quality value templates were taken from the sequencing of <italic>E. coli </italic>K12 substrain MG1655 [SRA:SRX000429]. The datasets contained an average of 1.17 M reads with errors. Of the reads that Quake tried to correct, 99.83% were corrected accurately to the true sequence. Quake properly corrected 88.3% (90.5% including trims) of error reads, which was 6.9% more reads than the second best program SOAPdenovo, made 2.3× fewer mis-corrections than SOAPdenovo, and allowed 1.8× fewer reads with errors. The 5265.4 error reads that Quake keeps have errors that only affect a few <italic>k</italic>-mers (at the end of the read), and these <italic>k</italic>-mers happen to exist elsewhere in the genome. We could not successfully run EULER on these short reads.</p>
      <table-wrap id="T1" position="float">
        <label>Table 1</label>
        <caption>
          <p>Simulated 36 bp E. coli</p>
        </caption>
        <table frame="hsides" rules="groups">
          <thead>
            <tr>
              <th/>
              <th align="center">Corrections</th>
              <th align="center">Trim corrections</th>
              <th align="center">Mis-corrections</th>
              <th align="center">Error reads kept</th>
              <th align="center">Time (min)</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="center">Quake</td>
              <td align="center">1035709.4</td>
              <td align="center">26337.0</td>
              <td align="center">1744.0</td>
              <td align="center">5537.0</td>
              <td align="center">14.2</td>
            </tr>
            <tr>
              <td align="center">SOAPdenovo</td>
              <td align="center">969666.4</td>
              <td align="center">120529.0</td>
              <td align="center">3912.8</td>
              <td align="center">9288.4</td>
              <td align="center">12.4</td>
            </tr>
            <tr>
              <td align="center">Shrec</td>
              <td align="center">964431.8</td>
              <td align="center">0.0</td>
              <td align="center">165422.0</td>
              <td align="center">41733.6</td>
              <td align="center">87.6</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <p>Simulated <italic>E. coli </italic>36 bp reads at 40× coverage averaged over five runs. For each method, we counted the number of reads that were properly corrected to their original state (Corrections), trimmed such that no errors remained (Trim corrections), mis-corrected to false sequence (Mis-corrections), and contained errors but were kept in the set (Error reads kept). Quake corrects more reads while mis-correcting fewer reads and keeping fewer reads with errors than all programs.</p>
        </table-wrap-foot>
      </table-wrap>
      <p>We performed the same test using five iterations on 40× coverage (1.6 M reads) of 124 bp reads from <italic>E. coli 536</italic>. Most of these reads had very low quality suffixes expected to contain many errors. Quake handled these reads seamlessly, but the other programs produced very poor results. Thus, we first trimmed every read <italic>r </italic>to the length</p>
      <p>
        <disp-formula id="bmcM1">
          <label>(1)</label>
          <mml:math id="M1" name="gb-2010-11-11-r116-i1" overflow="scroll">
            <mml:mrow>
              <mml:mi>l</mml:mi>
              <mml:mo>=</mml:mo>
              <mml:munder>
                <mml:mrow>
                  <mml:mi>arg</mml:mi>
                  <mml:mtext> </mml:mtext>
                  <mml:mi>max</mml:mi>
                </mml:mrow>
                <mml:mi>x</mml:mi>
              </mml:munder>
              <mml:mstyle displaystyle="true">
                <mml:munderover>
                  <mml:mo>∑</mml:mo>
                  <mml:mrow>
                    <mml:mi>i</mml:mi>
                    <mml:mo>=</mml:mo>
                    <mml:mi>x</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mo stretchy="false">|</mml:mo>
                    <mml:mi>r</mml:mi>
                    <mml:mo stretchy="false">|</mml:mo>
                  </mml:mrow>
                </mml:munderover>
                <mml:mrow>
                  <mml:mi>t</mml:mi>
                  <mml:mo>−</mml:mo>
                  <mml:msub>
                    <mml:mi>q</mml:mi>
                    <mml:mi>i</mml:mi>
                  </mml:msub>
                </mml:mrow>
              </mml:mstyle>
            </mml:mrow>
          </mml:math>
        </disp-formula>
      </p>
      <p>By setting <italic>t </italic>= 3, we mainly trim nucleotides with quality value 2 off the ends of the reads, but will trim past a higher quality base call if there are a sufficient number of nucleotides with quality ≤2 preceding it. On this data (where full results are displayed in Table <xref ref-type="table" rid="T2">2</xref>), Quake is 99.9% accurate on reads that it tries to correct. Of the 297 K error reads, Quake corrected 95.6% (97.9% including trims), 2.5% more than SOAPdenovo, the second most effective program. However, SOAPdenovo makes many more mistakes on the longer reads by mis-correcting 28.9× more reads and keeping 11.9× more reads with errors in the set. Shrec and EULER correct far fewer reads and mis-correct more reads than Quake.</p>
      <table-wrap id="T2" position="float">
        <label>Table 2</label>
        <caption>
          <p>Simulated 124 bp E. coli</p>
        </caption>
        <table frame="hsides" rules="groups">
          <thead>
            <tr>
              <th/>
              <th align="center">Corrections</th>
              <th align="center">Trim corrections</th>
              <th align="center">Mis-corrections</th>
              <th align="center">Error reads kept</th>
              <th align="center">Time (min)</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="center">Quake</td>
              <td align="center">283769.4</td>
              <td align="center">6581.2</td>
              <td align="center">243.0</td>
              <td align="center">393.6</td>
              <td align="center">11.8</td>
            </tr>
            <tr>
              <td align="center">SOAPdenovo</td>
              <td align="center">276770.4</td>
              <td align="center">2942.6</td>
              <td align="center">7019.4</td>
              <td align="center">5490.2</td>
              <td align="center">16.9</td>
            </tr>
            <tr>
              <td align="center">Shrec</td>
              <td align="center">165942.7</td>
              <td align="center">0.0</td>
              <td align="center">33140.3</td>
              <td align="center">96626.7</td>
              <td align="center">97.1</td>
            </tr>
            <tr>
              <td align="center">EULER</td>
              <td align="center">228316.4</td>
              <td align="center">16577.4</td>
              <td align="center">3763.0</td>
              <td align="center">414.8</td>
              <td align="center">6.9</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <p>Simulated <italic>E. coli </italic>124 bp reads at 40× coverage averaged over five runs. Column descriptions are the same as Table 1. Quake corrects more reads while mis-correcting far fewer reads and keeping fewer reads with errors than all programs.</p>
        </table-wrap-foot>
      </table-wrap>
      <p>To demonstrate Quake's ability to scale to larger genomes, we simulated 325 million 124 bp reads from the 249 Mbp human chromosome 1 (version hg19), which provided 34× coverage after trimming. Due to the larger size of the sequencing target, we counted and corrected 18-mers in the reads. Of the 15.23 M reads containing errors, Quake corrected 12.83 M (84.2%) and trimmed to a correct prefix another 0.82 M (5.4%). Because we could not successfully run SOAPdenovo using 18-mers, we corrected using 17-mers, a reasonable choice given that the authors of that software chose to correct reads using 17-mers for the entire human genome [<xref ref-type="bibr" rid="B13">13</xref>]. Quake corrected 11% more reads than SOAPdenovo, reduced mis-corrections by 64%, and kept 15% fewer error reads. EULER produced very poor correction results, for example, correcting less than half as many reads as Quake with more mis-corrections and error reads kept. On a dataset this large, Shrec required more memory than our largest computer (256 GB).</p>
      <p>Relative to the 124 bp simulated reads from <italic>E. coli</italic>, Quake's attempted corrections were accurate at a lower rate (99.02%) and Quake kept more error reads in the dataset (1.11 M, 7.27%). This is caused by the fact that the human genome contains far more repetitive elements than <italic>E. coli</italic>, such as the LINE and SINE retrotransposon families [<xref ref-type="bibr" rid="B35">35</xref>]. The more repetitive the genome is, the greater the chance is that a sequencing error will merely change one trusted <italic>k</italic>-mer to another trusted <italic>k</italic>-mer, hiding the error. To quantify this property of the two genomes, we computed the percentage of all possible single base mutations to <italic>k</italic>-mers in each genome which create <italic>k</italic>-mers that also exist in the genome. In <italic>E. coli 536</italic>, this is true for 2.25% of 15-mer mutations, and in chromosome 1 of the human genome, it is true for 13.8% of 18-mer mutations. Increasing the <italic>k</italic>-mer size does little to alleviate the problem as still 11.1% of 19-mer mutations are problematic. Nevertheless, allowing a small percentage of error reads may not be terribly problematic for most applications. For example, genome assemblers will notice the lower coverage on the paths created by these reads and clean them out of the assembly graph.</p>
    </sec>
    <sec>
      <title>Genome assembly</title>
      <p>In <italic>de novo </italic>genome assembly, the goal is to build contiguous and unambiguous sequences called contigs from overlapping reads. The traditional formulation of the assembly problem involves first finding all overlaps between reads [<xref ref-type="bibr" rid="B36">36</xref>], taking care to find all true overlaps between reads sequenced from the same genome location and avoid false overlaps between reads sequenced from remote regions [<xref ref-type="bibr" rid="B7">7</xref>]. Because of sequencing errors, we must allow mismatches in the overlap alignments to find all true overlaps, but we cannot allow too many or false overlaps will be found and fragment the assembly. With short reads, we must allow a short minimum overlap length, but in the presence of sequencing errors, particularly when these errors tend to occur at the ends of the reads, we may frequently overlook true overlaps (see Figure <xref ref-type="fig" rid="F1">1</xref>). A de Bruijn graph formulation of the assembly problem has become very popular for short reads [<xref ref-type="bibr" rid="B10">10</xref>,<xref ref-type="bibr" rid="B11">11</xref>,<xref ref-type="bibr" rid="B13">13</xref>,<xref ref-type="bibr" rid="B20">20</xref>], but is very sensitive to sequencing errors. A substantial portion of the work performed by these programs goes towards recognizing and correcting errors in the graph.</p>
      <fig id="F1" position="float">
        <label>Figure 1</label>
        <caption>
          <p><bold>Alignment difficulty</bold>. Detecting alignments of short reads is more difficult in the presence of sequencing errors (represented as X's). (a) In the case of genome assembly, we may miss short overlaps between reads containing sequencing errors, particularly because the errors tend to occur at the ends of the reads. (b) To find variations between the sequenced genome and a reference genome, we typically first map the reads to the reference. However, reads containing variants (represented as stars) and sequencing errors will have too many mismatches and not align to their true genomic location.</p>
        </caption>
        <graphic xlink:href="gb-2010-11-11-r116-1"/>
      </fig>
      <p>Having established the accuracy of Quake for error correction on simulated data, we measured the impact of Quake on genome assembly by assembling the reads before and after error correction. One assembly is better than another if it is more connected and more accurately represents the sequenced genome. To measure connectedness, we counted the number of contigs and scaffolds in the assembly larger than 50 bp as well as the N50 and N90 for each, which is the contig/scaffold size for which 50% (90%) of the genome is contained in contigs/scaffolds of equal or larger size. Fewer contigs/scaffolds and larger N50 and N90 values signify that the reads have been more effectively merged into large genomic sequences. In addition, we counted the number of reads included in the assembly because greater coverage generally leads to better accuracy in consensus calling. When a reference genome was available, we used it to validate the correctness of the assembly. We aligned all scaffolds to the reference using MUMmer [<xref ref-type="bibr" rid="B37">37</xref>] and considered scaffolds that did not align for their entire length (ignoring 35 bp on each end) at &gt;95% identity to be mis-assembled. We also counted the number of single base differences between the reference and otherwise properly assembled scaffolds. Finally, we computed the percentage of reference nucleotides covered by some aligning scaffold.</p>
      <p>Velvet is a widely used de Bruijn graph-based assembler that performs error correction by identifying graph motifs that signify sequencing errors [<xref ref-type="bibr" rid="B20">20</xref>], but does not use a stand-alone error correction module like EULER [<xref ref-type="bibr" rid="B10">10</xref>] or SOAPdenovo [<xref ref-type="bibr" rid="B13">13</xref>]. Thus, we hypothesized that Quake would help Velvet produce better assemblies. To test this hypothesis, we corrected and assembled 152× (20.8 M reads) coverage of 36 bp reads from <italic>E. coli </italic>K12 substrain MG1655 [SRA:SRX000429]. We used Velvet's option for automatic computation of expected coverage and chose the de Bruijn graph <italic>k</italic>-mer size that resulted in the best assembly based on the connectedness and correctness statistics discussed above.</p>
      <p>Table <xref ref-type="table" rid="T3">3</xref> displays the assembly statistics for <italic>E. coli </italic>with Velvet. Quake corrected 2.44 M (11.7%) and removed 0.57 M (2.8%) reads from the dataset. After correction, 0.75 M (3.8%) more reads were included in the assembly, which contained 13% fewer contigs and 13% fewer scaffolds. Though this significant increase in connectedness of the assembly does not manifest in the N50 values, which are similar for both assemblies, the contig N90 increases by 47% and the scaffold N90 increases by 11%. With respect to correctness, the corrected read assembly contained one fewer mis-assembled scaffold and 31% fewer mis-called bases, and still covered slightly more of the reference genome. This improvement was consistent in experiments holding out reads for lesser coverage of the genome (data not shown). As the coverage decreases, the distributions of error and true <italic>k</italic>-mers blend together and the choice of cutoff must carefully balance making corrections and removing useful reads from low coverage regions. On this dataset, the minimum coverage at which the assembly improved after correction using Quake was 16×.</p>
      <table-wrap id="T3" position="float">
        <label>Table 3</label>
        <caption>
          <p>Velvet E. coli assembly</p>
        </caption>
        <table frame="hsides" rules="groups">
          <thead>
            <tr>
              <th/>
              <th align="center">Contigs</th>
              <th align="center">N50</th>
              <th align="center">N90</th>
              <th align="center">Scaffolds</th>
              <th align="center">N50</th>
              <th align="center">N90</th>
              <th align="center">Breaks</th>
              <th align="center">Miscalls</th>
              <th align="center">Cov</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="center">Uncorrected</td>
              <td align="center">398</td>
              <td align="center">94,827</td>
              <td align="center">17,503</td>
              <td align="center">380</td>
              <td align="center">95,365</td>
              <td align="center">23,869</td>
              <td align="center">5</td>
              <td align="center">456</td>
              <td align="center">0.9990</td>
            </tr>
            <tr>
              <td align="center">Corrected</td>
              <td align="center">345</td>
              <td align="center">94,831</td>
              <td align="center">25,757</td>
              <td align="center">332</td>
              <td align="center">95,369</td>
              <td align="center">26,561</td>
              <td align="center">4</td>
              <td align="center">315</td>
              <td align="center">0.9992</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <p>Velvet assemblies of <italic>E. coli </italic>36 bp paired end reads at 152× coverage. After correcting the reads, more reads are included in the assembly into fewer contigs and scaffolds. N50 and N90 values were computed using the genome size 4,639,675 bp. The N50 value was similar for both assemblies, but N90 grew significantly with corrected reads. Correcting the reads also improved the correctness of the assembly producing fewer mis-assembled scaffolds (Breaks) and miscalled bases (Miscalls) and covering a greater percentage of the reference genome (Cov).</p>
        </table-wrap-foot>
      </table-wrap>
      <p>We also measured Quake's impact on a larger assembly with longer reads by assembling 353.7 M Illumina reads, all of them 124 bp in length, from the alfalfa leafcutting bee <italic>Megachile rotundata</italic>, with an estimated genome size of 300 Mbp. (Contact the corresponding author for details on data access.) Assembly was performed with SOAPdenovo [<xref ref-type="bibr" rid="B13">13</xref>] using a de Bruijn graph <italic>k</italic>-mer size of 31 and the '-R' option to resolve small repeats. Assembly of the raw uncorrected reads was quite poor because of the very low quality suffixes of many of the 124 bp reads. Thus, we compare assembly of quality trimmed reads (performed as described above), reads corrected using Quake, and trimmed reads corrected with SOAPdenovo's own error correction module. Quake and SOAPdenovo corrected using 18-mers and a coverage cutoff of 1.0.</p>
      <p>Correcting errors in the reads had a significant affect on the quality of the assembly as seen in Table <xref ref-type="table" rid="T4">4</xref>. In the Quake assembly, &gt;123 K fewer contigs were returned as contig N50 grew by 71% and contig N90 more than doubled compared to the standard approach of only trimming the reads before assembly. Similarly to the simulated reads, Quake is able to correct more reads than SOAPdenovo, which leads to 1.5% more reads included in the assembly than SOAPdenovo and slightly more than the assembly of uncorrected reads. Improvements to the connectedness statistics compared to SOAPdenovo were modest. Surprisingly, although nearly 2.5× fewer scaffolds were returned after error correction with Quake, scaffold N50 remained virtually the same and N90 slightly decreased. We investigated a few possible explanations for this with inconclusive results; for example, scaffold sizes did not improve substantially after adding back mate pairs 8 excluded due to uncorrectable errors. Because N50 and N90 can be somewhat volatile and the scaffolds in the <italic>E. coli </italic>assembly above did improve after error correction, this is potentially an artifact of this particular dataset, that is the library sizes used with respect to the repeat structure of the genome.</p>
      <table-wrap id="T4" position="float">
        <label>Table 4</label>
        <caption>
          <p>SOAPdenovo bee assembly</p>
        </caption>
        <table frame="hsides" rules="groups">
          <thead>
            <tr>
              <th align="center">Assembly</th>
              <th align="center">Trimmed Only</th>
              <th align="center">Corrected</th>
              <th align="center">Removed</th>
              <th align="center">Contigs</th>
              <th align="center">N50</th>
              <th align="center">N90</th>
              <th align="center">Scaffolds</th>
              <th align="center">N50</th>
              <th align="center">N90</th>
              <th align="center">Reads</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="center">Uncorrected Corrected</td>
              <td align="center">146.0 M</td>
              <td align="center">-</td>
              <td align="center">12.9 M</td>
              <td align="center">312,414</td>
              <td align="center">2,383</td>
              <td align="center">198</td>
              <td align="center">90,201</td>
              <td align="center">37,138</td>
              <td align="center">9,960</td>
              <td align="center">167.3 M</td>
            </tr>
            <tr>
              <td align="center">SOAPdenovo Corrected</td>
              <td align="center">134.4 M</td>
              <td align="center">15.7 M</td>
              <td align="center">15.6 M</td>
              <td align="center">188,480</td>
              <td align="center">4,051</td>
              <td align="center">515</td>
              <td align="center">36,525</td>
              <td align="center">36,525</td>
              <td align="center">9,162</td>
              <td align="center">164.8 M</td>
            </tr>
            <tr>
              <td align="center">Quake</td>
              <td align="center">146.9 M</td>
              <td align="center">16.5 M</td>
              <td align="center">13.0 M</td>
              <td align="center">189,621</td>
              <td align="center">4,076</td>
              <td align="center">514</td>
              <td align="center">37,279</td>
              <td align="center">37,014</td>
              <td align="center">9,255</td>
              <td align="center">167.3 M</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <p>SOAPdenovo assemblies of <italic>Megachile rotundata </italic>124 bp paired end reads. We trimmed the reads before correcting with SOAPdenovo, which greatly improved its performance on our experiments with simulated data. The 'Trimmed only' column includes reads trimmed before and during SOAPdenovo correction. Quake trims reads automatically during correction. Correcting the reads reduces the number of contigs and scaffolds, increases the contig sizes, and allows the assembler to include more reads. Quake corrects more reads than SOAPdenovo which results in a slightly better assembly.</p>
        </table-wrap-foot>
      </table-wrap>
    </sec>
    <sec>
      <title>SNP detection</title>
      <p>A second application of short reads that benefits from error correction is detection of variations, such as single nucleotide polymorphisms (SNPs). In such experiments, the genome from which the reads are sequenced differs from a reference genome to which the reads are compared. The first step is to align the reads to the reference genome using specialized methods [<xref ref-type="bibr" rid="B8">8</xref>] that will only allow a few mismatches between the read and reference, such as up to two mismatches in a recent study [<xref ref-type="bibr" rid="B38">38</xref>]. A read containing a SNP will start with one mismatch already, and any additional differences from the reference due to sequencing errors will make alignment difficult (see Figure <xref ref-type="fig" rid="F1">1</xref>). Furthermore, the distribution of SNPs in a genome is not uniform and clusters of SNPs tend to appear [<xref ref-type="bibr" rid="B39">39</xref>]. Reads from such regions may contain multiple SNPs. If these reads contain any sequencing errors, they will not align causing the highly polymorphic region to be overlooked.</p>
      <p>To explore the benefit that error correction with Quake may have on SNP detection, we randomly sampled reads representing 35× from the <italic>E. coli </italic>K12 reads used above. To call SNPs, we aligned the reads to a related reference genome (<italic>E. coli 536 </italic>[GenBank: <ext-link ext-link-type="gen" xlink:href="NC_008253">NC_008253</ext-link>]) with Bowtie [<xref ref-type="bibr" rid="B40">40</xref>] using two different modes. We first mapped reads allowing up to two mismatches to resemble the SNP calling pipeline in a recent, large study [<xref ref-type="bibr" rid="B38">38</xref>]. We also mapped reads using Bowtie's default mode, which allows mismatches between the reference and read until the sum of the quality values at those mismatches exceeds 70 [<xref ref-type="bibr" rid="B40">40</xref>]. We called SNPs using the SAMtools pileup program [<xref ref-type="bibr" rid="B41">41</xref>], requiring a Phred-style base call quality ≥40 and a coverage of ≥3 aligned reads. Having a reliable reference genome for both strains of <italic>E. coli </italic>allowed us to compare the SNPs detected using the reads to SNPs detected by performing a whole genome alignment. To call SNPs using the reference genomes, we used the MUMmer utility <italic>dnadiff </italic>which aligns the genomes with MUMmer, identifies the optimal alignment for each region, and enumerates SNPs in aligning regions [<xref ref-type="bibr" rid="B37">37</xref>]. We treat these SNPs as the gold standard (though there may be some false positives in improperly aligned regions) in order to compute recall and precision statistics for the read-based SNP calls.</p>
      <p>In the first experiment, 128 K additional reads of 4.12 M aligned after correcting with Quake, of which 110 K (85.8%) aligned to SNPs, demonstrating the major benefit of error correction before SNP calling. As seen in Table <xref ref-type="table" rid="T5">5</xref> with these reads mapped, we discovered more SNPs and recall increased at the same level of precision. Supporting the hypothesis that many of these newly discovered SNPs would exist in SNP-dense regions, we found that 62% of the new SNPs were within 10 bp of another SNP, compared to 38% for the entire set of SNPs. On the uncorrected reads, Bowtie's quality-aware alignment policy mapped 165 K (4.9%) more reads than a two mismatch policy. Similarly, many of these new alignments contained SNPs, which led to more SNPs discovered, increasing recall with only a slight drop in precision. Using the quality-aware policy, slightly fewer reads mapped to the reference after error correction because some reads that could not be corrected and were removed could still be aligned. However, 33.7 K new read alignments of corrected reads were found, which allowed the discovery of 518 additional SNPs at the same level of precision. Thus, error correction of the reads using Quake leads to the discovery of more true SNPs using two different alignment policies.</p>
      <table-wrap id="T5" position="float">
        <label>Table 5</label>
        <caption>
          <p>E. coli SNP calling</p>
        </caption>
        <table frame="hsides" rules="groups">
          <thead>
            <tr>
              <th align="center">Method</th>
              <th align="center">Reads mapped</th>
              <th align="center">SNPs</th>
              <th align="center">Recall</th>
              <th align="center">Precision</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="center">Two mismatch uncorrected</td>
              <td align="center">3.39 M</td>
              <td align="center">79,748</td>
              <td align="center">0.746</td>
              <td align="center">0.987</td>
            </tr>
            <tr>
              <td align="center">Two mismatch corrected</td>
              <td align="center">3.51 M</td>
              <td align="center">80,796</td>
              <td align="center">0.755</td>
              <td align="center">0.987</td>
            </tr>
            <tr>
              <td align="center">Quality-aware uncorrected</td>
              <td align="center">3.56 M</td>
              <td align="center">85,071</td>
              <td align="center">0.793</td>
              <td align="center">0.984</td>
            </tr>
            <tr>
              <td align="center">Quality-aware corrected</td>
              <td align="center">3.55 M</td>
              <td align="center">85,589</td>
              <td align="center">0.798</td>
              <td align="center">0.984</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <p>We called SNPs in 35× coverage of 36 bp reads from <italic>E. coli </italic>K12 by aligning the reads to a close relative genome <italic>E. coli 536 </italic>with Bowtie using both a two mismatch and quality-aware alignment policy and calling SNPs with SAMtools pileup. SNPs were validated by comparing the <italic>E. coli </italic>K12 and <italic>E. coli 536 </italic>reference genomes directly. Under both alignment policies, correcting the reads with Quake helps find more true SNPs.</p>
        </table-wrap-foot>
      </table-wrap>
      <p>In order to demonstrate the ability of Quake to scale to larger datasets and benefit re-sequencing studies of humans, we corrected 1.7 billion reads from a Korean individual [SRA:SRA008175] [<xref ref-type="bibr" rid="B42">42</xref>]. This set includes 1.2 B 36 bp reads and 504 M 75 bp reads. Quake corrected 206 M (11.9%) of these reads, trimmed an additional 75.3 M (4.4%), and removed 344 M (19.9%). Before and after error correction, we aligned the reads to the human genome (NCBI build 37) and called SNPs with Bowtie allowing two mismatches and SAMtools as described above (though requiring the diploid genotype to have quality ≥40 implicitly requires coverage ≥4). Because some putative SNPs had read coverage indicative of a repeat, we filtered out locations with read coverage greater than three times the median coverage of 19, leaving 3,024,283 SNPs based on the uncorrected reads. After error correction, we found 3,083,481 SNPs, an increase of 2.0%. The mean coverage of these SNPs was 20.1 reads, an increase of 4.8% over the coverage of these locations in the alignments of uncorrected reads, which should provide greater accuracy. Thus, Quake helps detect more SNPs in larger diploid genomes as well.</p>
    </sec>
    <sec>
      <title>Data quality</title>
      <p>Our experiences correcting errors in these datasets allowed us to assess the quality of the sequencing data used in a number of interesting ways. First, as has previously been established, nucleotide-specific error rates in Illumina sequencing reads are not uniform [<xref ref-type="bibr" rid="B26">26</xref>]. For example, adenines were miscalled far more often as cytosine than thymine or guanine in <italic>Megachile rotundata </italic>(see Figure <xref ref-type="fig" rid="F2">2</xref>). As exemplified in the figure, error rates also differ significantly by quality value. While miscalls at adenines were highly likely to be cytosines at low quality, errors were closer to uniform at high quality positions in the read. Finally, error rates varied from lane to lane within a sequencing project. For example, the multinomial samples of nucleotide to nucleotide miscall rates for every pair of six lanes from the <italic>Megachile rotundata </italic>sequencing reads differed with unquestionably significant <italic>P</italic>-values using two sample chi square tests.</p>
      <fig id="F2" position="float">
        <label>Figure 2</label>
        <caption>
          <p><bold>Adenine error rate</bold>. The observed error rate and predicted error rate after nonparametric regression are plotted for adenine by quality value for a single lane of Illumina sequencing of <italic>Megachile rotundata</italic>. The number of training instances at each quality value are drawn as a histogram below the plot. At low and medium quality values, adenine is far more likely to be miscalled as cytosine than thymine or guanine. However, the distribution at high quality is more uniform.</p>
        </caption>
        <graphic xlink:href="gb-2010-11-11-r116-2"/>
      </fig>
      <p>As sequencing becomes more prevalent in biological research, researchers will want to examine and compare the quality of an instance (single lane, machine run, or whole project) of data generation. Error correction with Quake provides two simple measures of data quality in the number of reads corrected and the number of reads removed. Furthermore, Quake allows the user to search for biases in the data like those described above using bundled analysis scripts on the log of all corrections made. Thus, researchers can detect and characterize problems and biases in their data before downstream analyzes are performed.</p>
    </sec>
  </sec>
  <sec>
    <title>Conclusions</title>
    <p>The low cost and high throughput of second-generation sequencing technologies are changing the face of genome research. Despite the many advantages of the new technology, sequencing errors can easily confound analyzes by introducing false polymorphisms and fragmenting genome assemblies. The Quake system detects and corrects sequencing errors by using the redundancy inherent in the sequence data. Our results show that Quake corrects more reads more accurately than previous methods, which in turn leads to more effective downstream analyzes.</p>
    <p>One way Quake improves over prior corrections methods is by <italic>q</italic>-mer counting, which uses the quality values assigned to each base as a means of weighting each <italic>k</italic>-mer. The coverage distributions of error and true <italic>k</italic>-mers cannot be separated perfectly according to their number of appearances due to high coverage errors and low coverage genomic regions. Yet, the choice of a cutoff to determine which <italic>k</italic>-mers will be trusted in the correction stage can have a significant affect on downstream applications like genome assembly.</p>
    <p>Weighting <italic>k</italic>-mer appearances by quality puts more distance between the two distributions because erroneous <italic>k</italic>-mers generally have lower quality than true <italic>k</italic>-mers. Furthermore, with <italic>q</italic>-mers, the cutoff value separating the two distributions no longer needs to be an integer. For example, at low coverage we might use 0.95 as a cutoff, such that <italic>k</italic>-mers that appear once with high quality bases would be trusted, but those with lower quality would not. Such fine-grained cutoff selection is impossible with simple <italic>k</italic>-mer counting.</p>
    <p>Quake includes a sophisticated model of sequencing errors that allows the correction search to examine sets of corrections in order of decreasing likelihood, thus correcting the read more accurately. The model also helps to better identify reads with multiple sets of equally good corrections, which allows the system to avoid mis-correcting and creating a chimeric read. At a minimum, quality values should be included in error correction as a guide to the likely locations of sequencing errors. In each dataset we examined, the rates at which each nucleotide was mis-called to other nucleotides were not uniform and often varied according to quality. Adjusting for these rates provides further improvements in error correction, and distinguishes our method.</p>
    <p>We expect Quake will be useful to researchers interested in a number of downstream applications. Correcting reads with Quake improves genome assembly by producing larger and more accurate contigs and scaffolds using the assemblers Velvet [<xref ref-type="bibr" rid="B20">20</xref>] and SOAPdenovo [<xref ref-type="bibr" rid="B13">13</xref>]. Error correction removes many of the false paths in the assembly graphs caused by errors and helps the assembler to detect overlaps between reads that would have been missed. Eliminating erroneous <italic>k</italic>-mers also significantly reduces the size of the assembly graph, which for large genomes may be the difference between being able to store the graph in a computer's memory or not [<xref ref-type="bibr" rid="B13">13</xref>]. In a re-sequencing application, correcting reads with Quake allows Bowtie [<xref ref-type="bibr" rid="B40">40</xref>] to align many more reads to locations in the reference genome where there is one or more SNPs. Reads containing variants already have differences from the reference genome; correcting additional differences caused by sequencing errors makes these reads easier to align and then available as input for the SNP calling program. Finally, Quake offers a unique perspective into the quality of the data from a sequencing experiment. The proportion of reads corrected, trimmed, and removed are useful statistics with which experiments can be compared and data quality can be monitored. The output log of corrections can be mined for troubling biases.</p>
    <p>On microbial sized genomes, error correction with Quake is fast and unobtrusive for the researcher. On larger datasets, such as a human re-sequencing, it is computationally expensive and requires substantial resources. For the Korean individual reads, we counted <italic>k</italic>-mers on a 20-core computer cluster running Hadoop [<xref ref-type="bibr" rid="B43">43</xref>], which required from two to three days. For error correction, the data structure used to store trusted <italic>k</italic>-mers requires 4<italic><sup>k </sup></italic>bits, which is 32 GB for human if <italic>k </italic>= 19. Thus, the correction stage of Quake is best run on a large shared memory machine, where correction is parallelized across multiple threads using OpenMP [<xref ref-type="bibr" rid="B44">44</xref>]. Running on 16 cores, this took a few days for the Korean individual dataset. Future work will explore alternative ways to perform this step that would require less memory. This way correction could be parallelized across a larger computer cluster and made more accessible to researchers without a large shared memory machine.</p>
    <p><italic>k</italic>-mer based error correction programs are affected significantly by the cutoff separating true and error <italic>k</italic>-mers. Improvements in <italic>k</italic>-mer classification, such as the <italic>q</italic>-mer counting introduced by Quake, improve the accuracy of error correction. Coverage biases in second-generation sequencing technologies, which are largely inexplicable outside of the affect of local GC content, add to the difficulty [<xref ref-type="bibr" rid="B26">26</xref>]. Further characterization of these biases would allow better modeling of <italic>k</italic>-mer coverage and better classification of <italic>k</italic>-mers as true or error. In more repetitive genomes, the probability increases that a <italic>k</italic>-mer that is an artifact of an error actually does occur in the genome. Such <italic>k</italic>-mers are not really misclassified, but may cause Quake to ignore a sequencing error. To improve error correction in these cases, the local context of the <italic>k</italic>-mer in the sequencing reads must be taken into account. Though this was done for Sanger read error correction [<xref ref-type="bibr" rid="B15">15</xref>-<xref ref-type="bibr" rid="B17">17</xref>], it is not currently computationally and algorithmically feasible for high throughput datasets containing many more reads.</p>
    <p>Quake's model for sequencing errors takes into account substantial information about which types of substitution errors are more likely. We considered using Quake to re-estimate the probability of a sequencing error at each quality value before using the quality values for correction. Doing so is difficult because Quake detects many reads that have errors for which it cannot find a valid set of corrections and pinpoint the errors' locations. If Quake re-estimated quality value error probabilities without considering these reads, the error probabilities would be underestimated. Additionally, the benefit of re-estimation is minimal because quality values are mainly used to determine the order in which sets of corrections are considered. Alternatively, passing on more information from the base calling stage, such as the probability that each individual nucleotide is the correct one, would be very helpful. Quake's error model could be made more specific, the need to learn nucleotide specific error rates would be alleviated, and more accurate error correction could be expected.</p>
  </sec>
  <sec sec-type="methods">
    <title>Methods</title>
    <p>Quake detects and corrects errors in sequencing reads by using <italic>k</italic>-mer coverage to differentiate <italic>k</italic>-mers trusted to be in the genome and <italic>k</italic>-mers that are untrustworthy artifacts of sequencing errors. For reads with untrusted <italic>k</italic>-mers, Quake uses the pattern of trusted and untrusted <italic>k</italic>-mers to localize the errors and searches for the set of corrections with maximum likelihood that make all <italic>k</italic>-mers trusted. The likelihood of a set of corrections to a read is defined by a probabilistic model of sequencing errors incorporating the read's quality values as well as the rates at which nucleotides are miscalled as different nucleotides. Correction proceeds by examining changes to the read in order of decreasing likelihood until a set of changes making all <italic>k</italic>-mers trusted is discovered and found to be sufficiently unambiguous.</p>
    <sec>
      <title>Counting <italic>k</italic>-mers</title>
      <p>Counting the number of occurrences of all <italic>k</italic>-mers in the sequencing reads is the first step in the Quake pipeline. <italic>k </italic>must be chosen carefully, but a simple equation suffices to capture the competing goals. Smaller values of <italic>k </italic>provide greater discriminative power for identifying the location of errors in the reads and allow the algorithm to run faster. However, <italic>k </italic>cannot be so small that there is a high probability that one <italic>k</italic>-mer in the genome would be similar to another <italic>k</italic>-mer in the genome after a single nucleotide substitution because these occurrences confound error detection. We recommend setting <italic>k </italic>such that the probability that a randomly selected <italic>k</italic>-mer from the space of <inline-formula><mml:math id="M2" name="gb-2010-11-11-r116-i2" overflow="scroll"><mml:mrow><mml:mfrac><mml:mrow><mml:msup><mml:mn>4</mml:mn><mml:mi>k</mml:mi></mml:msup></mml:mrow><mml:mn>2</mml:mn></mml:mfrac></mml:mrow></mml:math></inline-formula> (for odd <italic>k </italic>considering reverse complements as equivalent) possible <italic>k</italic>-mers occurs in a random sequence of nucleotides the size of the sequenced genome <italic>G </italic>is ~0.01. That, is we want <italic>k </italic>such that</p>
      <p>
        <disp-formula id="bmcM2">
          <label>(2)</label>
          <mml:math id="M3" name="gb-2010-11-11-r116-i3" overflow="scroll">
            <mml:mrow>
              <mml:mfrac>
                <mml:mrow>
                  <mml:mn>2</mml:mn>
                  <mml:mi>G</mml:mi>
                </mml:mrow>
                <mml:mrow>
                  <mml:msup>
                    <mml:mn>4</mml:mn>
                    <mml:mi>k</mml:mi>
                  </mml:msup>
                </mml:mrow>
              </mml:mfrac>
              <mml:mo>≃</mml:mo>
              <mml:mn>0.01</mml:mn>
            </mml:mrow>
          </mml:math>
        </disp-formula>
      </p>
      <p>which simplifies to</p>
      <p>
        <disp-formula id="bmcM3">
          <label>(3)</label>
          <mml:math id="M4" name="gb-2010-11-11-r116-i4" overflow="scroll">
            <mml:mrow>
              <mml:mi>k</mml:mi>
              <mml:mo>≃</mml:mo>
              <mml:msub>
                <mml:mrow>
                  <mml:mi>log</mml:mi>
                </mml:mrow>
                <mml:mn>4</mml:mn>
              </mml:msub>
              <mml:mn>200</mml:mn>
              <mml:mi>G</mml:mi>
            </mml:mrow>
          </mml:math>
        </disp-formula>
      </p>
      <p>For an approximately 5 Mbp such as <italic>E. coli</italic>, we set <italic>k </italic>to 15, and for the approximately 3 Gbp human genome, we set <italic>k </italic>to 19 (rounding down for computational reasons). For the human genome, counting all 19-mers in the reads is not a trivial task, requiring &gt;100 GB of RAM to store the <italic>k</italic>-mers and counts, many of which are artifacts of sequencing errors. Instead of executing this computation on a single large memory machine, we harnessed the power of many small memory machines working in parallel on different batches of reads. We execute the analysis using Hadoop [<xref ref-type="bibr" rid="B43">43</xref>] to monitor the workflow, and also to sum together the partial counts computed on individual machines using an extension of the MapReduce word counting algorithm [<xref ref-type="bibr" rid="B45">45</xref>]. The Hadoop cluster used in these experiments contains 10 nodes, each with a dual core 3.2 gigahertz Intel Xeon processors, 4 GB of RAM, and 367 GB local disk (20 cores, 40 GB RAM, 3.6 TB local disk total).</p>
      <p>In order to better differentiate true <italic>k</italic>-mers and error <italic>k</italic>-mers, we incorporate the quality values into <italic>k</italic>-mer counting. The number of appearances of low coverage true <italic>k</italic>-mers and high copy error <italic>k</italic>-mers may be similar, but we expect the error <italic>k</italic>-mers to have lower quality base calls. Rather than increment a <italic>k</italic>-mer's coverage by one for every occurrence, we increment it by the product of the probabilities that the base calls in the <italic>k</italic>-mer are correct as defined by the quality values. We refer to this process as <italic>q-mer counting</italic>. <italic>q</italic>-mer counts approximate the expected coverage of a <italic>k</italic>-mer over the error distribution specified by the read's quality values. By counting <italic>q</italic>-mers, we are able to better differentiate between true <italic>k</italic>-mers that were sequenced to low coverage and error <italic>k</italic>-mers that occurred multiple times due to bias or repetitive sequence.</p>
    </sec>
    <sec>
      <title>Coverage cutoff</title>
      <p>A histogram of <italic>q</italic>-mer counts shows a mixture of two distributions - the coverage of true <italic>k</italic>-mers, and the coverage of error <italic>k</italic>-mers (see Figure <xref ref-type="fig" rid="F3">3</xref>). Inevitably, these distributions will mix and the cutoff at which true and error <italic>k</italic>-mers are differentiated must be chosen carefully [<xref ref-type="bibr" rid="B46">46</xref>]. By defining these two distributions, we can calculate the ratio of likelihoods that a <italic>k</italic>-mer at a given coverage came from one distribution or the other. Then the cutoff can be set to correspond to a likelihood ratio that suits the application of the sequencing. For instance, mistaking low coverage <italic>k</italic>-mers for errors will remove true sequence, fragmenting a <italic>de novo </italic>genome assembly and potentially creating mis-assemblies at repeats. To avoid this, we can set the cutoff to a point where the ratio of error <italic>k</italic>-mers to true <italic>k</italic>-mers is high, for example 1,000:1.</p>
      <fig id="F3" position="float">
        <label>Figure 3</label>
        <caption>
          <p><bold><italic>k</italic>-mer coverage</bold>. 15-mer coverage model fit to 76× coverage of 36 bp reads from <italic>E. coli</italic>. Note that the expected coverage of a <italic>k</italic>-mer in the genome using reads of length <italic>L </italic>will be <inline-formula><mml:math id="M5" name="gb-2010-11-11-r116-i10" overflow="scroll"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>L</mml:mi><mml:mo>−</mml:mo><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>L</mml:mi></mml:mfrac></mml:mrow></mml:math></inline-formula> times the expected coverage of a single nucleotide because the full <italic>k</italic>-mer must be covered by the read. Above, <italic>q</italic>-mer counts are binned at integers in the histogram. The error <italic>k</italic>-mer distribution rises outside the displayed region to 0.032 at coverage two and 0.691 at coverage one. The mixture parameter for the prior probability that a <italic>k</italic>-mer's coverage is from the error distribution is 0.73. The mean and variance for true <italic>k</italic>-mers are 41 and 77 suggesting that a coverage bias exists as the variance is almost twice the theoretical 41 suggested by the Poisson distribution. The likelihood ratio of error to true <italic>k</italic>-mer is one at a coverage of seven, but we may choose a smaller cutoff for some applications.</p>
        </caption>
        <graphic xlink:href="gb-2010-11-11-r116-3"/>
      </fig>
      <p>In theory, the true <italic>k</italic>-mer coverage distribution should be Poisson, but Illumina sequencing has biases that add variance [<xref ref-type="bibr" rid="B26">26</xref>]. Instead, we model true <italic>k</italic>-mer coverage as Gaussian to allow a free parameter for the variance. <italic>k</italic>-mers that occur multiple times in the genome due to repetitive sequence and duplications also complicate the distribution. We found that <italic>k</italic>-mer copy number in various genomes has a 'heavy tail' (meaning the tail of the distribution is not exponentially bounded) that is approximated well by the Zeta distribution [<xref ref-type="bibr" rid="B47">47</xref>], which has a single shape parameter. Our full model for true <italic>k</italic>-mer coverage is to sample a copy number from a Zeta distribution, and then sample a coverage from a Gaussian distribution with mean and variance proportional to the chosen copy number.</p>
      <p>The error <italic>k</italic>-mer coverage distribution has been previously modeled as Poisson [<xref ref-type="bibr" rid="B10">10</xref>]. In data we examined, this distribution also has a heavy tail, which could plausibly be explained if certain sequence motifs were more prone to errors than others due to sequence composition or other variables of the sequencing process. Additionally, by counting <italic>q</italic>-mers, we have real values rather than the integers that Poisson models. We examined a few options and chose the Gamma distribution with free shape and scale parameters to model error <italic>q</italic>-mer counts.</p>
      <p>Finally, we include a mixture parameter to determine which of the two distributions a <italic>k</italic>-mer coverage will be sampled from. We fit the parameters of this mixture model by maximizing the likelihood function over the <italic>q</italic>-mer counts using the BFGS algorithm, implemented as the <italic>optim </italic>function in the statistical language R [<xref ref-type="bibr" rid="B48">48</xref>]. Figure <xref ref-type="fig" rid="F3">3</xref> shows an example fit to 76× coverage of <italic>E. coli</italic>. Using the optimized model, we compute the likelihood ratio of error <italic>k</italic>-mer to true <italic>k</italic>-mer at various coverages and set the cutoff to correspond to the appropriate ratio.</p>
    </sec>
    <sec>
      <title>Localizing errors</title>
      <p>Once a cutoff to separate trusted and untrusted <italic>k</italic>-mers has been chosen, all reads containing an untrusted <italic>k</italic>-mer become candidates for correction. In most cases the pattern of untrusted <italic>k</italic>-mers will localize the sequencing error to a small region. For example, in Figure <xref ref-type="fig" rid="F4">4a</xref>, a single base substitution causes 15 adjacent untrusted 15-mers. To find the most likely region for the sequencing error(s), we take the intersection of a read's untrusted <italic>k</italic>-mers. This method is robust to a few misclassified error <italic>k</italic>-mers, but not to true <italic>k</italic>-mers with low coverage that are classified as untrusted. Thus, if the intersection of the untrusted <italic>k</italic>-mers is empty (which also occurs when there are multiple nearby errors) or a valid correction cannot be found, we try again localizing to the union of all untrusted <italic>k</italic>-mers.</p>
      <fig id="F4" position="float">
        <label>Figure 4</label>
        <caption>
          <p><bold>Localize errors</bold>. Trusted (green) and untrusted (red) 15-mers are drawn against a 36 bp read. In (a), the intersection of the untrusted <italic>k</italic>-mers localizes the sequencing error to the highlighted column. In (b), the untrusted <italic>k</italic>-mers reach the edge of the read, so we must consider the bases at the edge in addition to the intersection of the untrusted <italic>k</italic>-mers. However, in most cases, we can further localize the error by considering all bases covered by the right-most trusted <italic>k</italic>-mer to be correct and removing them from the error region as shown in (c).</p>
        </caption>
        <graphic xlink:href="gb-2010-11-11-r116-4"/>
      </fig>
      <p>A few more complications are worth noting. If the untrusted <italic>k</italic>-mers reach the edge of the read, there may be more sequencing errors at the edge, so we must extend the region to the edge, as in Figure <xref ref-type="fig" rid="F4">4b</xref>. In this case and in the case of multiple nearby sequencing errors, we may also benefit from considering every base covered by the right-most trusted <italic>k</italic>-mer and left-most trusted <italic>k</italic>-mer to be correct, and trimming the region as in Figure <xref ref-type="fig" rid="F4">4c</xref>. Because this heuristic is sensitive to misclassified <italic>k</italic>-mers, we first try to correct in the region shown in Figure <xref ref-type="fig" rid="F4">4c</xref>, but if no valid set of corrections is found, we try again with the larger region in Figure <xref ref-type="fig" rid="F4">4b</xref>. Finally, in longer reads we often see clusters of untrusted <italic>k</italic>-mers that do not overlap. We perform this localizing procedure and correction on each of these clusters separately. Altogether, these heuristics for localizing the error in a read vastly decrease the runtime of the algorithm compared to considering corrections across the entire read.</p>
    </sec>
    <sec>
      <title>Sequencing error probability model</title>
      <p>After finding a region of the read to focus our correction efforts on, we want to search for the maximum likelihood set of corrections that makes all <italic>k</italic>-mers overlapping the region trusted. First, we must define the likelihood of a set of corrections. Let <italic>O </italic>= <italic>O</italic><sub>1, </sub><italic>O</italic><sub>2</sub>,..., <italic>O<sub>N </sub></italic>represent the observed nucleotides of the read, and <italic>A </italic>= <italic>A</italic><sub>1</sub>, <italic>A</italic><sub>2</sub>,..., <italic>A<sub>N </sub></italic>the actual nucleotides of the sequenced fragment of DNA. Given the observed nucleotides we would like to evaluate the conditional probability of a potential assignment to <italic>A</italic>. Assuming independence of sequencing errors at nucleotide positions in the read and using Bayes theorem, we can write</p>
      <p>
        <disp-formula id="bmcM4">
          <label>(4)</label>
          <mml:math id="M6" name="gb-2010-11-11-r116-i5" overflow="scroll">
            <mml:mrow>
              <mml:mi>P</mml:mi>
              <mml:mo stretchy="false">(</mml:mo>
              <mml:mi>A</mml:mi>
              <mml:mo>=</mml:mo>
              <mml:mi>a</mml:mi>
              <mml:mo stretchy="false">|</mml:mo>
              <mml:mi>O</mml:mi>
              <mml:mo>=</mml:mo>
              <mml:mi>o</mml:mi>
              <mml:mo stretchy="false">)</mml:mo>
              <mml:mo>=</mml:mo>
              <mml:mstyle displaystyle="true">
                <mml:munderover>
                  <mml:mo>∏</mml:mo>
                  <mml:mrow>
                    <mml:mi>i</mml:mi>
                    <mml:mo>=</mml:mo>
                    <mml:mn>1</mml:mn>
                  </mml:mrow>
                  <mml:mi>N</mml:mi>
                </mml:munderover>
                <mml:mrow>
                  <mml:mfrac>
                    <mml:mrow>
                      <mml:mi>P</mml:mi>
                      <mml:mo stretchy="false">(</mml:mo>
                      <mml:msub>
                        <mml:mi>O</mml:mi>
                        <mml:mi>i</mml:mi>
                      </mml:msub>
                      <mml:mo>=</mml:mo>
                      <mml:msub>
                        <mml:mi>o</mml:mi>
                        <mml:mi>i</mml:mi>
                      </mml:msub>
                      <mml:mo stretchy="false">|</mml:mo>
                      <mml:msub>
                        <mml:mi>A</mml:mi>
                        <mml:mi>i</mml:mi>
                      </mml:msub>
                      <mml:mo>=</mml:mo>
                      <mml:msub>
                        <mml:mi>a</mml:mi>
                        <mml:mi>i</mml:mi>
                      </mml:msub>
                      <mml:mo stretchy="false">)</mml:mo>
                      <mml:mi>P</mml:mi>
                      <mml:mo stretchy="false">(</mml:mo>
                      <mml:msub>
                        <mml:mi>A</mml:mi>
                        <mml:mi>i</mml:mi>
                      </mml:msub>
                      <mml:mo>=</mml:mo>
                      <mml:msub>
                        <mml:mi>a</mml:mi>
                        <mml:mi>i</mml:mi>
                      </mml:msub>
                      <mml:mo stretchy="false">)</mml:mo>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi>P</mml:mi>
                      <mml:mo stretchy="false">(</mml:mo>
                      <mml:msub>
                        <mml:mi>O</mml:mi>
                        <mml:mi>i</mml:mi>
                      </mml:msub>
                      <mml:mo>=</mml:mo>
                      <mml:msub>
                        <mml:mi>o</mml:mi>
                        <mml:mi>i</mml:mi>
                      </mml:msub>
                      <mml:mo stretchy="false">)</mml:mo>
                    </mml:mrow>
                  </mml:mfrac>
                </mml:mrow>
              </mml:mstyle>
            </mml:mrow>
          </mml:math>
        </disp-formula>
      </p>
      <p>Because we compare likelihoods for a single observed read <italic>O </italic>at a time, <italic>P</italic>(<italic>O<sub>i </sub></italic>= <italic>o<sub>i</sub></italic>) is the same for all assignments to <italic>A </italic>and is ignored. <italic>P</italic>(<italic>A<sub>i </sub></italic>= <italic>a<sub>i</sub></italic>) is defined by the GC% of the genome, which we estimate by counting Gs and Cs in the sequencing reads. Let <inline-formula><mml:math id="M7" name="gb-2010-11-11-r116-i6" overflow="scroll"><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msup><mml:mrow><mml:mn>10</mml:mn></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mi>q</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:mn>10</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> be the probability that the nucleotide at position <italic>i </italic>is accurate, where <italic>q<sub>i </sub></italic>is the corresponding quality value. Also, let <italic>Eq</italic>(<italic>x</italic>, <italic>y</italic>) be the probability that the base call <italic>y </italic>is made for the nucleotide <italic>x </italic>at quality value <italic>q </italic>given that there has been a sequencing error. Then <italic>P</italic>(<italic>O<sub>i </sub></italic>= <italic>o<sub>i</sub>|A<sub>i </sub></italic>= <italic>a<sub>i</sub></italic>) can be specified as</p>
      <p>
        <disp-formula id="bmcM5">
          <label>(5)</label>
          <mml:math id="M8" name="gb-2010-11-11-r116-i7" overflow="scroll">
            <mml:mrow>
              <mml:mi>P</mml:mi>
              <mml:mo stretchy="false">(</mml:mo>
              <mml:msub>
                <mml:mi>O</mml:mi>
                <mml:mi>i</mml:mi>
              </mml:msub>
              <mml:mo>=</mml:mo>
              <mml:msub>
                <mml:mi>o</mml:mi>
                <mml:mi>i</mml:mi>
              </mml:msub>
              <mml:mo stretchy="false">|</mml:mo>
              <mml:msub>
                <mml:mi>A</mml:mi>
                <mml:mi>i</mml:mi>
              </mml:msub>
              <mml:mo>=</mml:mo>
              <mml:msub>
                <mml:mi>a</mml:mi>
                <mml:mi>i</mml:mi>
              </mml:msub>
              <mml:mo stretchy="false">)</mml:mo>
              <mml:mo>=</mml:mo>
              <mml:mrow>
                <mml:mo>{</mml:mo>
                <mml:mrow>
                  <mml:mtable columnalign="left">
                    <mml:mtr columnalign="left">
                      <mml:mtd columnalign="left">
                        <mml:mrow>
                          <mml:msub>
                            <mml:mi>p</mml:mi>
                            <mml:mi>i</mml:mi>
                          </mml:msub>
                        </mml:mrow>
                      </mml:mtd>
                      <mml:mtd columnalign="left">
                        <mml:mrow>
                          <mml:mtext>if</mml:mtext>
                          <mml:mtext> </mml:mtext>
                          <mml:msub>
                            <mml:mi>o</mml:mi>
                            <mml:mi>i</mml:mi>
                          </mml:msub>
                          <mml:mo>=</mml:mo>
                          <mml:msub>
                            <mml:mi>a</mml:mi>
                            <mml:mi>i</mml:mi>
                          </mml:msub>
                        </mml:mrow>
                      </mml:mtd>
                    </mml:mtr>
                    <mml:mtr columnalign="left">
                      <mml:mtd columnalign="left">
                        <mml:mrow>
                          <mml:mo stretchy="false">(</mml:mo>
                          <mml:mn>1</mml:mn>
                          <mml:mo>−</mml:mo>
                          <mml:msub>
                            <mml:mi>p</mml:mi>
                            <mml:mi>i</mml:mi>
                          </mml:msub>
                          <mml:mo stretchy="false">)</mml:mo>
                          <mml:msub>
                            <mml:mi>E</mml:mi>
                            <mml:mrow>
                              <mml:msub>
                                <mml:mi>q</mml:mi>
                                <mml:mi>i</mml:mi>
                              </mml:msub>
                            </mml:mrow>
                          </mml:msub>
                          <mml:mo stretchy="false">(</mml:mo>
                          <mml:msub>
                            <mml:mi>a</mml:mi>
                            <mml:mi>i</mml:mi>
                          </mml:msub>
                          <mml:mo>,</mml:mo>
                          <mml:msub>
                            <mml:mi>o</mml:mi>
                            <mml:mi>i</mml:mi>
                          </mml:msub>
                          <mml:mo stretchy="false">)</mml:mo>
                        </mml:mrow>
                      </mml:mtd>
                      <mml:mtd columnalign="left">
                        <mml:mrow>
                          <mml:mtext>otherwise</mml:mtext>
                        </mml:mrow>
                      </mml:mtd>
                    </mml:mtr>
                  </mml:mtable>
                </mml:mrow>
              </mml:mrow>
            </mml:mrow>
          </mml:math>
        </disp-formula>
      </p>
      <p>Modeling sequencing errors with <italic>E </italic>allows for biases in base substitution that are known to exist for the Illumina platform. For example, one study found A to C was the most frequent error, likely because A and C are detected by one laser while G and T are detected by another [<xref ref-type="bibr" rid="B26">26</xref>]. Making the substitution distribution conditional upon the quality value allows this substitution bias to vary at different qualities, which was found to occur for Sanger sequencing [<xref ref-type="bibr" rid="B49">49</xref>] and here for Illumina (see Figure <xref ref-type="fig" rid="F2">2</xref>). Although some work has modeled error distributions conditionally on the position of the nucleotide in the read [<xref ref-type="bibr" rid="B50">50</xref>], we assume that quality values capture this sequencing cycle effect. Recent base-calling algorithms incorporate this effect on fluorescence intensity measurements explicitly in some way and generate quality values that satisfy our assumption [<xref ref-type="bibr" rid="B27">27</xref>-<xref ref-type="bibr" rid="B31">31</xref>].</p>
      <p>The error matrices <italic>E </italic>are estimated from the sequencing reads as follows. First we initially set <inline-formula><mml:math id="M9" name="gb-2010-11-11-r116-i8" overflow="scroll"><mml:mrow><mml:msub><mml:mi>E</mml:mi><mml:mi>q</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>y</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mn>3</mml:mn></mml:mfrac><mml:mtext> </mml:mtext><mml:mtext> </mml:mtext><mml:mtext> </mml:mtext><mml:mo>∀</mml:mo><mml:mi>q</mml:mi><mml:mo>,</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>y</mml:mi></mml:mrow></mml:math></inline-formula> and run the algorithm, counting the corrections by quality value and nucleotide to nucleotide type. During this initial pass, we only make simple, unambiguous corrections by abandoning low quality reads more aggressively and using a greater ambiguity threshold (described below). In order to reduce the variance of our estimate of <italic>E</italic>, we perform kernel smoothing across the quality <italic>q </italic>using a Gaussian kernel [<xref ref-type="bibr" rid="B51">51</xref>] with standard deviation two. Let <italic>C<sub>q</sub></italic>(<italic>x</italic>, <italic>y</italic>) be the number of times actual nucleotide <italic>x </italic>was observed as error nucleotide <italic>y </italic>at quality value <italic>q</italic>, <italic>C<sub>q</sub></italic>(<italic>x</italic>) be the number of times actual nucleotide <italic>x </italic>was observed as an error at quality value <italic>q</italic>, and <italic>N</italic>(<italic>q</italic>; <italic>u</italic>, <italic>s</italic>) be the probability of <italic>q </italic>from a Gaussian distribution with mean <italic>u </italic>and standard deviation <italic>s</italic>. Then <italic>E </italic>is defined by</p>
      <p>
        <disp-formula id="bmcM6">
          <label>(6)</label>
          <mml:math id="M10" name="gb-2010-11-11-r116-i9" overflow="scroll">
            <mml:mrow>
              <mml:msub>
                <mml:mi>E</mml:mi>
                <mml:mi>q</mml:mi>
              </mml:msub>
              <mml:mo stretchy="false">(</mml:mo>
              <mml:mi>x</mml:mi>
              <mml:mo>,</mml:mo>
              <mml:mi>y</mml:mi>
              <mml:mo stretchy="false">)</mml:mo>
              <mml:mo>=</mml:mo>
              <mml:mfrac>
                <mml:mrow>
                  <mml:mstyle displaystyle="true">
                    <mml:msub>
                      <mml:mo>∑</mml:mo>
                      <mml:mi>i</mml:mi>
                    </mml:msub>
                    <mml:mrow>
                      <mml:msub>
                        <mml:mi>C</mml:mi>
                        <mml:mrow>
                          <mml:msub>
                            <mml:mi>q</mml:mi>
                            <mml:mi>i</mml:mi>
                          </mml:msub>
                        </mml:mrow>
                      </mml:msub>
                      <mml:mo stretchy="false">(</mml:mo>
                      <mml:mi>x</mml:mi>
                      <mml:mo>,</mml:mo>
                      <mml:mi>y</mml:mi>
                      <mml:mo stretchy="false">)</mml:mo>
                      <mml:mi>N</mml:mi>
                      <mml:mo stretchy="false">(</mml:mo>
                      <mml:msub>
                        <mml:mi>q</mml:mi>
                        <mml:mi>i</mml:mi>
                      </mml:msub>
                      <mml:mo>;</mml:mo>
                      <mml:mi>q</mml:mi>
                      <mml:mo>,</mml:mo>
                      <mml:mn>2</mml:mn>
                      <mml:mo stretchy="false">)</mml:mo>
                    </mml:mrow>
                  </mml:mstyle>
                </mml:mrow>
                <mml:mrow>
                  <mml:mstyle displaystyle="true">
                    <mml:msub>
                      <mml:mo>∑</mml:mo>
                      <mml:mi>i</mml:mi>
                    </mml:msub>
                    <mml:mrow>
                      <mml:msub>
                        <mml:mi>C</mml:mi>
                        <mml:mrow>
                          <mml:msub>
                            <mml:mi>q</mml:mi>
                            <mml:mi>i</mml:mi>
                          </mml:msub>
                        </mml:mrow>
                      </mml:msub>
                      <mml:mo stretchy="false">(</mml:mo>
                      <mml:mi>x</mml:mi>
                      <mml:mo stretchy="false">)</mml:mo>
                      <mml:mi>N</mml:mi>
                      <mml:mo stretchy="false">(</mml:mo>
                      <mml:msub>
                        <mml:mi>q</mml:mi>
                        <mml:mi>i</mml:mi>
                      </mml:msub>
                      <mml:mo>;</mml:mo>
                      <mml:mi>q</mml:mi>
                      <mml:mo>,</mml:mo>
                      <mml:mn>2</mml:mn>
                      <mml:mo stretchy="false">)</mml:mo>
                    </mml:mrow>
                  </mml:mstyle>
                </mml:mrow>
              </mml:mfrac>
            </mml:mrow>
          </mml:math>
        </disp-formula>
      </p>
    </sec>
    <sec>
      <title>Correction search</title>
      <p>Once we can assign a likelihood to a set of corrections and localize the error(s) to a specific region of the read, we must search for the set with maximum likelihood such that all <italic>k</italic>-mers in the corrected read are trusted. We refer to a set of corrections as <italic>valid </italic>if all resulting <italic>k</italic>-mers are trusted. In order to limit the search space, we consider only sets of corrections for which the ratio of the likelihood of the corrected read to the original is above a fixed threshold (default 10<sup>-6</sup>).</p>
      <p>Figure <xref ref-type="fig" rid="F5">5</xref> outlines the algorithm. To consider sets of corrections in order of decreasing likelihood, the algorithm maintains a heap-based priority queue <italic>P </italic>where each element contains a set of corrections <italic>C </italic>and the ratio of their likelihood to the original read's likelihood <italic>L</italic>. In each iteration through the main loop, the algorithm pops the maximum likelihood set of corrections <italic>C </italic>from the queue <italic>P</italic>. If <italic>C </italic>makes all <italic>k</italic>-mers in the region trusted, then it returns <italic>C</italic>. Otherwise, it examines the next lowest quality read position that has not yet been considered, which we track with minor additional bookkeeping. For each nucleotide substitution at this position, we compute a new likelihood and add the updated set of corrections to the priority queue if its likelihood ratio is above the threshold. If the queue empties without finding a valid set of corrections, we abandon the read. This procedure could alternatively be viewed as searching a tree where nodes are corrected reads and branches represent corrections (see Figure <xref ref-type="fig" rid="F6">6</xref>).</p>
      <fig id="F5" position="float">
        <label>Figure 5</label>
        <caption>
          <p><bold>Correction search algorithm</bold>. Pseudocode for the algorithm to search for the most likely set of corrections that makes all k-mers in the read trusted. <italic>P </italic>is a heap-based priority queue that sorts sets of corrections <italic>C </italic>by their likelihood ratio <italic>L</italic>. The algorithm examines sets of corrections in decreasing order of their likelihood until a set is found that converts all <italic>k</italic>-mers in the read to trusted <italic>k</italic>-mers.</p>
        </caption>
        <graphic xlink:href="gb-2010-11-11-r116-5"/>
      </fig>
      <fig id="F6" position="float">
        <label>Figure 6</label>
        <caption>
          <p><bold>Correction search</bold>. The search for the proper set of corrections that change an observed read with errors into the actual sequence from the genome can be viewed as exploring a tree. Nodes in the tree represent possible corrected reads (and implicitly sets of corrections to the observed read). Branches in the tree represent corrections. Each node can be assigned a likelihood by our model for sequencing errors as described in the text. Quake's algorithm visits the nodes in order of decreasing likelihood until a valid read is found or the threshold is passed.</p>
        </caption>
        <graphic xlink:href="gb-2010-11-11-r116-6"/>
      </fig>
      <p>In practice, we make a few adjustments to this procedure. Reads from repeats may have multiple sets of valid corrections separated by a small likelihood difference so that the true correction is ambiguous. Therefore, we actually continue past the point of finding a valid set of corrections to ensure that another valid set does not exist within a certain likelihood threshold (default 0.1). As described, the algorithm will devote a large majority of its computation effort to the lowest quality reads, which have many potential sets of corrections to consider. In order to balance correction sensitivity with speed, we pre-screen the error region and immediately abandon a read if its error region is filled with low quality base calls. More specifically, in our experiments we found that regions containing ≥13 positions with a probability of error &gt;1% were difficult or impossible to correct quickly, and these reads are abandoned without further effort. For regions containing ≥9 such positions, we increase the likelihood ratio threshold to 10<sup>-3 </sup>so that we only consider a limited number of corrections before giving up.</p>
      <p>In order to run Quake on very large datasets (for example, containing billions of reads), we must be able to determine very quickly whether a set of corrections makes all <italic>k</italic>-mers trusted. We accomplish this by mapping all 4<italic><sup>k </sup>k</italic>-mers to an index in a bit array that is set to one if the <italic>k</italic>-mer is trusted and zero otherwise. For 15-mers this bit array uses just 128 MB of space, while it requires 32 GB for 19-mers, which are needed for larger genomes. If memory usage must be reduced, a Bloom filter could be used to hash the trusted <italic>k</italic>-mers in &lt;4 GB at the expense of occasional false positive queries [<xref ref-type="bibr" rid="B12">12</xref>].</p>
    </sec>
  </sec>
  <sec>
    <title>Abbreviations</title>
    <p>bp: base pair; Gbp: gigabases; Mbp: megabases; SNP: single nucleotide polymorphism.</p>
  </sec>
  <sec>
    <title>Competing interests</title>
    <p>The authors declare that they have no competing interests.</p>
  </sec>
  <sec>
    <title>Authors' contributions</title>
    <p>DRK conceived and implemented the method and carried out the experiments. MCS assisted with Hadoop. MCS and SLS provided helpful discussion at all stages. DRK, MCS, and SLS wrote the manuscript.</p>
  </sec>
</body>
<back>
  <sec>
    <title>Acknowledgements</title>
    <p>Thanks to Gene Robinson at the University of Illinois for permission to use preliminary sequence data from <italic>Megachile rotundata</italic>. Thanks to Héctor Corrada Bravo and Darryl Reeves for helpful discussion and feedback.</p>
    <p>This work was supported by NIH grants R01-LM006845 and R01-GM083873.</p>
  </sec>
  <ref-list>
    <ref id="B1">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Shendure</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Ji</surname>
          <given-names>H</given-names>
        </name>
        <article-title>Next-generation DNA sequencing.</article-title>
        <source>Nat Biotechnol</source>
        <year>2008</year>
        <volume>26</volume>
        <fpage>1135</fpage>
        <lpage>1145</lpage>
        <pub-id pub-id-type="doi">10.1038/nbt1486</pub-id>
        <pub-id pub-id-type="pmid">18846087</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B2">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Hawkins</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Hon</surname>
          <given-names>G</given-names>
        </name>
        <name>
          <surname>Ren</surname>
          <given-names>B</given-names>
        </name>
        <article-title>Next-generation genomics: an integrative approach.</article-title>
        <source>Nat Rev Genet</source>
        <year>2010</year>
        <volume>11</volume>
        <fpage>476</fpage>
        <lpage>486</lpage>
        <pub-id pub-id-type="pmid">20531367</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B3">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Siva</surname>
          <given-names>N</given-names>
        </name>
        <article-title>1000 Genomes project.</article-title>
        <source>Nat Biotechnol</source>
        <year>2008</year>
        <volume>26</volume>
        <fpage>256</fpage>
        <pub-id pub-id-type="pmid">18327223</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B4">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Haussler</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>O'Brien</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Ryder</surname>
          <given-names>O</given-names>
        </name>
        <name>
          <surname>Barker</surname>
          <given-names>F</given-names>
        </name>
        <name>
          <surname>Clamp</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Crawford</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Hanner</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Hanotte</surname>
          <given-names>O</given-names>
        </name>
        <name>
          <surname>Johnson</surname>
          <given-names>W</given-names>
        </name>
        <name>
          <surname>McGuire</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Miller</surname>
          <given-names>W</given-names>
        </name>
        <name>
          <surname>Murphy</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Murphy</surname>
          <given-names>W</given-names>
        </name>
        <name>
          <surname>Sheldon</surname>
          <given-names>F</given-names>
        </name>
        <name>
          <surname>Sinervo</surname>
          <given-names>B</given-names>
        </name>
        <name>
          <surname>Venkatesh</surname>
          <given-names>B</given-names>
        </name>
        <name>
          <surname>Wiley</surname>
          <given-names>E</given-names>
        </name>
        <name>
          <surname>Allendorf</surname>
          <given-names>F</given-names>
        </name>
        <name>
          <surname>Amato</surname>
          <given-names>G</given-names>
        </name>
        <name>
          <surname>Baker</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Bauer</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Beja-Pereira</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Bermingham</surname>
          <given-names>E</given-names>
        </name>
        <name>
          <surname>Bernardi</surname>
          <given-names>G</given-names>
        </name>
        <name>
          <surname>Bonvicino</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Brenner</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Burke</surname>
          <given-names>T</given-names>
        </name>
        <name>
          <surname>Cracraft</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Diekhans</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Edwards</surname>
          <given-names>S</given-names>
        </name>
        <etal/>
        <article-title>Genome 10K: a proposal to obtain whole-genome sequence for 10 000 vertebrate species.</article-title>
        <source>J Hered</source>
        <year>2009</year>
        <volume>100</volume>
        <fpage>659</fpage>
        <lpage>674</lpage>
        <pub-id pub-id-type="doi">10.1093/jhered/esp086</pub-id>
        <pub-id pub-id-type="pmid">19892720</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B5">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Mardis</surname>
          <given-names>E</given-names>
        </name>
        <article-title>Cancer genomics identifies determinants of tumor biology.</article-title>
        <source>Genome Biol</source>
        <year>2010</year>
        <volume>11</volume>
        <fpage>211</fpage>
        <pub-id pub-id-type="doi">10.1186/gb-2010-11-5-211</pub-id>
        <pub-id pub-id-type="pmid">20441611</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B6">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Robison</surname>
          <given-names>K</given-names>
        </name>
        <article-title>Application of second-generation sequencing to cancer genomics.</article-title>
        <source>Brief Bioinform</source>
        <year>2010</year>
        <volume>11</volume>
        <fpage>524</fpage>
        <lpage>534</lpage>
        <pub-id pub-id-type="doi">10.1093/bib/bbq013</pub-id>
        <pub-id pub-id-type="pmid">20427421</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B7">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Palmer</surname>
          <given-names>L</given-names>
        </name>
        <name>
          <surname>Dejori</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Bolanos</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Fasulo</surname>
          <given-names>D</given-names>
        </name>
        <article-title>Improving de novo sequence assembly using machine learning and comparative genomics for overlap correction.</article-title>
        <source>BMC Bioinformatics</source>
        <year>2010</year>
        <volume>11</volume>
        <fpage>33</fpage>
        <pub-id pub-id-type="doi">10.1186/1471-2105-11-33</pub-id>
        <pub-id pub-id-type="pmid">20078885</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B8">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Trapnell</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Salzberg</surname>
          <given-names>S</given-names>
        </name>
        <article-title>How to map billions of short reads onto genomes.</article-title>
        <source>Nat Biotechnol</source>
        <year>2009</year>
        <volume>27</volume>
        <fpage>455</fpage>
        <lpage>7</lpage>
        <pub-id pub-id-type="doi">10.1038/nbt0509-455</pub-id>
        <pub-id pub-id-type="pmid">19430453</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B9">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Pevzner</surname>
          <given-names>P</given-names>
        </name>
        <name>
          <surname>Tang</surname>
          <given-names>H</given-names>
        </name>
        <name>
          <surname>Waterman</surname>
          <given-names>M</given-names>
        </name>
        <article-title>An Eulerian path approach to DNA fragment assembly.</article-title>
        <source>Proc Natl Acad Sci USA</source>
        <year>2001</year>
        <volume>98</volume>
        <fpage>9748</fpage>
        <pub-id pub-id-type="doi">10.1073/pnas.171285098</pub-id>
        <pub-id pub-id-type="pmid">11504945</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B10">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Chaisson</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Brinza</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Pevzner</surname>
          <given-names>P</given-names>
        </name>
        <article-title>De novo fragment assembly with short mate-paired reads: does the read length matter?.</article-title>
        <source>Genome Res</source>
        <year>2009</year>
        <volume>19</volume>
        <fpage>336</fpage>
        <pub-id pub-id-type="doi">10.1101/gr.079053.108</pub-id>
        <pub-id pub-id-type="pmid">19056694</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B11">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Butler</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>MacCallum</surname>
          <given-names>I</given-names>
        </name>
        <name>
          <surname>Kleber</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Shlyakhter</surname>
          <given-names>IA</given-names>
        </name>
        <name>
          <surname>Belmonte</surname>
          <given-names>MK</given-names>
        </name>
        <name>
          <surname>Lander</surname>
          <given-names>ES</given-names>
        </name>
        <name>
          <surname>Nusbaum</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Jaffe</surname>
          <given-names>DB</given-names>
        </name>
        <article-title>ALLPATHS: de novo assembly of whole-genome shotgun microreads.</article-title>
        <source>Genome Res</source>
        <year>2008</year>
        <volume>18</volume>
        <fpage>810</fpage>
        <lpage>820</lpage>
        <pub-id pub-id-type="doi">10.1101/gr.7337908</pub-id>
        <pub-id pub-id-type="pmid">18340039</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B12">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Shi</surname>
          <given-names>H</given-names>
        </name>
        <name>
          <surname>Schmidt</surname>
          <given-names>B</given-names>
        </name>
        <name>
          <surname>Liu</surname>
          <given-names>W</given-names>
        </name>
        <name>
          <surname>Muller-Wittig</surname>
          <given-names>W</given-names>
        </name>
        <article-title>A parallel algorithm for error correction in high-throughput short-read data on CUDA-enabled graphics hardware.</article-title>
        <source>J Comput Biol</source>
        <year>2010</year>
        <volume>17</volume>
        <fpage>603</fpage>
        <lpage>615</lpage>
        <pub-id pub-id-type="doi">10.1089/cmb.2009.0062</pub-id>
        <pub-id pub-id-type="pmid">20426693</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B13">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Li</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Zhu</surname>
          <given-names>H</given-names>
        </name>
        <name>
          <surname>Ruan</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Qian</surname>
          <given-names>W</given-names>
        </name>
        <name>
          <surname>Fang</surname>
          <given-names>X</given-names>
        </name>
        <name>
          <surname>Shi</surname>
          <given-names>Z</given-names>
        </name>
        <name>
          <surname>Li</surname>
          <given-names>Y</given-names>
        </name>
        <name>
          <surname>Li</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Shan</surname>
          <given-names>G</given-names>
        </name>
        <name>
          <surname>Kristiansen</surname>
          <given-names>K</given-names>
        </name>
        <name>
          <surname>Li</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Yang</surname>
          <given-names>H</given-names>
        </name>
        <name>
          <surname>Wang</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Wang</surname>
          <given-names>J</given-names>
        </name>
        <article-title>De novo assembly of human genomes with massively parallel short read sequencing.</article-title>
        <source>Genome Res</source>
        <year>2010</year>
        <volume>20</volume>
        <fpage>265</fpage>
        <lpage>272</lpage>
        <pub-id pub-id-type="doi">10.1101/gr.097261.109</pub-id>
        <pub-id pub-id-type="pmid">20019144</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B14">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Yang</surname>
          <given-names>X</given-names>
        </name>
        <name>
          <surname>Dorman</surname>
          <given-names>K</given-names>
        </name>
        <name>
          <surname>Aluru</surname>
          <given-names>S</given-names>
        </name>
        <article-title>Reptile: representative tiling for short read error correction.</article-title>
        <source>Bioinformatics</source>
        <year>2010</year>
        <volume>26</volume>
        <fpage>2526</fpage>
        <lpage>2533</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btq468</pub-id>
        <pub-id pub-id-type="pmid">20834037</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B15">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Gajer</surname>
          <given-names>P</given-names>
        </name>
        <name>
          <surname>Schatz</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Salzberg</surname>
          <given-names>S</given-names>
        </name>
        <article-title>Automated correction of genome sequence errors.</article-title>
        <source>Nucleic Acids Res</source>
        <year>2004</year>
        <volume>32</volume>
        <fpage>562</fpage>
        <pub-id pub-id-type="doi">10.1093/nar/gkh216</pub-id>
        <pub-id pub-id-type="pmid">14744981</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B16">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Batzoglou</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Jaffe</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Stanley</surname>
          <given-names>K</given-names>
        </name>
        <name>
          <surname>Butler</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Gnerre</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Mauceli</surname>
          <given-names>E</given-names>
        </name>
        <name>
          <surname>Berger</surname>
          <given-names>B</given-names>
        </name>
        <name>
          <surname>Mesirov</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Lander</surname>
          <given-names>E</given-names>
        </name>
        <article-title>ARACHNE: a whole-genome shotgun assembler.</article-title>
        <source>Genome Res</source>
        <year>2002</year>
        <volume>12</volume>
        <fpage>177</fpage>
        <pub-id pub-id-type="doi">10.1101/gr.208902</pub-id>
        <pub-id pub-id-type="pmid">11779843</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B17">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Tammi</surname>
          <given-names>MT</given-names>
        </name>
        <name>
          <surname>Arner</surname>
          <given-names>E</given-names>
        </name>
        <name>
          <surname>Kindlund</surname>
          <given-names>E</given-names>
        </name>
        <name>
          <surname>Andersson</surname>
          <given-names>B</given-names>
        </name>
        <article-title>Correcting errors in shotgun sequences.</article-title>
        <source>Nucleic Acids Res</source>
        <year>2003</year>
        <volume>31</volume>
        <fpage>4663</fpage>
        <lpage>4672</lpage>
        <pub-id pub-id-type="doi">10.1093/nar/gkg653;</pub-id>
        <pub-id pub-id-type="pmid">12888528</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B18">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Schroder</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Schroder</surname>
          <given-names>H</given-names>
        </name>
        <name>
          <surname>Puglisi</surname>
          <given-names>SJ</given-names>
        </name>
        <name>
          <surname>Sinha</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Schmidt</surname>
          <given-names>B</given-names>
        </name>
        <article-title>SHREC: a short-read error correction method.</article-title>
        <source>Bioinformatics</source>
        <year>2009</year>
        <volume>25</volume>
        <fpage>2157</fpage>
        <lpage>2163</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btp379</pub-id>
        <pub-id pub-id-type="pmid">19542152</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B19">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Salmela</surname>
          <given-names>L</given-names>
        </name>
        <article-title>Correction of sequencing errors in a mixed set of reads.</article-title>
        <source>Bioinformatics</source>
        <year>2010</year>
        <volume>26</volume>
        <fpage>1284</fpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btq151</pub-id>
        <pub-id pub-id-type="pmid">20378555</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B20">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Zerbino</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Birney</surname>
          <given-names>E</given-names>
        </name>
        <article-title>Velvet: algorithms for de novo short read assembly using de Bruijn graphs.</article-title>
        <source>Genome Res</source>
        <year>2008</year>
        <volume>18</volume>
        <fpage>821</fpage>
        <pub-id pub-id-type="doi">10.1101/gr.074492.107</pub-id>
        <pub-id pub-id-type="pmid">18349386</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B21">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Simpson</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Wong</surname>
          <given-names>K</given-names>
        </name>
        <name>
          <surname>Jackman</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Schein</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Jones</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Birol</surname>
          <given-names>I</given-names>
        </name>
        <article-title>ABySS: a parallel assembler for short read sequence data.</article-title>
        <source>Genome Res</source>
        <year>2009</year>
        <volume>19</volume>
        <fpage>1117</fpage>
        <pub-id pub-id-type="doi">10.1101/gr.089532.108</pub-id>
        <pub-id pub-id-type="pmid">19251739</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B22">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Qu</surname>
          <given-names>W</given-names>
        </name>
        <name>
          <surname>Hashimoto</surname>
          <given-names>Si</given-names>
        </name>
        <name>
          <surname>Morishita</surname>
          <given-names>S</given-names>
        </name>
        <article-title>Efficient frequency-based de novo short-read clustering for error trimming in next-generation sequencing.</article-title>
        <source>Genome Res</source>
        <year>2009</year>
        <volume>19</volume>
        <fpage>1309</fpage>
        <lpage>1315</lpage>
        <pub-id pub-id-type="doi">10.1101/gr.089151.108</pub-id>
        <pub-id pub-id-type="pmid">19439514</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B23">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Wijaya</surname>
          <given-names>E</given-names>
        </name>
        <name>
          <surname>Frith</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Suzuki</surname>
          <given-names>Y</given-names>
        </name>
        <name>
          <surname>Horton</surname>
          <given-names>P</given-names>
        </name>
        <article-title>Recount: expectation maximization based error correction tool for next generation sequencing data.</article-title>
        <source>Genome Inform</source>
        <year>2009</year>
        <volume>23</volume>
        <fpage>189</fpage>
        <lpage>201</lpage>
        <comment>full_text</comment>
        <pub-id pub-id-type="pmid">20180274</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B24">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Zagordi</surname>
          <given-names>O</given-names>
        </name>
        <name>
          <surname>Geyrhofer</surname>
          <given-names>L</given-names>
        </name>
        <name>
          <surname>Roth</surname>
          <given-names>V</given-names>
        </name>
        <name>
          <surname>Beerenwinkel</surname>
          <given-names>N</given-names>
        </name>
        <article-title>Deep sequencing of a genetically heterogeneous sample: local haplotype reconstruction and read error correction.</article-title>
        <source>J Comput Biol</source>
        <year>2010</year>
        <volume>17</volume>
        <fpage>417</fpage>
        <lpage>428</lpage>
        <pub-id pub-id-type="doi">10.1089/cmb.2009.0164</pub-id>
        <pub-id pub-id-type="pmid">20377454</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B25">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Quince</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Lanzen</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Curtis</surname>
          <given-names>T</given-names>
        </name>
        <name>
          <surname>Davenport</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Hall</surname>
          <given-names>N</given-names>
        </name>
        <name>
          <surname>Head</surname>
          <given-names>I</given-names>
        </name>
        <name>
          <surname>Read</surname>
          <given-names>L</given-names>
        </name>
        <name>
          <surname>Sloan</surname>
          <given-names>W</given-names>
        </name>
        <article-title>Accurate determination of microbial diversity from 454 pyrosequencing data.</article-title>
        <source>Nat Methods</source>
        <year>2009</year>
        <volume>6</volume>
        <fpage>639</fpage>
        <lpage>641</lpage>
        <pub-id pub-id-type="doi">10.1038/nmeth.1361</pub-id>
        <pub-id pub-id-type="pmid">19668203</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B26">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Dohm</surname>
          <given-names>JC</given-names>
        </name>
        <name>
          <surname>Lottaz</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Borodina</surname>
          <given-names>T</given-names>
        </name>
        <name>
          <surname>Himmelbauer</surname>
          <given-names>H</given-names>
        </name>
        <article-title>Substantial biases in ultra-short read data sets from high-throughput DNA sequencing.</article-title>
        <source>Nucleic Acids Res</source>
        <year>2008</year>
        <volume>36</volume>
        <fpage>e105+</fpage>
        <pub-id pub-id-type="doi">10.1093/nar/gkn425</pub-id>
        <pub-id pub-id-type="pmid">18660515</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B27">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Bravo</surname>
          <given-names>H</given-names>
        </name>
        <name>
          <surname>Irizarry</surname>
          <given-names>R</given-names>
        </name>
        <article-title>Model-based quality assessment and base-calling for second-generation sequencing data.</article-title>
        <source>Biometrics</source>
        <year>2010</year>
        <volume>66</volume>
        <fpage>665</fpage>
        <lpage>674</lpage>
        <pub-id pub-id-type="doi">10.1111/j.1541-0420.2009.01353.x</pub-id>
        <pub-id pub-id-type="pmid">19912177</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B28">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Kao</surname>
          <given-names>W</given-names>
        </name>
        <name>
          <surname>Stevens</surname>
          <given-names>K</given-names>
        </name>
        <name>
          <surname>Song</surname>
          <given-names>Y</given-names>
        </name>
        <article-title>BayesCall: a model-based base-calling algorithm for high-throughput short-read sequencing.</article-title>
        <source>Genome Res</source>
        <year>2009</year>
        <volume>19</volume>
        <fpage>1884</fpage>
        <pub-id pub-id-type="doi">10.1101/gr.095299.109</pub-id>
        <pub-id pub-id-type="pmid">19661376</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B29">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Erlich</surname>
          <given-names>Y</given-names>
        </name>
        <name>
          <surname>Mitra</surname>
          <given-names>P</given-names>
        </name>
        <name>
          <surname>de la Bastide</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>McCombie</surname>
          <given-names>W</given-names>
        </name>
        <name>
          <surname>Hannon</surname>
          <given-names>G</given-names>
        </name>
        <article-title>Alta-Cyclic: a self-optimizing base caller for next-generation sequencing.</article-title>
        <source>Nat Methods</source>
        <year>2008</year>
        <volume>5</volume>
        <fpage>679</fpage>
        <pub-id pub-id-type="doi">10.1038/nmeth.1230</pub-id>
        <pub-id pub-id-type="pmid">18604217</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B30">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Kircher</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Stenzel</surname>
          <given-names>U</given-names>
        </name>
        <name>
          <surname>Kelso</surname>
          <given-names>J</given-names>
        </name>
        <article-title>Improved base calling for the Illumina Genome Analyzer using machine learning strategies.</article-title>
        <source>Genome Biol</source>
        <year>2009</year>
        <volume>10</volume>
        <fpage>R83</fpage>
        <pub-id pub-id-type="doi">10.1186/gb-2009-10-8-r83</pub-id>
        <pub-id pub-id-type="pmid">19682367</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B31">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Rougemont</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Amzallag</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Iseli</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Farinelli</surname>
          <given-names>L</given-names>
        </name>
        <name>
          <surname>Xenarios</surname>
          <given-names>I</given-names>
        </name>
        <name>
          <surname>Naef</surname>
          <given-names>F</given-names>
        </name>
        <article-title>Probabilistic base calling of Solexa sequencing data.</article-title>
        <source>BMC Bioinformatics</source>
        <year>2008</year>
        <volume>9</volume>
        <fpage>431</fpage>
        <pub-id pub-id-type="doi">10.1186/1471-2105-9-431</pub-id>
        <pub-id pub-id-type="pmid">18851737</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B32">
      <mixed-citation publication-type="other">
        <article-title>Quake.</article-title>
        <ext-link ext-link-type="uri" xlink:href="http://www.cbcb.umd.edu/software/quake">http://www.cbcb.umd.edu/software/quake</ext-link>
      </mixed-citation>
    </ref>
    <ref id="B33">
      <mixed-citation publication-type="other">
        <article-title>Perl Artistic License.</article-title>
        <ext-link ext-link-type="uri" xlink:href="http://www.perl.com/pub/a/language/misc/Artistic.html">http://www.perl.com/pub/a/language/misc/Artistic.html</ext-link>
      </mixed-citation>
    </ref>
    <ref id="B34">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Li</surname>
          <given-names>H</given-names>
        </name>
        <name>
          <surname>Ruan</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Durbin</surname>
          <given-names>R</given-names>
        </name>
        <article-title>Mapping short DNA sequencing reads and calling variants using mapping quality scores.</article-title>
        <source>Genome Res</source>
        <year>2008</year>
        <volume>18</volume>
        <fpage>1851</fpage>
        <pub-id pub-id-type="doi">10.1101/gr.078212.108</pub-id>
        <pub-id pub-id-type="pmid">18714091</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B35">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Cordaux</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Batzer</surname>
          <given-names>M</given-names>
        </name>
        <article-title>The impact of retrotransposons on human genome evolution.</article-title>
        <source>Nat Rev Genet</source>
        <year>2009</year>
        <volume>10</volume>
        <fpage>691</fpage>
        <lpage>703</lpage>
        <pub-id pub-id-type="doi">10.1038/nrg2640</pub-id>
        <pub-id pub-id-type="pmid">19763152</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B36">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Myers</surname>
          <given-names>E</given-names>
        </name>
        <article-title>Toward simplifying and accurately formulating fragment assembly.</article-title>
        <source>J Comput Biol</source>
        <year>1995</year>
        <volume>2</volume>
        <fpage>275</fpage>
        <lpage>290</lpage>
        <pub-id pub-id-type="doi">10.1089/cmb.1995.2.275</pub-id>
        <pub-id pub-id-type="pmid">7497129</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B37">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Kurtz</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Phillippy</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Delcher</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Smoot</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Shumway</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Antonescu</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Salzberg</surname>
          <given-names>S</given-names>
        </name>
        <article-title>Versatile and open software for comparing large genomes.</article-title>
        <source>Genome Biol</source>
        <year>2004</year>
        <volume>5</volume>
        <fpage>R12</fpage>
        <pub-id pub-id-type="doi">10.1186/gb-2004-5-2-r12</pub-id>
        <pub-id pub-id-type="pmid">14759262</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B38">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Pleasance</surname>
          <given-names>ED</given-names>
        </name>
        <name>
          <surname>Cheetham</surname>
          <given-names>RK</given-names>
        </name>
        <name>
          <surname>Stephens</surname>
          <given-names>PJ</given-names>
        </name>
        <name>
          <surname>McBride</surname>
          <given-names>DJ</given-names>
        </name>
        <name>
          <surname>Humphray</surname>
          <given-names>SJ</given-names>
        </name>
        <name>
          <surname>Greenman</surname>
          <given-names>CD</given-names>
        </name>
        <name>
          <surname>Varela</surname>
          <given-names>I</given-names>
        </name>
        <name>
          <surname>Lin</surname>
          <given-names>MLL</given-names>
        </name>
        <name>
          <surname>Ordonez</surname>
          <given-names>GR</given-names>
        </name>
        <name>
          <surname>Bignell</surname>
          <given-names>GR</given-names>
        </name>
        <name>
          <surname>Ye</surname>
          <given-names>K</given-names>
        </name>
        <name>
          <surname>Alipaz</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Bauer</surname>
          <given-names>MJ</given-names>
        </name>
        <name>
          <surname>Beare</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Butler</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Carter</surname>
          <given-names>RJ</given-names>
        </name>
        <name>
          <surname>Chen</surname>
          <given-names>L</given-names>
        </name>
        <name>
          <surname>Cox</surname>
          <given-names>AJ</given-names>
        </name>
        <name>
          <surname>Edkins</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Kokko-Gonzales</surname>
          <given-names>PI</given-names>
        </name>
        <name>
          <surname>Gormley</surname>
          <given-names>NA</given-names>
        </name>
        <name>
          <surname>Grocock</surname>
          <given-names>RJ</given-names>
        </name>
        <name>
          <surname>Haudenschild</surname>
          <given-names>CD</given-names>
        </name>
        <name>
          <surname>Hims</surname>
          <given-names>MM</given-names>
        </name>
        <name>
          <surname>James</surname>
          <given-names>T</given-names>
        </name>
        <name>
          <surname>Jia</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Kingsbury</surname>
          <given-names>Z</given-names>
        </name>
        <name>
          <surname>Leroy</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Marshall</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Menzies</surname>
          <given-names>A</given-names>
        </name>
        <etal/>
        <article-title>A comprehensive catalogue of somatic mutations from a human cancer genome.</article-title>
        <source>Nature</source>
        <year>2010</year>
        <volume>463</volume>
        <fpage>191</fpage>
        <lpage>196</lpage>
        <pub-id pub-id-type="doi">10.1038/nature08658</pub-id>
        <pub-id pub-id-type="pmid">20016485</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B39">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Kendal</surname>
          <given-names>W</given-names>
        </name>
        <article-title>An exponential dispersion model for the distribution of human single nucleotide polymorphisms.</article-title>
        <source>Mol Biol Evol</source>
        <year>2003</year>
        <volume>20</volume>
        <fpage>579</fpage>
        <pub-id pub-id-type="doi">10.1093/molbev/msg057</pub-id>
        <pub-id pub-id-type="pmid">12679541</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B40">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Langmead</surname>
          <given-names>B</given-names>
        </name>
        <name>
          <surname>Trapnell</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Pop</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Salzberg</surname>
          <given-names>S</given-names>
        </name>
        <article-title>Ultrafast and memory-efficient alignment of short DNA sequences to the human genome.</article-title>
        <source>Genome Biol</source>
        <year>2009</year>
        <volume>10</volume>
        <fpage>R25</fpage>
        <pub-id pub-id-type="doi">10.1186/gb-2009-10-3-r25</pub-id>
        <pub-id pub-id-type="pmid">19261174</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B41">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Li</surname>
          <given-names>H</given-names>
        </name>
        <name>
          <surname>Handsaker</surname>
          <given-names>B</given-names>
        </name>
        <name>
          <surname>Wysoker</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Fennell</surname>
          <given-names>T</given-names>
        </name>
        <name>
          <surname>Ruan</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Homer</surname>
          <given-names>N</given-names>
        </name>
        <name>
          <surname>Marth</surname>
          <given-names>G</given-names>
        </name>
        <name>
          <surname>Abecasis</surname>
          <given-names>G</given-names>
        </name>
        <name>
          <surname>Durbin</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Subgroup</surname>
          <given-names>GPDP</given-names>
        </name>
        <article-title>The sequence alignment/Map format and SAMtools.</article-title>
        <source>Bioinformatics</source>
        <year>2009</year>
        <volume>25</volume>
        <fpage>2078</fpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btp352</pub-id>
        <pub-id pub-id-type="pmid">19505943</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B42">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Ahn</surname>
          <given-names>SM</given-names>
        </name>
        <name>
          <surname>Kim</surname>
          <given-names>TH</given-names>
        </name>
        <name>
          <surname>Lee</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Kim</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Ghang</surname>
          <given-names>H</given-names>
        </name>
        <name>
          <surname>Kim</surname>
          <given-names>DS</given-names>
        </name>
        <name>
          <surname>Kim</surname>
          <given-names>BC</given-names>
        </name>
        <name>
          <surname>Kim</surname>
          <given-names>SY</given-names>
        </name>
        <name>
          <surname>Kim</surname>
          <given-names>WY</given-names>
        </name>
        <name>
          <surname>Kim</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Park</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Lee</surname>
          <given-names>YS</given-names>
        </name>
        <name>
          <surname>Kim</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Reja</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Jho</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Kim</surname>
          <given-names>CG</given-names>
        </name>
        <name>
          <surname>Cha</surname>
          <given-names>JY</given-names>
        </name>
        <name>
          <surname>Kim</surname>
          <given-names>KH</given-names>
        </name>
        <name>
          <surname>Lee</surname>
          <given-names>B</given-names>
        </name>
        <name>
          <surname>Bhak</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Kim</surname>
          <given-names>SJ</given-names>
        </name>
        <article-title>The first Korean genome sequence and analysis: full genome sequencing for a socio-ethnic group.</article-title>
        <source>Genome Res</source>
        <year>2009</year>
        <volume>19</volume>
        <fpage>1622</fpage>
        <lpage>1629</lpage>
        <pub-id pub-id-type="doi">10.1101/gr.092197.109</pub-id>
        <pub-id pub-id-type="pmid">19470904</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B43">
      <mixed-citation publication-type="other">
        <article-title>Hadoop.</article-title>
        <ext-link ext-link-type="uri" xlink:href="http://hadoop.apache.org">http://hadoop.apache.org</ext-link>
      </mixed-citation>
    </ref>
    <ref id="B44">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Dagum</surname>
          <given-names>L</given-names>
        </name>
        <name>
          <surname>Menon</surname>
          <given-names>R</given-names>
        </name>
        <article-title>Open MP: an industry-standard API for shared-memory programming.</article-title>
        <source>IEEE Comput Sci Eng</source>
        <year>1998</year>
        <volume>5</volume>
        <fpage>46</fpage>
        <lpage>55</lpage>
        <pub-id pub-id-type="doi">10.1109/99.660313</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B45">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Dean</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Ghemawat</surname>
          <given-names>S</given-names>
        </name>
        <article-title>MapReduce: simplified data processing on large clusters.</article-title>
        <source>Commun ACM</source>
        <year>2008</year>
        <volume>51</volume>
        <fpage>107</fpage>
        <lpage>113</lpage>
        <pub-id pub-id-type="doi">10.1145/1327452.1327492</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B46">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Chin</surname>
          <given-names>F</given-names>
        </name>
        <name>
          <surname>Leung</surname>
          <given-names>H</given-names>
        </name>
        <name>
          <surname>Li</surname>
          <given-names>W</given-names>
        </name>
        <name>
          <surname>Yiu</surname>
          <given-names>S</given-names>
        </name>
        <article-title>Finding optimal threshold for correction error reads in DNA assembling.</article-title>
        <source>BMC Bioinformatics</source>
        <year>2009</year>
        <volume>10 Suppl 1</volume>
        <fpage>S15</fpage>
        <pub-id pub-id-type="doi">10.1186/1471-2105-10-S1-S15</pub-id>
        <pub-id pub-id-type="pmid">19208114</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B47">
      <mixed-citation publication-type="book">
        <name>
          <surname>Johnson</surname>
          <given-names>N</given-names>
        </name>
        <name>
          <surname>Kemp</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Kotz</surname>
          <given-names>S</given-names>
        </name>
        <source>Univariate Discrete Distributions</source>
        <year>2005</year>
        <publisher-name>New York: Wiley-Interscience</publisher-name>
      </mixed-citation>
    </ref>
    <ref id="B48">
      <mixed-citation publication-type="other">
        <article-title>R: A Language and Environment for Statistical Computing.</article-title>
        <ext-link ext-link-type="uri" xlink:href="http://www.R-project.org">http://www.R-project.org</ext-link>
      </mixed-citation>
    </ref>
    <ref id="B49">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Li</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Nordborg</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Li</surname>
          <given-names>LM</given-names>
        </name>
        <article-title>Adjust quality scores from alignment and improve sequencing accuracy.</article-title>
        <source>Nucleic Acids Res</source>
        <year>2004</year>
        <volume>32</volume>
        <fpage>5183</fpage>
        <lpage>5191</lpage>
        <pub-id pub-id-type="doi">10.1093/nar/gkh850</pub-id>
        <pub-id pub-id-type="pmid">15459287</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B50">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Li</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Li</surname>
          <given-names>Y</given-names>
        </name>
        <name>
          <surname>Fang</surname>
          <given-names>X</given-names>
        </name>
        <name>
          <surname>Yang</surname>
          <given-names>H</given-names>
        </name>
        <name>
          <surname>Wang</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Kristiansen</surname>
          <given-names>K</given-names>
        </name>
        <name>
          <surname>Wang</surname>
          <given-names>J</given-names>
        </name>
        <article-title>SNP detection for massively parallel whole-genome resequencing.</article-title>
        <source>Genome Res</source>
        <year>2009</year>
        <volume>19</volume>
        <fpage>1124</fpage>
        <pub-id pub-id-type="doi">10.1101/gr.088013.108</pub-id>
        <pub-id pub-id-type="pmid">19420381</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B51">
      <mixed-citation publication-type="book">
        <name>
          <surname>Hastie</surname>
          <given-names>T</given-names>
        </name>
        <name>
          <surname>Tibshirani</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Friedman</surname>
          <given-names>J</given-names>
        </name>
        <source>The Elements of Statistical Learning</source>
        <year>2009</year>
        <publisher-name>Berlin: Springer</publisher-name>
      </mixed-citation>
    </ref>
  </ref-list>
</back>
