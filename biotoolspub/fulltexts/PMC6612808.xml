<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.1 20151215//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 1.1?>
<?ConverterInfo.XSLTName jp2nlmx2.xsl?>
<?ConverterInfo.Version 1?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">6612808</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/btz322</article-id>
    <article-id pub-id-type="publisher-id">btz322</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Ismb/Eccb 2019 Conference Proceedings</subject>
        <subj-group subj-group-type="category-toc-heading">
          <subject>General Computational Biology</subject>
        </subj-group>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>GkmExplain: fast and accurate interpretation of nonlinear gapped <italic>k</italic>-mer SVMs</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Shrikumar</surname>
          <given-names>Avanti</given-names>
        </name>
        <xref ref-type="aff" rid="btz322-aff1">1</xref>
        <xref ref-type="corresp" rid="btz322-cor1"/>
        <xref ref-type="author-notes" rid="btz322-FM2"/>
        <!--<email>avanti@stanford.edu</email>-->
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Prakash</surname>
          <given-names>Eva</given-names>
        </name>
        <xref ref-type="aff" rid="btz322-aff2">2</xref>
        <xref ref-type="author-notes" rid="btz322-FM2"/>
      </contrib>
      <contrib contrib-type="author">
        <contrib-id contrib-id-type="orcid" authenticated="false">http://orcid.org/0000-0003-3084-2287</contrib-id>
        <name>
          <surname>Kundaje</surname>
          <given-names>Anshul</given-names>
        </name>
        <xref ref-type="aff" rid="btz322-aff1">1</xref>
        <xref ref-type="aff" rid="btz322-aff3">3</xref>
        <xref ref-type="corresp" rid="btz322-cor1"/>
        <!--<email>akundaje@stanford.edu</email>-->
      </contrib>
    </contrib-group>
    <aff id="btz322-aff1"><label>1</label>Department of Computer Science, Stanford University, Stanford, CA, USA</aff>
    <aff id="btz322-aff2"><label>2</label>Computer Science, BASIS Independent Silicon Valley, San Jose, CA, USA</aff>
    <aff id="btz322-aff3"><label>3</label>Department of Genetics, Stanford University, Stanford, CA, USA</aff>
    <author-notes>
      <corresp id="btz322-cor1">To whom correspondence should be addressed. <email>avanti@stanford.edu</email> or <email>akundaje@stanford.edu</email></corresp>
      <fn id="btz322-FM2">
        <p>The authors wish it to be known that, in their opinion, the first two authors should be regarded as Joint First Authors.</p>
      </fn>
    </author-notes>
    <pub-date pub-type="ppub">
      <month>7</month>
      <year>2019</year>
    </pub-date>
    <pub-date pub-type="epub" iso-8601-date="2019-07-05">
      <day>05</day>
      <month>7</month>
      <year>2019</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>05</day>
      <month>7</month>
      <year>2019</year>
    </pub-date>
    <!-- PMC Release delay is 0 months and 0 days and was based on the <pub-date pub-type="epub"/>. -->
    <volume>35</volume>
    <issue>14</issue>
    <fpage>i173</fpage>
    <lpage>i182</lpage>
    <permissions>
      <copyright-statement>© The Author(s) 2019. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2019</copyright-year>
      <license license-type="cc-by-nc" xlink:href="http://creativecommons.org/licenses/by-nc/4.0/">
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution Non-Commercial License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by-nc/4.0/">http://creativecommons.org/licenses/by-nc/4.0/</ext-link>), which permits non-commercial re-use, distribution, and reproduction in any medium, provided the original work is properly cited. For commercial re-use, please contact journals.permissions@oup.com</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="btz322.pdf"/>
    <abstract>
      <title>Abstract</title>
      <sec id="s1">
        <title>Summary</title>
        <p> Support Vector Machines with gapped <italic>k</italic>-mer kernels (gkm-SVMs) have been used to learn predictive models of regulatory DNA sequence. However, interpreting predictive sequence patterns learned by gkm-SVMs can be challenging. Existing interpretation methods such as deltaSVM, in-silico mutagenesis (ISM) or SHAP either do not scale well or make limiting assumptions about the model that can produce misleading results when the gkm kernel is combined with nonlinear kernels. Here, we propose GkmExplain: a computationally efficient feature attribution method for interpreting predictive sequence patterns from gkm-SVM models that has theoretical connections to the method of Integrated Gradients. Using simulated regulatory DNA sequences, we show that GkmExplain identifies predictive patterns with high accuracy while avoiding pitfalls of deltaSVM and ISM and being orders of magnitude more computationally efficient than SHAP. By applying GkmExplain and a recently developed motif discovery method called TF-MoDISco to gkm-SVM models trained on <italic>in vivo</italic> transcription factor (TF) binding data, we recover consolidated, non-redundant TF motifs. Mutation impact scores derived using GkmExplain consistently outperform deltaSVM and ISM at identifying regulatory genetic variants from gkm-SVM models of chromatin accessibility in lymphoblastoid cell-lines.</p>
      </sec>
      <sec id="s2">
        <title>Availability and implementation</title>
        <p> Code and example notebooks to reproduce results are at <ext-link ext-link-type="uri" xlink:href="https://github.com/kundajelab/gkmexplain">https://github.com/kundajelab/gkmexplain</ext-link>.</p>
      </sec>
      <sec id="s3">
        <title>Supplementary information</title>
        <p><xref ref-type="supplementary-material" rid="sup1">Supplementary data</xref> are available at <italic>Bioinformatics</italic> online.</p>
      </sec>
    </abstract>
    <funding-group>
      <award-group award-type="grant">
        <funding-source>
          <named-content content-type="funder-name">National Institute of Health</named-content>
        </funding-source>
        <award-id>1DP2GM123485</award-id>
        <award-id>1U01HG009431</award-id>
        <award-id>1R01HG00967401</award-id>
      </award-group>
    </funding-group>
    <counts>
      <page-count count="10"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec>
    <title>1 Introduction</title>
    <p>Deciphering the combinatorial regulatory DNA sequence patterns that determine transcription factor (TF) binding and chromatin state is critical to understand gene regulation and interpret the molecular impact of regulatory genetic variation. High-throughput <italic>in vivo</italic> and <italic>in vitro</italic> functional genomics experiments provide large datasets to train predictive models using machine learning approaches that can learn the relationship between regulatory DNA sequences and their associated molecular phenotypes. A Support Vector Machine (SVM) is a popular type of supervised classification model that learns an optimal linear separating hyperplane in a high-dimensional feature space. SVMs rely on a function called a kernel that measures the similarity between all pairs of datapoints in the high-dimensional feature space. SVMs are appealing because they are stable to train and, when used with an appropriate kernel, can model complex input-output relationships. The gapped <italic>k</italic>-mer (gkm) string kernel (<xref rid="btz322-B5" ref-type="bibr">Ghandi <italic>et al.</italic>, 2014</xref>; <xref rid="btz322-B10" ref-type="bibr">Leslie and Kuang, 2004</xref>) was developed to enable training SVMs on string inputs such as DNA or protein sequences. The gkm kernel computes a similarity between pairs of sequences based on the biologically motivated notion of shared approximate occurrences of short subsequences allowing for gaps and mismatches. The gkm kernel can be further combined with other nonlinear kernels such as the radial basis function (RBF) kernel to capture complex nonlinear relationships between the input string features. Gapped <italic>k</italic>-mer SVMs and their extensions have been successfully applied to several prediction tasks in regulatory genomics such as TF binding and chromatin accessibility prediction (<xref rid="btz322-B5" ref-type="bibr">Ghandi <italic>et al.</italic>, 2014</xref>; <xref rid="btz322-B8" ref-type="bibr">Lee, 2016</xref>; <xref rid="btz322-B9" ref-type="bibr">Lee <italic>et al.</italic>, 2015</xref>). Interpretation of these trained SVMs is important to decipher the patterns such as TF binding motifs present in input DNA sequences that are predictive of their associated molecular labels. Moreover, these models can be used to predict the impacts of genetic variants in regulatory DNA sequences (<xref rid="btz322-B9" ref-type="bibr">Lee <italic>et al.</italic>, 2015</xref>). Unfortunately, interpretation of gkm-SVMs can be challenging. DeltaSVM (<xref rid="btz322-B9" ref-type="bibr">Lee <italic>et al.</italic>, 2015</xref>), a popular tool that estimates the effects of variants using a trained gkm-SVM, does not give improvements in variant scoring when applied to SVMs trained with nonlinear versions of the gkm kernel, even though these nonlinear kernels perform better at regulatory sequence classification (suggesting that deltaSVM is not fully leveraging the advantages of the nonlinear kernel) (<xref rid="btz322-B8" ref-type="bibr">Lee, 2016</xref>). In-silico mutagenesis (ISM) (<xref rid="btz322-B2" ref-type="bibr">Bromberg and Rost, 2008</xref>), an interpretation approach that involves measuring the impact of exhaustive perturbations of every nucleotide in an input sequence on the output label, can be computationally inefficient and can fail to reveal the presence of motifs when nonlinear saturation effects are present (<xref rid="btz322-B12" ref-type="bibr">Shrikumar <italic>et al.</italic>, 2017</xref>). SHAP (<xref rid="btz322-B11" ref-type="bibr">Lundberg and Lee, 2017</xref>), a method based on estimating Shapely values, can address the nonlinearity issues faced by deltaSVM and ISM but is even less computationally efficient than ISM. As such, there is a need for fast interpretation of gapped <italic>k</italic>-mer Support Vector Machines that works reliably in the presence of nonlinear effects.</p>
  </sec>
  <sec>
    <title>2 Our contributions</title>
    <p>Here we present GkmExplain, a computationally efficient method for explaining the predictions of both linear and nonlinear versions of gapped <italic>k</italic>-mer SVMs. Specifically, GkmExplain is a feature attribution method that efficiently computes the predictive contribution or importance of every nucleotide in an input DNA sequence to its associated output label through the lens of a gkm-SVM model. GkmExplain works by decomposing the output of the gapped <italic>k</italic>-mer string kernel into the contributions of matching positions within the <italic>k</italic>-mers. It has theoretical connections to Integrated Gradients, a feature attribution method originally developed to interpret deep learning models (<xref rid="btz322-B14" ref-type="bibr">Sundararajan <italic>et al.</italic>, 2017</xref>). On simulated regulatory DNA sequences, where the ground truth predictive motifs are known, we find that GkmExplain substantially outperforms deltaSVM and ISM at identifying predictive motifs and also outperforms SHAP while being multiple orders of magnitude more computationally efficient. We further show that by supplying GkmExplain contribution score profiles to the recently-developed importance score clustering and aggregation tool TF-MoDISco (<xref rid="btz322-B13" ref-type="bibr">Shrikumar <italic>et al.</italic>, 2018</xref>), we can recover motifs of TFs from gkm-SVM models trained on <italic>in vivo</italic> TF binding data. The resulting motifs are more consolidated, less redundant and better matches to known canonical TF motifs when compared to those produced by the method of <xref rid="btz322-B5" ref-type="bibr">Ghandi <italic>et al.</italic> (2014)</xref> as well as those produced by the traditional motif discovery approaches MEME and HOMER. Finally, using non-linear gkmSVM models trained to identify regulatory DNA sequences associated with accessible chromatin, we show that mutation impact scores derived through GkmExplain outperform deltaSVM and ISM at identifying DNase-I hypersensitive quantitative trait loci (dsQTLs) in lymphoblastoid cell-lines (LCLs).</p>
  </sec>
  <sec>
    <title>3 Background</title>
    <sec>
      <title>3.1 Gapped <italic>k</italic>-mers</title>
      <p>A full <italic>k</italic>-mer refers to a letter subsequence of length <italic>k</italic>—for example, AAGT is a full 4-mer. By contrast, a gapped <italic>k</italic>-mer refers to a subsequence containing <italic>k</italic> letters and some number of gaps—for example, A*AG*T is a gapped 4-mer containing 2 gaps (* is used to denote a gap). In the gkm-SVM implementation, the parameter <italic>l</italic> denotes the full length of the subsequences considered (including gaps), while <italic>k</italic> denotes the number of non-gap positions—for example, the <italic>l</italic>-mer ACG (where <italic>l </italic>=<italic> </italic>3) contains the gapped <italic>k</italic>-mers AC*, A*G and *CG (where <italic>k </italic>=<italic> </italic>2). The parameter <italic>l</italic> is also called the ‘word length’. The number of possible gapped <italic>k</italic>-mers can be calculated using the formula <inline-formula id="IE1"><mml:math id="IM1"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mtable><mml:mtr><mml:mtd><mml:mi>l</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mi>k</mml:mi></mml:mtd></mml:mtr></mml:mtable><mml:mo>)</mml:mo></mml:mrow><mml:msup><mml:mrow><mml:mn>4</mml:mn></mml:mrow><mml:mi>k</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula>. A higher value of <italic>l</italic> allows the gkm-SVM to learn wider patterns, while a higher value of the number of gaps (<italic>l</italic> – <italic>k</italic>) increases the flexibility of the learned patterns.</p>
    </sec>
    <sec>
      <title>3.2 Support vector machines and gapped <italic>k</italic>-mer kernels</title>
      <p>Let <bold>x</bold> be an input to a Support Vector Machine (SVM), <italic>m</italic> be the total number of support vectors, <italic>Z<sup>i</sup></italic> be the <italic>i</italic>th support vector, <italic>y<sup>i</sup></italic> be the label (+1 or -1) associated with the <italic>i</italic>th support vector, <italic>α<sub>i</sub></italic> be the weight associated with the <italic>i</italic>th support vector, <italic>b</italic> be a constant bias term and <italic>K</italic> be a <italic>kernel function</italic> that is used to compute a similarity score between <italic>Z<sup>i</sup></italic> and <bold>x</bold>. SVMs produce an output of the form:
<disp-formula id="E1"><label>(1)</label><mml:math id="M1"><mml:mrow><mml:mi>F</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>b</mml:mi><mml:mo>+</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>m</mml:mi></mml:munderover><mml:mrow><mml:msub><mml:mrow><mml:mo>α</mml:mo></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:msup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msup><mml:mi>K</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>Z</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msup><mml:mo>,</mml:mo><mml:mi mathvariant="bold">x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></disp-formula></p>
      <p>Kernel functions can be thought of as implicitly mapping their inputs to vectors in some feature space and then computing a dot product. For example, the <italic>gapped k-mer</italic> kernel implicitly maps its DNA sequence inputs to feature vectors representing the normalized counts of distinct gapped <italic>k</italic>-mers. Formally, it can be written as:
<disp-formula id="E2"><label>(2)</label><mml:math id="M2"><mml:mrow><mml:mtable><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mtext>gkm</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mo>〈</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:msubsup><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mtext>gkm</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msubsup></mml:mrow><mml:mrow><mml:mrow><mml:mo>‖</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mtext>gkm</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msubsup></mml:mrow><mml:mo>‖</mml:mo></mml:mrow></mml:mrow></mml:mfrac><mml:mo>,</mml:mo><mml:mfrac><mml:mrow><mml:msubsup><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mtext>gkm</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msubsup></mml:mrow><mml:mrow><mml:mrow><mml:mo>‖</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mtext>gkm</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msubsup></mml:mrow><mml:mo>‖</mml:mo></mml:mrow></mml:mrow></mml:mfrac></mml:mrow><mml:mo>〉</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mo>〈</mml:mo><mml:msubsup><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mtext>gkm</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mtext>gkm</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msubsup><mml:mo>〉</mml:mo></mml:mrow><mml:mrow><mml:msqrt><mml:mrow><mml:mo>〈</mml:mo><mml:msubsup><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mtext>gkm</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mtext>gkm</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msubsup><mml:mo>〉</mml:mo></mml:mrow></mml:msqrt><mml:msqrt><mml:mrow><mml:mo>〈</mml:mo><mml:msubsup><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mtext>gkm</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mtext>gkm</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msubsup><mml:mo>〉</mml:mo></mml:mrow></mml:msqrt></mml:mrow></mml:mfrac></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math></disp-formula>
where <inline-formula id="IE2"><mml:math id="IM2"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mtext>gkm</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE3"><mml:math id="IM3"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mtext>gkm</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> are feature vectors representing the counts of distinct gapped <italic>k</italic>-mers in sequences <italic>S</italic><sub>1</sub> and <italic>S</italic><sub>2</sub> respectively. As the feature space corresponding to gapped <italic>k</italic>-mer counts can be large, for computationally efficiency the gkm kernel (<xref rid="btz322-B7" ref-type="bibr">Ghandi <italic>et al.</italic>, 2014</xref>; <xref rid="btz322-B10" ref-type="bibr">Leslie and Kuang, 2004</xref>) computes the dot product <inline-formula id="IE4"><mml:math id="IM4"><mml:mrow><mml:mo>〈</mml:mo><mml:msubsup><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mtext>gkm</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mtext>gkm</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msubsup><mml:mo>〉</mml:mo></mml:mrow></mml:math></inline-formula> without explicitly computing <inline-formula id="IE5"><mml:math id="IM5"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mtext>gkm</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> or <inline-formula id="IE6"><mml:math id="IM6"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mtext>gkm</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula>. Let <inline-formula id="IE7"><mml:math id="IM7"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> represent the identity of the <italic>l</italic>-mer at position <italic>i</italic> in sequence <italic>S<sub>x</sub></italic>, and let <inline-formula id="IE8"><mml:math id="IM8"><mml:mrow><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mi>m</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mi>j</mml:mi><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msubsup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> be a function that returns the number of mismatching positions between the <italic>l</italic>-mers <inline-formula id="IE9"><mml:math id="IM9"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE10"><mml:math id="IM10"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mi>j</mml:mi><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula>. The gkm kernel leverages the fact that:
<disp-formula id="E3"><label>(3)</label><mml:math id="M3"><mml:mrow><mml:mrow><mml:mo>〈</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mtext>gkm</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mtext>gkm</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msubsup></mml:mrow><mml:mo>〉</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:munder><mml:mo>∑</mml:mo><mml:mi>i</mml:mi></mml:munder><mml:mrow><mml:munder><mml:mo>∑</mml:mo><mml:mi>j</mml:mi></mml:munder><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mi>m</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mi>j</mml:mi><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msubsup><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></disp-formula>
where the indexes <italic>i</italic> and <italic>j</italic> sum over all <italic>l</italic>-mers in <italic>S</italic><sub>1</sub> and <italic>S</italic><sub>2</sub> respectively, and <italic>h</italic>(<italic>m</italic>) is a function that returns the contribution of an <italic>l</italic>-mer pair with <italic>m</italic> mismatches to the dot product <inline-formula id="IE11"><mml:math id="IM11"><mml:mrow><mml:mo>〈</mml:mo><mml:msup><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msup><mml:mo>〉</mml:mo></mml:mrow></mml:math></inline-formula>. For example, if <inline-formula id="IE12"><mml:math id="IM12"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE13"><mml:math id="IM13"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mi>j</mml:mi><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> are a pair of <italic>l</italic>-mers with <italic>m</italic> mismatches between them, then the number of gapped <italic>k</italic>-mers they share is <inline-formula id="IE14"><mml:math id="IM14"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mtable><mml:mtr><mml:mtd><mml:mi>l</mml:mi><mml:mo>−</mml:mo><mml:mi>m</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mi>k</mml:mi></mml:mtd></mml:mtr></mml:mtable><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>. Thus, in the case of the traditional gapped <italic>k</italic>-mer kernel, <inline-formula id="IE15"><mml:math id="IM15"><mml:mrow><mml:mi>h</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mtable><mml:mtr><mml:mtd><mml:mi>l</mml:mi><mml:mo>−</mml:mo><mml:mi>m</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mi>k</mml:mi></mml:mtd></mml:mtr></mml:mtable><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>. <xref rid="btz322-B5" ref-type="bibr">Ghandi <italic>et al.</italic> (2014)</xref> additionally proposed variants of the gapped <italic>k</italic>-mer kernel such as the <italic>truncated gkm-filter</italic> that differ in the function <italic>h</italic>(<italic>m</italic>), but otherwise have an identical formulation.</p>
      <p>For computational efficiency, the gkm-SVM implementation contains a parameter <italic>d</italic> that sets <italic>h</italic>(<italic>m</italic>) = 0 for all <italic>m </italic>&gt;<italic> d</italic> (regardless of the values of <italic>l</italic> and <italic>k</italic>). This is efficient because it limits the number of <italic>l</italic>-mer pairs that need to be considered to those where <inline-formula id="IE16"><mml:math id="IM16"><mml:mrow><mml:mi>m</mml:mi><mml:mo>≤</mml:mo><mml:mi>d</mml:mi></mml:mrow></mml:math></inline-formula>. In the documentation, <italic>d</italic> is referred to as the maximum number of allowed mismatches.</p>
    </sec>
    <sec>
      <title>3.3 Extensions of the gkm kernel</title>
      <p><xref rid="btz322-B8" ref-type="bibr">Lee (2016)</xref> proposed variants of the gapped k-mer kernel. We describe these variants below.</p>
      <sec>
        <title>3.3.1 The wgkm kernel</title>
        <p>In regulatory DNA sequence, motifs often exhibit a positional preferences—for example, they may tend to occur close to the summit of peaks in ChIP-seq data. The weighted gkm (wgkm) kernel leverages this property by giving <italic>l</italic>-mers weights according to the position at which they occur. These weights are pre-defined by the user, and the lsgkm implementation supports weights that decay exponentially with distance from the center of the sequence. A dot product in the feature space of weighted gapped <italic>k</italic>-mers can be expressed as:
<disp-formula id="E4"><label>(4)</label><mml:math id="M4"><mml:mrow><mml:mrow><mml:mo>〈</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mtext>wgkm</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mtext>wgkm</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msubsup></mml:mrow><mml:mo>〉</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:munder><mml:mo>∑</mml:mo><mml:mi>i</mml:mi></mml:munder><mml:mrow><mml:munder><mml:mo>∑</mml:mo><mml:mi>j</mml:mi></mml:munder><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mi>m</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mi>j</mml:mi><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msubsup><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:math></disp-formula>
where <italic>w<sub>i</sub></italic> and <italic>w<sub>j</sub></italic> are the weights associated with <italic>l</italic>-mers at positions <italic>i</italic> and <italic>j</italic> respectively. Analogous to <xref ref-type="disp-formula" rid="E2"><bold>Eqn. 2</bold></xref>, the wgkm kernel can be written as:
<disp-formula id="E5"><label>(5)</label><mml:math id="M5"><mml:mrow><mml:mtable><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mtext>wgkm</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mo>〈</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:msubsup><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mtext>wgkm</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msubsup></mml:mrow><mml:mrow><mml:mrow><mml:mo>‖</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mtext>wgkm</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msubsup></mml:mrow><mml:mo>‖</mml:mo></mml:mrow></mml:mrow></mml:mfrac><mml:mo>,</mml:mo><mml:mfrac><mml:mrow><mml:msubsup><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mtext>wgkm</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msubsup></mml:mrow><mml:mrow><mml:mrow><mml:mo>‖</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mtext>wgkm</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msubsup></mml:mrow><mml:mo>‖</mml:mo></mml:mrow></mml:mrow></mml:mfrac></mml:mrow><mml:mo>〉</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mo>〈</mml:mo><mml:msubsup><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mtext>wgkm</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mtext>wgkm</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msubsup><mml:mo>〉</mml:mo></mml:mrow><mml:mrow><mml:msqrt><mml:mrow><mml:mo>〈</mml:mo><mml:msubsup><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mtext>wgkm</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mtext>wgkm</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msubsup><mml:mo>〉</mml:mo></mml:mrow></mml:msqrt><mml:msqrt><mml:mrow><mml:mo>〈</mml:mo><mml:msubsup><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mtext>wgkm</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mtext>wgkm</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msubsup><mml:mo>〉</mml:mo></mml:mrow></mml:msqrt></mml:mrow></mml:mfrac></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math></disp-formula></p>
        <p>The gkm kernel is a special case of the wgkm kernel with <italic>w<sub>i</sub></italic>=1 for all <italic>i</italic>.</p>
      </sec>
      <sec>
        <title>3.3.2 The gkmrbf kernel</title>
        <p>The RBF kernel is useful for modeling complex nonlinear interactions between input features. It is defined as <inline-formula id="IE17"><mml:math id="IM17"><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mtext>RBF</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold">x</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="bold">y</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mtext>exp</mml:mtext><mml:mo> </mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mo>−</mml:mo><mml:mfrac><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mrow><mml:mo>‖</mml:mo><mml:mrow><mml:mi mathvariant="bold">x</mml:mi><mml:mo>−</mml:mo><mml:mi mathvariant="bold">y</mml:mi></mml:mrow><mml:mo>‖</mml:mo></mml:mrow></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:msup><mml:mrow><mml:mo>σ</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mfrac></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> (where <bold>x</bold> and <bold>y</bold> are vectors). Recall that the gkm kernel can be thought of as mapping the input sequences to a feature space of normalized gapped <italic>k</italic>-mer counts. The gkmrbf kernel maps sequences to the same feature space as the gkm kernel, but then applies the RBF kernel to the vectors rather than the dot product. For efficient computation, this equality is leveraged:
<disp-formula id="E6"><mml:math id="M6"><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mrow><mml:mo>‖</mml:mo><mml:mrow><mml:mi mathvariant="bold">x</mml:mi><mml:mo>−</mml:mo><mml:mi mathvariant="bold">y</mml:mi></mml:mrow><mml:mo>‖</mml:mo></mml:mrow></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo>=</mml:mo><mml:mo>〈</mml:mo><mml:mi mathvariant="bold">x</mml:mi><mml:mo>−</mml:mo><mml:mi mathvariant="bold">y</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="bold">x</mml:mi><mml:mo>−</mml:mo><mml:mi mathvariant="bold">y</mml:mi><mml:mo>〉</mml:mo><mml:mo>=</mml:mo><mml:mo>〈</mml:mo><mml:mi mathvariant="bold">x</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="bold">x</mml:mi><mml:mo>〉</mml:mo><mml:mo>+</mml:mo><mml:mo>〈</mml:mo><mml:mi mathvariant="bold">y</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="bold">y</mml:mi><mml:mo>〉</mml:mo><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:mo>〈</mml:mo><mml:mi mathvariant="bold">x</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="bold">y</mml:mi><mml:mo>〉</mml:mo></mml:mrow></mml:math></disp-formula></p>
        <p>As gkm feature vectors are always unit normalized, <inline-formula id="IE18"><mml:math id="IM18"><mml:mrow><mml:mo>〈</mml:mo><mml:mi mathvariant="bold">x</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="bold">x</mml:mi><mml:mo>〉</mml:mo><mml:mo>=</mml:mo><mml:mo>〈</mml:mo><mml:mi mathvariant="bold">y</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="bold">y</mml:mi><mml:mo>〉</mml:mo><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>. If we let <inline-formula id="IE19"><mml:math id="IM19"><mml:mrow><mml:mo>γ</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:msup><mml:mrow><mml:mo>σ</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mfrac></mml:mrow></mml:math></inline-formula>, we get:
<disp-formula id="E7"><label>(6)</label><mml:math id="M7"><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mtext>gkmrbf</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>y</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mtext>exp</mml:mtext><mml:mo> </mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mo>γ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mtext>gkm</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>y</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></disp-formula></p>
      </sec>
      <sec>
        <title>3.3.3 The wgkmrbf kernel</title>
        <p>Analogous to <xref ref-type="disp-formula" rid="E7"><bold>Eqn. 6</bold></xref>, the wgkmrbf kernel is a combination of the wgkm kernel and the RBF kernel:
<disp-formula id="E8"><label>(7)</label><mml:math id="M8"><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mtext>wgkmrbf</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>y</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mtext>exp</mml:mtext><mml:mo> </mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mo>γ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mtext>wgkm</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>y</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></disp-formula></p>
      </sec>
    </sec>
  </sec>
  <sec>
    <title>4 Previous work</title>
    <sec>
      <title>4.1 DeltaSVM</title>
      <p>DeltaSVM (<xref rid="btz322-B9" ref-type="bibr">Lee <italic>et al.</italic>, 2015</xref>) is a popular tool developed by the authors of gkm-SVM to estimate the in-silico effects of genetic variants. DeltaSVM precomputes a score for each <italic>l</italic>-mer as the output when the gkm-SVM is supplied only that <italic>l</italic>-mer as input. It then estimates the impact of a mutation as the total change in the scores of all <italic>l</italic>-mers overlapping the mutation. Because the scores of individual <italic>l</italic>-mers are precomputed, calculating the impact of a single mutation is computationally efficient. However, this formulation does not consider non-additive relationships between <italic>l</italic>-mers that can be learned by the gkmrbf or wgkmrbf kernels, such as those illustrated in <xref ref-type="fig" rid="btz322-F1">Figure 1</xref>. It also does not consider the influence of positional weights that are present in the wgkm or wgkmrbf kernels. Consistent with this, Lee (<xref rid="btz322-B8" ref-type="bibr">Lee, 2016</xref>) observed that deltaSVM used in conjunction with the gkmrbf, wgkm or wgkmrbf kernels did not produce improvements in variant scoring relative to the gkm kernel, even when predictive models trained with the former kernels performed better.
</p>
      <fig id="btz322-F1" orientation="portrait" position="float">
        <label>Fig. 1.</label>
        <caption>
          <p>Toy example illustrating drawback of ISM. Presented is a gkmrbf model exhibiting ‘AND’-type logic: at least one instance of ‘TATA’ and one instance of ‘CCGG’ must be present for the model to give a high positive prediction. The model has a single positively-weighted support vector containing one TATA and one CCGG. It has two negatively-weighted support vectors consisting exclusively of TATA and CCGG. Importance scores on a sequence containing two instances of TATA (blue boxes) and one instance of CCGG (violet box) are shown. The sequence has a positive prediction. Although the TATA instances are relevant for the positive prediction, ISM does not clearly highlight them. This is because perturbing any single TATA instance does not tend to decrease the prediction, as high similarity with the positively-weighted support vector can be achieved with only one TATA instance</p>
        </caption>
        <graphic xlink:href="btz322f1"/>
      </fig>
    </sec>
    <sec>
      <title>4.2 In-silico mutagenesis (ISM)</title>
      <p>An alternative to deltaSVM for estimating the impact of individual mutations is to directly compute the change in the output of the SVM when the mutation is introduced into the input sequence. This approach is called in-silico mutagenesis (ISM) (<xref rid="btz322-B2" ref-type="bibr">Bromberg and Rost, 2008</xref>), and it has been successfully applied to interpret complex machine learning models (<xref rid="btz322-B17" ref-type="bibr">Zhou and Troyanskaya, 2015</xref>). However, repeatedly rerunning the model to compute the impact of every possible mutation in an input sequence can become computationally inefficient. Further, when ISM is applied to a model that has learned nonlinear saturating effects, it can fail to reveal the presence of motifs in a sequence (<xref rid="btz322-B12" ref-type="bibr">Shrikumar <italic>et al.</italic>, 2017</xref>). Such nonlinear effects can be learned by the gkmrbf or wgkmrbf kernels (Section 3.3), both of which were found to produce improvements in performance relative to the gkm kernel (<xref rid="btz322-B8" ref-type="bibr">Lee, 2016</xref>). An example is provided in <xref ref-type="fig" rid="btz322-F1">Figure 1</xref>.</p>
    </sec>
    <sec>
      <title>4.3 SHAP</title>
      <p>SHAP (<xref rid="btz322-B11" ref-type="bibr">Lundberg and Lee, 2017</xref>) is a general-purpose model interpretation algorithm that addresses the saturation issue of ISM by sampling several combinations of input perturbations and looking at the change in the output for all the sets of perturbations. Perturbations are performed by replacing the perturbed features with the values that those features have in a user-supplied ‘background’. For example, in the case of DNA sequence, if the original input sequence is AAA and the background is TTT, and positions 1 and 3 are sampled for perturbation, then the corresponding perturbed sequence would be TAT. In scenarios where there is no single background input, but rather there is a collection of potential background inputs (as is often the case for DNA sequence), SHAP computes the model output when each background input is used individually for substitution and takes the average. For example, if the original input sequence is AAA, and there are three background sequences of TTT, CCC and GGG, then when computing the output when positions 1 and 3 are sampled for perturbation, SHAP would compute the average of the model output over TAT, CAC and GAG. The runtime of SHAP thus depends on the product of the number of sampled perturbations and the number of background sequences.</p>
      <p>Although SHAP has been shown to have good theoretical guarantees, it is far less computationally efficient than ISM because the number of sampled perturbations needed to get accurate importance estimates can be quite large. For example, the authors of SHAP used 50 000 sampled perturbations to obtain stable estimates of feature importance on a single example from the MNIST digit recognition dataset (each MNIST digit is a 28 × 28 image, and only one background—consisting of the all-zeros image—was used). In our experiments with simulated DNA sequences of length 200 bp, we ran SHAP with both 2000 and 20 000 sampled perturbations per input and 20 background sequences per input, where the background sequences were generated for each input sequence by performing a dinucleotide-preserving shuffle. We found that increasing the number of background sequences from 20 to 200 did not appear to substantially change the results (<xref ref-type="fig" rid="btz322-F2">Fig. 2</xref>). At 20 000 perturbations per input and 20 background sequences, the number of model evaluations needed per sequence was <inline-formula id="IE20"><mml:math id="IM20"><mml:mrow><mml:mn>20</mml:mn><mml:mo> </mml:mo><mml:mn>000</mml:mn><mml:mo>×</mml:mo><mml:mn>20</mml:mn><mml:mo>=</mml:mo><mml:mn>400</mml:mn><mml:mo> </mml:mo><mml:mn>000</mml:mn></mml:mrow></mml:math></inline-formula>. Despite this hefty computational requirement, we still found that GkmExplain outperformed SHAP (<xref ref-type="fig" rid="btz322-F2">Figs 2 and 4</xref> and <xref ref-type="supplementary-material" rid="sup1">Supplementary Fig. SA.1</xref>).
</p>
      <fig id="btz322-F2" orientation="portrait" position="float">
        <label>Fig. 2.</label>
        <caption>
          <p>Comparison of GkmExplain, ISM, deltaSVM and SHAP on an individual simulated sequence. An SVM with a gkmrbf kernel with <italic>l </italic>=<italic> </italic>6, <italic>k </italic>=<italic> </italic>5 and <italic>d </italic>=<italic> </italic>1 was used to distinguish sequences containing both TAL1 and GATA1 motifs from sequences containing only one kind of motif or neither kind of motif. The locations of embedded GATA1 motifs are indicated by blue stars, and the location of the embedded TAL1 motif is indicated by a red star. The relatively poor performance of ISM and deltaSVM is due to the nonlinear nature of the RBF kernel</p>
        </caption>
        <graphic xlink:href="btz322f2"/>
      </fig>
    </sec>
    <sec>
      <title>4.4 SVM motif discovery method of <xref rid="btz322-B5" ref-type="bibr">Ghandi <italic>et al.</italic> (2014)</xref></title>
      <p>Although there exist a variety of unsupervised motif discovery methods such as MEME (<xref rid="btz322-B1" ref-type="bibr">Bailey <italic>et al.</italic>, 2009</xref>) and HOMER (<xref rid="btz322-B6" ref-type="bibr">Heinz <italic>et al.</italic>, 2010</xref>), we sometimes wish to understand the motifs that are specifically learned de-novo by a supervised machine learning model. For example, when debugging our models, we may wish to know which patterns the supervised model has failed to pick up. In cases where the supervised model can represent more complex motifs, we may be curious whether the supervised model has learned motifs that the unsupervised model did not identify. To our knowledge, the only method in the literature that attempts to reveal the motifs specifically learned by a gapped <italic>k</italic>-mer SVM is the method presented by <xref rid="btz322-B5" ref-type="bibr">Gandhi <italic>et al.</italic> (2014)</xref> in the gkm-SVM paper (<xref rid="btz322-B5" ref-type="bibr">Ghandi <italic>et al.</italic>, 2014</xref>). Their strategy was based on first scoring all possible 10-mers using the gkm-SVM and then finding motifs within the top 1% of 10-mers that received the highest scores using an iterative greedy algorithm. In our experiments, we found that by supplying the importance scores produced by GkmExplain to the importance score clustering and aggregation tool TF-MoDISco (<xref rid="btz322-B13" ref-type="bibr">Shrikumar <italic>et al.</italic>, 2018</xref>), we recovered more consolidated, non-redundant motifs with better matches to known canonical motifs than those produced by the method of <xref rid="btz322-B5" ref-type="bibr">Ghandi <italic>et al.</italic> (2014)</xref> (see <xref ref-type="fig" rid="btz322-F5">Figs 5 and 6</xref>).</p>
    </sec>
  </sec>
  <sec>
    <title>5 Materials and methods</title>
    <sec>
      <title>5.1 GkmExplain importance scores</title>
      <p>We will begin by presenting a method for explaining the wgkm kernel output between a sequence <italic>S<sub>x</sub></italic> and a support vector <italic>S<sub>z</sub></italic> in terms of the contributions of individual basepairs in sequence <italic>S<sub>x</sub></italic>. Once we have a method for explaining the kernel output, it will be straightforward to extend this to explain the final SVM output. Recall that the gkm kernel is a special case of the wgkm kernel where the weights are uniformly set to 1, and that the gkmrbf and wgkmrbf kernels build on the gkm and wgkm kernels respectively. Thus, explaining the wgkm kernel is an essential step to explaining the gkmrbf and wgkmrbf kernels as well.</p>
      <p>As a reminder, the weighted gapped <italic>k</italic>-mer kernel between sequences <italic>S<sub>x</sub></italic> and <italic>S<sub>z</sub></italic>, denoted as <inline-formula id="IE21"><mml:math id="IM21"><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mtext>wgkm</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>z</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, can be understood as the dot product between unit-normalized feature vectors <inline-formula id="IE22"><mml:math id="IM22"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mtext>wgkm</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE23"><mml:math id="IM23"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mtext>wgkm</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>z</mml:mi></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula>, where <inline-formula id="IE24"><mml:math id="IM24"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mtext>wgkm</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> denotes a vector of the position-weighted gapped <italic>k</italic>-mer counts in <italic>S<sub>x</sub></italic>. Also recall that, for computational efficiency, rather than explicitly computing the feature vectors <inline-formula id="IE25"><mml:math id="IM25"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mtext>wgkm</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE26"><mml:math id="IM26"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mtext>wgkm</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>z</mml:mi></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula>, we can instead compute the dot product <inline-formula id="IE27"><mml:math id="IM27"><mml:mrow><mml:mo>〈</mml:mo><mml:msubsup><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mtext>wgkm</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mtext>wgkm</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>z</mml:mi></mml:msub></mml:mrow></mml:msubsup><mml:mo>〉</mml:mo></mml:mrow></mml:math></inline-formula> in terms of the number of mismatches between the <italic>l</italic>-mers in <italic>S<sub>x</sub></italic> and <italic>S<sub>z</sub></italic>. Formally, if we let <inline-formula id="IE28"><mml:math id="IM28"><mml:mrow><mml:msubsup><mml:mrow><mml:mo>μ</mml:mo></mml:mrow><mml:mi>j</mml:mi><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> denote the <italic>l</italic>-mer at position <italic>j</italic> in <italic>S<sub>x</sub></italic>, <inline-formula id="IE29"><mml:math id="IM29"><mml:mrow><mml:msubsup><mml:mrow><mml:mo>μ</mml:mo></mml:mrow><mml:mi>k</mml:mi><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>z</mml:mi></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> denote the <italic>l</italic>-mer at position <italic>k</italic> in <italic>S<sub>z</sub></italic>, we had in <xref ref-type="disp-formula" rid="E3"><bold>Eqn. 3</bold></xref> that the contribution of the <italic>l</italic>-mer pair <inline-formula id="IE30"><mml:math id="IM30"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mrow><mml:mo>μ</mml:mo></mml:mrow><mml:mi>j</mml:mi><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mo>μ</mml:mo></mml:mrow><mml:mi>k</mml:mi><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>z</mml:mi></mml:msub></mml:mrow></mml:msubsup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> to <inline-formula id="IE31"><mml:math id="IM31"><mml:mrow><mml:mo>〈</mml:mo><mml:msubsup><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mtext>wgkm</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mtext>wgkm</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>z</mml:mi></mml:msub></mml:mrow></mml:msubsup><mml:mo>〉</mml:mo></mml:mrow></mml:math></inline-formula> is <inline-formula id="IE32"><mml:math id="IM32"><mml:mrow><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mi>h</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mi>m</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mrow><mml:mo>μ</mml:mo></mml:mrow><mml:mi>j</mml:mi><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mo>μ</mml:mo></mml:mrow><mml:mi>k</mml:mi><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>z</mml:mi></mml:msub></mml:mrow></mml:msubsup><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, where <italic>f<sub>m</sub></italic> is a function that returns the number of mismatches and <italic>h</italic> is a function that depends on the specific variant of the kernel used. For notational convenience, we will denote <inline-formula id="IE33"><mml:math id="IM33"><mml:mrow><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mi>m</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mrow><mml:mo>μ</mml:mo></mml:mrow><mml:mi>j</mml:mi><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mo>μ</mml:mo></mml:mrow><mml:mi>k</mml:mi><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>z</mml:mi></mml:msub></mml:mrow></mml:msubsup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> as <italic>m</italic> here.</p>
      <p>How should we distribute the quantity <inline-formula id="IE34"><mml:math id="IM34"><mml:mrow><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mi>h</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> over the bases in <italic>S<sub>x</sub></italic>? Consider a position <italic>i</italic> in sequence <italic>S<sub>x</sub></italic> that overlaps the <italic>l</italic>-mer <inline-formula id="IE35"><mml:math id="IM35"><mml:mrow><mml:msubsup><mml:mrow><mml:mo>μ</mml:mo></mml:mrow><mml:mi>j</mml:mi><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula>. Let us denote the base at position <italic>i</italic> as <inline-formula id="IE36"><mml:math id="IM36"><mml:mrow><mml:msub><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msubsup><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula>, and the corresponding base within the other <italic>l</italic>-mer <inline-formula id="IE37"><mml:math id="IM37"><mml:mrow><mml:msubsup><mml:mrow><mml:mo>μ</mml:mo></mml:mrow><mml:mi>k</mml:mi><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>z</mml:mi></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> (from position <italic>k</italic> in support vector <italic>S<sub>z</sub></italic>) as <inline-formula id="IE38"><mml:math id="IM38"><mml:mrow><mml:msub><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mi>z</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msubsup><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>z</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> (‘corresponding’ means that the offset of <italic>B<sub>x</sub></italic> relative to the start of <inline-formula id="IE39"><mml:math id="IM39"><mml:mrow><mml:msubsup><mml:mrow><mml:mo>μ</mml:mo></mml:mrow><mml:mi>j</mml:mi><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> is the same as the offset of <italic>B<sub>z</sub></italic> relative to the start of <inline-formula id="IE40"><mml:math id="IM40"><mml:mrow><mml:msubsup><mml:mrow><mml:mo>μ</mml:mo></mml:mrow><mml:mi>k</mml:mi><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>z</mml:mi></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula>). If we evenly distribute <inline-formula id="IE41"><mml:math id="IM41"><mml:mrow><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mi>h</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> among the <inline-formula id="IE42"><mml:math id="IM42"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>l</mml:mi><mml:mo>−</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> matching positions between <italic>l</italic>-mers <inline-formula id="IE43"><mml:math id="IM43"><mml:mrow><mml:msubsup><mml:mrow><mml:mo>μ</mml:mo></mml:mrow><mml:mi>i</mml:mi><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE44"><mml:math id="IM44"><mml:mrow><mml:msubsup><mml:mrow><mml:mo>μ</mml:mo></mml:mrow><mml:mi>j</mml:mi><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>z</mml:mi></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula>, then position <italic>i</italic> would inherit an importance of <inline-formula id="IE45"><mml:math id="IM45"><mml:mrow><mml:mfrac><mml:mrow><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mi>h</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mi>l</mml:mi><mml:mo>−</mml:mo><mml:mi>m</mml:mi></mml:mrow></mml:mfrac></mml:mrow></mml:math></inline-formula> if <italic>B<sub>x</sub></italic> = <italic>B<sub>z</sub></italic>, and would inherit an importance of 0 if <inline-formula id="IE46"><mml:math id="IM46"><mml:mrow><mml:msub><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>≠</mml:mo><mml:msub><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mi>z</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>. Leaving out the weights <inline-formula id="IE47"><mml:math id="IM47"><mml:mrow><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> (which don’t depend on <italic>m</italic>, <italic>B<sub>x</sub></italic> or <italic>B<sub>z</sub></italic>), we can encapsulate the core logic in the function <inline-formula id="IE48"><mml:math id="IM48"><mml:mrow><mml:mtext>eff</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mi>z</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, defined as:
<disp-formula id="E9"><label>(8)</label><mml:math id="M9"><mml:mrow><mml:mtext>eff</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mi>z</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>:</mml:mo><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mtable><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>h</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mi>l</mml:mi><mml:mo>−</mml:mo><mml:mi>m</mml:mi></mml:mrow></mml:mfrac></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo> </mml:mo><mml:mtext>if</mml:mtext><mml:mo> </mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="normal">B</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:msub><mml:mrow><mml:mrow><mml:mo>=</mml:mo><mml:mi mathvariant="normal">B</mml:mi></mml:mrow></mml:mrow><mml:mi>z</mml:mi></mml:msub></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mn>0</mml:mn></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo> </mml:mo><mml:mtext>otherwise</mml:mtext></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mrow></mml:mrow></mml:math></disp-formula></p>
      <p>Using this function, we write the weighted contribution to <inline-formula id="IE49"><mml:math id="IM49"><mml:mrow><mml:mo>〈</mml:mo><mml:msubsup><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mtext>wgkm</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mtext>wgkm</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>z</mml:mi></mml:msub></mml:mrow></mml:msubsup><mml:mo>〉</mml:mo></mml:mrow></mml:math></inline-formula> inherited by position <italic>i</italic> from the <italic>l</italic>-mer pair <inline-formula id="IE50"><mml:math id="IM50"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mrow><mml:mo>μ</mml:mo></mml:mrow><mml:mi>j</mml:mi><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mo>μ</mml:mo></mml:mrow><mml:mi>k</mml:mi><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>z</mml:mi></mml:msub></mml:mrow></mml:msubsup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> as:
<disp-formula id="E10"><label>(9)</label><mml:math id="M10"><mml:mrow><mml:mtext>imp</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>z</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>:</mml:mo><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mtext>eff</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mi>m</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mrow><mml:mo>μ</mml:mo></mml:mrow><mml:mi>j</mml:mi><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mo>μ</mml:mo></mml:mrow><mml:mi>k</mml:mi><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>z</mml:mi></mml:msub></mml:mrow></mml:msubsup><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>z</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></disp-formula></p>
      <p>If we sum this quantity over all possible <italic>l</italic>-mer pairs where <inline-formula id="IE51"><mml:math id="IM51"><mml:mrow><mml:msubsup><mml:mrow><mml:mo>μ</mml:mo></mml:mrow><mml:mi>j</mml:mi><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> overlaps position <italic>i</italic>—that is, we sum over the range <inline-formula id="IE52"><mml:math id="IM52"><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mi>max</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>l</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> to <inline-formula id="IE53"><mml:math id="IM53"><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mi>min</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mtext>len</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:mi>l</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>—and normalize by the total wgkm feature vector lengths <inline-formula id="IE54"><mml:math id="IM54"><mml:mrow><mml:mrow><mml:mo>‖</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mtext>wgkm</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub></mml:mrow></mml:msubsup></mml:mrow><mml:mo>‖</mml:mo></mml:mrow><mml:mrow><mml:mo>‖</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mtext>wgkm</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>z</mml:mi></mml:msub></mml:mrow></mml:msubsup></mml:mrow><mml:mo>‖</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> (as is done in the wgkm kernel), we arrive at the total contribution of position <italic>i</italic> in <italic>S<sub>x</sub></italic> to <inline-formula id="IE55"><mml:math id="IM55"><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mtext>wgkm</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>z</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, which we denote as <inline-formula id="IE56"><mml:math id="IM56"><mml:mrow><mml:msubsup><mml:mrow><mml:mo>ϕ</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>z</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:mtext>wgkm</mml:mtext></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula>:
<disp-formula id="E11"><label>(10)</label><mml:math id="M11"><mml:mrow><mml:msubsup><mml:mrow><mml:mo>ϕ</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>z</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:mtext>wgkm</mml:mtext></mml:mrow></mml:msubsup><mml:mo>:</mml:mo><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mi>max</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>l</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mi>min</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mtext>len</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:mi>l</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:munderover><mml:mrow><mml:munder><mml:mo>∑</mml:mo><mml:mi>k</mml:mi></mml:munder><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:mtext>imp</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>z</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mrow><mml:mo>‖</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mtext>wgkm</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub></mml:mrow></mml:msubsup></mml:mrow><mml:mo>‖</mml:mo></mml:mrow><mml:mrow><mml:mo>‖</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mtext>wgkm</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>z</mml:mi></mml:msub></mml:mrow></mml:msubsup></mml:mrow><mml:mo>‖</mml:mo></mml:mrow></mml:mrow></mml:mfrac></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:mrow></mml:math></disp-formula></p>
      <p><inline-formula id="IE57"><mml:math id="IM57"><mml:mrow><mml:mrow><mml:mo>‖</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mtext>wgkm</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub></mml:mrow></mml:msubsup></mml:mrow><mml:mo>‖</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msqrt><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mtext>wgkm</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msqrt></mml:mrow></mml:math></inline-formula> is efficiently computed using the kernel function. Now that we have defined the contribution of base <italic>i</italic> to the wgkm kernel output <inline-formula id="IE58"><mml:math id="IM58"><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mtext>wgkm</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, we can define the final contribution of base <italic>i</italic> to the output of the wgkm-SVM as simply being the weighted sum of <inline-formula id="IE59"><mml:math id="IM59"><mml:mrow><mml:msubsup><mml:mrow><mml:mo>ϕ</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msup></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mtext>wgkm</mml:mtext></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> over all support vectors <inline-formula id="IE60"><mml:math id="IM60"><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msup></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, where the weights are <inline-formula id="IE61"><mml:math id="IM61"><mml:mrow><mml:msub><mml:mrow><mml:mo>α</mml:mo></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:msup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula> (as per <xref ref-type="disp-formula" rid="E1"><bold>Eqn. 1</bold></xref>). We denote this quantity as <inline-formula id="IE62"><mml:math id="IM62"><mml:mrow><mml:msubsup><mml:mrow><mml:mo>ϕ</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:mtext>wgkmsvm</mml:mtext></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula><disp-formula id="E12"><label>(11)</label><mml:math id="M12"><mml:mrow><mml:msubsup><mml:mrow><mml:mo>ϕ</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:mtext>wgkmsvm</mml:mtext></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>m</mml:mi></mml:munderover><mml:mrow><mml:msub><mml:mrow><mml:mo>α</mml:mo></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow><mml:msup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msup><mml:msubsup><mml:mrow><mml:mo>ϕ</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msup></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mtext>wgkm</mml:mtext></mml:mrow></mml:msubsup></mml:mrow></mml:math></disp-formula></p>
      <p>How can we compute a similar quantity for per-base attributions with the wkgmrbf kernel? We first note that when <inline-formula id="IE63"><mml:math id="IM63"><mml:mrow><mml:mo>〈</mml:mo><mml:msubsup><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mtext>wgkm</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mtext>wgkm</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>z</mml:mi></mml:msub></mml:mrow></mml:msubsup><mml:mo>〉</mml:mo></mml:mrow></mml:math></inline-formula> is 0, the output of <inline-formula id="IE64"><mml:math id="IM64"><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mtext>wgkmrbf</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>z</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is <inline-formula id="IE65"><mml:math id="IM65"><mml:mrow><mml:mtext>exp</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mo>−</mml:mo><mml:mo>γ</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> as per <xref ref-type="disp-formula" rid="E8"><bold>Eqn. 7</bold></xref>. If we pretend that a hypothetical ‘baseline’ input <italic>S<sub>x</sub></italic> is one that produces <inline-formula id="IE66"><mml:math id="IM66"><mml:mrow><mml:mo>〈</mml:mo><mml:msubsup><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mtext>wgkm</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mtext>wgkm</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>z</mml:mi></mml:msub></mml:mrow></mml:msubsup><mml:mo>〉</mml:mo><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula> for any support vector <italic>S<sub>z</sub></italic>, then <inline-formula id="IE67"><mml:math id="IM67"><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mtext>wgkmrbf</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>z</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:mtext>exp</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mo>−</mml:mo><mml:mo>γ</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is the ‘difference from baseline’. How can we explain this ‘difference from baseline’ in terms of the contributions from individual bases in <italic>S<sub>x</sub></italic>? Given that we already have a way to compute <inline-formula id="IE68"><mml:math id="IM68"><mml:mrow><mml:msubsup><mml:mrow><mml:mo>ϕ</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>z</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:mtext>wgkm</mml:mtext></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula>, we can simply distribute the ‘difference from baseline’ proportionally to <inline-formula id="IE69"><mml:math id="IM69"><mml:mrow><mml:msubsup><mml:mrow><mml:mo>ϕ</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>z</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:mtext>wgkm</mml:mtext></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula>. Because <inline-formula id="IE70"><mml:math id="IM70"><mml:mrow><mml:munder><mml:mo>∑</mml:mo><mml:mi>i</mml:mi></mml:munder><mml:mrow><mml:msubsup><mml:mrow><mml:mo>ϕ</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>z</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:mtext>wgkm</mml:mtext></mml:mrow></mml:msubsup></mml:mrow><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mtext>wgkm</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>z</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> by design, this gives us:
<disp-formula id="E13"><label>(12)</label><mml:math id="M13"><mml:mrow><mml:msubsup><mml:mrow><mml:mo>ϕ</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>z</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:mtext>wgkmrbf</mml:mtext></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msubsup><mml:mrow><mml:mo>ϕ</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>z</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:mtext>wgkm</mml:mtext></mml:mrow></mml:msubsup></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mtext>wgkm</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>z</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mfrac><mml:mo stretchy="true">(</mml:mo><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mtext>wgkmrbf</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>z</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:mtext>exp</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mo>−</mml:mo><mml:mo>γ</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></disp-formula></p>
      <p>Thus, by design, we again have the property that <inline-formula id="IE71"><mml:math id="IM71"><mml:mrow><mml:munder><mml:mo>∑</mml:mo><mml:mi>i</mml:mi></mml:munder><mml:mrow><mml:msubsup><mml:mrow><mml:mo>ϕ</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>z</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:mtext>wgkmrbf</mml:mtext></mml:mrow></mml:msubsup></mml:mrow><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mtext>wgkmrbf</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>z</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:mtext>exp</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mo>−</mml:mo><mml:mo>γ</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. This is what allows GkmExplain to address the saturation issue faced by ISM in <xref ref-type="fig" rid="btz322-F1">Figure 1</xref>: even in situations where perturbing any individual base locally produces a near-zero change in the kernel <inline-formula id="IE72"><mml:math id="IM72"><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mtext>wgkmrbf</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>z</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, the GkmExplain importance scores are not saturated as they cover the entire difference <inline-formula id="IE73"><mml:math id="IM73"><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mtext>wgkmrbf</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>z</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:mtext>exp</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mo>−</mml:mo><mml:mo>γ</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Specifically, in the case of the toy example in <xref ref-type="fig" rid="btz322-F1">Figure 1</xref>, GkmExplain recognizes that the similarity with the positively-weighted support vector is well above its baseline value, and therefore grants positive importance to gapped <italic>k</italic>-mer matches between the input sequence this support vector—even though similarity with the support vector is locally insensitive to specific individual perturbations. The fact that importance scores sum to the ‘difference from baseline’ is related to a theoretical connection between GkmExplain and the method of Integrated Gradients, which we discuss in <xref ref-type="supplementary-material" rid="sup1">Supplementary Appendix SA.2</xref>.</p>
      <p>Once we have the contribution of base <italic>i</italic> to the wgkmrbf kernel output <inline-formula id="IE74"><mml:math id="IM74"><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mtext>wgkmrbf</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>z</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, we can find the contribution of base <italic>i</italic> to the wgkmrbf-SVM output by simply taking the weighted sum of <inline-formula id="IE75"><mml:math id="IM75"><mml:mrow><mml:msubsup><mml:mrow><mml:mo>ϕ</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msup></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mtext>wgkmrbf</mml:mtext></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> over all support vectors <inline-formula id="IE76"><mml:math id="IM76"><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msup></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, analogous to what we did in <xref ref-type="disp-formula" rid="E12"><bold>Eqn. 11</bold></xref>, giving:
<disp-formula id="E14"><label>(13)</label><mml:math id="M14"><mml:mrow><mml:msubsup><mml:mrow><mml:mo>ϕ</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:mtext>wgkmrbfsvm</mml:mtext></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>m</mml:mi></mml:munderover><mml:mrow><mml:msub><mml:mrow><mml:mo>α</mml:mo></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow><mml:msup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msup><mml:msubsup><mml:mrow><mml:mo>ϕ</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msup></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mtext>wgkmrbf</mml:mtext></mml:mrow></mml:msubsup></mml:mrow></mml:math></disp-formula></p>
      <p>In terms of implementation, GkmExplain importance scores can be computed efficiently by modifying the <italic>k</italic>-mer tree depth-first search originally used to compute the output of the gkm-SVM (our implementation is at <ext-link ext-link-type="uri" xlink:href="https://github.com/kundajelab/lsgkm">https://github.com/kundajelab/lsgkm</ext-link>).</p>
    </sec>
    <sec>
      <title>5.2 Mutation impact scores</title>
      <p>An intuitive approach to estimating the impact of individual mutations is in-silico mutagenesis (ISM) (<xref rid="btz322-B17" ref-type="bibr">Zhou and Troyanskaya, 2015</xref>). In ISM, a mutation is introduced in the sequence and the change in the predicted output is computed. However, as illustrated in <xref ref-type="fig" rid="btz322-F1">Figures 1</xref> and <xref ref-type="fig" rid="btz322-F2">2</xref>, ISM can overlook motifs if the response of the model has saturated in the presence of the motif (as can happen when RBF variants of the gkm kernel are used). For these reasons, it can be beneficial to estimate the effects of mutations using a different quantity that we call the GkmExplain Mutation Impact Scores, which we describe in detail below.</p>
      <p>Consider a pair of <italic>l</italic>-mers <inline-formula id="IE77"><mml:math id="IM77"><mml:mrow><mml:msubsup><mml:mrow><mml:mo>μ</mml:mo></mml:mrow><mml:mi>j</mml:mi><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE78"><mml:math id="IM78"><mml:mrow><mml:msubsup><mml:mrow><mml:mo>μ</mml:mo></mml:mrow><mml:mi>k</mml:mi><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>z</mml:mi></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula>, and a mutation that changes base <italic>B<sub>x</sub></italic> in <inline-formula id="IE79"><mml:math id="IM79"><mml:mrow><mml:msubsup><mml:mrow><mml:mo>μ</mml:mo></mml:mrow><mml:mi>j</mml:mi><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> to <inline-formula id="IE80"><mml:math id="IM80"><mml:mrow><mml:msup><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula>. Let <italic>B<sub>z</sub></italic> denote the base in <inline-formula id="IE81"><mml:math id="IM81"><mml:mrow><mml:msubsup><mml:mrow><mml:mo>μ</mml:mo></mml:mrow><mml:mi>k</mml:mi><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>z</mml:mi></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> that has the same relative position within the <italic>l</italic>-mer as <italic>B<sub>x</sub></italic> has in <inline-formula id="IE82"><mml:math id="IM82"><mml:mrow><mml:msubsup><mml:mrow><mml:mo>μ</mml:mo></mml:mrow><mml:mi>j</mml:mi><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula>. As before, let <italic>m</italic> denote the number of mismatches between <inline-formula id="IE83"><mml:math id="IM83"><mml:mrow><mml:msubsup><mml:mrow><mml:mo>μ</mml:mo></mml:mrow><mml:mi>j</mml:mi><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE84"><mml:math id="IM84"><mml:mrow><mml:msubsup><mml:mrow><mml:mo>μ</mml:mo></mml:mrow><mml:mi>k</mml:mi><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>z</mml:mi></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula>. If the mutation from <italic>B<sub>x</sub></italic> to <inline-formula id="IE85"><mml:math id="IM85"><mml:mrow><mml:msup><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> decreased the number of mismatches between <inline-formula id="IE86"><mml:math id="IM86"><mml:mrow><mml:msubsup><mml:mrow><mml:mo>μ</mml:mo></mml:mrow><mml:mi>j</mml:mi><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE87"><mml:math id="IM87"><mml:mrow><mml:msubsup><mml:mrow><mml:mo>μ</mml:mo></mml:mrow><mml:mi>k</mml:mi><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>z</mml:mi></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> (that is, <inline-formula id="IE88"><mml:math id="IM88"><mml:mrow><mml:msub><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mi>z</mml:mi></mml:msub><mml:mo>≠</mml:mo><mml:msub><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE89"><mml:math id="IM89"><mml:mrow><mml:msub><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mi>z</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula>), then the contribution of the <italic>l</italic>-mer pair to the dot product between <inline-formula id="IE90"><mml:math id="IM90"><mml:mrow><mml:mo>〈</mml:mo><mml:msubsup><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mtext>wgkm</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mtext>wgkm</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>z</mml:mi></mml:msub></mml:mrow></mml:msubsup><mml:mo>〉</mml:mo></mml:mrow></mml:math></inline-formula> would change by <inline-formula id="IE91"><mml:math id="IM91"><mml:mrow><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>h</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:mi>h</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Let us set aside the weights <inline-formula id="IE92"><mml:math id="IM92"><mml:mrow><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> for now, and focus the term <inline-formula id="IE93"><mml:math id="IM93"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>h</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:mi>h</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Let us call this term <inline-formula id="IE94"><mml:math id="IM94"><mml:mrow><mml:mtext>meff</mml:mtext></mml:mrow></mml:math></inline-formula>, for ‘mutation effect’—analogous to <inline-formula id="IE95"><mml:math id="IM95"><mml:mrow><mml:mtext>eff</mml:mtext></mml:mrow></mml:math></inline-formula> in <xref ref-type="disp-formula" rid="E9">Eqn. 8</xref>. If the mutation from <italic>B<sub>x</sub></italic> to <inline-formula id="IE96"><mml:math id="IM96"><mml:mrow><mml:msup><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> increased the number of mismatches (that is, <italic>B<sub>z</sub></italic> = <italic>B<sub>x</sub></italic> and <inline-formula id="IE97"><mml:math id="IM97"><mml:mrow><mml:msub><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mi>z</mml:mi></mml:msub><mml:mo>≠</mml:mo><mml:msup><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula>), then <inline-formula id="IE98"><mml:math id="IM98"><mml:mrow><mml:mtext>meff</mml:mtext></mml:mrow></mml:math></inline-formula> would be <inline-formula id="IE99"><mml:math id="IM99"><mml:mrow><mml:mi>h</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:mi>h</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. If the mutation did not change the number of mismatches, then <inline-formula id="IE100"><mml:math id="IM100"><mml:mrow><mml:mtext>meff</mml:mtext></mml:mrow></mml:math></inline-formula> would be 0. To summarize:
<disp-formula id="E15"><label>(14)</label><mml:math id="M15"><mml:mrow><mml:mtext>meff</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mi>z</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>:</mml:mo><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="true">{</mml:mo><mml:mrow><mml:mtable><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:mi>h</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:mi>h</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo> </mml:mo><mml:mtext>if</mml:mtext><mml:mo> </mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="normal">B</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>≠</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="normal">B</mml:mi></mml:mrow><mml:mi>z</mml:mi></mml:msub><mml:mo> </mml:mo><mml:mtext>and</mml:mtext><mml:mo> </mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="normal">B</mml:mi></mml:mrow><mml:mi>z</mml:mi></mml:msub><mml:msup><mml:mrow><mml:mrow><mml:mo>=</mml:mo><mml:mi mathvariant="normal">B</mml:mi></mml:mrow></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:mi>h</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:mi>h</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo> </mml:mo><mml:mtext>if</mml:mtext><mml:mo> </mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="normal">B</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:msub><mml:mrow><mml:mrow><mml:mo>=</mml:mo><mml:mi mathvariant="normal">B</mml:mi></mml:mrow></mml:mrow><mml:mi>z</mml:mi></mml:msub><mml:mo> </mml:mo><mml:mtext>and</mml:mtext><mml:mo> </mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="normal">B</mml:mi></mml:mrow><mml:mi>z</mml:mi></mml:msub><mml:mo>≠</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="normal">B</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mn>0</mml:mn></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo> </mml:mo><mml:mtext>otherwise</mml:mtext></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mrow></mml:mrow></mml:math></disp-formula></p>
      <p>By analogy to <xref ref-type="disp-formula" rid="E10"><bold>Eqn. 9</bold></xref>, we can now include the <italic>l</italic>-mer weights <italic>w<sub>j</sub></italic> and <italic>w<sub>k</sub></italic> to get the impact of mutating the <italic>i</italic>th base in <italic>S<sub>x</sub></italic> to <inline-formula id="IE101"><mml:math id="IM101"><mml:mrow><mml:msup><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula>, mediated by the <italic>l</italic>-mer pair <inline-formula id="IE102"><mml:math id="IM102"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mrow><mml:mo>μ</mml:mo></mml:mrow><mml:mi>j</mml:mi><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mo>μ</mml:mo></mml:mrow><mml:mi>k</mml:mi><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>z</mml:mi></mml:msub></mml:mrow></mml:msubsup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, on <inline-formula id="IE103"><mml:math id="IM103"><mml:mrow><mml:mo>〈</mml:mo><mml:msubsup><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mtext>wgkm</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mtext>wgkm</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>z</mml:mi></mml:msub></mml:mrow></mml:msubsup><mml:mo>〉</mml:mo></mml:mrow></mml:math></inline-formula>:
<disp-formula id="E16"><label>(15)</label><mml:math id="M16"><mml:mrow><mml:mtext>mimp</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>z</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>:</mml:mo><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mtext>meff</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mi>m</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mrow><mml:mo>μ</mml:mo></mml:mrow><mml:mi>j</mml:mi><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mo>μ</mml:mo></mml:mrow><mml:mi>k</mml:mi><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>z</mml:mi></mml:msub></mml:mrow></mml:msubsup><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>z</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></disp-formula></p>
      <p>By analogy to <xref ref-type="disp-formula" rid="E11"><bold>Eqn. 10</bold></xref>, we replace <inline-formula id="IE104"><mml:math id="IM104"><mml:mrow><mml:mtext>imp</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mo>…</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> with <inline-formula id="IE105"><mml:math id="IM105"><mml:mrow><mml:mtext>mimp</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mo>…</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> to get the a score for the impact on <inline-formula id="IE106"><mml:math id="IM106"><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mtext>wgkm</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>z</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> of mutating the base at position <italic>i</italic> in <italic>S<sub>x</sub></italic> to <inline-formula id="IE107"><mml:math id="IM107"><mml:mrow><mml:msup><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula>:
<disp-formula id="E17"><label>(16)</label><mml:math id="M17"><mml:mrow><mml:msubsup><mml:mrow><mml:mo>ϕ</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>z</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:mtext>mwgkm</mml:mtext></mml:mrow></mml:msubsup><mml:mo>:</mml:mo><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mtext>max</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>l</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mtext>min</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mtext>len</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:mi>l</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:munderover><mml:mrow><mml:munder><mml:mo>∑</mml:mo><mml:mi>k</mml:mi></mml:munder><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:mtext>mimp</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>z</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mrow><mml:mo>‖</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mtext>wgkm</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub></mml:mrow></mml:msubsup></mml:mrow><mml:mo>‖</mml:mo></mml:mrow><mml:mrow><mml:mo>‖</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mtext>wgkm</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>z</mml:mi></mml:msub></mml:mrow></mml:msubsup></mml:mrow><mml:mo>‖</mml:mo></mml:mrow></mml:mrow></mml:mfrac></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:mrow></mml:math></disp-formula></p>
      <p>Formulas for <inline-formula id="IE108"><mml:math id="IM108"><mml:mrow><mml:msubsup><mml:mrow><mml:mo>ϕ</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:mtext>mwgkmsvm</mml:mtext></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE109"><mml:math id="IM109"><mml:mrow><mml:msubsup><mml:mrow><mml:mo>ϕ</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:mtext>mwgkmrbfsvm</mml:mtext></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> can then be obtained by replacing <inline-formula id="IE110"><mml:math id="IM110"><mml:mrow><mml:msubsup><mml:mrow><mml:mo>ϕ</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>z</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:mtext>wgkm</mml:mtext></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> with <inline-formula id="IE111"><mml:math id="IM111"><mml:mrow><mml:msubsup><mml:mrow><mml:mo>ϕ</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>z</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:mtext>mwgkm</mml:mtext></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> in <xref ref-type="disp-formula" rid="E12">Eqns. 11</xref> and <xref ref-type="disp-formula" rid="E14">13</xref> respectively. As before, these quantities can be efficiently computed by modifying the <italic>k</italic>-mer tree depth-first search originally used to compute the output of the gkm-SVM. While the original implementation only performs recursion on <italic>l</italic>-mer pairs for which no more than <italic>d</italic> mismatches have been encountered so far, we perform recursion on <italic>l</italic>-mer pairs for which up to <italic>d </italic>+<italic> </italic>1 mismatches have been encountered (because a mutation can flip a mismatching position to a match).</p>
    </sec>
    <sec>
      <title>5.3 Hypothetical importance scores</title>
      <p>For motif discovery with TF-MoDISco (<xref rid="btz322-B13" ref-type="bibr">Shrikumar <italic>et al.</italic>, 2018</xref>), it is useful to have <italic>hypothetical</italic> importance scores in addition to the true importance scores. The hypothetical importance score of base <italic>B</italic> at position <italic>i</italic> estimates the preference of the classifier for seeing base <italic>B</italic> at position <italic>i</italic> instead of the base that is actually present at position <italic>i</italic>. If base <italic>B</italic> is the same as the base that is actually present in the sequence at position <italic>i</italic>, the hypothetical importance score is defined to be the same as the actual importance score. As an example, suppose a particular TF has high affinity to the sequences GATAAT and GATTAT and a low affinity to the sequences GATCAT and GATGAT. If the sequence GATAAT is presented to a classifier trained to predict binding sites of the TF, the hypothetical importance assigned to base T in the 4th position would be high, as would be the (actual) importance assigned to base A in the 4th position. By contrast, the hypothetical importance scores assigned to C and G in the 4th position would be low and likely negative. These hypothetical importance scores are useful for motif discovery with TF-MoDISco because different instances of a motif that have slight variations in their underlying sequence may nonetheless have similar hypothetical importance scores, because the hypothetical importance scores impute the importance on all possible bases that could be present (and not just the bases that happen to be present in the specific instance of the motif). Although it may seem that the Mutation Impact Scores defined in <bold>Section 5.2</bold> could serve this purpose, this is not the case because the mutation impact scores for the bases that are actually present in the sequence are always 0 (as mutating them to be themselves does not change the output).</p>
      <p>To motivate our formula for the hypothetical importance scores, recall from <xref ref-type="disp-formula" rid="E9"><bold>Eqn. 8</bold></xref> that when an <italic>l</italic>-mer <inline-formula id="IE112"><mml:math id="IM112"><mml:mrow><mml:msubsup><mml:mrow><mml:mo>μ</mml:mo></mml:mrow><mml:mi>j</mml:mi><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> in input sequence <italic>S<sub>x</sub></italic> has <italic>m</italic> mismatches with an <italic>l</italic>-mer <inline-formula id="IE113"><mml:math id="IM113"><mml:mrow><mml:msubsup><mml:mrow><mml:mo>μ</mml:mo></mml:mrow><mml:mi>k</mml:mi><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>z</mml:mi></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> in support vector <italic>S<sub>z</sub></italic>, each matching position in <inline-formula id="IE114"><mml:math id="IM114"><mml:mrow><mml:msubsup><mml:mrow><mml:mo>μ</mml:mo></mml:mrow><mml:mi>j</mml:mi><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> can be thought of as contributing <inline-formula id="IE115"><mml:math id="IM115"><mml:mrow><mml:mfrac><mml:mrow><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mi>h</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mi>l</mml:mi><mml:mo>−</mml:mo><mml:mi>m</mml:mi></mml:mrow></mml:mfrac></mml:mrow></mml:math></inline-formula> through the <italic>l</italic>-mer pair <inline-formula id="IE116"><mml:math id="IM116"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mrow><mml:mo>μ</mml:mo></mml:mrow><mml:mi>j</mml:mi><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mo>μ</mml:mo></mml:mrow><mml:mi>k</mml:mi><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>z</mml:mi></mml:msub></mml:mrow></mml:msubsup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> to the dot product <inline-formula id="IE117"><mml:math id="IM117"><mml:mrow><mml:mo>〈</mml:mo><mml:msubsup><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mtext>wgkm</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mtext>wgkm</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>z</mml:mi></mml:msub></mml:mrow></mml:msubsup><mml:mo>〉</mml:mo></mml:mrow></mml:math></inline-formula>. Let us set aside the weights <inline-formula id="IE118"><mml:math id="IM118"><mml:mrow><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> for now and focus on how the term <inline-formula id="IE119"><mml:math id="IM119"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>h</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mi>l</mml:mi><mml:mo>−</mml:mo><mml:mi>m</mml:mi></mml:mrow></mml:mfrac></mml:mrow></mml:math></inline-formula> changes as different bases are substituted in <italic>S<sub>x</sub></italic>. Call this term <inline-formula id="IE120"><mml:math id="IM120"><mml:mrow><mml:mtext>heff</mml:mtext></mml:mrow></mml:math></inline-formula>, for ‘hypothetical effect’—analogous to <inline-formula id="IE121"><mml:math id="IM121"><mml:mrow><mml:mtext>eff</mml:mtext></mml:mrow></mml:math></inline-formula> in <xref ref-type="disp-formula" rid="E9"><bold>Eqn. 8</bold></xref>. Let <italic>B<sub>x</sub></italic> denote a base in <inline-formula id="IE122"><mml:math id="IM122"><mml:mrow><mml:msubsup><mml:mrow><mml:mo>μ</mml:mo></mml:mrow><mml:mi>j</mml:mi><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:msup><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> denote the ‘hypothetical’ alternative to <italic>B<sub>x</sub></italic>, and <italic>B<sub>z</sub></italic> denote the base in <inline-formula id="IE123"><mml:math id="IM123"><mml:mrow><mml:msubsup><mml:mrow><mml:mo>μ</mml:mo></mml:mrow><mml:mi>k</mml:mi><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>z</mml:mi></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> that has the same relative position within the <italic>l</italic>-mer as <italic>B<sub>x</sub></italic> has in <inline-formula id="IE124"><mml:math id="IM124"><mml:mrow><mml:msubsup><mml:mrow><mml:mo>μ</mml:mo></mml:mrow><mml:mi>j</mml:mi><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula>. We define <inline-formula id="IE125"><mml:math id="IM125"><mml:mrow><mml:mtext>heff</mml:mtext></mml:mrow></mml:math></inline-formula> to be the value that <inline-formula id="IE126"><mml:math id="IM126"><mml:mrow><mml:mtext>eff</mml:mtext></mml:mrow></mml:math></inline-formula> would have if we were to substitute <inline-formula id="IE127"><mml:math id="IM127"><mml:mrow><mml:msup><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> for <italic>B<sub>x</sub></italic>. If <inline-formula id="IE128"><mml:math id="IM128"><mml:mrow><mml:msub><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> and <italic>B<sub>x</sub></italic> = <italic>B<sub>z</sub></italic> (that is, if the ‘hypothetical’ base we are looking at is the same as the base that is actually present, and it is a match), we’d have, by definition, that <inline-formula id="IE129"><mml:math id="IM129"><mml:mrow><mml:mtext>heff</mml:mtext><mml:mo>=</mml:mo><mml:mtext>eff</mml:mtext><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mi>h</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mi>l</mml:mi><mml:mo>−</mml:mo><mml:mi>m</mml:mi></mml:mrow></mml:mfrac></mml:mrow></mml:math></inline-formula>. If, instead, we had <inline-formula id="IE130"><mml:math id="IM130"><mml:mrow><mml:msub><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>≠</mml:mo><mml:msup><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE131"><mml:math id="IM131"><mml:mrow><mml:msup><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mi>z</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> (that is, substituting <inline-formula id="IE132"><mml:math id="IM132"><mml:mrow><mml:msup><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> for <italic>B<sub>x</sub></italic> would flip a mismatch to a match), then we’d decrease the number of mismatches <italic>m</italic> by one to get <inline-formula id="IE133"><mml:math id="IM133"><mml:mrow><mml:mtext>heff</mml:mtext><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mi>h</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mi>l</mml:mi><mml:mo>−</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mfrac></mml:mrow></mml:math></inline-formula>. Finally, if we had <inline-formula id="IE134"><mml:math id="IM134"><mml:mrow><mml:msup><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo>≠</mml:mo><mml:msub><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mi>z</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>—that is, <inline-formula id="IE135"><mml:math id="IM135"><mml:mrow><mml:msup><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> is a mismatch to <italic>B<sub>z</sub></italic>—then <inline-formula id="IE136"><mml:math id="IM136"><mml:mrow><mml:msup><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> would not be viewed as contributing through the <italic>l</italic>-mer pair, and we would have <inline-formula id="IE137"><mml:math id="IM137"><mml:mrow><mml:mtext>heff</mml:mtext><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula>. To summarize:
<disp-formula id="E18"><label>(17)</label><mml:math id="M18"><mml:mrow><mml:mtext>heff</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mi>z</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>:</mml:mo><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mtable><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>h</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mi>l</mml:mi><mml:mo>−</mml:mo><mml:mi>m</mml:mi></mml:mrow></mml:mfrac></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo> </mml:mo><mml:mtext>if</mml:mtext><mml:mo> </mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="normal">B</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:msub><mml:mrow><mml:mrow><mml:mo>=</mml:mo><mml:mi mathvariant="normal">B</mml:mi></mml:mrow></mml:mrow><mml:mi>z</mml:mi></mml:msub><mml:mo> </mml:mo><mml:mtext>and</mml:mtext><mml:mo> </mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="normal">B</mml:mi></mml:mrow><mml:mi>z</mml:mi></mml:msub><mml:msup><mml:mrow><mml:mrow><mml:mo>=</mml:mo><mml:mi mathvariant="normal">B</mml:mi></mml:mrow></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>h</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mi>l</mml:mi><mml:mo>−</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mfrac></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo> </mml:mo><mml:mtext>if</mml:mtext><mml:mo> </mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="normal">B</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>≠</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="normal">B</mml:mi></mml:mrow><mml:mi>z</mml:mi></mml:msub><mml:mo> </mml:mo><mml:mtext>and</mml:mtext><mml:mo> </mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="normal">B</mml:mi></mml:mrow><mml:mi>z</mml:mi></mml:msub><mml:msup><mml:mrow><mml:mrow><mml:mo>=</mml:mo><mml:mi mathvariant="normal">B</mml:mi></mml:mrow></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mn>0</mml:mn></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo> </mml:mo><mml:mtext>otherwise</mml:mtext></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mrow></mml:mrow></mml:math></disp-formula></p>
      <p>By replacing <inline-formula id="IE138"><mml:math id="IM138"><mml:mrow><mml:mtext>meff</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mi>z</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> with <inline-formula id="IE139"><mml:math id="IM139"><mml:mrow><mml:mtext>heff</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mi>z</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> everywhere in the Mutation Impact Score formulas defined in Section 5.2, we get the corresponding formulas for the hypothetical importance scores <inline-formula id="IE140"><mml:math id="IM140"><mml:mrow><mml:msubsup><mml:mrow><mml:mo>ϕ</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:mtext>hwgkmsvm</mml:mtext></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE141"><mml:math id="IM141"><mml:mrow><mml:msubsup><mml:mrow><mml:mo>ϕ</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:mtext>hwgkmrbfsvm</mml:mtext></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula>. As before, these hypothetical importance scores can be efficiently computed by modifying the <italic>k</italic>-mer tree depth-first search originally used to compute the output of the gkm-SVM. While the original implementation only performs recursion on <italic>l</italic>-mer pairs for which no more than <italic>d</italic> mismatches have been encountered so far, in order to get the most accurate hypothetical importance scores we should perform recursion on <italic>l</italic>-mer pairs for which up to <italic>d </italic>+<italic> </italic>1 mismatches have been encountered, because a mutation can flip a mismatching position to a match. However, the additional layer of recursion can increase runtime substantially. In practice, we found that hypothetical importance scores derived by only considering recursions on <italic>l</italic>-mer pairs with up to <italic>d</italic> mismatches work well, and that is what we used in this paper.</p>
    </sec>
  </sec>
  <sec>
    <title>6 Results</title>
    <sec>
      <title>6.1 Recovery of predictive motifs from SVM models of simulated regulatory DNA sequences</title>
      <p>To evaluate the performance of different explanation methods, we used the simulated genomics dataset from <xref rid="btz322-B12" ref-type="bibr">Shrikumar <italic>et al.</italic> (2017</xref>). Briefly, 8000 200 bp-long sequences were generated by randomly sampling the letters A, C, G, T with background probabilities of 0.3, 0.2, 0.2 and 0.3 respectively. 0-3 instances of TAL1_known1 (a known motif for TAL1) and GATA1_disc1 (a motif for GATA1 discovered from GATA1 ChIP-seq data) from <xref rid="btz322-B7" ref-type="bibr">Kheradpour and Kellis (2014)</xref> were then embedded into non-overlapping positions in each sequence. 25% of sequences contained both embedded TAL1 motifs and embedded GATA1 motifs and were labeled + 1. The remaining sequences contained either embedded GATA1 motifs only, embedded TAL1 motifs only or did not contain either of the two motifs, and were labeled -1. 10% of sequences were reserved for a testing set, while the remaining were used for training. An SVM with a gkmrbf kernel and parameters <italic>l </italic>=<italic> </italic>6, <italic>k </italic>=<italic> </italic>5 and <italic>d </italic>=<italic> </italic>1 was trained to distinguish the positive set from the negative set (due to the non-additive nature of the interaction between the TAL1 and GATA1 motif, a regular gkm kernel does not perform well on this task). As shown in <xref ref-type="fig" rid="btz322-F5">Figure 5</xref>, the core TAL1 and GATA1 motifs are 6 bp long, hence the choice of <italic>l </italic>=<italic> </italic>6. The gkmrbf-SVM attained 90% auROC.</p>
      <p><xref ref-type="fig" rid="btz322-F2">Figure 2</xref> illustrates the behavior of different algorithms on a sequence containing three GATA1 motifs and one TAL1 motif. For deltaSVM and ISM, the importance of a position was computed as the negative of the mean impact of all 3 possible mutations at that position (positions that produce negative deltas when mutated will therefore receive positive importance). SHAP was run with the following different settings: 2000 samples per example sequence with 20 dinuc-shuffled backgrounds each (for a total of 40 000 model evaluations per sequence), 2000 samples per example sequence with 200 dinuc-shuffled backgrounds each (for a total of 400 000 model evaluations per sequence), and 20 000 samples per example sequence with 20 dinuc-shuffled backgrounds each (for a total of 400 000 model evaluations per sequence). See Section 4.3 for more details on the SHAP algorithm. We found that GkmExplain successfully highlights all GATA1 and TAL1 motifs present in the sequence. DeltaSVM performs very poorly, likely due to the nonlinear nature of the gkmrbf decision function (the nonlinearity is needed to learn the logic that both GATA1 and TAL1 must be present in the sequence for the output to be positive). ISM fails to clearly highlight some individual GATA1 motifs in this sequence, likely because the presence of multiple GATA1 motifs has a saturating effect on the nonlinear decision function. SHAP shows promise at highlighting the relevant motifs, but only when many perturbation samples are used. Unfortunately, at 40 000+ model evaluations per sequence, SHAP has a very slow runtime compared to the other methods (<xref ref-type="fig" rid="btz322-F3">Fig. 3</xref>). To confirm this was not an isolated example, we compared the ability of GkmExplain, ISM and SHAP to identify the embedded motifs across all examples in the test set, and found that GkmExplain does indeed perform better (<xref ref-type="fig" rid="btz322-F4">Fig. 4</xref> and Supplementary <xref ref-type="supplementary-material" rid="sup1">Fig. SA.1</xref>).
</p>
      <fig id="btz322-F3" orientation="portrait" position="float">
        <label>Fig. 3.</label>
        <caption>
          <p>Time taken to compute importance on a single sequence for various algorithms (log scale). Evaluation was done on model and data described in Section 6.1. Runtime estimates for ISM and SHAP are optimistic, as they were calculated by estimating the time required for evaluating the model on a single example and multiplying by the min. number of model evaluations required by each method (i.e. any computational overhead required by the algorithm to synthesize the results of the model evaluations was excluded). For example, ISM requires a min. of 601 model evaluations for a sequence of length 200 (one for the original sequence, and 600 for all three possible mutations at every position). SHAP with 2 K samples per sequence and 20 backgrounds requires a minimum of 40 K model evaluations (see Section 4.3 for more details on the SHAP algorithm)</p>
        </caption>
        <graphic xlink:href="btz322f3"/>
      </fig>
      <fig id="btz322-F4" orientation="portrait" position="float">
        <label>Fig. 4.</label>
        <caption>
          <p>GkmExplain outperforms ISM at identifying GATA1 motifs. A gkmrbf SVM was trained as described in Section 6.1. The 400 positives in the held-out test set were scanned using 10 bp windows (the length of the GATA_disc1 motif). Windows containing a complete embedded GATA_disc1 motif were labeled positive. Windows containing no portion of any embedded motif were labeled negative. All other windows were excluded from analysis. Windows were ranked according to the total importance score produced by the importance scoring method in question, and auROC and auPRC were computed. The GkmExplain method outperforms ISM and SHAP on both metrics. The dashed black line shows the performance of a random classifier. See text for more details</p>
        </caption>
        <graphic xlink:href="btz322f4"/>
      </fig>
      <p>As further confirmation that GkmExplain was able to detect the embedded TAL1 and GATA1 motifs, we supplied GkmExplain-derived importance score profiles across all sequences in the positive set to the recently-developed importance score clustering and aggregation tool TF-MoDISco (<xref rid="btz322-B13" ref-type="bibr">Shrikumar <italic>et al.</italic>, 2018</xref>). Briefly, TF-MoDISco identifies subsequences (termed ‘seqlets’) of high importance in all the input sequences, builds an affinity (similarity) matrix between seqlets using a cross-correlation-like metric, clusters the seqlets using the affinity matrix, and then aggregates aligned seqlets in each cluster to form consolidated motifs. TF-MoDISco accepts both importance score profiles as well as ‘hypothetical’ importance score profiles of multiple sequences. Hypothetical importance scores can be intuitively thought of as revealing the preference of the classifier for seeing alternative bases at any given position in a sequence (see Section 5.3). We also normalized the scores as described in <xref ref-type="supplementary-material" rid="sup1">Supplementary Appendix</xref> SA.3, as we found this improved the results. For comparison, we also ran the motif discovery method of <xref rid="btz322-B5" ref-type="bibr">Ghandi <italic>et al.</italic> (2014)</xref> with default settings. The resulting motifs are shown in <xref ref-type="fig" rid="btz322-F5">Figure 5</xref>. We find that, in contrast to the method of Gandhi <italic>et al.</italic>, TF-MoDISco is able to learn motifs that closely match the true embedded motifs. This is likely because the method of Gandhi <italic>et al.</italic> works by scoring <italic>k</italic>-mers individually and then merging the most predictive <italic>k</italic>-mers, but in this particular simulation, the dependency between the TAL1 and GATA1 motifs causes the scores of <italic>k</italic>-mers calculated in isolation to be unreliable. This is similar to the reason why deltaSVM also produces poor results in this scenario.
</p>
      <fig id="btz322-F5" orientation="portrait" position="float">
        <label>Fig. 5.</label>
        <caption>
          <p>Motifs extracted by running TF-MoDISco on GkmExplain importance scores successfully recovers ground-truth simulated motifs. Letter heights are proportional to the information content of the probabilities across the different bases at that position. The single motif returned by the method of Gandhi <italic>et al.</italic> on this dataset is also shown</p>
        </caption>
        <graphic xlink:href="btz322f5"/>
      </fig>
    </sec>
    <sec>
      <title>6.2 Motif discovery from SVM models of <italic>in vivo</italic> transcription factor binding</title>
      <p>We used GkmExplain to interpret a gkm-SVM trained on ChIP-seq data for the Nanog transcription factor in H1-hESCs. The positive set consisted of 200 bp sequences around the summits of 5647 reproducible Nanog ChIP-seq peaks (we used ‘conservative’ IDR peaks) (<xref rid="btz322-B4" ref-type="bibr">ENCODE Project Consortium, 2012</xref>). The negative set consisted of 200 bp sequences around the summits of ENCODE DNase-seq peaks in H1-hESCs that were not within 1 kb of reproducible Nanog ChIP-seq peaks (we used the union of ‘optimal’ and ‘conservative’ IDR peaks here) in H1-hESCs. To achieve a roughly balanced dataset for training the gkm-SVM, the negative set was subsampled by a factor of 20 to produce 5981 negatives. The held-out test set consisted of regions on chromosomes 1 and 2. The SVM was trained with the gkm kernel using the lsgkm package (<xref rid="btz322-B8" ref-type="bibr">Lee, 2016</xref>). Other parameters were set to their default values (<italic>l </italic>=<italic> </italic>11, <italic>k </italic>=<italic> </italic>7 and <italic>d </italic>=<italic> </italic>3). The model achieved an auROC of 83%.</p>
      <p>GkmExplain was run on the 960 positives in the test set, and the importance scores were supplied to TF-MoDISco. For comparison, we ran HOMER (<xref rid="btz322-B6" ref-type="bibr">Heinz <italic>et al.</italic>, 2010</xref>) and MEME in discriminative mode (<xref rid="btz322-B1" ref-type="bibr">Bailey <italic>et al.</italic>, 2009</xref>) with default settings to find motifs enriched in the full set of 5647 positives relative to the 5981 negatives. We also ran the SVM motif discovery method of <xref rid="btz322-B5" ref-type="bibr">Ghandi <italic>et al.</italic> (2014)</xref> using 11-mers rather than 10-mers (the default setting involving 10-mers failed to produce motifs, likely because our model was trained with 11-mers). The results for motif discovery are shown in <xref ref-type="fig" rid="btz322-F6">Figure 6</xref>. Scores on a few example sequences are shown in <xref ref-type="fig" rid="btz322-F7">Figure 7</xref>. TF-MODISCO+gkmExplain found motifs matching canonical Zic3, Sox2 and Oct4-Sox2-Nanog motifs. Gandhi <italic>et al.</italic> and MEME missed the SOX2 motif. Gandi <italic>et al.</italic> motifs were also far noisier when compared to canonical known motifs. HOMER found multiple partially redundant and often truncated versions for the three motifs.
</p>
      <fig id="btz322-F6" orientation="portrait" position="float">
        <label>Fig. 6.</label>
        <caption>
          <p>Nanog motifs in H1-hESCs derived using TF-MoDISco with GkmExplain scores, HOMER, MEME and the method of Gandhi <italic>et al.</italic> Letter heights are proportional to the information content of the probabilities across the different bases at each position in the motif. ‘Seqlets’ are subsequences of high importance that are used by TF-MoDISco to create motifs (<xref rid="btz322-B13" ref-type="bibr">Shrikumar <italic>et al.</italic>, 2018</xref>). The number of seqlets contained within each TF-MoDISco motif is indicated. The TF-MoDISco motifs were derived using only importance scores from the test set, while HOMER and MEME used the full set of training and test sequences. We find that TF-MoDISco run on GkmExplain importance scores tends to produce consolidated motifs that have a strong resemblance to the canonical motifs. Note that the underlying GkmExplain model used 11-mers, which might be why the Oct4-Sox2-Nanog motif, which is wider than 11 bp, is learned as two separate motifs by TF-MoDISco. Also note that the Sox2 motif, while present in the MEME results, did not meet the E-value threshold for significance and was 9th in the list of 10 motifs, ranking below several non-significant motifs that had very few supporting instances</p>
        </caption>
        <graphic xlink:href="btz322f7"/>
      </fig>
      <fig id="btz322-F7" orientation="portrait" position="float">
        <label>Fig. 7.</label>
        <caption>
          <p>Normalized GkmExplain importance scores on three example sequences that were strongly predicted as being bound by Nanog. The underlying model was trained to distinguish 200 bp sequences centered around the summits of H1-hESC Nanog ChIP-seq peaks from sequences that were accessible in H1-hESCs but were not bound by Nanog. The model used the standard (unweighted) gkm kernel and achieved an auROC of 83%</p>
        </caption>
        <graphic xlink:href="btz322f6"/>
      </fig>
    </sec>
    <sec>
      <title>6.3 Predicting regulatory genetic variants affecting chromatin accessibility</title>
      <p>We trained models using the lsgkm package (<xref rid="btz322-B8" ref-type="bibr">Lee, 2016</xref>) on a DNase-seq dataset in the GM12878 lymphoblastoid cell-line obtained from the deltaSVM website [<ext-link ext-link-type="uri" xlink:href="http://www.beerlab.org/deltasvm/">www.beerlab.org/deltasvm/</ext-link>. <ext-link ext-link-type="uri" xlink:href="http://www.beerlab.org/deltasvm/">http://www.beerlab.org/deltasvm/</ext-link> (Accessed on 10/26/2018)]. It consists of a single positive set containing 22 384 300  bp sequences that overlapped DNase hypersensitive peaks, and five independently-generated negative sets that each matched the size, length distribution, GC-content and repeat-fraction of the positive set. One gkm-SVM and one gkmrbf-SVM were trained for each choice of negative set. For the gkm-SVM and gkmrbf-SVM, we used the parameter settings <italic>l </italic>=<italic> </italic>10, <italic>k </italic>=<italic> </italic>6 and <italic>d </italic>=<italic> </italic>3, consistent with the deltaSVM paper. For the gkmrbf-SVM, we further set the regularization parameter <italic>c</italic> to 10 and the gamma value <italic>g</italic> to 2, as suggested by the lsgkm documentation. Remaining values were left to the lsgkm defaults.</p>
      <p>To assess whether GkmExplain could be used to quantify the functional impact of regulatory genetic variants, we used the same benchmarking dataset of DNase I-sensitivity quantitative trait loci (dsQTLs) in lymphomablastoid cell lines (LCLs) that was used in the deltaSVM paper (<xref rid="btz322-B3" ref-type="bibr">Degner <italic>et al.</italic>, 2012</xref>; <xref rid="btz322-B9" ref-type="bibr">Lee <italic>et al.</italic>, 2015</xref>), consisting of 579 dsQTL SNPs and 28 950 control SNPs. The dsQTL SNPs were each located within their associated 100 bp DNase hypersensitive peak and had an association <italic>P</italic>-value below <inline-formula id="IE142"><mml:math id="IM142"><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mn>10</mml:mn></mml:mrow></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>5</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula>, while the control SNPs each had minor allele frequency above 5% and were randomly sampled from the top 5% of DNase hypersensitive sites.</p>
      <p>We used 4 methods to score dsQTLs and control SNPs: deltaSVM applied to the gkm-SVM, deltaSVM applied to the gkmrbf-SVM, in-silico mutagenesis (ISM) applied to the gkmrbf-SVM, and GkmExplain mutation impact scores (Section 5.2) applied to the gkmrbf-SVM. For ISM and GkmExplain, a window of 51 bp centered on the SNP was used as context. Although we attempted to use SHAP, we found the runtime to be prohibitively large (at a context size of 51 bp, 20 backgrounds per sequence, and 510 samples per sequence, SHAP was taking over 8 min per example; note that these models were substantially larger than the ones used to profile runtimes in <xref ref-type="fig" rid="btz322-F3">Figure 3</xref>). Results are shown in <xref ref-type="fig" rid="btz322-F8">Figure 8</xref>, and GkmExplain scores on example dsQTLs are visualized in <xref ref-type="fig" rid="btz322-F9">Figure 9</xref>. Across the models trained on the 5 independent negative sequence sets, GkmExplain consistently produced the best auPRC (binomial <italic>P</italic>-value = <inline-formula id="IE143"><mml:math id="IM143"><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mn>0.5</mml:mn></mml:mrow></mml:mrow><mml:mn>5</mml:mn></mml:msup><mml:mo>=</mml:mo><mml:mn>0.03125</mml:mn></mml:mrow></mml:math></inline-formula>). Interestingly, we found that deltaSVM applied to the gkmrbf-SVM consistently produced better auRPC than deltaSVM applied to the gkm-SVM, even though <xref rid="btz322-B8" ref-type="bibr">Lee (2016)</xref> found that deltaSVM did not produce improvements when used with the gkmrbf kernel (<xref rid="btz322-B8" ref-type="bibr">Lee, 2016</xref>), possibly due to differences in the dataset and parameter settings. Results for auROC are in <xref ref-type="supplementary-material" rid="sup1">Supplementary Appendix</xref> SA.4.
</p>
      <fig id="btz322-F8" orientation="portrait" position="float">
        <label>Fig. 8.</label>
        <caption>
          <p>GkmExplain Mutation Impact Scores Outperform deltaSVM and ISM at identifying dsQTLs. For each choice of negative set provided in the deltaSVM paper, we trained a gkm-SVM and gkmrbf-SVM. LCL dsQTLs and control SNPs were then scored using four methods: deltaSVM on the gkm-SVM, deltaSVM on the gkmrbf-SVM, ISM on the gkmrbf-SVM and GkmExplain Mutation Impact Scores (Section 5.2) on the gkmrbf-SVM. For ISM and GkmExplain, a 51 bp window centered around the SNP was used as context. The GkmExplain mutation impact scores consistently produce the best auPRC across all 5 choices of the negative set (binomial <italic>P</italic>-value = <inline-formula id="IE144"><mml:math id="IM144"><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mn>0.5</mml:mn></mml:mrow></mml:mrow><mml:mn>5</mml:mn></mml:msup><mml:mo>=</mml:mo><mml:mn>0.03125</mml:mn></mml:mrow></mml:math></inline-formula>). SHAP was excluded from the comparison due to a prohibitively large runtime</p>
        </caption>
        <graphic xlink:href="btz322f8"/>
      </fig>
      <fig id="btz322-F9" orientation="portrait" position="float">
        <label>Fig. 9.</label>
        <caption>
          <p>GkmExplain scores around significant dsQTLs. Pictured are GkmExplain scores around dsQTLs that were identified by GkmExplain at precision levels &gt;75%. The dsQTLs are present at the centers of the sequences, with 25  bp flanks on either side. GkmExplain scores on the sequences with the major and minor alleles are shown in pairs. In the top example, a mutation from C to T disrupts a RELA motif. In the bottom example, a mutation from G to T strengthens an IRF8 motif. The corresponding precision level of deltaSVM for these variants was more than 5% lower than the precision level achieved by GkmExplain</p>
        </caption>
        <graphic xlink:href="btz322f9"/>
      </fig>
    </sec>
  </sec>
  <sec>
    <title>7 Conclusion</title>
    <p>We presented GkmExplain, an algorithm with theoretical connections to Integrated Gradients that can explain the predictions of an SVM trained with various gapped <italic>k</italic>-mer string kernels. On simulated data, GkmExplain outperforms ISM and deltaSVM when used with a nonlinear gapper <italic>k</italic>-mer kernel such as the gkmrbf kernel (<xref ref-type="fig" rid="btz322-F2">Figs 2 and 4</xref> and Supplementary Fig. SA.1), while being far more computationally efficient than ISM or SHAP (<xref ref-type="fig" rid="btz322-F3">Fig. 3</xref>). Importance scores derived through GkmExplain can be supplied to TF-MoDISco (<xref rid="btz322-B13" ref-type="bibr">Shrikumar <italic>et al.</italic>, 2018</xref>) to perform motif discovery (<xref ref-type="fig" rid="btz322-F5">Figs 5 and 6</xref>), resulting in improved recovery of consolidated, non-redundant motifs as compared to previous motif discovery approaches for gkmSVMs (<xref rid="btz322-B5" ref-type="bibr">Ghandi <italic>et al.</italic>, 2014</xref>). Mutation Impact Scores derived from GkmExplain outperform ISM and deltaSVM for identifying regulatory genetic variants (dsQTLs) affecting chromatin accessibility in LCLs. (<xref ref-type="fig" rid="btz322-F8">Fig. 8</xref>). Our approach is not limited to SVM models of genomic sequences and can be generalized to other data modalities, as illustrated in <xref ref-type="supplementary-material" rid="sup1">Supplementary Appendix</xref> SA.5.</p>
  </sec>
  <sec>
    <title>Funding</title>
    <p>AS was funded by HHMI International Student Research and Bio-X Bowes fellowships. AK was funded by National Institute of Health grants 1DP2GM123485, 1U01HG009431 and 1R01HG00967401.</p>
    <p><italic>Conflict of Interest</italic>: none declared.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material content-type="local-data" id="sup1">
      <label>btz322_Supplementary_Data</label>
      <media xlink:href="btz322_supplementary_data.pdf">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
  </sec>
</body>
<back>
  <ref-list id="ref1">
    <title>References</title>
    <ref id="btz322-B1">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Bailey</surname><given-names>T.L.</given-names></name></person-group><etal>et al</etal> (<year>2009</year>) 
<article-title>MEME SUITE: tools for motif discovery and searching</article-title>. <source>Nucleic Acids Res</source>., <volume>37</volume>, <fpage>W202</fpage>–<lpage>W208</lpage>.<pub-id pub-id-type="pmid">19458158</pub-id></mixed-citation>
    </ref>
    <ref id="btz322-B2">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Bromberg</surname><given-names>Y.</given-names></name>, <name name-style="western"><surname>Rost</surname><given-names>B.</given-names></name></person-group> (<year>2008</year>) 
<article-title>Comprehensive in silico mutagenesis highlights functionally important residues in proteins</article-title>. <source>Bioinformatics</source>, <volume>24</volume>, <fpage>i207</fpage>–<lpage>i212</lpage>.<pub-id pub-id-type="pmid">18689826</pub-id></mixed-citation>
    </ref>
    <ref id="btz322-B3">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Degner</surname><given-names>J.F.</given-names></name></person-group><etal>et al</etal> (<year>2012</year>) 
<article-title>DNase I sensitivity QTLs are a major determinant of human expression variation</article-title>. <source>Nature</source>, <volume>482</volume>, <fpage>390</fpage>–<lpage>394</lpage>.<pub-id pub-id-type="pmid">22307276</pub-id></mixed-citation>
    </ref>
    <ref id="btz322-B4">
      <mixed-citation publication-type="journal">ENCODE Project Consortium (<year>2012</year>) 
<article-title>An integrated encyclopedia of DNA elements in the human genome</article-title>. <source>Nature</source>, <volume>489</volume>, <fpage>57</fpage>–<lpage>74</lpage>.<pub-id pub-id-type="pmid">22955616</pub-id></mixed-citation>
    </ref>
    <ref id="btz322-B5">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Ghandi</surname><given-names>M.</given-names></name></person-group><etal>et al</etal> (<year>2014</year>) 
<article-title>Enhanced regulatory sequence prediction using gapped k-mer features</article-title>. <source>PLoS Comput. Biol</source>., <volume>10</volume>, <fpage>e1003711.</fpage><pub-id pub-id-type="pmid">25033408</pub-id></mixed-citation>
    </ref>
    <ref id="btz322-B6">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Heinz</surname><given-names>S.</given-names></name></person-group><etal>et al</etal> (<year>2010</year>) 
<article-title>Simple combinations of lineage-determining transcription factors prime cis-regulatory elements required for macrophage and B cell identities</article-title>. <source>Mol. Cell</source>, <volume>38</volume>, <fpage>576</fpage>–<lpage>589</lpage>.<pub-id pub-id-type="pmid">20513432</pub-id></mixed-citation>
    </ref>
    <ref id="btz322-B7">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Kheradpour</surname><given-names>P.</given-names></name>, <name name-style="western"><surname>Kellis</surname><given-names>M.</given-names></name></person-group> (<year>2014</year>) 
<article-title>Systematic discovery and characterization of regulatory motifs in ENCODE TF binding experiments</article-title>. <source>Nucleic Acids Res</source>., <volume>42</volume>, <fpage>2976</fpage>–<lpage>2987</lpage>.<pub-id pub-id-type="pmid">24335146</pub-id></mixed-citation>
    </ref>
    <ref id="btz322-B8">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Lee</surname><given-names>D.</given-names></name></person-group> (<year>2016</year>) 
<article-title>LS-GKM: a new gkm-SVM for large-scale datasets</article-title>. <source>Bioinformatics</source>, <volume>32</volume>, <fpage>2196</fpage>–<lpage>2198</lpage>.<pub-id pub-id-type="pmid">27153584</pub-id></mixed-citation>
    </ref>
    <ref id="btz322-B9">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Lee</surname><given-names>D.</given-names></name></person-group><etal>et al</etal> (<year>2015</year>) 
<article-title>A method to predict the impact of regulatory variants from DNA sequence</article-title>. <source>Nat. Genet</source>., <volume>47</volume>, <fpage>955</fpage>–<lpage>961</lpage>.<pub-id pub-id-type="pmid">26075791</pub-id></mixed-citation>
    </ref>
    <ref id="btz322-B10">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Leslie</surname><given-names>C.</given-names></name>, <name name-style="western"><surname>Kuang</surname><given-names>R.</given-names></name></person-group> (<year>2004</year>) 
<article-title>Fast String Kernels using inexact matching for protein sequences</article-title>. <source>J. Mach. Learn. Res</source>., <volume>5</volume>, <fpage>1435</fpage>–<lpage>1455</lpage>.</mixed-citation>
    </ref>
    <ref id="btz322-B11">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Lundberg</surname><given-names>S.M.</given-names></name>, <name name-style="western"><surname>Lee</surname><given-names>S.-I.</given-names></name></person-group> (<year>2017</year>) 
<article-title>A unified approach to interpreting model predictions</article-title>. In: Guyon,I. et al. (eds) <italic>Advances in Neural Information Processing Systems 30</italic>. Curran Associates, Inc., pp. 4765–4774.</mixed-citation>
    </ref>
    <ref id="btz322-B12">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><name name-style="western"><surname>Shrikumar</surname><given-names>A.</given-names></name></person-group><etal>et al</etal> (<year>2017</year>) Learning important features through propagating activation differences. In: Doina,P. and Yee,W.T. (eds) <italic>Proceedings of the 34th International Conference on Machine Learning</italic>. Vol. 70. PMLR, Sydney, Australia, pp. 3145–3153.</mixed-citation>
    </ref>
    <ref id="btz322-B13">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><name name-style="western"><surname>Shrikumar</surname><given-names>A.</given-names></name></person-group><etal>et al</etal> (<year>2018</year>) Tf-modisco v0.4.2.2-alpha: Technical note. <italic>CoRR</italic>, abs/1811.00416.</mixed-citation>
    </ref>
    <ref id="btz322-B14">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><name name-style="western"><surname>Sundararajan</surname><given-names>M.</given-names></name></person-group><etal>et al</etal> (<year>2017</year>) Axiomatic attribution for deep networks. In: Doina,P. and Yee,W.T. (eds) <italic>Proceedings of the 34th International Conference on Machine Learning</italic>. Vol. 70. PMLR, Sydney, Australia, pp. 3319–3328.</mixed-citation>
    </ref>
    <ref id="btz322-B16">
      <mixed-citation publication-type="other"><ext-link ext-link-type="uri" xlink:href="http://www.beerlab.org/deltasvm/">www.beerlab.org/deltasvm/</ext-link>. <ext-link ext-link-type="uri" xlink:href="http://www.beerlab.org/deltasvm/">http://www.beerlab.org/deltasvm/</ext-link>. (26 October 2018, date last accessed).</mixed-citation>
    </ref>
    <ref id="btz322-B17">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Zhou</surname><given-names>J.</given-names></name>, <name name-style="western"><surname>Troyanskaya</surname><given-names>O.G.</given-names></name></person-group> (<year>2015</year>) 
<article-title>Predicting effects of noncoding variants with deep learning–based sequence model</article-title>. <source>Nat. Methods</source>, <volume>12</volume>, <fpage>931</fpage>–<lpage>934</lpage>.<pub-id pub-id-type="pmid">26301843</pub-id></mixed-citation>
    </ref>
  </ref-list>
</back>
