<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//NLM//DTD Journal Publishing DTD v2.3 20070202//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName journalpublishing.dtd?>
<?SourceDTD.Version 2.3?>
<?ConverterInfo.XSLTName nlm2jats3.xsl?>
<?ConverterInfo.Version 1?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Front Genet</journal-id>
    <journal-id journal-id-type="iso-abbrev">Front Genet</journal-id>
    <journal-id journal-id-type="publisher-id">Front. Genet.</journal-id>
    <journal-title-group>
      <journal-title>Frontiers in Genetics</journal-title>
    </journal-title-group>
    <issn pub-type="epub">1664-8021</issn>
    <publisher>
      <publisher-name>Frontiers Media S.A.</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">8212059</article-id>
    <article-id pub-id-type="doi">10.3389/fgene.2021.692964</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Genetics</subject>
        <subj-group>
          <subject>Original Research</subject>
        </subj-group>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>GRMT: Generative Reconstruction of Mutation Tree From Scratch Using Single-Cell Sequencing Data</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Yu</surname>
          <given-names>Zhenhua</given-names>
        </name>
        <xref ref-type="aff" rid="aff1">
          <sup>1</sup>
        </xref>
        <xref ref-type="aff" rid="aff2">
          <sup>2</sup>
        </xref>
        <xref ref-type="corresp" rid="c001">
          <sup>*</sup>
        </xref>
        <uri xlink:type="simple" xlink:href="http://loop.frontiersin.org/people/1090079/overview"/>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Liu</surname>
          <given-names>Huidong</given-names>
        </name>
        <xref ref-type="aff" rid="aff1">
          <sup>1</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Du</surname>
          <given-names>Fang</given-names>
        </name>
        <xref ref-type="aff" rid="aff1">
          <sup>1</sup>
        </xref>
        <xref ref-type="aff" rid="aff2">
          <sup>2</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Tang</surname>
          <given-names>Xiaofen</given-names>
        </name>
        <xref ref-type="aff" rid="aff1">
          <sup>1</sup>
        </xref>
        <xref ref-type="aff" rid="aff2">
          <sup>2</sup>
        </xref>
      </contrib>
    </contrib-group>
    <aff id="aff1"><sup>1</sup><institution>School of Information Engineering, Ningxia University</institution>, <addr-line>Yinchuan</addr-line>, <country>China</country></aff>
    <aff id="aff2"><sup>2</sup><institution>Collaborative Innovation Center for Ningxia Big Data and Artificial Intelligence Co-founded by Ningxia Municipality and Ministry of Education, Ningxia University</institution>, <addr-line>Yinchuan</addr-line>, <country>China</country></aff>
    <author-notes>
      <fn fn-type="edited-by">
        <p>Edited by: Ka-Chun Wong, City University of Hong Kong, Hong Kong, China</p>
      </fn>
      <fn fn-type="edited-by">
        <p>Reviewed by: Shixiong Zhang, Xidian University, China; Joao Alves, University of Vigo, Spain</p>
      </fn>
      <corresp id="c001">*Correspondence: Zhenhua Yu <email>zhyu@nxu.edu.cn</email></corresp>
      <fn fn-type="other" id="fn001">
        <p>This article was submitted to Computational Genomics, a section of the journal Frontiers in Genetics</p>
      </fn>
    </author-notes>
    <pub-date pub-type="epub">
      <day>04</day>
      <month>6</month>
      <year>2021</year>
    </pub-date>
    <pub-date pub-type="collection">
      <year>2021</year>
    </pub-date>
    <volume>12</volume>
    <elocation-id>692964</elocation-id>
    <history>
      <date date-type="received">
        <day>09</day>
        <month>4</month>
        <year>2021</year>
      </date>
      <date date-type="accepted">
        <day>17</day>
        <month>5</month>
        <year>2021</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>Copyright © 2021 Yu, Liu, Du and Tang.</copyright-statement>
      <copyright-year>2021</copyright-year>
      <copyright-holder>Yu, Liu, Du and Tang</copyright-holder>
      <license>
        <ali:license_ref xmlns:ali="http://www.niso.org/schemas/ali/1.0/" specific-use="textmining" content-type="ccbylicense">https://creativecommons.org/licenses/by/4.0/</ali:license_ref>
        <license-p>This is an open-access article distributed under the terms of the Creative Commons Attribution License (CC BY). The use, distribution or reproduction in other forums is permitted, provided the original author(s) and the copyright owner(s) are credited and that the original publication in this journal is cited, in accordance with accepted academic practice. No use, distribution or reproduction is permitted which does not comply with these terms.</license-p>
      </license>
    </permissions>
    <abstract>
      <p>Single-cell sequencing (SCS) now promises the landscape of genetic diversity at single cell level, and is particularly useful to reconstruct the evolutionary history of tumor. There are multiple types of noise that make the SCS data notoriously error-prone, and significantly complicate tumor tree reconstruction. Existing methods for tumor phylogeny estimation suffer from either high computational intensity or low-resolution indication of clonal architecture, giving a necessity of developing new methods for efficient and accurate reconstruction of tumor trees. We introduce GRMT (<underline>G</underline>enerative <underline>R</underline>econstruction of <underline>M</underline>utation <underline>T</underline>ree from scratch), a method for inferring tumor mutation tree from SCS data. GRMT exploits the <italic>k</italic>-Dollo parsimony model to allow each mutation to be gained once and lost at most <italic>k</italic> times. Under this constraint on mutation evolution, GRMT searches for mutation tree structures from a perspective of tree generation from scratch, and implements it to an iterative process that gradually increases the tree size by introducing a new mutation per time until a complete tree structure that contains all mutations is obtained. This enables GRMT to efficiently recover the chronological order of mutations and scale well to large datasets. Extensive evaluations on simulated and real datasets suggest GRMT outperforms the state-of-the-arts in multiple performance metrics. The GRMT software is freely available at <ext-link ext-link-type="uri" xlink:href="https://github.com/qasimyu/grmt">https://github.com/qasimyu/grmt</ext-link>.</p>
    </abstract>
    <kwd-group>
      <kwd>next-generation sequencing</kwd>
      <kwd>single-cell sequencing</kwd>
      <kwd>Bayesian optimization</kwd>
      <kwd>intra-tumor heterogeneity</kwd>
      <kwd>tumor tree</kwd>
    </kwd-group>
    <counts>
      <fig-count count="7"/>
      <table-count count="1"/>
      <equation-count count="12"/>
      <ref-count count="39"/>
      <page-count count="13"/>
      <word-count count="8505"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec sec-type="intro" id="s1">
    <title>1. Introduction</title>
    <p>Tumor progression follows a dynamic evolutionary process that is activated by the genetic lesions of a single founder cell (Nowell, <xref rid="B21" ref-type="bibr">1976</xref>). The descendants of the cell gain a growth advantage to resist apoptosis and develop into subclones through accumulation of somatic mutations. After many generations of clonal expansion, distinct cell populations emerge in the tumor and relate with an evolutionary tree that depicts their chronological relationship. Each cell population constitutes a subclone that is uniquely characterized by a complement of genetic mutations. The genetic diversity of the subclones is called as the intra-tumor heterogeneity (Nowell, <xref rid="B21" ref-type="bibr">1976</xref>; Greaves and Maley, <xref rid="B8" ref-type="bibr">2012</xref>; Swanton, <xref rid="B28" ref-type="bibr">2012</xref>), and provides the cues of key mutations that drive tumor growth. Therefore, accurately disentangling the clonal composition and underlying evolutionary relationship is essential for finding the driver mutations (Xi et al., <xref rid="B31" ref-type="bibr">2018</xref>, <xref rid="B32" ref-type="bibr">2020</xref>) that dominate the tumor progression, and helps design of personalized cancer therapies (Stratton et al., <xref rid="B27" ref-type="bibr">2009</xref>; Swanton, <xref rid="B28" ref-type="bibr">2012</xref>).</p>
    <p>With the breakthrough of whole-genome amplification (WGA) (Zong et al., <xref rid="B39" ref-type="bibr">2012</xref>) and single cell isolation (Brasko et al., <xref rid="B1" ref-type="bibr">2018</xref>) technologies, single-cell DNA sequencing (SCS) (Gawad et al., <xref rid="B7" ref-type="bibr">2016</xref>) now promises a high-resolution landscape of the genetic diversity at single cell level. SCS allows for the reconstruction of tumor evolutionary tree by exploiting the mutation profiles of single cells. However, the current WGA procedures in SCS inevitably introduce different types of noise that contribute considerably to the genotyping errors, making the data obtained from SCS experiments notoriously error-prone. Allele dropout (ADO) is a prominent technical issue that results in false negative (FN) errors in SCS data (Navin, <xref rid="B20" ref-type="bibr">2014</xref>). The reported FN rates in current SCS-based studies vary from 0.1 to 0.43 (Hou et al., <xref rid="B9" ref-type="bibr">2012</xref>; Xu et al., <xref rid="B33" ref-type="bibr">2012</xref>; Gawad et al., <xref rid="B6" ref-type="bibr">2014</xref>; Wang et al., <xref rid="B29" ref-type="bibr">2014</xref>). False positive (FP) calls also present with an elevated rate compared to bulk-sequencing. A consensus based trick is often employed to attenuate the effect of FP errors by filtering the mutations only observed in one single cell (Zhang et al., <xref rid="B38" ref-type="bibr">2015</xref>; Zafar et al., <xref rid="B37" ref-type="bibr">2016</xref>), however this approach may result in removal of true biological mutations unique to single cell. Unobserved sites can also be a critical issue caused by ADO and non-uniform coverage. The missing rate may exceed 50% due to the low quality of sequencing data (Hou et al., <xref rid="B9" ref-type="bibr">2012</xref>). Lastly, cell doublets act as another type of noise in SCS data that result from unintended libraries from two or more cells (Roth et al., <xref rid="B24" ref-type="bibr">2016</xref>; Zafar et al., <xref rid="B36" ref-type="bibr">2017</xref>). The cell doublet rate can be as high as 10% in oral pipette and droplet encapsulation cell isolation techniques (Hou et al., <xref rid="B9" ref-type="bibr">2012</xref>; Xu et al., <xref rid="B33" ref-type="bibr">2012</xref>; Macosko et al., <xref rid="B13" ref-type="bibr">2015</xref>). Critically, aforementioned issues often occur together in SCS data, making it much complicated to accurately infer the evolutionary tree.</p>
    <p>There has been a great interest of developing computational tools for reasoning tumor trees by addressing the aforementioned issues in SCS data (Jahn et al., <xref rid="B10" ref-type="bibr">2016</xref>; Kuipers et al., <xref rid="B11" ref-type="bibr">2017</xref>; Zafar et al., <xref rid="B36" ref-type="bibr">2017</xref>, <xref rid="B35" ref-type="bibr">2019</xref>; El-Kebir, <xref rid="B5" ref-type="bibr">2018</xref>; Chen et al., <xref rid="B2" ref-type="bibr">2020</xref>; Myers et al., <xref rid="B19" ref-type="bibr">2020</xref>; Sadeqi Azer et al., <xref rid="B25" ref-type="bibr">2020</xref>). SCITE (Jahn et al., <xref rid="B10" ref-type="bibr">2016</xref>) exploits a Markov Chain Monte Carlo (MCMC) based approach to jointly search the best scoring mutation tree and FN rate. OncoNEM (Ross and Markowetz, <xref rid="B23" ref-type="bibr">2016</xref>) adopts a heuristic search algorithm to find best-performing subclonal tree refined by unobserved clones. SCG (Roth et al., <xref rid="B24" ref-type="bibr">2016</xref>) depends on a hierarchical Bayesian model to group single cells into subclones. These methods are built by following the infinite sites model (ISM) that each site gets mutated only once and the mutation will not be lost once acquired. The assumption may often not hold for human tumor evolution where loss of mutations frequently occurs due to copy number alterations (CNAs). To relax the constraint, SiFit (Zafar et al., <xref rid="B36" ref-type="bibr">2017</xref>) adopts the finite site model (FSM) to permit back mutation and parallel evolution, and infers a maximum likelihood estimation of the cell lineage tree. Another method called BEAM (Miura et al., <xref rid="B17" ref-type="bibr">2018</xref>) aims to improve the quality of SCS data using classical molecular evolutionary phylogenetics without explicit restrictions on evolutionary model. SPhyR (El-Kebir, <xref rid="B5" ref-type="bibr">2018</xref>) infers tumor phylogeny based on the Dollo parsimony evolutionary model (Dollo, <xref rid="B4" ref-type="bibr">1893</xref>) that is slightly more restrictive than FSM and only allows back mutation. As loss of mutations is the main factor that contributes to homoplasy in tumor evolution, the Dollo parsimony model is a good tradeoff between ISM and FSM. Recently, RobustClone (Chen et al., <xref rid="B2" ref-type="bibr">2020</xref>) is proposed to efficiently reconstruct subclonal evolution tree via robust principal component analysis. Several methods additionally incorporate other information to improve tumor tree inference (Satas et al., <xref rid="B26" ref-type="bibr">2020</xref>; Wu, <xref rid="B30" ref-type="bibr">2020</xref>). For instance, ScisTree (Wu, <xref rid="B30" ref-type="bibr">2020</xref>) utilizes genotype uncertainty available from the results of genotype callers to model non-uniformly distributed errors in genotypes.</p>
    <p>While the existing methods perform acceptably well, there are certain drawbacks that limit their applications. First, MCMC based methods like SCITE and SiFit suffer from high computational intensity when applied to large datasets (Chen et al., <xref rid="B2" ref-type="bibr">2020</xref>). Second, methods that search for subclonal trees (e.g., SPhyR and RobustClone) may fail to detect low-prevalence subclones and thus result in an incomplete and low-resolution indication of clonal architecture. Third, most of the existing methods are based on ISM that is not in line with the underlying tumor evolution where loss of mutations occurs frequently. Finally, to the best of our knowledge, mutation tree that represents the highest-resolution indication of tumor evolutionary process is reported by only one method SCITE. As SCITE does not scale well on large datasets, methods for efficient and accurate reconstruction of mutation tree are still highly needed.</p>
    <p>In this study, we introduce a novel method called GRMT for <underline>G</underline>enerative <underline>R</underline>econstruction of <underline>M</underline>utation <underline>T</underline>ree from scratch using SCS data. GRMT employs the <italic>k</italic>-Dollo parsimony model to add a constraint on mutation evolution, i.e., each mutation can be gained once and lost at most <italic>k</italic> times. Unlike previous approaches that yield different tree topologies via structure transformation (e.g., swap of nodes or subtrees), GRMT searches for mutation tree structures from a perspective of tree generation from scratch. Formally, reconstruction of mutation tree is depicted as a generative process that begins with the initial tree that only encompass root node, proceeds with attachment of a new node per time that represents gain or loss of a mutation to the tree, and terminates with the complete structure that contains all mutations. To prevent overfitting, we define a score metric to evaluate the goodness of each tree, and early stopping of tree generation is activated when the monitored metric is less than a pre-defined threshold. In GRMT framework, chronological order of mutations is expressed by a tree growing process, therefore the proposed generative model is intuitively more suitable for deciphering the evolutionary history of the tumor. In addition, we employ Bayesian optimization (BO) algorithm to efficiently infer the error rates in SCS data. We apply GRMT to various simulated datasets to show its superior performance in mutation tree inference, and also demonstrate the effectiveness of GRMT in real data.</p>
  </sec>
  <sec sec-type="materials and methods" id="s2">
    <title>2. Materials and Methods</title>
    <p>Given the observed mutation data <italic>D</italic>, the FP rate (FPR) α and FN rate (FNR) β in <italic>D</italic>, and the parameter <italic>k</italic> of the <italic>k</italic>-Dollo parsimony model, the workflow of reasoning optimal mutation tree is as follows: (1) for each of the <italic>M</italic> mutations, generate <italic>k</italic> + 1 nodes of which one represents gain of the mutation and the rest denote loss of the mutation, yielding in total (<italic>k</italic> + 1)<italic>M</italic> isolated nodes as well as a root node indicating no mutations; (2) initialize the tree <inline-formula><mml:math id="M1"><mml:msubsup><mml:mrow><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mo>*</mml:mo></mml:mrow></mml:msubsup></mml:math></inline-formula> to only contain the root node; (3) generate new trees <inline-formula><mml:math id="M2"><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow></mml:mrow><mml:mrow><mml:mi>t</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> by connecting a free node to the previous tree <inline-formula><mml:math id="M3"><mml:msubsup><mml:mrow><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow></mml:mrow><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mo>*</mml:mo></mml:mrow></mml:msubsup></mml:math></inline-formula>; (4) evaluate all proposals in step 3 to keep the best tree <inline-formula><mml:math id="M4"><mml:msubsup><mml:mrow><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow></mml:mrow><mml:mrow><mml:mi>t</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mo>*</mml:mo></mml:mrow></mml:msubsup></mml:math></inline-formula>; (5) iteratively repeat steps 3 and 4 until there are no free nodes or the score of <inline-formula><mml:math id="M5"><mml:msubsup><mml:mrow><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow></mml:mrow><mml:mrow><mml:mi>t</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mo>*</mml:mo></mml:mrow></mml:msubsup></mml:math></inline-formula> is less than a predefined threshold. During the whole process, a globally optimal tree <inline-formula><mml:math id="M6"><mml:msup><mml:mrow><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow></mml:mrow><mml:mrow><mml:mo>*</mml:mo></mml:mrow></mml:msup></mml:math></inline-formula> is updated when a new better tree is found. The cells are then attached to <inline-formula><mml:math id="M7"><mml:msup><mml:mrow><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow></mml:mrow><mml:mrow><mml:mo>*</mml:mo></mml:mrow></mml:msup></mml:math></inline-formula> via maximizing likelihoods. An illustration of the mutation tree inference procedure is shown in <xref ref-type="fig" rid="F1">Figure 1</xref>. The tree encompassed by dotted lines is the best solution found by our method. The following sections give a description of methodological details of GRMT.</p>
    <fig id="F1" position="float">
      <label>Figure 1</label>
      <caption>
        <p>An illustration of the mutation tree reconstruction procedure adopted in GRMT. Our method generatively recover the mutation tree from a perspective of tree generation from scratch based on the <italic>k</italic>-Dollo parsimony model. <bold>(A)</bold> An example of the observed mutation data with 6 cells and 5 mutations denoted by a 6×5 matrix, the elements 1 and 0 marked in red color represent false positive and false negative, respectively, and the symbol “?” means missing data. <bold>(B)</bold> GRMT generatively rebuilds the mutation tree by iteratively increasing the tree size. Parameters α, β, <italic>k</italic>, λ, and κ are set to 0.077, 0.071, 0, 0.7, and 0.5, respectively. The value contained in each root node denotes <inline-formula><mml:math id="M8"><mml:mi>s</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow></mml:mrow><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mo>*</mml:mo></mml:mrow></mml:msubsup></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> of the best tree <inline-formula><mml:math id="M9"><mml:msubsup><mml:mrow><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow></mml:mrow><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mo>*</mml:mo></mml:mrow></mml:msubsup></mml:math></inline-formula> at time <italic>t</italic>. The tree encompassed by dotted lines is the optimal solution found by our method. <bold>(C)</bold> The cells are attached to mutation tree by maximizing likelihoods, and the value contained in root node of the mutation tree represents the log-likelihood of the observed mutation data.</p>
      </caption>
      <graphic xlink:href="fgene-12-692964-g0001"/>
    </fig>
    <sec>
      <title>2.1. Formulating Mutation Data</title>
      <p>We present the mutation states of <italic>N</italic> cells at <italic>M</italic> genomic loci as a <italic>N</italic> × <italic>M</italic> binary matrix <italic>E</italic>, where <italic>E</italic><sub><italic>ij</italic></sub> = 1 and <italic>E</italic><sub><italic>ij</italic></sub> = 0 denote the presence and absence of mutation <italic>j</italic> in cell <italic>i</italic>, respectively. The observed mutation data <italic>D</italic> is a noisy version of <italic>E</italic>, and the probability distribution of <italic>D</italic><sub><italic>ij</italic></sub> can be formulated as:</p>
      <disp-formula id="E1">
        <label>(1)</label>
        <mml:math id="M10">
          <mml:mtable class="eqnarray" columnalign="left">
            <mml:mtr>
              <mml:mtd>
                <mml:mi>p</mml:mi>
                <mml:mrow>
                  <mml:mo stretchy="false">(</mml:mo>
                  <mml:mrow>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>D</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>i</mml:mi>
                        <mml:mi>j</mml:mi>
                      </mml:mrow>
                    </mml:msub>
                    <mml:mo stretchy="false">|</mml:mo>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>E</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>i</mml:mi>
                        <mml:mi>j</mml:mi>
                      </mml:mrow>
                    </mml:msub>
                  </mml:mrow>
                  <mml:mo stretchy="false">)</mml:mo>
                </mml:mrow>
                <mml:mo>=</mml:mo>
                <mml:mrow>
                  <mml:mo stretchy="true">(</mml:mo>
                  <mml:mrow>
                    <mml:mtable style="text-align:axis;" equalrows="false" columnlines="none none none none none none none none none" equalcolumns="false" class="array">
                      <mml:mtr>
                        <mml:mtd>
                          <mml:mi>p</mml:mi>
                          <mml:mrow>
                            <mml:mo stretchy="false">(</mml:mo>
                            <mml:mrow>
                              <mml:mn>0</mml:mn>
                              <mml:mo stretchy="false">|</mml:mo>
                              <mml:mn>0</mml:mn>
                            </mml:mrow>
                            <mml:mo stretchy="false">)</mml:mo>
                          </mml:mrow>
                        </mml:mtd>
                        <mml:mtd>
                          <mml:mi>p</mml:mi>
                          <mml:mrow>
                            <mml:mo stretchy="false">(</mml:mo>
                            <mml:mrow>
                              <mml:mn>1</mml:mn>
                              <mml:mo stretchy="false">|</mml:mo>
                              <mml:mn>0</mml:mn>
                            </mml:mrow>
                            <mml:mo stretchy="false">)</mml:mo>
                          </mml:mrow>
                        </mml:mtd>
                      </mml:mtr>
                      <mml:mtr>
                        <mml:mtd>
                          <mml:mi>p</mml:mi>
                          <mml:mrow>
                            <mml:mo stretchy="false">(</mml:mo>
                            <mml:mrow>
                              <mml:mn>0</mml:mn>
                              <mml:mo stretchy="false">|</mml:mo>
                              <mml:mn>1</mml:mn>
                            </mml:mrow>
                            <mml:mo stretchy="false">)</mml:mo>
                          </mml:mrow>
                        </mml:mtd>
                        <mml:mtd>
                          <mml:mi>p</mml:mi>
                          <mml:mrow>
                            <mml:mo stretchy="false">(</mml:mo>
                            <mml:mrow>
                              <mml:mn>1</mml:mn>
                              <mml:mo stretchy="false">|</mml:mo>
                              <mml:mn>1</mml:mn>
                            </mml:mrow>
                            <mml:mo stretchy="false">)</mml:mo>
                          </mml:mrow>
                        </mml:mtd>
                      </mml:mtr>
                    </mml:mtable>
                  </mml:mrow>
                  <mml:mo stretchy="true">)</mml:mo>
                </mml:mrow>
                <mml:mo>=</mml:mo>
                <mml:mrow>
                  <mml:mo stretchy="true">(</mml:mo>
                  <mml:mrow>
                    <mml:mtable style="text-align:axis;" equalrows="false" columnlines="none none none none none none none none none" equalcolumns="false" class="array">
                      <mml:mtr>
                        <mml:mtd>
                          <mml:mn>1</mml:mn>
                          <mml:mo>-</mml:mo>
                          <mml:mi>α</mml:mi>
                        </mml:mtd>
                        <mml:mtd>
                          <mml:mi>α</mml:mi>
                        </mml:mtd>
                      </mml:mtr>
                      <mml:mtr>
                        <mml:mtd>
                          <mml:mi>β</mml:mi>
                        </mml:mtd>
                        <mml:mtd>
                          <mml:mn>1</mml:mn>
                          <mml:mo>-</mml:mo>
                          <mml:mi>β</mml:mi>
                        </mml:mtd>
                      </mml:mtr>
                    </mml:mtable>
                  </mml:mrow>
                  <mml:mo stretchy="true">)</mml:mo>
                </mml:mrow>
              </mml:mtd>
            </mml:mtr>
          </mml:mtable>
        </mml:math>
      </disp-formula>
      <p>For ternary mutation matrix <italic>D</italic> whose elements take value from {0, 1, 2}, where 0 denotes normal state, 1 denotes heterozygous mutation, and 2 means that a heterozygous mutation is recorded as homozygous due to allele dropout, we use the similar probability distribution of <italic>D</italic><sub><italic>ij</italic></sub> as adopted in Jahn et al. (<xref rid="B10" ref-type="bibr">2016</xref>):</p>
      <disp-formula id="E2">
        <label>(2)</label>
        <mml:math id="M11">
          <mml:mtable class="eqnarray" columnalign="left">
            <mml:mtr>
              <mml:mtd>
                <mml:mtable style="text-align:axis;" equalrows="false" columnlines="none" equalcolumns="false" class="array">
                  <mml:mtr>
                    <mml:mtd>
                      <mml:mi>p</mml:mi>
                      <mml:mrow>
                        <mml:mo stretchy="false">(</mml:mo>
                        <mml:mrow>
                          <mml:msub>
                            <mml:mrow>
                              <mml:mi>D</mml:mi>
                            </mml:mrow>
                            <mml:mrow>
                              <mml:mi>i</mml:mi>
                              <mml:mi>j</mml:mi>
                            </mml:mrow>
                          </mml:msub>
                          <mml:mo stretchy="false">|</mml:mo>
                          <mml:msub>
                            <mml:mrow>
                              <mml:mi>E</mml:mi>
                            </mml:mrow>
                            <mml:mrow>
                              <mml:mi>i</mml:mi>
                              <mml:mi>j</mml:mi>
                            </mml:mrow>
                          </mml:msub>
                        </mml:mrow>
                        <mml:mo stretchy="false">)</mml:mo>
                      </mml:mrow>
                      <mml:mo>=</mml:mo>
                      <mml:mrow>
                        <mml:mo stretchy="true">(</mml:mo>
                        <mml:mrow>
                          <mml:mtable>
                            <mml:mtr>
                              <mml:mtd>
                                <mml:mi>p</mml:mi>
                                <mml:mrow>
                                  <mml:mo stretchy="false">(</mml:mo>
                                  <mml:mrow>
                                    <mml:mn>0</mml:mn>
                                    <mml:mo stretchy="false">|</mml:mo>
                                    <mml:mn>0</mml:mn>
                                  </mml:mrow>
                                  <mml:mo stretchy="false">)</mml:mo>
                                </mml:mrow>
                              </mml:mtd>
                              <mml:mtd>
                                <mml:mi>p</mml:mi>
                                <mml:mrow>
                                  <mml:mo stretchy="false">(</mml:mo>
                                  <mml:mrow>
                                    <mml:mn>1</mml:mn>
                                    <mml:mo stretchy="false">|</mml:mo>
                                    <mml:mn>0</mml:mn>
                                  </mml:mrow>
                                  <mml:mo stretchy="false">)</mml:mo>
                                </mml:mrow>
                              </mml:mtd>
                              <mml:mtd>
                                <mml:mi>p</mml:mi>
                                <mml:mrow>
                                  <mml:mo stretchy="false">(</mml:mo>
                                  <mml:mrow>
                                    <mml:mn>2</mml:mn>
                                    <mml:mo stretchy="false">|</mml:mo>
                                    <mml:mn>0</mml:mn>
                                  </mml:mrow>
                                  <mml:mo stretchy="false">)</mml:mo>
                                </mml:mrow>
                              </mml:mtd>
                            </mml:mtr>
                            <mml:mtr>
                              <mml:mtd>
                                <mml:mi>p</mml:mi>
                                <mml:mrow>
                                  <mml:mo stretchy="false">(</mml:mo>
                                  <mml:mrow>
                                    <mml:mn>0</mml:mn>
                                    <mml:mo stretchy="false">|</mml:mo>
                                    <mml:mn>1</mml:mn>
                                  </mml:mrow>
                                  <mml:mo stretchy="false">)</mml:mo>
                                </mml:mrow>
                              </mml:mtd>
                              <mml:mtd>
                                <mml:mi>p</mml:mi>
                                <mml:mrow>
                                  <mml:mo stretchy="false">(</mml:mo>
                                  <mml:mrow>
                                    <mml:mn>1</mml:mn>
                                    <mml:mo stretchy="false">|</mml:mo>
                                    <mml:mn>1</mml:mn>
                                  </mml:mrow>
                                  <mml:mo stretchy="false">)</mml:mo>
                                </mml:mrow>
                              </mml:mtd>
                              <mml:mtd>
                                <mml:mi>p</mml:mi>
                                <mml:mrow>
                                  <mml:mo stretchy="false">(</mml:mo>
                                  <mml:mrow>
                                    <mml:mn>2</mml:mn>
                                    <mml:mo stretchy="false">|</mml:mo>
                                    <mml:mn>1</mml:mn>
                                  </mml:mrow>
                                  <mml:mo stretchy="false">)</mml:mo>
                                </mml:mrow>
                              </mml:mtd>
                            </mml:mtr>
                          </mml:mtable>
                        </mml:mrow>
                        <mml:mo stretchy="true">)</mml:mo>
                      </mml:mrow>
                    </mml:mtd>
                  </mml:mtr>
                  <mml:mtr>
                    <mml:mtd>
                      <mml:mtext>                        </mml:mtext>
                      <mml:mo>=</mml:mo>
                      <mml:mrow>
                        <mml:mo stretchy="true">(</mml:mo>
                        <mml:mrow>
                          <mml:mtable style="text-align:axis;" equalrows="false" columnlines="none none none none none none none none none" equalcolumns="false" class="array">
                            <mml:mtr>
                              <mml:mtd>
                                <mml:mn>1</mml:mn>
                                <mml:mo>-</mml:mo>
                                <mml:mi>α</mml:mi>
                                <mml:mo>-</mml:mo>
                                <mml:mi>α</mml:mi>
                                <mml:mi>β</mml:mi>
                                <mml:mo>/</mml:mo>
                                <mml:mn>2</mml:mn>
                              </mml:mtd>
                              <mml:mtd>
                                <mml:mi>α</mml:mi>
                              </mml:mtd>
                              <mml:mtd>
                                <mml:mi>α</mml:mi>
                                <mml:mi>β</mml:mi>
                                <mml:mo>/</mml:mo>
                                <mml:mn>2</mml:mn>
                              </mml:mtd>
                            </mml:mtr>
                            <mml:mtr>
                              <mml:mtd>
                                <mml:mi>β</mml:mi>
                                <mml:mo>/</mml:mo>
                                <mml:mn>2</mml:mn>
                              </mml:mtd>
                              <mml:mtd>
                                <mml:mn>1</mml:mn>
                                <mml:mo>-</mml:mo>
                                <mml:mi>β</mml:mi>
                              </mml:mtd>
                              <mml:mtd>
                                <mml:mi>β</mml:mi>
                                <mml:mo>/</mml:mo>
                                <mml:mn>2</mml:mn>
                              </mml:mtd>
                            </mml:mtr>
                          </mml:mtable>
                        </mml:mrow>
                        <mml:mo stretchy="true">)</mml:mo>
                      </mml:mrow>
                    </mml:mtd>
                  </mml:mtr>
                </mml:mtable>
              </mml:mtd>
            </mml:mtr>
          </mml:mtable>
        </mml:math>
      </disp-formula>
      <p>Given a mutation tree, each cell is attached to the internal node of the tree that maximizes the likelihood of the observed mutation data. Provided that the <italic>i</italic>-th cell is derived from the <italic>n</italic>-th internal node, the likelihood can be calculated as <inline-formula><mml:math id="M12"><mml:mi>p</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msubsup><mml:mrow><mml:mo>∏</mml:mo></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>M</mml:mi></mml:mrow></mml:msubsup><mml:mi>p</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Here <italic>S</italic><sub><italic>n</italic></sub> is a vector with length of <italic>M</italic> and denotes the underlying mutation state associated with the <italic>n</italic>-th internal node. The value of <italic>S</italic><sub><italic>n</italic></sub> can be deduced by traversing the path from the root to the <italic>n</italic>-th internal node that gives the evolution history of mutations along that path. If loss of mutation occurs after a mutation is gained, the corresponding element of <italic>S</italic><sub><italic>n</italic></sub> is set to 0. Suppose the best locations of attachments for all cells are represented by ξ = (ξ<sub>1</sub>, ξ<sub>2</sub>, ..., ξ<sub><italic>N</italic></sub>) under a tree <inline-formula><mml:math id="M13"><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow></mml:math></inline-formula>, then the log-likelihood is given by:</p>
      <disp-formula id="E3">
        <label>(3)</label>
        <mml:math id="M14">
          <mml:mtable class="eqnarray" columnalign="left">
            <mml:mtr>
              <mml:mtd>
                <mml:mi>l</mml:mi>
                <mml:mrow>
                  <mml:mo stretchy="false">(</mml:mo>
                  <mml:mrow>
                    <mml:mi>D</mml:mi>
                    <mml:mo stretchy="false">|</mml:mo>
                    <mml:mrow>
                      <mml:mi mathvariant="script">T</mml:mi>
                    </mml:mrow>
                    <mml:mo>,</mml:mo>
                    <mml:mi>α</mml:mi>
                    <mml:mo>,</mml:mo>
                    <mml:mi>β</mml:mi>
                  </mml:mrow>
                  <mml:mo stretchy="false">)</mml:mo>
                </mml:mrow>
                <mml:mo>=</mml:mo>
                <mml:mstyle displaystyle="true">
                  <mml:munderover accentunder="false" accent="false">
                    <mml:mrow>
                      <mml:mo>∑</mml:mo>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi>i</mml:mi>
                      <mml:mo>=</mml:mo>
                      <mml:mn>1</mml:mn>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi>N</mml:mi>
                    </mml:mrow>
                  </mml:munderover>
                </mml:mstyle>
                <mml:mo class="qopname">log</mml:mo>
                <mml:mrow>
                  <mml:mo stretchy="false">(</mml:mo>
                  <mml:mrow>
                    <mml:mi>p</mml:mi>
                    <mml:mrow>
                      <mml:mo stretchy="false">(</mml:mo>
                      <mml:mrow>
                        <mml:msub>
                          <mml:mrow>
                            <mml:mi>D</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mi>i</mml:mi>
                          </mml:mrow>
                        </mml:msub>
                        <mml:mo stretchy="false">|</mml:mo>
                        <mml:msub>
                          <mml:mrow>
                            <mml:mi>S</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:msub>
                              <mml:mrow>
                                <mml:mi>ξ</mml:mi>
                              </mml:mrow>
                              <mml:mrow>
                                <mml:mi>i</mml:mi>
                              </mml:mrow>
                            </mml:msub>
                          </mml:mrow>
                        </mml:msub>
                      </mml:mrow>
                      <mml:mo stretchy="false">)</mml:mo>
                    </mml:mrow>
                  </mml:mrow>
                  <mml:mo stretchy="false">)</mml:mo>
                </mml:mrow>
              </mml:mtd>
            </mml:mtr>
          </mml:mtable>
        </mml:math>
      </disp-formula>
    </sec>
    <sec>
      <title>2.2. Constructing Mutation Tree</title>
      <p>Given FPR α and FNR β, we aim to find the tree <inline-formula><mml:math id="M15"><mml:msup><mml:mrow><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow></mml:mrow><mml:mrow><mml:mo>*</mml:mo></mml:mrow></mml:msup></mml:math></inline-formula> that best explains the observed mutation data. To explicitly model the loss of mutations due to copy number alterations and loss of heterozygosity that are frequently observed in cancer genomes, the <italic>k</italic>-Dollo parsimony model is employed in GRMT to add a constraint on mutation evolution, i.e., each mutation can be gained once and lost at most <italic>k</italic> times. Formally, the internal nodes of the mutation tree is denoted by a vector <inline-formula><mml:math id="M16"><mml:mrow><mml:mi mathvariant="script">S</mml:mi></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mi>r</mml:mi><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo>+</mml:mo><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo>-</mml:mo><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo>-</mml:mo><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo>-</mml:mo><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo>+</mml:mo><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo>-</mml:mo><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo>-</mml:mo><mml:mo>,</mml:mo><mml:mo>…</mml:mo></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, where <italic>r</italic> signifies the root of the tree, <italic>a</italic>+ represents gain of mutation <italic>a</italic>, and <italic>a</italic>− suggests loss of mutation <italic>a</italic> and appears <italic>k</italic> times in the vector. In addition, the structure of the mutation tree is depicted by a vector <inline-formula><mml:math id="M17"><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow></mml:math></inline-formula> of the same length to <inline-formula><mml:math id="M18"><mml:mrow><mml:mi mathvariant="script">S</mml:mi></mml:mrow></mml:math></inline-formula>, and each element of <inline-formula><mml:math id="M19"><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow></mml:math></inline-formula> indicates the index of parent of the corresponding node in <inline-formula><mml:math id="M20"><mml:mrow><mml:mi mathvariant="script">S</mml:mi></mml:mrow></mml:math></inline-formula> (we use 0 to denote root node and –1 to indicate no parent). The internal nodes of <inline-formula><mml:math id="M21"><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow></mml:math></inline-formula> are denoted by <inline-formula><mml:math id="M22"><mml:mi>V</mml:mi><mml:mtext> </mml:mtext><mml:mo>=</mml:mo><mml:mtext> </mml:mtext><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mi>v</mml:mi><mml:mo>|</mml:mo><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>≠</mml:mo><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
      <p>We start with <inline-formula><mml:math id="M23"><mml:msubsup><mml:mrow><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mo>*</mml:mo></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> that only contains the root node, and iteratively increase the size of the tree through introduction of a new node per time. Specifically, neighborhoods of the precursor tree <inline-formula><mml:math id="M24"><mml:msubsup><mml:mrow><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow></mml:mrow><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mo>*</mml:mo></mml:mrow></mml:msubsup></mml:math></inline-formula> are generated as a set of trees <inline-formula><mml:math id="M25"><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow></mml:mrow><mml:mrow><mml:mi>t</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> where each <inline-formula><mml:math id="M26"><mml:msubsup><mml:mrow><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow></mml:mrow><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi></mml:mrow></mml:msubsup><mml:mo>∈</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow></mml:mrow><mml:mrow><mml:mi>t</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> contains <italic>t</italic>+1 nodes and derives from connecting node <italic>c</italic> to the split point <italic>p</italic> (internal node) of <inline-formula><mml:math id="M27"><mml:msubsup><mml:mrow><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow></mml:mrow><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mo>*</mml:mo></mml:mrow></mml:msubsup></mml:math></inline-formula>, by following the restriction that the node symbolized by <italic>a</italic>− can only be connected to an internal node of <inline-formula><mml:math id="M28"><mml:msubsup><mml:mrow><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow></mml:mrow><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mo>*</mml:mo></mml:mrow></mml:msubsup></mml:math></inline-formula> where mutation <italic>a</italic> has been gained and not yet lost. This results in at most <italic>t</italic>(<italic>Mk</italic> + <italic>M</italic> + 1 − <italic>t</italic>) neighborhoods. To find the most probable tree from all proposals in <inline-formula><mml:math id="M29"><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow></mml:mrow><mml:mrow><mml:mi>t</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>, we propose a metric to score each <inline-formula><mml:math id="M30"><mml:msubsup><mml:mrow><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow></mml:mrow><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi></mml:mrow></mml:msubsup></mml:math></inline-formula>.</p>
      <p>With an assumption of uniform prior probability distribution of cell attachment points, the posterior probability that the <italic>i</italic>-th cell derives from the node <italic>p</italic> of <inline-formula><mml:math id="M31"><mml:msubsup><mml:mrow><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow></mml:mrow><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mo>*</mml:mo></mml:mrow></mml:msubsup></mml:math></inline-formula> is measured as:</p>
      <disp-formula id="E4">
        <label>(4)</label>
        <mml:math id="M32">
          <mml:mtable class="eqnarray" columnalign="left">
            <mml:mtr>
              <mml:mtd>
                <mml:mi>p</mml:mi>
                <mml:mrow>
                  <mml:mo stretchy="false">(</mml:mo>
                  <mml:mrow>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>ξ</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>i</mml:mi>
                      </mml:mrow>
                    </mml:msub>
                    <mml:mo>=</mml:mo>
                    <mml:mi>p</mml:mi>
                    <mml:mo stretchy="false">|</mml:mo>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>D</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>i</mml:mi>
                      </mml:mrow>
                    </mml:msub>
                    <mml:mo>,</mml:mo>
                    <mml:msubsup>
                      <mml:mrow>
                        <mml:mrow>
                          <mml:mi mathvariant="script">T</mml:mi>
                        </mml:mrow>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>t</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mo>*</mml:mo>
                      </mml:mrow>
                    </mml:msubsup>
                  </mml:mrow>
                  <mml:mo stretchy="false">)</mml:mo>
                </mml:mrow>
                <mml:mo>=</mml:mo>
                <mml:mfrac>
                  <mml:mrow>
                    <mml:mi>p</mml:mi>
                    <mml:mrow>
                      <mml:mo stretchy="false">(</mml:mo>
                      <mml:mrow>
                        <mml:msub>
                          <mml:mrow>
                            <mml:mi>D</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mi>i</mml:mi>
                          </mml:mrow>
                        </mml:msub>
                        <mml:mo stretchy="false">|</mml:mo>
                        <mml:msub>
                          <mml:mrow>
                            <mml:mi>ξ</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mi>i</mml:mi>
                          </mml:mrow>
                        </mml:msub>
                        <mml:mo>=</mml:mo>
                        <mml:mi>p</mml:mi>
                        <mml:mo>,</mml:mo>
                        <mml:msubsup>
                          <mml:mrow>
                            <mml:mrow>
                              <mml:mi mathvariant="script">T</mml:mi>
                            </mml:mrow>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mi>t</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mo>*</mml:mo>
                          </mml:mrow>
                        </mml:msubsup>
                      </mml:mrow>
                      <mml:mo stretchy="false">)</mml:mo>
                    </mml:mrow>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mstyle displaystyle="false">
                      <mml:munder class="msub">
                        <mml:mrow>
                          <mml:mo>∑</mml:mo>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi>v</mml:mi>
                          <mml:mo>∈</mml:mo>
                          <mml:msub>
                            <mml:mrow>
                              <mml:mi>V</mml:mi>
                            </mml:mrow>
                            <mml:mrow>
                              <mml:mi>t</mml:mi>
                            </mml:mrow>
                          </mml:msub>
                        </mml:mrow>
                      </mml:munder>
                    </mml:mstyle>
                    <mml:mi>p</mml:mi>
                    <mml:mrow>
                      <mml:mo stretchy="false">(</mml:mo>
                      <mml:mrow>
                        <mml:msub>
                          <mml:mrow>
                            <mml:mi>D</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mi>i</mml:mi>
                          </mml:mrow>
                        </mml:msub>
                        <mml:mo stretchy="false">|</mml:mo>
                        <mml:msub>
                          <mml:mrow>
                            <mml:mi>ξ</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mi>i</mml:mi>
                          </mml:mrow>
                        </mml:msub>
                        <mml:mo>=</mml:mo>
                        <mml:mi>v</mml:mi>
                        <mml:mo>,</mml:mo>
                        <mml:msubsup>
                          <mml:mrow>
                            <mml:mrow>
                              <mml:mi mathvariant="script">T</mml:mi>
                            </mml:mrow>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mi>t</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mo>*</mml:mo>
                          </mml:mrow>
                        </mml:msubsup>
                      </mml:mrow>
                      <mml:mo stretchy="false">)</mml:mo>
                    </mml:mrow>
                  </mml:mrow>
                </mml:mfrac>
              </mml:mtd>
            </mml:mtr>
          </mml:mtable>
        </mml:math>
      </disp-formula>
      <p>where <italic>V</italic><sub><italic>t</italic></sub> denotes the internal nodes of <inline-formula><mml:math id="M33"><mml:msubsup><mml:mrow><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow></mml:mrow><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mo>*</mml:mo></mml:mrow></mml:msubsup></mml:math></inline-formula>. We then calculate the expected number of cells attached to node <italic>p</italic> as:</p>
      <disp-formula id="E5">
        <label>(5)</label>
        <mml:math id="M34">
          <mml:mtable class="eqnarray" columnalign="left">
            <mml:mtr>
              <mml:mtd>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>π</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>p</mml:mi>
                  </mml:mrow>
                </mml:msub>
                <mml:mrow>
                  <mml:mo stretchy="false">(</mml:mo>
                  <mml:mrow>
                    <mml:msubsup>
                      <mml:mrow>
                        <mml:mrow>
                          <mml:mi mathvariant="script">T</mml:mi>
                        </mml:mrow>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>t</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mo>*</mml:mo>
                      </mml:mrow>
                    </mml:msubsup>
                  </mml:mrow>
                  <mml:mo stretchy="false">)</mml:mo>
                </mml:mrow>
                <mml:mo>=</mml:mo>
                <mml:mstyle displaystyle="true">
                  <mml:munderover accentunder="false" accent="false">
                    <mml:mrow>
                      <mml:mo>∑</mml:mo>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi>i</mml:mi>
                      <mml:mo>=</mml:mo>
                      <mml:mn>1</mml:mn>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi>N</mml:mi>
                    </mml:mrow>
                  </mml:munderover>
                </mml:mstyle>
                <mml:mi>p</mml:mi>
                <mml:mrow>
                  <mml:mo stretchy="false">(</mml:mo>
                  <mml:mrow>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>ξ</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>i</mml:mi>
                      </mml:mrow>
                    </mml:msub>
                    <mml:mo>=</mml:mo>
                    <mml:mi>p</mml:mi>
                    <mml:mo stretchy="false">|</mml:mo>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>D</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>i</mml:mi>
                      </mml:mrow>
                    </mml:msub>
                    <mml:mo>,</mml:mo>
                    <mml:msubsup>
                      <mml:mrow>
                        <mml:mrow>
                          <mml:mi mathvariant="script">T</mml:mi>
                        </mml:mrow>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>t</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mo>*</mml:mo>
                      </mml:mrow>
                    </mml:msubsup>
                  </mml:mrow>
                  <mml:mo stretchy="false">)</mml:mo>
                </mml:mrow>
              </mml:mtd>
            </mml:mtr>
          </mml:mtable>
        </mml:math>
      </disp-formula>
      <p>Note that, the tree <inline-formula><mml:math id="M35"><mml:msubsup><mml:mrow><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow></mml:mrow><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi></mml:mrow></mml:msubsup></mml:math></inline-formula> is generated by adding edge &lt; <italic>p, c</italic>&gt; to <inline-formula><mml:math id="M36"><mml:msubsup><mml:mrow><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow></mml:mrow><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mo>*</mml:mo></mml:mrow></mml:msubsup></mml:math></inline-formula>, the expected number of cells transferring from node <italic>p</italic> to node <italic>c</italic> can be measured as:</p>
      <disp-formula id="E6">
        <label>(6)</label>
        <mml:math id="M37">
          <mml:mtable class="eqnarray" columnalign="left">
            <mml:mtr>
              <mml:mtd>
                <mml:msub>
                  <mml:mrow>
                    <mml:mover accent="true">
                      <mml:mrow>
                        <mml:mi>π</mml:mi>
                      </mml:mrow>
                      <mml:mo>¯</mml:mo>
                    </mml:mover>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>p</mml:mi>
                  </mml:mrow>
                </mml:msub>
                <mml:mo>=</mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>π</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>p</mml:mi>
                  </mml:mrow>
                </mml:msub>
                <mml:mrow>
                  <mml:mo stretchy="false">(</mml:mo>
                  <mml:mrow>
                    <mml:msubsup>
                      <mml:mrow>
                        <mml:mrow>
                          <mml:mi mathvariant="script">T</mml:mi>
                        </mml:mrow>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>t</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mo>*</mml:mo>
                      </mml:mrow>
                    </mml:msubsup>
                  </mml:mrow>
                  <mml:mo stretchy="false">)</mml:mo>
                </mml:mrow>
                <mml:mo>-</mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>π</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>p</mml:mi>
                  </mml:mrow>
                </mml:msub>
                <mml:mrow>
                  <mml:mo stretchy="false">(</mml:mo>
                  <mml:mrow>
                    <mml:msubsup>
                      <mml:mrow>
                        <mml:mrow>
                          <mml:mi mathvariant="script">T</mml:mi>
                        </mml:mrow>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>p</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>c</mml:mi>
                      </mml:mrow>
                    </mml:msubsup>
                  </mml:mrow>
                  <mml:mo stretchy="false">)</mml:mo>
                </mml:mrow>
              </mml:mtd>
            </mml:mtr>
          </mml:mtable>
        </mml:math>
      </disp-formula>
      <p>Similarlly, the expected number of cells that are originally located in nodes {<italic>v</italic>|<italic>v</italic> ∈ <italic>V</italic><sub><italic>t</italic></sub>, <italic>v</italic> ≠ <italic>p</italic>} of <inline-formula><mml:math id="M38"><mml:msubsup><mml:mrow><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow></mml:mrow><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mo>*</mml:mo></mml:mrow></mml:msubsup></mml:math></inline-formula> and now attached to node <italic>c</italic> of <inline-formula><mml:math id="M39"><mml:msubsup><mml:mrow><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow></mml:mrow><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi></mml:mrow></mml:msubsup></mml:math></inline-formula> is formulated as:</p>
      <disp-formula id="E7">
        <label>(7)</label>
        <mml:math id="M40">
          <mml:mtable class="eqnarray" columnalign="left">
            <mml:mtr>
              <mml:mtd>
                <mml:msub>
                  <mml:mrow>
                    <mml:mover accent="true">
                      <mml:mrow>
                        <mml:mi>π</mml:mi>
                      </mml:mrow>
                      <mml:mo>~</mml:mo>
                    </mml:mover>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>p</mml:mi>
                  </mml:mrow>
                </mml:msub>
                <mml:mo>=</mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>π</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>c</mml:mi>
                  </mml:mrow>
                </mml:msub>
                <mml:mrow>
                  <mml:mo stretchy="false">(</mml:mo>
                  <mml:mrow>
                    <mml:msubsup>
                      <mml:mrow>
                        <mml:mrow>
                          <mml:mi mathvariant="script">T</mml:mi>
                        </mml:mrow>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>p</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>c</mml:mi>
                      </mml:mrow>
                    </mml:msubsup>
                  </mml:mrow>
                  <mml:mo stretchy="false">)</mml:mo>
                </mml:mrow>
                <mml:mo>-</mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mover accent="true">
                      <mml:mrow>
                        <mml:mi>π</mml:mi>
                      </mml:mrow>
                      <mml:mo>¯</mml:mo>
                    </mml:mover>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>p</mml:mi>
                  </mml:mrow>
                </mml:msub>
              </mml:mtd>
            </mml:mtr>
          </mml:mtable>
        </mml:math>
      </disp-formula>
      <p>Based on above definitions, we propose a score metric to compare different trees in <inline-formula><mml:math id="M41"><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow></mml:mrow><mml:mrow><mml:mi>t</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>:</p>
      <disp-formula id="E8">
        <label>(8)</label>
        <mml:math id="M42">
          <mml:mtable class="eqnarray" columnalign="left">
            <mml:mtr>
              <mml:mtd>
                <mml:mi>s</mml:mi>
                <mml:mrow>
                  <mml:mo stretchy="false">(</mml:mo>
                  <mml:mrow>
                    <mml:msubsup>
                      <mml:mrow>
                        <mml:mrow>
                          <mml:mi mathvariant="script">T</mml:mi>
                        </mml:mrow>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>p</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>c</mml:mi>
                      </mml:mrow>
                    </mml:msubsup>
                  </mml:mrow>
                  <mml:mo stretchy="false">)</mml:mo>
                </mml:mrow>
                <mml:mo>=</mml:mo>
                <mml:mi>λ</mml:mi>
                <mml:msub>
                  <mml:mrow>
                    <mml:mover accent="true">
                      <mml:mrow>
                        <mml:mi>π</mml:mi>
                      </mml:mrow>
                      <mml:mo>¯</mml:mo>
                    </mml:mover>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>p</mml:mi>
                  </mml:mrow>
                </mml:msub>
                <mml:mo>+</mml:mo>
                <mml:mrow>
                  <mml:mo stretchy="false">(</mml:mo>
                  <mml:mrow>
                    <mml:mn>1</mml:mn>
                    <mml:mo>-</mml:mo>
                    <mml:mi>λ</mml:mi>
                  </mml:mrow>
                  <mml:mo stretchy="false">)</mml:mo>
                </mml:mrow>
                <mml:msub>
                  <mml:mrow>
                    <mml:mover accent="true">
                      <mml:mrow>
                        <mml:mi>π</mml:mi>
                      </mml:mrow>
                      <mml:mo>~</mml:mo>
                    </mml:mover>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>p</mml:mi>
                  </mml:mrow>
                </mml:msub>
              </mml:mtd>
            </mml:mtr>
          </mml:mtable>
        </mml:math>
      </disp-formula>
      <p>where λ is a hyper-parameter controlling the weights of the two terms. Conceptually, <inline-formula><mml:math id="M43"><mml:msub><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>π</mml:mi></mml:mrow><mml:mo>¯</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>p</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula> is the direct “cell flow” from node <italic>p</italic> to <italic>c</italic>, and <inline-formula><mml:math id="M44"><mml:msub><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>π</mml:mi></mml:mrow><mml:mo>~</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>p</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula> is the “cell flow” from other nodes to <italic>c</italic> via <italic>p</italic>. We give higher weight (λ &gt; 0.5) to the term <inline-formula><mml:math id="M45"><mml:msub><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>π</mml:mi></mml:mrow><mml:mo>¯</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>p</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula> to encourage tree expansion toward the direction of larger direct “cell flow.” Finally, the best tree at time <italic>t</italic>+1 is inferred as:</p>
      <disp-formula id="E9">
        <label>(9)</label>
        <mml:math id="M46">
          <mml:mtable class="eqnarray" columnalign="left">
            <mml:mtr>
              <mml:mtd>
                <mml:mrow>
                  <mml:msubsup>
                    <mml:mi mathvariant="script">T</mml:mi>
                    <mml:mrow>
                      <mml:mi>t</mml:mi>
                      <mml:mo>+</mml:mo>
                      <mml:mn>1</mml:mn>
                    </mml:mrow>
                    <mml:mo>*</mml:mo>
                  </mml:msubsup>
                  <mml:mo>=</mml:mo>
                  <mml:munder>
                    <mml:mrow>
                      <mml:mi>arg</mml:mi>
                      <mml:mtext> </mml:mtext>
                      <mml:mi>max</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:msub>
                        <mml:mi mathvariant="script">T</mml:mi>
                        <mml:mrow>
                          <mml:mi>t</mml:mi>
                          <mml:mo>+</mml:mo>
                          <mml:mn>1</mml:mn>
                        </mml:mrow>
                      </mml:msub>
                    </mml:mrow>
                  </mml:munder>
                  <mml:mtext> </mml:mtext>
                  <mml:mi>s</mml:mi>
                  <mml:mo stretchy="false">(</mml:mo>
                  <mml:msub>
                    <mml:mi mathvariant="script">T</mml:mi>
                    <mml:mrow>
                      <mml:mi>t</mml:mi>
                      <mml:mo>+</mml:mo>
                      <mml:mn>1</mml:mn>
                    </mml:mrow>
                  </mml:msub>
                  <mml:mo stretchy="false">)</mml:mo>
                </mml:mrow>
              </mml:mtd>
            </mml:mtr>
          </mml:mtable>
        </mml:math>
      </disp-formula>
      <p>A globally best tree <inline-formula><mml:math id="M47"><mml:msup><mml:mrow><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow></mml:mrow><mml:mrow><mml:mo>*</mml:mo></mml:mrow></mml:msup></mml:math></inline-formula> is maintained and updated when a new better tree is found, i.e., <inline-formula><mml:math id="M48"><mml:mi>l</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mi>D</mml:mi><mml:mo>|</mml:mo><mml:msubsup><mml:mrow><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow></mml:mrow><mml:mrow><mml:mi>t</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mo>*</mml:mo></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:mi>α</mml:mi><mml:mo>,</mml:mo><mml:mi>β</mml:mi></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>&gt;</mml:mo><mml:mi>l</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mi>D</mml:mi><mml:mo>|</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow></mml:mrow><mml:mrow><mml:mo>*</mml:mo></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:mi>α</mml:mi><mml:mo>,</mml:mo><mml:mi>β</mml:mi></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. During each iteration, only the probability <inline-formula><mml:math id="M49"><mml:mi>p</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>ξ</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>c</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:msub><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow></mml:mrow><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi></mml:mrow></mml:msubsup></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> needs to be calculated for each cell, therefore the mutation tree can be reconstructed with high efficiency. The tree grows until no free nodes are available or <inline-formula><mml:math id="M50"><mml:mi>s</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow></mml:mrow><mml:mrow><mml:mi>t</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mo>*</mml:mo></mml:mrow></mml:msubsup></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is less than a predefined threshold κ. A brief illustration of the mutation tree inference procedure is provided in Algorithm 1.</p>
    </sec>
    <sec>
      <title>2.3. Inferring the Error Rates</title>
      <p>We formulate finding optimal α and β as the following optimization problem:</p>
      <disp-formula id="E10">
        <label>(10)</label>
        <mml:math id="M66">
          <mml:mtable class="eqnarray" columnalign="left">
            <mml:mtr>
              <mml:mtd>
                <mml:mrow>
                  <mml:mo stretchy="false">(</mml:mo>
                  <mml:msup>
                    <mml:mi>α</mml:mi>
                    <mml:mo>*</mml:mo>
                  </mml:msup>
                  <mml:mo>,</mml:mo>
                  <mml:msup>
                    <mml:mi>β</mml:mi>
                    <mml:mo>*</mml:mo>
                  </mml:msup>
                  <mml:mo stretchy="false">)</mml:mo>
                  <mml:mo>=</mml:mo>
                  <mml:munder>
                    <mml:mrow>
                      <mml:mi>arg</mml:mi>
                      <mml:mtext> </mml:mtext>
                      <mml:mi>max</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi>α</mml:mi>
                      <mml:mo>,</mml:mo>
                      <mml:mi>β</mml:mi>
                    </mml:mrow>
                  </mml:munder>
                  <mml:mtext> </mml:mtext>
                  <mml:mi>f</mml:mi>
                  <mml:mo stretchy="false">(</mml:mo>
                  <mml:mi>α</mml:mi>
                  <mml:mo>,</mml:mo>
                  <mml:mi>β</mml:mi>
                  <mml:mo stretchy="false">)</mml:mo>
                </mml:mrow>
              </mml:mtd>
            </mml:mtr>
          </mml:mtable>
        </mml:math>
      </disp-formula>
      <p>where <inline-formula><mml:math id="M67"><mml:mi>f</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mi>α</mml:mi><mml:mo>,</mml:mo><mml:mi>β</mml:mi></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mi>l</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mi>D</mml:mi><mml:mo>|</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow></mml:mrow><mml:mrow><mml:mo>*</mml:mo></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:mi>α</mml:mi><mml:mo>,</mml:mo><mml:mi>β</mml:mi></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> represents the log-likelihood associated with the best tree <inline-formula><mml:math id="M68"><mml:msup><mml:mrow><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow></mml:mrow><mml:mrow><mml:mo>*</mml:mo></mml:mrow></mml:msup></mml:math></inline-formula> given parameters <italic>x</italic> = (α, β). As the computational complexity of assessing the value of <italic>f</italic>(<italic>x</italic>) is exponentially increased with the data size, the values of <italic>x</italic> should be judiciously selected for evaluation to reduce the computational cost. To achieve this, we propose an approach to generate a priority ordering of the values of <italic>x</italic> to evaluate by developing a search algorithm based on the BO. Formally, we place a Gaussian process (GP) prior on <italic>f</italic>(<italic>x</italic>) to infer it's posterior probability distribution at a candidate point <italic>x</italic>. To find the solution, we first sample <italic>t</italic> candidate points according to an initial space-filling design, and evaluate all points to obtain the values <italic>f</italic>(<italic>x</italic><sub>1:<italic>t</italic></sub>) = [<italic>f</italic>(<italic>x</italic><sub>1</sub>), <italic>f</italic>(<italic>x</italic><sub>2</sub>), …, <italic>f</italic>(<italic>x</italic><sub><italic>t</italic></sub>)]. Leveraging the <italic>t</italic> evaluated points up to now, we compute the posterior probability distribution on <italic>f</italic> as follows:</p>
      <disp-formula id="E11">
        <label>(11)</label>
        <mml:math id="M69">
          <mml:mtable class="eqnarray" columnalign="left">
            <mml:mtr>
              <mml:mtd>
                <mml:mi>f</mml:mi>
                <mml:mrow>
                  <mml:mo stretchy="false">(</mml:mo>
                  <mml:mrow>
                    <mml:mi>x</mml:mi>
                  </mml:mrow>
                  <mml:mo stretchy="false">)</mml:mo>
                </mml:mrow>
                <mml:mo>|</mml:mo>
                <mml:mi>f</mml:mi>
                <mml:mrow>
                  <mml:mo stretchy="false">(</mml:mo>
                  <mml:mrow>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>x</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mn>1</mml:mn>
                        <mml:mo>:</mml:mo>
                        <mml:mi>t</mml:mi>
                      </mml:mrow>
                    </mml:msub>
                  </mml:mrow>
                  <mml:mo stretchy="false">)</mml:mo>
                </mml:mrow>
                <mml:mo>~</mml:mo>
                <mml:mrow>
                  <mml:mi mathvariant="script">N</mml:mi>
                </mml:mrow>
                <mml:mrow>
                  <mml:mo stretchy="false">(</mml:mo>
                  <mml:mrow>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>μ</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>t</mml:mi>
                      </mml:mrow>
                    </mml:msub>
                    <mml:mrow>
                      <mml:mo stretchy="false">(</mml:mo>
                      <mml:mrow>
                        <mml:mi>x</mml:mi>
                      </mml:mrow>
                      <mml:mo stretchy="false">)</mml:mo>
                    </mml:mrow>
                    <mml:mo>,</mml:mo>
                    <mml:msubsup>
                      <mml:mrow>
                        <mml:mi>σ</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>t</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mn>2</mml:mn>
                      </mml:mrow>
                    </mml:msubsup>
                    <mml:mrow>
                      <mml:mo stretchy="false">(</mml:mo>
                      <mml:mrow>
                        <mml:mi>x</mml:mi>
                      </mml:mrow>
                      <mml:mo stretchy="false">)</mml:mo>
                    </mml:mrow>
                  </mml:mrow>
                  <mml:mo stretchy="false">)</mml:mo>
                </mml:mrow>
              </mml:mtd>
            </mml:mtr>
          </mml:mtable>
        </mml:math>
      </disp-formula>
      <p>where the posterior mean μ<sub><italic>t</italic></sub>(<italic>x</italic>) and posterior variance <inline-formula><mml:math id="M70"><mml:msubsup><mml:mrow><mml:mi>σ</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msubsup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> can be computed efficiently using the GP prior (Rasmussen and Williams, <xref rid="B22" ref-type="bibr">2005</xref>).</p>
      <table-wrap id="d24e2112" position="float">
        <label>Algorithm 1</label>
        <caption>
          <p>Algorithm for mutation tree reconstruction. <italic>D</italic> is a mutation matrix representing the observed genotypes of all cells, α is the FPR, β is the FNR, and <italic>k</italic> is the parameter of the <italic>k</italic>-Dollo parsimony model. The algorithm starts with the tree <inline-formula><mml:math id="M51"><mml:msub><mml:mrow><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math></inline-formula> where only the root node presents in the tree and others are free nodes, and terminates if no free nodes are available or the score metric <italic>s</italic> is less than a predefined threshold κ.</p>
        </caption>
        <table frame="hsides" rules="groups">
          <tbody>
            <tr>
              <td align="left" valign="top" rowspan="1" colspan="1">   1:  <bold>function</bold>
<sc>build</sc>M<sc>utation</sc>T<sc>ree</sc>(<italic>D</italic>, α, β, <italic>k</italic>, λ, κ) </td>
            </tr>
            <tr>
              <td align="left" valign="top" rowspan="1" colspan="1">   2:        <bold>Initialize:</bold>
</td>
            </tr>
            <tr>
              <td align="left" valign="top" rowspan="1" colspan="1">   3:        <italic>M</italic>← number of columns of matrix <italic>D</italic>; </td>
            </tr>
            <tr>
              <td align="left" valign="top" rowspan="1" colspan="1">   4:        ζ ← <italic>M</italic>(<italic>k</italic> + 1) + 1; </td>
            </tr>
            <tr>
              <td align="left" valign="top" rowspan="1" colspan="1">   5:        <inline-formula><mml:math id="M52"><mml:msubsup><mml:mrow><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mo>*</mml:mo></mml:mrow></mml:msubsup><mml:mo>←</mml:mo></mml:math></inline-formula> vector (0,-1,-1,.,-1) that has ξ elements; </td>
            </tr>
            <tr>
              <td align="left" valign="top" rowspan="1" colspan="1">   6:        <inline-formula><mml:math id="M53"><mml:msup><mml:mrow><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow></mml:mrow><mml:mrow><mml:mo>*</mml:mo></mml:mrow></mml:msup><mml:mo>←</mml:mo><mml:msubsup><mml:mrow><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mo>*</mml:mo></mml:mrow></mml:msubsup></mml:math></inline-formula>, <inline-formula><mml:math id="M54"><mml:msup><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mo>*</mml:mo></mml:mrow></mml:msup><mml:mo>←</mml:mo><mml:mi>l</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mi>D</mml:mi><mml:mo>|</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow></mml:mrow><mml:mrow><mml:mo>*</mml:mo></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:mi>α</mml:mi><mml:mo>,</mml:mo><mml:mi>β</mml:mi></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>; </td>
            </tr>
            <tr>
              <td align="left" valign="top" rowspan="1" colspan="1">   7:        <bold>for</bold>
<italic>t</italic> = 2 to ζ <bold>do</bold>
</td>
            </tr>
            <tr>
              <td align="left" valign="top" rowspan="1" colspan="1">   8:            generate neighborhoods of the precursor tree <inline-formula><mml:math id="M55"><mml:msubsup><mml:mrow><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow></mml:mrow><mml:mrow><mml:mi>t</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mo>*</mml:mo></mml:mrow></mml:msubsup></mml:math></inline-formula> as <inline-formula><mml:math id="M56"><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow></mml:mrow><mml:mrow><mml:mi>t</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>; </td>
            </tr>
            <tr>
              <td align="left" valign="top" rowspan="1" colspan="1">   9:            calculate score of each tree <inline-formula><mml:math id="M57"><mml:msubsup><mml:mrow><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow></mml:mrow><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi></mml:mrow></mml:msubsup><mml:mo>∈</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow></mml:mrow><mml:mrow><mml:mi>t</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> as <inline-formula><mml:math id="M58"><mml:mi>s</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow></mml:mrow><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi></mml:mrow></mml:msubsup></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mi>λ</mml:mi><mml:msub><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>π</mml:mi></mml:mrow><mml:mo>¯</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>p</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>-</mml:mo><mml:mi>λ</mml:mi></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>π</mml:mi></mml:mrow><mml:mo>~</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>p</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula>; </td>
            </tr>
            <tr>
              <td align="left" valign="top" rowspan="1" colspan="1"> 10:          <inline-formula><mml:math id="M59"><mml:msubsup><mml:mrow><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow></mml:mrow><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mo>*</mml:mo></mml:mrow></mml:msubsup></mml:math></inline-formula> ← <inline-formula><mml:math id="M60"><mml:msub><mml:mrow><mml:mo class="qopname">arg</mml:mo><mml:mo class="qopname">max</mml:mo></mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow></mml:mrow><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi></mml:mrow></mml:msubsup></mml:mrow></mml:msub><mml:mi>s</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow></mml:mrow><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi></mml:mrow></mml:msubsup></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>; </td>
            </tr>
            <tr>
              <td align="left" valign="top" rowspan="1" colspan="1"> 11:          <bold>if</bold>
<inline-formula><mml:math id="M61"><mml:mi>s</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow></mml:mrow><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mo>*</mml:mo></mml:mrow></mml:msubsup></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>&lt;</mml:mo><mml:mi>κ</mml:mi></mml:math></inline-formula>
<bold>then</bold>
</td>
            </tr>
            <tr>
              <td align="left" valign="top" rowspan="1" colspan="1"> 12:            break; </td>
            </tr>
            <tr>
              <td align="left" valign="top" rowspan="1" colspan="1"> 13:          <bold>end</bold>
<bold>if</bold>
</td>
            </tr>
            <tr>
              <td align="left" valign="top" rowspan="1" colspan="1"> 14:          <bold>if</bold>
<inline-formula><mml:math id="M62"><mml:mi>l</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mi>D</mml:mi><mml:mo>|</mml:mo><mml:msubsup><mml:mrow><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow></mml:mrow><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mo>*</mml:mo></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:mi>α</mml:mi><mml:mo>,</mml:mo><mml:mi>β</mml:mi></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>&gt;</mml:mo><mml:msup><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mo>*</mml:mo></mml:mrow></mml:msup></mml:math></inline-formula>
<bold>then</bold>
</td>
            </tr>
            <tr>
              <td align="left" valign="top" rowspan="1" colspan="1"> 15:            <inline-formula><mml:math id="M63"><mml:msup><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mo>*</mml:mo></mml:mrow></mml:msup><mml:mo>←</mml:mo><mml:mi>l</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mi>D</mml:mi><mml:mo>|</mml:mo><mml:msubsup><mml:mrow><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow></mml:mrow><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mo>*</mml:mo></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:mi>α</mml:mi><mml:mo>,</mml:mo><mml:mi>β</mml:mi></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>; </td>
            </tr>
            <tr>
              <td align="left" valign="top" rowspan="1" colspan="1"> 16:            <inline-formula><mml:math id="M64"><mml:msup><mml:mrow><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow></mml:mrow><mml:mrow><mml:mo>*</mml:mo></mml:mrow></mml:msup><mml:mo>←</mml:mo><mml:msubsup><mml:mrow><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow></mml:mrow><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mo>*</mml:mo></mml:mrow></mml:msubsup></mml:math></inline-formula>; </td>
            </tr>
            <tr>
              <td align="left" valign="top" rowspan="1" colspan="1"> 17:          <bold>end</bold>
<bold>if</bold>
</td>
            </tr>
            <tr>
              <td align="left" valign="top" rowspan="1" colspan="1"> 18:      <bold>end</bold>
<bold>for</bold>
</td>
            </tr>
            <tr>
              <td align="left" valign="top" rowspan="1" colspan="1"> 19:      <bold>return</bold>
<inline-formula><mml:math id="M65"><mml:msup><mml:mrow><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow></mml:mrow><mml:mrow><mml:mo>*</mml:mo></mml:mrow></mml:msup></mml:math></inline-formula>; </td>
            </tr>
            <tr>
              <td align="left" valign="top" rowspan="1" colspan="1"> 20:  <bold>end</bold>
<bold>function</bold></td>
            </tr>
          </tbody>
        </table>
      </table-wrap>
      <p>Based on the posterior distribution, we adopt the expected improvement (EI) (Mockus and Mockus, <xref rid="B18" ref-type="bibr">1991</xref>) as the acquisition function to decide the next point <italic>x</italic><sub><italic>t</italic>+1</sub> to evaluate by maximizing the EI function, i.e., <italic>x</italic><sub><italic>t</italic>+1</sub> = argmax<sub><italic>x</italic></sub>EI<sub><italic>t</italic></sub>(<italic>x</italic>). The EI function EI<sub><italic>t</italic></sub>(<italic>x</italic>) measures the expected improvement over the current largest observed value <inline-formula><mml:math id="M71"><mml:msubsup><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mo>*</mml:mo></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mo class="qopname">max</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>≤</mml:mo><mml:mi>t</mml:mi></mml:mrow></mml:msub><mml:mi>f</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and is defined as:</p>
      <disp-formula id="E12">
        <label>(12)</label>
        <mml:math id="M72">
          <mml:mtable class="eqnarray" columnalign="left">
            <mml:mtr>
              <mml:mtd>
                <mml:msub>
                  <mml:mrow>
                    <mml:mtext>EI</mml:mtext>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>t</mml:mi>
                  </mml:mrow>
                </mml:msub>
                <mml:mrow>
                  <mml:mo stretchy="false">(</mml:mo>
                  <mml:mrow>
                    <mml:mi>x</mml:mi>
                  </mml:mrow>
                  <mml:mo stretchy="false">)</mml:mo>
                </mml:mrow>
                <mml:mo>:</mml:mo>
                <mml:mo>=</mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>𝔼</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>t</mml:mi>
                  </mml:mrow>
                </mml:msub>
                <mml:mrow>
                  <mml:mo>[</mml:mo>
                  <mml:mrow>
                    <mml:msup>
                      <mml:mrow>
                        <mml:mrow>
                          <mml:mo>[</mml:mo>
                          <mml:mrow>
                            <mml:mi>f</mml:mi>
                            <mml:mrow>
                              <mml:mo stretchy="false">(</mml:mo>
                              <mml:mrow>
                                <mml:mi>x</mml:mi>
                              </mml:mrow>
                              <mml:mo stretchy="false">)</mml:mo>
                            </mml:mrow>
                            <mml:mo>-</mml:mo>
                            <mml:msubsup>
                              <mml:mrow>
                                <mml:mi>f</mml:mi>
                              </mml:mrow>
                              <mml:mrow>
                                <mml:mi>t</mml:mi>
                              </mml:mrow>
                              <mml:mrow>
                                <mml:mo>*</mml:mo>
                              </mml:mrow>
                            </mml:msubsup>
                          </mml:mrow>
                          <mml:mo>]</mml:mo>
                        </mml:mrow>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mo>+</mml:mo>
                      </mml:mrow>
                    </mml:msup>
                  </mml:mrow>
                  <mml:mo>]</mml:mo>
                </mml:mrow>
              </mml:mtd>
            </mml:mtr>
          </mml:mtable>
        </mml:math>
      </disp-formula>
      <p>where <italic>g</italic><sup>+</sup> = max(<italic>g</italic>, 0) denotes the positive part, and <italic>E</italic><sub><italic>t</italic></sub> represents the expectation taken under the posterior distribution <italic>f</italic>(<italic>x</italic>)|<italic>f</italic>(<italic>x</italic><sub>1:<italic>t</italic></sub>). We repeatedly select a point to evaluate per time by following above presented procedure until the maximum number of steps is reached. Finally, the best values of (α, β) are returned as the solution. We integrate a previously developed BO package (Martinez-Cantin, <xref rid="B15" ref-type="bibr">2014</xref>) into the framework of GRMT for parameter optimization.</p>
    </sec>
    <sec>
      <title>2.4. Simulating Single-Cell Mutation Data</title>
      <p>We simulate single-cell mutation data by first generating a mutation tree and then sampling single cells from the tree. The chronological order of mutations is emulated from a tree growing perspective based on the <italic>k</italic>-Dollo parsimony model. By following the simulation strategy employed in Jahn et al. (<xref rid="B10" ref-type="bibr">2016</xref>), single-cell mutation data are produced from the simulated mutation tree via cell attachment and mutation state inference. Each cell is randomly attached to one of the internal nodes of the mutation tree, and the mutation state of the cell is fetched through exploring the mutation evolution trajectory from the root to the attachment point. The generated mutation data is further tuned according to predefined FP, FN, doublet and missing rates. Detailed description of the simulation procedure is provided in <xref ref-type="supplementary-material" rid="SM1">Supplementary Methods</xref>.</p>
    </sec>
    <sec>
      <title>2.5. Performance Metrics</title>
      <p>To examine the performance of the proposed method in deciphering the underlying genotype matrix (GTM) and the chronological order of mutations, we compare GRMT to four state-of-the-art (SOTA) methods including SCITE, SiFit, SPhyR and RobustClone in various simulated datasets. infSCITE (Kuipers et al., <xref rid="B11" ref-type="bibr">2017</xref>) and SiCloneFit (Zafar et al., <xref rid="B35" ref-type="bibr">2019</xref>) are excluded from performance evaluation as we fail to get their results within an acceptable time frame. Two performance metrics adopted by Miura et al. (<xref rid="B17" ref-type="bibr">2018</xref>) and Chen et al. (<xref rid="B2" ref-type="bibr">2020</xref>) are employed to evaluate the consistency between the predicted and ground truth GTM: (1) the percentage of missing bases (MBs) correctly imputed and (2) the error rate of the GTM. The evaluations are performed with doublet samples excluded. To evaluate the construction errors of mutation trees, two metrics including CASet and DISC proposed by DiNardo et al. (<xref rid="B3" ref-type="bibr">2020</xref>) are utilized to measure distances between the recovered mutation tree and the ground truth. Specifically, we use CASet<sub>∩</sub> and DISC<sub>∩</sub> distances calculated using common mutations of the input trees, and each input tree is preprocessed to aggregate the mutations of which the chronological order is unknown by using the following strategy: (1) if an internal node <italic>p</italic> has only one child node <italic>c</italic> and no cells are attached to <italic>p</italic>, the chronological order of the mutations represented by <italic>p</italic> and <italic>c</italic> is unknown, therefore we aggregate <italic>p</italic> and <italic>c</italic> into a single internal node; and (2) this procedure is repeated until no internal nodes meet the condition. An example is illustrated in <xref ref-type="supplementary-material" rid="SM1">Supplementary Figure 1</xref>. The performance of mutation tree construction of GRMT, SCITE, and SPhyR are compared. The specific formulations for the evaluation metrics are provided in <xref ref-type="supplementary-material" rid="SM1">Supplementary Methods</xref>.</p>
    </sec>
    <sec>
      <title>2.6. Simulated and Real Data</title>
      <p>We build 6 simulated datasets (denoted by D1-D6) under different scenarios defined by several controlling factors: number of cells <italic>N</italic>, number of mutations <italic>M</italic>, FPR α, FNR β, missing rate η, doublet rate ρ and parameter <italic>k</italic> of the <italic>k</italic>-Dollo parsimony model. Each dataset is generated by changing at most two of the factors while keeping the remaining fixed. The default values are set to <italic>N</italic> = 200, <italic>M</italic> = 200, α = 0.01, β = 0.2, η = 0.1, ρ = 0.1, and <italic>k</italic> = 0, unless indicated otherwise. The specific settings for each dataset are as follows: β ∈ {0.1, 0.2, 0.3} for D1, η ∈ {0.1, 0.2, 0.3} for D2, <italic>N</italic> ∈ {100, 500, 1,000} for D3, <italic>M</italic> ∈ {100, 500, 1,000} for D4, <italic>M</italic> ∈ {100, 200} and <italic>k</italic> = 1 for D5, ρ = 0 and β ∈ (0.05, 0.3) for D6. In addition, 50 replicates of mutation trees are simulated per pair (<italic>M</italic>, <italic>k</italic>) for datasets D1-D5, and 100 mutation trees are generated for dataset D6. This results in 1100 GTMs for comprehensively evaluating the performance of GRMT. We also obtain real SCS data of a metastatic colorectal cancer (Leung et al., <xref rid="B12" ref-type="bibr">2017</xref>) and a high grade serous ovarian cancer (McPherson et al., <xref rid="B16" ref-type="bibr">2016</xref>; Roth et al., <xref rid="B24" ref-type="bibr">2016</xref>) to further examine the effectiveness of GRMT.</p>
    </sec>
    <sec>
      <title>2.7. Evaluations</title>
      <p>We first apply GRMT and other methods to simulated datasets D1-D5 generated under various conditions. The FPR and FNR required as the inputs of each method are set to the ground truth values. For SCITE and SiFit, the number of restarts and length of each MCMC chain are set to 3 and 200,000, respectively, and all other parameters use the default values. We adopt the default settings as documented in SPhyR and RobustClone. The hyper-parameters are configured as λ = 0.7 and κ = 1 for GRMT on both simulated and real datasets. The performance metrics quantifying the quality of recovered GTM and mutation tree are measured to make a comparison between different methods. We then assess the ability of GRMT in accurately estimating the FNR on simulated dataset D6.</p>
    </sec>
  </sec>
  <sec sec-type="results" id="s3">
    <title>3. Results</title>
    <sec>
      <title>3.1. Systematic Evaluation on Simulated Data</title>
      <sec>
        <title>3.1.1. The Effect of FN Errors</title>
        <p>We first evaluate the effect of FN errors on GTM and mutation tree inferences, and make a comparison between different methods on the dataset D1. As shown in <xref ref-type="fig" rid="F2">Figure 2</xref>, the distributions of four performance metrics are analyzed under different β values in {0.1, 0.2, 0.3}. It is observed that the ratio of correctly imputed MBs consistently decreases with the β for all methods. For instance, SiFit yields 95.22, 94.6, and 94.48% median accuracies when β changes from 0.1 to 0.3. SCITE outperforms other existing methods on all evaluations with median accuracy ranging from 98.19 to 98.75%. Compared to the competitors, our method achieves high robustness against β value. It delivers a median accuracy of 98.92% at β = 0.1, and results in 0.51% accuracy loss when β increases to 0.3. Further comparison results between the predicted GTM and ground truth indicate the proposed method has enhanced ability to precisely correct erroneous mutation calls. GRMT presents better results than SiFit, SPhyR and RobustClone by reducing the error rate by a large margin across all investigated β values, and also exhibits advantage over SCITE. In addition, analysis of CASet and DISC distances between the reconstructed and ground truth mutation trees gives similar comparison results. Since SPhyR primarily aims to infer subclonal trees, it results in low-resolution profiles of the mutation trees that present relatively low similarity to the ground truth. SCITE achieves more robust results than SPhyR, the median value of CASet distance increases from 0.083 at β = 0.1 to 0.13 at β = 0.3, and the DISC metric is also better than that of SPhyR. By comparison, our method generates more consistent mutation tree structure across all testing conditions. For instance, the median CASet distance is as low as 0.036 at β = 0.1 and 0.058 at β = 0.3, and the corresponding DISC distances are also smaller than those of SCITE (0.129 vs. 0.226 and 0.226 vs. 0.351). The comparison results suggest our method is able to cope with FN errors in SCS data.</p>
        <fig id="F2" position="float">
          <label>Figure 2</label>
          <caption>
            <p>Performance comparison results of different methods in inferring GTM and tumor tree on simulated datasets. Four performance metrics including proportion of correctly imputed MBs, error rate of recovered mutation data, CASet and DISC distances measuring quality of reconstructed tumor tree are calculated with respect to each of four controlling factors. These factors include false negative rate (β), missing rate (η), number of cells (<italic>N</italic>) and number of mutations (<italic>M</italic>).</p>
          </caption>
          <graphic xlink:href="fgene-12-692964-g0002"/>
        </fig>
      </sec>
      <sec>
        <title>3.1.2. The Effect of Missing Data</title>
        <p>We then evaluate the effect of missing data on the GTM and mutation tree reasoning on the dataset D2. Similar evaluation strategy is applied to benchmarking tests under different η values in {0.1, 0.2, 0.3}. Compared to the results on evaluation of β, SiFit, SPhyR and RobustClone show smaller variances in recovering GTMs with respect to η as shown in <xref ref-type="fig" rid="F2">Figure 2</xref>, implying their higher robustness against missing rate than FNR. SCITE performs best among the existing methods by effectively eliminating the effects of missing data, and delivers the lowest variance in each metric with respect to η. By comparison, our method produces results comparable to SICTE by correctly interpolating at least 98.3% missing entries and reducing error rate to below 0.01 on most tests. For reconstructing mutation tree, SPhyR, SCITE and GRMT show similar performance as in correcting FN errors on dataset D1, and our method still gets better results than the competitors. For instance, the median values of CASet distances derived from GRMT, SCITE and SPhyR are 0.073, 0.132, and 0.208 at η = 0.3, respectively, and the corresponding DISC distances are 0.248, 0.363, and 0.428. These results indicate our method has superior performance in imputing missing data.</p>
      </sec>
      <sec>
        <title>3.1.3. The Effect of Number of Cells and Mutations</title>
        <p>We proceed to assess the effectiveness of GRMT on large SCS datasets D3 and D4. As expected, GRMT and SCITE yield improved results when more cells are employed to recover the GTM and mutation tree. For instance, our method reduces the median error rate from 0.89% at <italic>N</italic> = 100 to 0.32% at <italic>N</italic> = 1000, representing an elevated capability when compared to SCITE (corresponding values are 1.09 and 0.36%). The performance of SiFit tends to deteriorate when the number of cells increases, which may result from under-convergence of the model caused by the high computational complexity in inferring lineage relationship among a large number of cells. SPhyR outperforms SiFit and RobustClone at larger values of <italic>N</italic>, and shows better robustness to the change in number of cells.</p>
        <p>The number of mutations also acts as one of the main factors that heavily affect the results of existing methods. With more mutations incorporated into the analysis, the mutational difference between cells get enhanced and the effects of technical errors are substantially attenuated, enabling an elevated accuracy of SiFit, SPhyR and RobustClone as depicted in <xref ref-type="fig" rid="F2">Figure 2</xref>. SCITE performs comparably to GRMT at <italic>M</italic> = 100, but shows degraded capability at larger values of <italic>M</italic> due to low efficiency of the MCMC scheme in deciphering evolutionary history of a large number of mutations. Generally, our method presents best results under different test conditions, and gains higher robustness to the change in number of mutations. For instance, the errors in GTM are corrected to account for a small median percent of 0.35 at <italic>M</italic> = 1,000, and the CASet distance slightly increases from 0.039 at <italic>M</italic> = 100 to 0.051 at <italic>M</italic> = 1,000.</p>
      </sec>
      <sec>
        <title>3.1.4. Evaluation on Mutation Loss Data</title>
        <p>To examine the ability of reasoning tumor evolutionary history involved with mutation loss, we apply GRMT to dataset D5. We run GRMT under two ways, i.e., <italic>k</italic> = 0 and <italic>k</italic> = 1, and compare the resulting metrics with the SOTAs. As shown in <xref ref-type="fig" rid="F3">Figure 3</xref>, with <italic>k</italic> = 1 GRMT shows better metrics when compared to the results with <italic>k</italic> = 0, and yields generally better inferences than the ISM based methods. For instance, the median values of the CASet distance derived from GRMT (<italic>k</italic> = 1), GRMT (<italic>k</italic> = 0), SCITE and SPhyR on 200 × 100 GTMs are 0.046, 0.055, 0.068, and 0.119, respectively, and the corresponding values on 200 × 200 GTMs are 0.045, 0.053, 0.106, and 0.142. The overall performance of GRMT with either <italic>k</italic> = 0 or <italic>k</italic> = 1 is better than the competitors, especially in deducing the underlying mutation trees.</p>
        <fig id="F3" position="float">
          <label>Figure 3</label>
          <caption>
            <p>Comparison results on mutation loss data. The performance of GRMT gets improved when modeling loss of mutation with <italic>k</italic> = 1. The evaluations are performed on 200 × 100 and 200 × 200 GTMs.</p>
          </caption>
          <graphic xlink:href="fgene-12-692964-g0003"/>
        </fig>
      </sec>
      <sec>
        <title>3.1.5. Estimating the False Negative Rate</title>
        <p>To examine the ability of GRMT in estimating the FNR, we apply GRMT to dataset D6. For the BO algorithm, the number of initial sampling points and iterations is set to 50 and 15, respectively. The results depicted in <xref ref-type="fig" rid="F4">Figure 4</xref> imply the FNR is accurately estimated by GRMT with high correlation (correlation coefficient of 0.94 and <italic>p</italic>-value of 1.88 × 10<sup>−48</sup>) to the ground truth that generates the data, suggesting GRMT performs well in inferring FNR from the highly disturbed mutation data.</p>
        <fig id="F4" position="float">
          <label>Figure 4</label>
          <caption>
            <p>Comparison between estimated FNR and the ground truth. GRMT accurately estiamtes the FNR with high correlation to the ground truth that generates the data.</p>
          </caption>
          <graphic xlink:href="fgene-12-692964-g0004"/>
        </fig>
      </sec>
      <sec>
        <title>3.1.6. The Effect of Hyper-Parameters</title>
        <p>The parameters λ and κ are two important hyper-parameters in GRMT, and control the expansion direction and depth of the mutation tree, respectively. To investigate the effect of λ and κ on inference results, we compare the performance metrics under different combinations of λ and κ values. The λ changes from 0.6 to 0.85, and κ varies from 0.4 to 10. The produced dataset consists of 50 100 × 100 GTMs per (λ, κ) pair, for which the mean value of each metric is measured. As shown in <xref ref-type="fig" rid="F5">Figure 5</xref>, each metric changes obviously with κ, and shows similar patterns across different λ values. The recovered GTM yields the best results when λ = 0.7 and κ ≤ 1, while presents dropped accuracy with κ &gt; 1 across all λ values. Since larger κ values will result in early stopping of the tree expansion, the cells near to ends of the branches cannot be correctly attached to right positions of the mutation tree, which contributes to the elevated error rate of the GTM. Inversely, small κ value encourages depth expansion of the tree, thus gives a relatively high probability of introducing unexpected edges that violate to the ground truth. As expected, the CASet distance approximately follows a V shaped relationship with κ and the minimum is reached near κ = 1.8. The inferred mutation tree exhibits decreased DISC distance with the baseline tree when κ increases from 0.4 to 3, and shows little changes in DISC distance at κ &gt; 3. Taken together, (λ = 0.7, κ = 1) is an appropriate choice that provides a good tradeoff among different metrics.</p>
        <fig id="F5" position="float">
          <label>Figure 5</label>
          <caption>
            <p>Analysis of the effects of hyper-parameters λ and κ on inference results of GRMT. The λ changes from 0.6 to 0.85, and κ varies from 0.4 to 2. Four performance metrics are measured under different (λ, κ) pairs.</p>
          </caption>
          <graphic xlink:href="fgene-12-692964-g0005"/>
        </fig>
        <p>In addition, we examine the performance of GRMT and the competitors on various simulated mutation trees with different levels of structural complexity. The structural complexity of mutation tree is controlled by parameter γ as described in <xref ref-type="supplementary-material" rid="SM1">Supplementary Methods</xref>. The results in <xref ref-type="supplementary-material" rid="SM1">Supplementary Figures 2, 3</xref> demonstrate our method is more accurate in handling mutation trees with complex structure. More details on the evaluations can be found in <xref ref-type="supplementary-material" rid="SM1">Supplementary Results</xref>.</p>
      </sec>
      <sec>
        <title>3.1.7. Runtime Performance</title>
        <p>We analyze the computational efficiency of the investigated methods on datasets D3 and D4. <xref ref-type="fig" rid="F6">Figure 6</xref> shows the results of elapsed time of each method respect to the number of cells and mutations. It is observed that GRMT presents comparable performance with SPhyR and RobustClone, and is significantly more efficient than SCITE and SiFit. For instance, GRMT requires average 65 s to process 1000 × 200 mutation data, while SCITE and SiFit need 2,864 and 9,265 s, respectively. To further examine the efficiency of GRMT on larger datasets, we simulate a dataset consisting of 2,000 × 500 GTMs with α = 0.01, β = 0.2, η = 0.1, and ρ = 0.1. The calculated performance metrics shown in <xref ref-type="supplementary-material" rid="SM1">Supplementary Figure 4</xref> indicate our method outperforms the competitors in all performance metrics. The average per-sample processing time of GRMT, SCITE and SiFit are 7, 270, and 1,974 min, respectively, suggesting GRMT scales well to large datasets.</p>
        <fig id="F6" position="float">
          <label>Figure 6</label>
          <caption>
            <p>Computational efficiency of the investigated methods. The running time with respect to each of the two controlling factors including number of cells (<italic>N</italic>) and number of mutations (<italic>M</italic>) are measured.</p>
          </caption>
          <graphic xlink:href="fgene-12-692964-g0006"/>
        </fig>
      </sec>
    </sec>
    <sec>
      <title>3.2. Reconstructing Evolutionary Histories From Real Data</title>
      <sec>
        <title>3.2.1. Applying GRMT to Metastatic Colorectal Cancer Dataset</title>
        <p>We use GRMT to recover the evolutionary history of a metastatic colorectal cancer from patient CRC1 (Leung et al., <xref rid="B12" ref-type="bibr">2017</xref>). The dataset contains 178 single cells sampled from primary and metastatic cancer tissues. Variant calling finds 16 single-nucleotide variants (SNVs) from the cells, resulting in a 178 × 16 binary mutation matrix with approximately 6.7% missing rate. The FPR and FNR are estimated as α = 1.52 and β = 7.89%, respectively.</p>
        <p>We first test GRMT under the ISM assumption, i.e., <italic>k</italic> = 0. With the fixed error rates (α = 1.52%, β = 7.89%), GRMT achieves a log-likelihood of –396.11 and the inferred mutation tree is depicted in <xref ref-type="supplementary-material" rid="SM1">Supplementary Figure 5</xref>. Previous studies (Zafar et al., <xref rid="B36" ref-type="bibr">2017</xref>; El-Kebir, <xref rid="B5" ref-type="bibr">2018</xref>) have reported identification of three subclones with somatic mutations as well as the population without mutations, we mark each population with a specific color. Most of the diploid cells are attached to the root of the mutation tree (marked in gray), implying they are normal stromal cells. The tumor is initiated by the mutation in the <italic>KRAS</italic> oncogene, and develops with the subsequent mutations in the <italic>APC</italic> and <italic>TP53</italic> tumor suppressor genes. These mutations delineate the first subclone (marked in blue) consisting mostly of diploid cells. Subsequent mutations acquired in genes like the <italic>ROBO2</italic> tumor suppressor gene and <italic>CCNE1</italic> oncogene result in emergence of the second subclone (marked in green) that contains mostly primary aneuploid cells. Further accumulation of mutations in <italic>ZNF521, TRRAP</italic>, and <italic>RBFOX1</italic> result in the metastatic clade that forms the third subclone (marked in red), and mark the point of tumor dissemination to the liver. The subclone consists of metastatic cells only, and most of cells acquire additional mutations in <italic>EYS</italic> and <italic>GATA1</italic> genes. By learning the error rates from the data, our method achieves a higher log-likelihood of –351.96, and estimates the parameters as α = 1.04 and β = 7.90%, respectively. The reconstructed mutation tree in <xref ref-type="supplementary-material" rid="SM1">Supplementary Figure 6</xref> suggests approximately one-third of the primary aneuploid cells have the <italic>TPM4</italic> mutation and constitute a separate clade of the second subclone.</p>
        <p>We then evaluate GRMT by allowing each mutation to be lost at most one time, i.e., <italic>k</italic> = 1. Under the fixed error rates (α = 1.52%, β = 7.89%), GRMT gets a elevated log-likelihood of -314.06. The recovered mutation tree in <xref ref-type="fig" rid="F7">Figure 7</xref> implies there are 11 mutation losses, and loss of mutation events mainly occur in the primary and metastatic aneuploid cells. For instance, the mutation in <italic>POU2AF1</italic> acquired in the primary aneuploid cells is lost in 5 metastatic cells. The evolutionary branches associated with loss of mutation enhance the resolution of clonal architecture by refining the inner-clone cell diversity. We further analyze the results derived from learning the error rates from the data. GRMT yields a significantly improved log-likelihood of –282.09 with α and β estimated as 1.07 and 5.72%, respectively. The inferred mutation tree in <xref ref-type="supplementary-material" rid="SM1">Supplementary Figure 7</xref> contains 10 mutation losses, and also suggests the mutation in <italic>TPM4</italic> only occurs in the primary aneuploid cells.</p>
        <fig id="F7" position="float">
          <label>Figure 7</label>
          <caption>
            <p>Mutation tree inferred by GRMT with α = 1.52%, β = 7.89% and <italic>k</italic> = 1 on metastatic colorectal cancer dataset. GRMT yields a improved log-likelihood of –314.06. The tree contains 11 mutation losses (prefixed by “”), and loss of mutation mainly occur in the primary and metastatic aneuploid cells. The normal population (marked in gray) consists of diploid cells, the first subclone (marked in blue) consists mostly of diploid cells, the second subclone (marked in green) contains mostly primary aneuploid cells, and the third subclone (marked in red) consists of metastatic cells only.</p>
          </caption>
          <graphic xlink:href="fgene-12-692964-g0007"/>
        </fig>
        <p>SCITE is also applied on this dataset with α = 1.52% and β = 7.89%. SCITE outputs a mutation tree (shown in <xref ref-type="supplementary-material" rid="SM1">Supplementary Figure 8</xref>) with a log-likelihood of –337.71. It also identifies the three subclones and the normal population following similar evolutionary patterns as the ones inferred by GRMT.</p>
      </sec>
      <sec>
        <title>3.2.2. Applying GRMT to High Grade Serous Ovarian Cancer Dataset</title>
        <p>We further examine GRMT on a high grade serous ovarian cancer (HGSOC) dataset (McPherson et al., <xref rid="B16" ref-type="bibr">2016</xref>; Roth et al., <xref rid="B24" ref-type="bibr">2016</xref>). The original HGSOC dataset consists of 420 cells and 43 mutations. Following the previously adopted strategy (Roth et al., <xref rid="B24" ref-type="bibr">2016</xref>), we exclude low-quality cells that show high rates of mutation missing, resulting in a 392 × 43 GTM with 8.6% missing rate. Due to the FPR and FNR are unknown for this dataset, we use GRMT to jointly infer the error rates and the mutation tree with <italic>k</italic> ∈ {0, 1}. With <italic>k</italic> = 0, our method estimates the α and β as 4.39% and 34.1% with a log-likelihood of -7320.5. The reconstructed mutation tree in <xref ref-type="supplementary-material" rid="SM1">Supplementary Figure 9</xref> provides a high-resolution landscape of the clonal architecture, and suggests multiple highly divergent subclones exists in the tumor, which is similar to the previously reported result (Roth et al., <xref rid="B24" ref-type="bibr">2016</xref>). The tumor is initiated by the mutation in the <italic>TP53</italic> tumor suppressor gene, then evolves into two branches one of which forms a separate clade after accumulating mutations in genes like <italic>BRCA1</italic> tumor suppressor gene and <italic>CENPI</italic> oncogene (marked in cyan). Another branch further splits into two clades after acquiring the mutation in <italic>YTHDF3</italic>. One of the clades (marked in red) consists of 113 cells of which 112 cells derive from the left ovary, while another clade excludes the LOv1 cells. This clade is characterized by an initial set of mutations that present in non-LOv1 cells (marked in green), and further extended by the mutations absent in LOv2 cells (marked in blue). By allowing loss of the mutations with <italic>k</italic> = 1, GRMT achieves a significantly improved log-likelihood of -6676.88 by learning the error rates as α = 2.73% and β = 29.7%. The inferred mutation tree (<xref ref-type="supplementary-material" rid="SM1">Supplementary Figure 10</xref>) has 42 mutation losses and yields a higher resolution indication of the clonal architecture refined by mutation loss events.</p>
        <p>We also apply SCITE on this dataset with α = 4.39% and β = 34.1%. SCITE infers a mutation tree (shown in <xref ref-type="supplementary-material" rid="SM1">Supplementary Figure 11</xref>) with the log-likelihood of -7312.88. It also identifies divergent subclones that evolve through similar patterns as the ones found by GRMT.</p>
      </sec>
    </sec>
  </sec>
  <sec sec-type="discussion" id="s4">
    <title>4. Discussion</title>
    <p>With the ability of delivering the genetic diversity at single cell resolution, SCS is particularly useful to decipher intra-tumor heterogeneity in cancer. In this study, we develop a new computational method GRMT for accurate and efficient reconstruction of mutation tree based on SCS data. As loss of mutation is the dominant factor that contributes to the homoplasy of SNVs in cancer (El-Kebir, <xref rid="B5" ref-type="bibr">2018</xref>), GRMT leverages the <italic>k</italic>-Dollo parsimony model to impose a restriction on mutation evolution that each mutation can be gained once and lost at most <italic>k</italic> times. We elaborate a generative framework to reconstruct mutation tree from scratch by iteratively introducing new node to the tree per mutation event. To best explain the observed error-prone mutation data, BO based parameter tuning is employed to infer the maximum likelihood estimation of the error rates. Compared to the existing tools, the advantages of GRMT lie in three aspects: (1) the generative model enables accurate and fast inference of chronological order of mutations; (2) the BO algorithm is more efficient than MCMC based approaches in estimating the FPR and FNR; (3) the good tradeoff between computational efficiency and inference accuracy makes GRMT scales very well to large datasets. We perform extensive evaluation of GRMT on simulated and real datasets to demonstrate its superior performance in profiling clonal architecture from SCS data.</p>
    <p>One limitation of GRMT lies in the fact that it does not explicitly model doublet events, thus may suffer from degraded performance when applied to datasets with high doublet rates, and we plan to elaborate on this issue in the future. In addition, there are several potential directions for future research to improve the performance of GRMT. First, the errors in genotypes is non-uniformly distributed across the cells, thus exploiting genotype uncertainty available from SNV callers can result in an improved inference (Wu, <xref rid="B30" ref-type="bibr">2020</xref>). This suggests a Bayesian framework that utilizes this information may yield more accurate results. Second, inclusion of other data sources may also be a feasible direction to refine the results solely derived from SCS data. A previous study (Malikic et al., <xref rid="B14" ref-type="bibr">2019</xref>) proposes to infer tumor evolutionary history from combined bulk and SCS data, where the fitness of the model to bulk data is also optimized. Finally, copy number information inferred from sequencing data (Yuan et al., <xref rid="B34" ref-type="bibr">2019</xref>; Satas et al., <xref rid="B26" ref-type="bibr">2020</xref>) may be useful to restrict the mutations that have undergone losses, thus shrinks the search space of candidate mutation trees.</p>
  </sec>
  <sec sec-type="data-availability" id="s5">
    <title>Data Availability Statement</title>
    <p>The original contributions presented in the study are included in the article/<xref ref-type="supplementary-material" rid="SM1">Supplementary Material</xref>, further inquiries can be directed to the corresponding author/s.</p>
  </sec>
  <sec id="s6">
    <title>Author Contributions</title>
    <p>ZY and FD conceived the study. ZY designed the methods and implemented the GRMT algorithm and wrote the first draft of the manuscript. HL and XT analyzed the data. All authors contributed to manuscript revision, read, and approved the submitted version.</p>
  </sec>
  <sec sec-type="COI-statement" id="conf1">
    <title>Conflict of Interest</title>
    <p>The authors declare that the research was conducted in the absence of any commercial or financial relationships that could be construed as a potential conflict of interest.</p>
  </sec>
</body>
<back>
  <fn-group>
    <fn fn-type="financial-disclosure">
      <p><bold>Funding.</bold> This work has been supported by the National Natural Science Foundation of China (61901238, 62062058, and 61966029).</p>
    </fn>
  </fn-group>
  <sec sec-type="supplementary-material" id="s7">
    <title>Supplementary Material</title>
    <p>The Supplementary Material for this article can be found online at: <ext-link ext-link-type="uri" xlink:href="https://www.frontiersin.org/articles/10.3389/fgene.2021.692964/full#supplementary-material">https://www.frontiersin.org/articles/10.3389/fgene.2021.692964/full#supplementary-material</ext-link></p>
    <supplementary-material content-type="local-data" id="SM1">
      <media xlink:href="Data_Sheet_1.PDF">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
  </sec>
  <ref-list>
    <title>References</title>
    <ref id="B1">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Brasko</surname><given-names>C.</given-names></name><name><surname>Smith</surname><given-names>K.</given-names></name><name><surname>Molnar</surname><given-names>C.</given-names></name><name><surname>Farago</surname><given-names>N.</given-names></name><name><surname>Hegedus</surname><given-names>L.</given-names></name><name><surname>Balind</surname><given-names>A.</given-names></name><etal/></person-group>. (<year>2018</year>). <article-title>Intelligent image-based in situ single-cell isolation</article-title>. <source>Nat Commun.</source><volume>9</volume>:<fpage>226</fpage>. <pub-id pub-id-type="doi">10.1038/s41467-017-02628-4</pub-id><?supplied-pmid 29335532?><pub-id pub-id-type="pmid">29335532</pub-id></mixed-citation>
    </ref>
    <ref id="B2">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Chen</surname><given-names>Z.</given-names></name><name><surname>Gong</surname><given-names>F.</given-names></name><name><surname>Wan</surname><given-names>L.</given-names></name><name><surname>Ma</surname><given-names>L.</given-names></name></person-group> (<year>2020</year>). <article-title>RobustClone: a robust PCA method for tumor clone and evolution inference from single-cell sequencing data</article-title>. <source>Bioinformatics</source>
<volume>36</volume>, <fpage>3299</fpage>–<lpage>3306</lpage>. <pub-id pub-id-type="doi">10.1093/bioinformatics/btaa172</pub-id><?supplied-pmid 32159762?><pub-id pub-id-type="pmid">32159762</pub-id></mixed-citation>
    </ref>
    <ref id="B3">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>DiNardo</surname><given-names>Z.</given-names></name><name><surname>Tomlinson</surname><given-names>K.</given-names></name><name><surname>Ritz</surname><given-names>A.</given-names></name><name><surname>Oesper</surname><given-names>L.</given-names></name></person-group> (<year>2020</year>). <article-title>Distance measures for tumor evolutionary trees</article-title>. <source>Bioinformatics</source>
<volume>36</volume>, <fpage>2090</fpage>–<lpage>2097</lpage>. <pub-id pub-id-type="doi">10.1093/bioinformatics/btz869</pub-id><?supplied-pmid 31750900?><pub-id pub-id-type="pmid">31750900</pub-id></mixed-citation>
    </ref>
    <ref id="B4">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Dollo</surname><given-names>L.</given-names></name></person-group> (<year>1893</year>). <article-title>The laws of evolutionr</article-title>. <source>Bull. Soc. Bel. Geol. Palaeontol.</source>
<volume>7</volume>, <fpage>164</fpage>–<lpage>166</lpage>.</mixed-citation>
    </ref>
    <ref id="B5">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>El-Kebir</surname><given-names>M.</given-names></name></person-group> (<year>2018</year>). <article-title>SPhyR: tumor phylogeny estimation from single-cell sequencing data under loss and error</article-title>. <source>Bioinformatics</source>
<volume>34</volume>, <fpage>i671</fpage>–<lpage>i679</lpage>. <pub-id pub-id-type="doi">10.1093/bioinformatics/bty589</pub-id><?supplied-pmid 30423070?><pub-id pub-id-type="pmid">30423070</pub-id></mixed-citation>
    </ref>
    <ref id="B6">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Gawad</surname><given-names>C.</given-names></name><name><surname>Koh</surname><given-names>W.</given-names></name><name><surname>Quake</surname><given-names>S. R.</given-names></name></person-group> (<year>2014</year>). <article-title>Dissecting the clonal origins of childhood acute lymphoblastic leukemia by single-cell genomics</article-title>. <source>Proc. Natl. Acad. Sci. U.S.A.</source>
<volume>111</volume>, <fpage>17947</fpage>–<lpage>17952</lpage>. <pub-id pub-id-type="doi">10.1073/pnas.1420822111</pub-id><?supplied-pmid 25425670?><pub-id pub-id-type="pmid">25425670</pub-id></mixed-citation>
    </ref>
    <ref id="B7">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Gawad</surname><given-names>C.</given-names></name><name><surname>Koh</surname><given-names>W.</given-names></name><name><surname>Quake</surname><given-names>S. R.</given-names></name></person-group> (<year>2016</year>). <article-title>Single-cell genome sequencing: current state of the science</article-title>. <source>Nat. Rev. Genet.</source>
<volume>17</volume>, <fpage>175</fpage>–<lpage>188</lpage>. <pub-id pub-id-type="doi">10.1038/nrg.2015.16</pub-id><?supplied-pmid 26806412?><pub-id pub-id-type="pmid">26806412</pub-id></mixed-citation>
    </ref>
    <ref id="B8">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Greaves</surname><given-names>M.</given-names></name><name><surname>Maley</surname><given-names>C. C.</given-names></name></person-group> (<year>2012</year>). <article-title>Clonal evolution in cancer</article-title>. <source>Nature</source>
<volume>481</volume>, <fpage>306</fpage>–<lpage>313</lpage>. <pub-id pub-id-type="doi">10.1038/nature10762</pub-id><pub-id pub-id-type="pmid">22258609</pub-id></mixed-citation>
    </ref>
    <ref id="B9">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Hou</surname><given-names>Y.</given-names></name><name><surname>Song</surname><given-names>L.</given-names></name><name><surname>Zhu</surname><given-names>P.</given-names></name><name><surname>Zhang</surname><given-names>B.</given-names></name><name><surname>Tao</surname><given-names>Y.</given-names></name><name><surname>Xu</surname><given-names>X.</given-names></name><etal/></person-group>. (<year>2012</year>). <article-title>Single-cell exome sequencing and monoclonal evolution of a JAK2-negative myeloproliferative neoplasm</article-title>. <source>Cell</source><volume>148</volume>, <fpage>873</fpage>–<lpage>885</lpage>. <pub-id pub-id-type="doi">10.1016/j.cell.2012.02.028</pub-id><?supplied-pmid 22385957?><pub-id pub-id-type="pmid">22385957</pub-id></mixed-citation>
    </ref>
    <ref id="B10">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Jahn</surname><given-names>K.</given-names></name><name><surname>Kuipers</surname><given-names>J.</given-names></name><name><surname>Beerenwinkel</surname><given-names>N.</given-names></name></person-group> (<year>2016</year>). <article-title>Tree inference for single-cell data</article-title>. <source>Genome Biol.</source>
<volume>17</volume>:<fpage>86</fpage>. <pub-id pub-id-type="doi">10.1186/s13059-016-0936-x</pub-id><pub-id pub-id-type="pmid">27149953</pub-id></mixed-citation>
    </ref>
    <ref id="B11">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Kuipers</surname><given-names>J.</given-names></name><name><surname>Jahn</surname><given-names>K.</given-names></name><name><surname>Raphael</surname><given-names>B. J.</given-names></name><name><surname>Beerenwinkel</surname><given-names>N.</given-names></name></person-group> (<year>2017</year>). <article-title>Single-cell sequencing data reveal widespread recurrence and loss of mutational hits in the life histories of tumors</article-title>. <source>Genome Res.</source>
<volume>27</volume>, <fpage>1885</fpage>–<lpage>1894</lpage>. <pub-id pub-id-type="doi">10.1101/gr.220707.117</pub-id><?supplied-pmid 29030470?><pub-id pub-id-type="pmid">29030470</pub-id></mixed-citation>
    </ref>
    <ref id="B12">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Leung</surname><given-names>M. L.</given-names></name><name><surname>Davis</surname><given-names>A.</given-names></name><name><surname>Gao</surname><given-names>R.</given-names></name><name><surname>Casasent</surname><given-names>A.</given-names></name><name><surname>Wang</surname><given-names>Y.</given-names></name><name><surname>Sei</surname><given-names>E.</given-names></name><etal/></person-group>. (<year>2017</year>). <article-title>Single-cell DNA sequencing reveals a late-dissemination model in metastatic colorectal cancer</article-title>. <source>Genome Res</source>. <volume>27</volume>, <fpage>1287</fpage>–<lpage>1299</lpage>. <pub-id pub-id-type="doi">10.1101/gr.209973.116</pub-id><?supplied-pmid 28546418?><pub-id pub-id-type="pmid">28546418</pub-id></mixed-citation>
    </ref>
    <ref id="B13">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Macosko</surname><given-names>E. Z.</given-names></name><name><surname>Basu</surname><given-names>A.</given-names></name><name><surname>Satija</surname><given-names>R.</given-names></name><name><surname>Nemesh</surname><given-names>J.</given-names></name><name><surname>Shekhar</surname><given-names>K.</given-names></name><name><surname>Goldman</surname><given-names>M.</given-names></name><etal/></person-group>. (<year>2015</year>). <article-title>Highly parallel genome-wide expression profiling of individual cells using nanoliter droplets</article-title>. <source>Cell</source><volume>161</volume>, <fpage>1202</fpage>–<lpage>1214</lpage>. <pub-id pub-id-type="doi">10.1016/j.cell.2015.05.002</pub-id><?supplied-pmid 26000488?><pub-id pub-id-type="pmid">26000488</pub-id></mixed-citation>
    </ref>
    <ref id="B14">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Malikic</surname><given-names>S.</given-names></name><name><surname>Jahn</surname><given-names>K.</given-names></name><name><surname>Kuipers</surname><given-names>J.</given-names></name><name><surname>Sahinalp</surname><given-names>S. C.</given-names></name><name><surname>Beerenwinkel</surname><given-names>N.</given-names></name></person-group> (<year>2019</year>). <article-title>Integrative inference of subclonal tumour evolution from single-cell and bulk sequencing data</article-title>. <source>Nat. Commun.</source>
<volume>10</volume>:<fpage>2750</fpage>. <pub-id pub-id-type="doi">10.1038/s41467-019-10737-5</pub-id><?supplied-pmid 31227714?><pub-id pub-id-type="pmid">31227714</pub-id></mixed-citation>
    </ref>
    <ref id="B15">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Martinez-Cantin</surname><given-names>R.</given-names></name></person-group> (<year>2014</year>). <article-title>Bayesopt: a bayesian optimization library for nonlinear optimization, experimental design and bandits</article-title>. <source>J. Mach. Learn. Res.</source>
<volume>15</volume>, <fpage>3915</fpage>–<lpage>3919</lpage>. <pub-id pub-id-type="doi">10.5555/2627435.2750364</pub-id></mixed-citation>
    </ref>
    <ref id="B16">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>McPherson</surname><given-names>A.</given-names></name><name><surname>Roth</surname><given-names>A.</given-names></name><name><surname>Laks</surname><given-names>E.</given-names></name><name><surname>Masud</surname><given-names>T.</given-names></name><name><surname>Bashashati</surname><given-names>A.</given-names></name><name><surname>Zhang</surname><given-names>A. W.</given-names></name><etal/></person-group>. (<year>2016</year>). <article-title>Divergent modes of clonal spread and intraperitoneal mixing in high-grade serous ovarian cancer</article-title>. <source>Nat. Genet.</source><volume>48</volume>, <fpage>758</fpage>–<lpage>767</lpage>. <pub-id pub-id-type="doi">10.1038/ng.3573</pub-id><?supplied-pmid 27182968?><pub-id pub-id-type="pmid">27182968</pub-id></mixed-citation>
    </ref>
    <ref id="B17">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Miura</surname><given-names>S.</given-names></name><name><surname>Huuki</surname><given-names>L. A.</given-names></name><name><surname>Buturla</surname><given-names>T.</given-names></name><name><surname>Vu</surname><given-names>T.</given-names></name><name><surname>Gomez</surname><given-names>K.</given-names></name><name><surname>Kumar</surname><given-names>S.</given-names></name></person-group> (<year>2018</year>). <article-title>Computational enhancement of single-cell sequences for inferring tumor evolution</article-title>. <source>Bioinformatics</source>
<volume>34</volume>, <fpage>i917</fpage>–<lpage>i926</lpage>. <pub-id pub-id-type="doi">10.1093/bioinformatics/bty571</pub-id><?supplied-pmid 30423071?><pub-id pub-id-type="pmid">30423071</pub-id></mixed-citation>
    </ref>
    <ref id="B18">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Mockus</surname><given-names>J. B.</given-names></name><name><surname>Mockus</surname><given-names>L. J.</given-names></name></person-group> (<year>1991</year>). <article-title>Bayesian approach to global optimization and application to multiobjective and constrained problems</article-title>. <source>J. Optim. Theory Appl.</source>
<volume>70</volume>, <fpage>157</fpage>–<lpage>172</lpage>. <pub-id pub-id-type="doi">10.1007/BF00940509</pub-id></mixed-citation>
    </ref>
    <ref id="B19">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Myers</surname><given-names>M. A.</given-names></name><name><surname>Zaccaria</surname><given-names>S.</given-names></name><name><surname>Raphael</surname><given-names>B. J.</given-names></name></person-group> (<year>2020</year>). <article-title>Identifying tumor clones in sparse single-cell mutation data</article-title>. <source>Bioinformatics</source>
<volume>36</volume>(<issue>Suppl. 1</issue>):i186–i193. <pub-id pub-id-type="doi">10.1093/bioinformatics/btaa449</pub-id><?supplied-pmid 32657385?><pub-id pub-id-type="pmid">32657385</pub-id></mixed-citation>
    </ref>
    <ref id="B20">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Navin</surname><given-names>N. E.</given-names></name></person-group> (<year>2014</year>). <article-title>Cancer genomics: one cell at a time</article-title>. <source>Genome Biol</source>. <volume>15</volume>:<fpage>452</fpage>. <pub-id pub-id-type="doi">10.1186/s13059-014-0452-9</pub-id><?supplied-pmid 25222669?><pub-id pub-id-type="pmid">25222669</pub-id></mixed-citation>
    </ref>
    <ref id="B21">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Nowell</surname><given-names>P.</given-names></name></person-group> (<year>1976</year>). <article-title>The clonal evolution of tumor cell populations</article-title>. <source>Science</source>
<volume>194</volume>, <fpage>23</fpage>–<lpage>28</lpage>. <pub-id pub-id-type="doi">10.1126/science.959840</pub-id><?supplied-pmid 27107655?><pub-id pub-id-type="pmid">959840</pub-id></mixed-citation>
    </ref>
    <ref id="B22">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Rasmussen</surname><given-names>C. E.</given-names></name><name><surname>Williams</surname><given-names>C. K. I.</given-names></name></person-group> (<year>2005</year>). <source>Gaussian Processes for Machine Learning</source>. The MIT Press.</mixed-citation>
    </ref>
    <ref id="B23">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Ross</surname><given-names>E. M.</given-names></name><name><surname>Markowetz</surname><given-names>F.</given-names></name></person-group> (<year>2016</year>). <article-title>OncoNEM: inferring tumor evolution from single-cell sequencing data</article-title>. <source>Genome Biol</source>. <volume>17</volume>:<fpage>69</fpage>. <pub-id pub-id-type="doi">10.1186/s13059-016-0929-9</pub-id><?supplied-pmid 27083415?><pub-id pub-id-type="pmid">27083415</pub-id></mixed-citation>
    </ref>
    <ref id="B24">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Roth</surname><given-names>A.</given-names></name><name><surname>McPherson</surname><given-names>A.</given-names></name><name><surname>Laks</surname><given-names>E.</given-names></name><name><surname>Biele</surname><given-names>J.</given-names></name><name><surname>Yap</surname><given-names>D.</given-names></name><name><surname>Wan</surname><given-names>A.</given-names></name><etal/></person-group>. (<year>2016</year>). <article-title>Clonal genotype and population structure inference from single-cell tumor sequencing</article-title>. <source>Nat. Methods</source><volume>13</volume>, <fpage>573</fpage>–<lpage>576</lpage>. <pub-id pub-id-type="doi">10.1038/nmeth.3867</pub-id><?supplied-pmid 27183439?><pub-id pub-id-type="pmid">27183439</pub-id></mixed-citation>
    </ref>
    <ref id="B25">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Sadeqi Azer</surname><given-names>E.</given-names></name><name><surname>Rashidi Mehrabadi</surname><given-names>F.</given-names></name><name><surname>Malikic</surname><given-names>S.</given-names></name><name><surname>Li</surname><given-names>X. C.</given-names></name><name><surname>Bartok</surname><given-names>O.</given-names></name><name><surname>Litchfield</surname><given-names>K.</given-names></name><etal/></person-group>. (<year>2020</year>). <article-title>PhISCS-BnB: a fast branch and bound algorithm for the perfect tumor phylogeny reconstruction problem</article-title>. <source>Bioinformatics</source><volume>36</volume>(<issue>Suppl. 1</issue>):i169–i176. <pub-id pub-id-type="doi">10.1093/bioinformatics/btaa464</pub-id><?supplied-pmid 32657358?><pub-id pub-id-type="pmid">32657358</pub-id></mixed-citation>
    </ref>
    <ref id="B26">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Satas</surname><given-names>G.</given-names></name><name><surname>Zaccaria</surname><given-names>S.</given-names></name><name><surname>Mon</surname><given-names>G.</given-names></name><name><surname>Raphael</surname><given-names>B. J.</given-names></name></person-group> (<year>2020</year>). <article-title>SCARLET: Single-cell tumor phylogeny inference with copy-number constrained mutation losses</article-title>. <source>Cell Syst</source>. <volume>10</volume>, <fpage>323</fpage>–<lpage>332</lpage>. <pub-id pub-id-type="doi">10.1016/j.cels.2020.04.001</pub-id><?supplied-pmid 32864481?><pub-id pub-id-type="pmid">32864481</pub-id></mixed-citation>
    </ref>
    <ref id="B27">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Stratton</surname><given-names>M. R.</given-names></name><name><surname>Campbell</surname><given-names>P. J.</given-names></name><name><surname>Futreal</surname><given-names>P. A.</given-names></name></person-group> (<year>2009</year>). <article-title>The cancer genome</article-title>. <source>Nature</source>
<volume>458</volume>, <fpage>719</fpage>–<lpage>724</lpage>. <pub-id pub-id-type="doi">10.1038/nature07943</pub-id><pub-id pub-id-type="pmid">19360079</pub-id></mixed-citation>
    </ref>
    <ref id="B28">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Swanton</surname><given-names>C.</given-names></name></person-group> (<year>2012</year>). <article-title>Intratumor heterogeneity: evolution through space and time</article-title>. <source>Cancer Res</source>. <volume>72</volume>, <fpage>4875</fpage>–<lpage>4882</lpage>. <pub-id pub-id-type="doi">10.1158/0008-5472.CAN-12-2217</pub-id><?supplied-pmid 31784650?><pub-id pub-id-type="pmid">23002210</pub-id></mixed-citation>
    </ref>
    <ref id="B29">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Wang</surname><given-names>Y.</given-names></name><name><surname>Waters</surname><given-names>J.</given-names></name><name><surname>Leung</surname><given-names>M. L.</given-names></name><name><surname>Unruh</surname><given-names>A.</given-names></name><name><surname>Roh</surname><given-names>W.</given-names></name><name><surname>Shi</surname><given-names>X.</given-names></name><etal/></person-group>. (<year>2014</year>). <article-title>Clonal evolution in breast cancer revealed by single nucleus genome sequencing</article-title>. <source>Nature</source><volume>512</volume>, <fpage>155</fpage>–<lpage>160</lpage>. <pub-id pub-id-type="doi">10.1038/nature13600</pub-id><?supplied-pmid 25079324?><pub-id pub-id-type="pmid">25079324</pub-id></mixed-citation>
    </ref>
    <ref id="B30">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Wu</surname><given-names>Y.</given-names></name></person-group> (<year>2020</year>). <article-title>Accurate and efficient cell lineage tree inference from noisy single cell data: the maximum likelihood perfect phylogeny approach</article-title>. <source>Bioinformatics</source>
<volume>36</volume>, <fpage>742</fpage>–<lpage>750</lpage>. <pub-id pub-id-type="doi">10.1093/bioinformatics/btz676</pub-id><?supplied-pmid 31504211?><pub-id pub-id-type="pmid">31504211</pub-id></mixed-citation>
    </ref>
    <ref id="B31">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Xi</surname><given-names>J.</given-names></name><name><surname>Wang</surname><given-names>M.</given-names></name><name><surname>Li</surname><given-names>A.</given-names></name></person-group> (<year>2018</year>). <article-title>Discovering mutated driver genes through a robust and sparse co-regularized matrix factorization framework with prior information from mRNA expression patterns and interaction network</article-title>. <source>BMC Bioinformatics</source>
<volume>19</volume>:<fpage>214</fpage>. <pub-id pub-id-type="doi">10.1186/s12859-018-2218-y</pub-id><?supplied-pmid 29871594?><pub-id pub-id-type="pmid">29871594</pub-id></mixed-citation>
    </ref>
    <ref id="B32">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Xi</surname><given-names>J.</given-names></name><name><surname>Yuan</surname><given-names>X.</given-names></name><name><surname>Wang</surname><given-names>M.</given-names></name><name><surname>Li</surname><given-names>A.</given-names></name><name><surname>Li</surname><given-names>X.</given-names></name><name><surname>Huang</surname><given-names>Q.</given-names></name></person-group> (<year>2020</year>). <article-title>Inferring subgroup-specific driver genes from heterogeneous cancer samples via subspace learning with subgroup indication</article-title>. <source>Bioinformatics</source>
<volume>36</volume>, <fpage>1855</fpage>–<lpage>1863</lpage>. <pub-id pub-id-type="doi">10.1093/bioinformatics/btz793</pub-id><?supplied-pmid 31626284?><pub-id pub-id-type="pmid">31626284</pub-id></mixed-citation>
    </ref>
    <ref id="B33">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Xu</surname><given-names>X.</given-names></name><name><surname>Hou</surname><given-names>Y.</given-names></name><name><surname>Yin</surname><given-names>X.</given-names></name><name><surname>Bao</surname><given-names>L.</given-names></name><name><surname>Tang</surname><given-names>A.</given-names></name><name><surname>Song</surname><given-names>L.</given-names></name><etal/></person-group>. (<year>2012</year>). <article-title>Single-cell exome sequencing reveals single-nucleotide mutation characteristics of a kidney tumor</article-title>. <source>Cell</source><volume>148</volume>, <fpage>886</fpage>–<lpage>895</lpage>. <pub-id pub-id-type="doi">10.1016/j.cell.2012.02.025</pub-id><?supplied-pmid 22385958?><pub-id pub-id-type="pmid">22385958</pub-id></mixed-citation>
    </ref>
    <ref id="B34">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Yuan</surname><given-names>X.</given-names></name><name><surname>Li</surname><given-names>J.</given-names></name><name><surname>Bai</surname><given-names>J.</given-names></name><name><surname>Xi</surname><given-names>J.</given-names></name></person-group> (<year>2019</year>). <article-title>A local outlier factor-based detection of copy number variations from ngs data</article-title>. <source>IEEE/ACM Transactions on Computational Biology and Bioinformatics</source>, <fpage>1</fpage>–<lpage>1</lpage>.<?supplied-pmid 31880558?><pub-id pub-id-type="pmid">31880558</pub-id></mixed-citation>
    </ref>
    <ref id="B35">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Zafar</surname><given-names>H.</given-names></name><name><surname>Navin</surname><given-names>N.</given-names></name><name><surname>Chen</surname><given-names>K.</given-names></name><name><surname>Nakhleh</surname><given-names>L.</given-names></name></person-group> (<year>2019</year>). <article-title>SiCloneFit: Bayesian inference of population structure, genotype, and phylogeny of tumor clones from single-cell genome sequencing data</article-title>. <source>Genome Res.</source>
<volume>29</volume>, <fpage>1847</fpage>–<lpage>1859</lpage>. <pub-id pub-id-type="doi">10.1101/gr.243121.118</pub-id><?supplied-pmid 31628257?><pub-id pub-id-type="pmid">31628257</pub-id></mixed-citation>
    </ref>
    <ref id="B36">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Zafar</surname><given-names>H.</given-names></name><name><surname>Tzen</surname><given-names>A.</given-names></name><name><surname>Navin</surname><given-names>N.</given-names></name><name><surname>Chen</surname><given-names>K.</given-names></name><name><surname>Nakhleh</surname><given-names>L.</given-names></name></person-group> (<year>2017</year>). <article-title>SiFit: inferring tumor trees from single-cell sequencing data under finite-sites models</article-title>. <source>Genome Biol.</source>
<volume>18</volume>:<fpage>178</fpage>. <pub-id pub-id-type="doi">10.1186/s13059-017-1311-2</pub-id><?supplied-pmid 31096998?><pub-id pub-id-type="pmid">28927434</pub-id></mixed-citation>
    </ref>
    <ref id="B37">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Zafar</surname><given-names>H.</given-names></name><name><surname>Wang</surname><given-names>Y.</given-names></name><name><surname>Nakhleh</surname><given-names>L.</given-names></name><name><surname>Navin</surname><given-names>N.</given-names></name><name><surname>Chen</surname><given-names>K.</given-names></name></person-group> (<year>2016</year>). <article-title>Monovar: single-nucleotide variant detection in single cells</article-title>. <source>Nat. Methods</source>
<volume>13</volume>, <fpage>505</fpage>–<lpage>507</lpage>. <pub-id pub-id-type="doi">10.1038/nmeth.3835</pub-id><?supplied-pmid 27088313?><pub-id pub-id-type="pmid">27088313</pub-id></mixed-citation>
    </ref>
    <ref id="B38">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Zhang</surname><given-names>C. Z.</given-names></name><name><surname>Adalsteinsson</surname><given-names>V. A.</given-names></name><name><surname>Francis</surname><given-names>J.</given-names></name><name><surname>Cornils</surname><given-names>H.</given-names></name><name><surname>Jung</surname><given-names>J.</given-names></name><name><surname>Maire</surname><given-names>C.</given-names></name><etal/></person-group>. (<year>2015</year>). <article-title>Calibrating genomic and allelic coverage bias in single-cell sequencing</article-title>. <source>Nat. Commun.</source><volume>6</volume>:<fpage>6822</fpage>. <pub-id pub-id-type="doi">10.1038/ncomms7822</pub-id><?supplied-pmid 25879913?><pub-id pub-id-type="pmid">25879913</pub-id></mixed-citation>
    </ref>
    <ref id="B39">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Zong</surname><given-names>C.</given-names></name><name><surname>Lu</surname><given-names>S.</given-names></name><name><surname>Chapman</surname><given-names>A. R.</given-names></name><name><surname>Xie</surname><given-names>X. S.</given-names></name></person-group> (<year>2012</year>). <article-title>Genome-wide detection of single-nucleotide and copy-number variations of a single human cell</article-title>. <source>Science</source>
<volume>338</volume>, <fpage>1622</fpage>–<lpage>1626</lpage>. <pub-id pub-id-type="doi">10.1126/science.1229164</pub-id><?supplied-pmid 23258894?><pub-id pub-id-type="pmid">23258894</pub-id></mixed-citation>
    </ref>
  </ref-list>
</back>
