<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">BMC Bioinformatics</journal-id>
    <journal-title>BMC Bioinformatics</journal-title>
    <issn pub-type="epub">1471-2105</issn>
    <publisher>
      <publisher-name>BioMed Central</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">2586757</article-id>
    <article-id pub-id-type="publisher-id">1471-2105-9-S11-S8</article-id>
    <article-id pub-id-type="doi">10.1186/1471-2105-9-S11-S8</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Research</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Accelerating the annotation of sparse named entities by dynamic sentence selection</article-title>
    </title-group>
    <contrib-group>
      <contrib id="A1" corresp="yes" contrib-type="author">
        <name>
          <surname>Tsuruoka</surname>
          <given-names>Yoshimasa</given-names>
        </name>
        <xref ref-type="aff" rid="I1">1</xref>
        <xref ref-type="aff" rid="I2">2</xref>
        <email>yoshimasa.tsuruoka@manchester.ac.uk</email>
      </contrib>
      <contrib id="A2" contrib-type="author">
        <name>
          <surname>Tsujii</surname>
          <given-names>Jun'ichi</given-names>
        </name>
        <xref ref-type="aff" rid="I1">1</xref>
        <xref ref-type="aff" rid="I2">2</xref>
        <xref ref-type="aff" rid="I3">3</xref>
        <email>tsujii@is.s.u-tokyo.ac.jp</email>
      </contrib>
      <contrib id="A3" contrib-type="author">
        <name>
          <surname>Ananiadou</surname>
          <given-names>Sophia</given-names>
        </name>
        <xref ref-type="aff" rid="I1">1</xref>
        <xref ref-type="aff" rid="I2">2</xref>
        <email>sophia.ananiadou@manchester.ac.uk</email>
      </contrib>
    </contrib-group>
    <aff id="I1"><label>1</label>School of Computer Science, The University of Manchester, MIB, 131 Princess Street, Manchester, M1 7DN, UK</aff>
    <aff id="I2"><label>2</label>National Centre for Text Mining (NaCTeM), MIB, 131 Princess Street, Manchester, M1 7DN, UK</aff>
    <aff id="I3"><label>3</label>Department of Computer Science, The University of Tokyo, 7-3-1 Hongo, Bunkyo-ku, Tokyo, Japan</aff>
    <pub-date pub-type="collection">
      <year>2008</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>19</day>
      <month>11</month>
      <year>2008</year>
    </pub-date>
    <volume>9</volume>
    <issue>Suppl 11</issue>
    <supplement>
      <named-content content-type="supplement-title">Proceedings of the BioNLP 08 ACL Workshop: Themes in biomedical language processing</named-content>
      <named-content content-type="supplement-editor">Dina Demner-Fushman, K Bretonnel Cohen, Sophia Ananiadou, John Pestian, Jun'ichi Tsujii and Bonnie Webber</named-content>
    </supplement>
    <fpage>S8</fpage>
    <lpage>S8</lpage>
    <ext-link ext-link-type="uri" xlink:href="http://www.biomedcentral.com/1471-2105/9/S11/S8"/>
    <permissions>
      <copyright-statement>Copyright © 2008 Tsuruoka et al; licensee BioMed Central Ltd.</copyright-statement>
      <copyright-year>2008</copyright-year>
      <copyright-holder>Tsuruoka et al; licensee BioMed Central Ltd.</copyright-holder>
      <license license-type="open-access" xlink:href="http://creativecommons.org/licenses/by/2.0">
        <p>This is an open access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/2.0"/>), which permits unrestricted use, distribution, and reproduction in any medium, provided the original work is properly cited.</p>
        <!--<rdf xmlns="http://web.resource.org/cc/" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:dc="http://purl.org/dc/elements/1.1" xmlns:dcterms="http://purl.org/dc/terms"><Work xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:dcterms="http://purl.org/dc/terms/" rdf:about=""><license rdf:resource="http://creativecommons.org/licenses/by/2.0"/><dc:type rdf:resource="http://purl.org/dc/dcmitype/Text"/><dc:author>
               Tsuruoka
               Yoshimasa
               
               
               yoshimasa.tsuruoka@manchester.ac.uk
            </dc:author><dc:title>
            Accelerating the annotation of sparse named entities by dynamic sentence selection
         </dc:title><dc:date>2008</dc:date><dcterms:bibliographicCitation>BMC Bioinformatics 9(Suppl 11): S8-. (2008)</dcterms:bibliographicCitation><dc:identifier type="sici">1471-2105(2008)9:Suppl 11&#x0003c;S8&#x0003e;</dc:identifier><dcterms:isPartOf>urn:ISSN:1471-2105</dcterms:isPartOf><License rdf:about="http://creativecommons.org/licenses/by/2.0"><permits rdf:resource="http://web.resource.org/cc/Reproduction" xmlns=""/><permits rdf:resource="http://web.resource.org/cc/Distribution" xmlns=""/><requires rdf:resource="http://web.resource.org/cc/Notice" xmlns=""/><requires rdf:resource="http://web.resource.org/cc/Attribution" xmlns=""/><permits rdf:resource="http://web.resource.org/cc/DerivativeWorks" xmlns=""/></License></Work></rdf>-->
      </license>
    </permissions>
    <abstract>
      <sec>
        <title>Background</title>
        <p>Previous studies of named entity recognition have shown that a reasonable level of recognition accuracy can be achieved by using machine learning models such as conditional random fields or support vector machines. However, the lack of training data (i.e. annotated corpora) makes it difficult for machine learning-based named entity recognizers to be used in building practical information extraction systems.</p>
      </sec>
      <sec>
        <title>Results</title>
        <p>This paper presents an active learning-like framework for reducing the human effort required to create named entity annotations in a corpus. In this framework, the annotation work is performed as an iterative and interactive process between the human annotator and a probabilistic named entity tagger. Unlike active learning, our framework aims to annotate all occurrences of the target named entities in the given corpus, so that the resulting annotations are free from the sampling bias which is inevitable in active learning approaches.</p>
      </sec>
      <sec>
        <title>Conclusion</title>
        <p>We evaluate our framework by simulating the annotation process using two named entity corpora and show that our approach can reduce the number of sentences which need to be examined by the human annotator. The cost reduction achieved by the framework could be drastic when the target named entities are sparse.</p>
      </sec>
    </abstract>
    <conference>
      <conf-date>
        <day>19</day>
        <month>6</month>
        <year>2008</year>
      </conf-date>
      <conf-name>Natural Language Processing in Biomedicine (BioNLP) ACL Workshop 2008</conf-name>
      <conf-loc>Columbus, OH, USA</conf-loc>
    </conference>
  </article-meta>
</front>
<body>
  <sec>
    <title>Background</title>
    <p>Named entities play a central role in conveying important domain specific information in text, and good named entity recognizers are often required in building practical information extraction systems. Previous studies have shown that automatic named entity recognition can be performed with a reasonable level of accuracy by using various machine learning models such as support vector machines (SVMs) or conditional random fields (CRFs) [<xref ref-type="bibr" rid="B1">1</xref>-<xref ref-type="bibr" rid="B3">3</xref>].</p>
    <p>However, the lack of annotated corpora, which are indispensable for training machine learning models, makes it difficult to broaden the scope of text mining applications. In the biomedical domain, for example, several annotated corpora such as GENIA [<xref ref-type="bibr" rid="B4">4</xref>], PennBioIE [<xref ref-type="bibr" rid="B5">5</xref>], and GENETAG [<xref ref-type="bibr" rid="B6">6</xref>] have been created and made publicly available, but the named entity categories annotated in these corpora are tailored to their specific needs and not always sufficient or suitable for text mining tasks that other researchers need to carry out.</p>
    <p><italic>Active learning </italic>is a framework which can be used for reducing the amount of human effort required to create a training corpus [<xref ref-type="bibr" rid="B7">7</xref>-<xref ref-type="bibr" rid="B10">10</xref>]. In active learning, samples that need to be annotated by the human annotator are picked up from a big pool of samples by a machine learning model in an iterative and interactive manner, considering the informativeness of the samples. It has been shown that, compared to random sampling, active learning can often drastically reduce the amount of training data necessary to achieve the same level of performance. The effectiveness of active learning has been demonstrated in several natural language processing tasks including named entity recognition.</p>
    <p>The problem with active learning, however, is that the resulting annotated data is dependent on the machine learning algorithm and the sampling strategy employed, because active learning annotates only a <italic>subset </italic>of the samples in the given corpus. This sampling bias is not a serious problem if one is to use the annotated corpus only for their own machine learning purpose and with the same machine learning algorithm. However, the existence of bias is not desirable if one wants the corpus to be used by other applications or researchers. For the same reason, active learning approaches cannot be used to enrich an existing linguistic corpus with a new named entity category.</p>
    <p>In this paper, we present a framework that enables one to make named entity annotations for a given corpus with a reduced cost. Unlike active learning approaches, our framework aims to annotate <italic>all </italic>named entities of the target category contained in the corpus. Obviously, if we were to ensure 100% coverage of annotation, there is no way of reducing the annotation cost, i.e. the human annotator has to go through every sentence in the corpus. However, we show in this paper that it is possible to reduce the cost by slightly relaxing the requirement for the coverage, and the reduction can be drastic when the target named entities are sparse.</p>
    <p>We should note here that the purpose of this paper is not to claim that our approach is superior to existing active learning approaches. The goals are different – while active learning aims at optimizing the performance of the resulting machine learning-based tagger, our framework aims to help develop an unbiased named entity-annotated corpus.</p>
  </sec>
  <sec sec-type="methods">
    <title>Methods</title>
    <sec>
      <title>Annotating named entities by dynamic sentence selection</title>
      <p>Figure <xref ref-type="fig" rid="F1">1</xref> shows the overall flow of our annotation framework. The framework is an iterative process between the human annotator and a named entity tagger based on CRFs. In each iteration, the CRF tagger is trained using all annotated sentences available and is applied to the unannotated sentences to select sentences that are likely to contain named entities of the target category. The selected sentences are then annotated by the human annotator and moved to the pool of annotated sentences.</p>
      <fig position="float" id="F1">
        <label>Figure 1</label>
        <caption>
          <p>Annotating named entities by dynamic sentence selection.</p>
        </caption>
        <graphic xlink:href="1471-2105-9-S11-S8-1"/>
      </fig>
      <p>This overall flow of annotation framework is very similar to that of active learning. In fact, the only differences are the criterion of sentence selection and the fact that our framework uses the estimated coverage as the stopping condition. In active learning, sentences are selected according to their informativeness to the machine learning algorithm. Our approach, in contrast, selects sentences that are most likely to contain named entities of the target category. The next section elaborates on how to select such sentences using the output of the CRF-based tagger.</p>
      <p>The other key in this annotation framework is when to stop the annotation work. If we repeat the process until all sentences are annotated, then obviously there is no merit of using this approach. We show in the next section that we can quite accurately estimate how many of the entities in the corpus are already annotated and use this estimated coverage as the stopping condition.</p>
    </sec>
    <sec>
      <title>Selecting sentences using the CRF tagger</title>
      <p>Our annotation framework takes advantage of the ability of CRFs to output multiple probabilistic hypotheses. This section describes how we obtain named entity candidates and their probabilities from CRFs in order to compute the expected number of named entities contained in a sentence.</p>
      <p>We should note that one could use other machine learning algorithms for this task as long as they can produce probabilistic output. For example, maximum entropy Markov models are a possible alternative. We have chosen the CRF model because it is currently one of the best models for named entity recognition and there are efficient algorithms to compute marginal probabilities and N-best sequences in CRFs.</p>
      <sec>
        <title>The CRF tagger</title>
        <p>CRFs [<xref ref-type="bibr" rid="B11">11</xref>] can be used for named entity recognition by representing the spans of named entities using the "BIO" tagging scheme, in which 'B' represents the beginning of a named entity, 'I' the inside, and 'O' the outside (See Table <xref ref-type="table" rid="T1">1</xref> for example). This representation converts the task of named entity recognition into a sequence tagging task.</p>
        <table-wrap position="float" id="T1">
          <label>Table 1</label>
          <caption>
            <p>N-best sequences output by the CRF tagger</p>
          </caption>
          <table frame="hsides" rules="groups">
            <thead>
              <tr>
                <td align="center">Probability</td>
                <td align="center">Transcription </td>
                <td align="center">factor</td>
                <td align="center">GATA-1</td>
                <td align="center">and</td>
                <td align="center">the</td>
                <td align="center">estrogen</td>
                <td align="center">receptor</td>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="center">0.677</td>
                <td align="center">B</td>
                <td align="center">I</td>
                <td align="center">O</td>
                <td align="center">O</td>
                <td align="center">O</td>
                <td align="center">O</td>
                <td align="center">O</td>
              </tr>
              <tr>
                <td align="center">0.242</td>
                <td align="center">B</td>
                <td align="center">I</td>
                <td align="center">O</td>
                <td align="center">O</td>
                <td align="center">O</td>
                <td align="center">B</td>
                <td align="center">I</td>
              </tr>
              <tr>
                <td align="center">0.035</td>
                <td align="center">O</td>
                <td align="center">O</td>
                <td align="center">O</td>
                <td align="center">O</td>
                <td align="center">O</td>
                <td align="center">O</td>
                <td align="center">O</td>
              </tr>
              <tr>
                <td align="center">0.012</td>
                <td align="center">B</td>
                <td align="center">I</td>
                <td align="center">I</td>
                <td align="center">O</td>
                <td align="center">O</td>
                <td align="center">O</td>
                <td align="center">O</td>
              </tr>
              <tr>
                <td align="center">0.009</td>
                <td align="center">B</td>
                <td align="center">I</td>
                <td align="center">I</td>
                <td align="center">O</td>
                <td align="center">O</td>
                <td align="center">B</td>
                <td align="center">I</td>
              </tr>
              <tr>
                <td align="center">:</td>
                <td align="center">:</td>
                <td align="center">:</td>
                <td align="center">:</td>
                <td align="center">:</td>
                <td align="center">:</td>
                <td align="center">:</td>
                <td align="center">:</td>
              </tr>
            </tbody>
          </table>
        </table-wrap>
        <p>A linear chain CRF defines a single log-linear probabilistic distribution over the possible tag sequences <bold>y </bold>for a sentence <bold>x</bold>:</p>
        <p>
          <disp-formula>
            <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M1" name="1471-2105-9-S11-S8-i1" overflow="scroll">
              <mml:semantics>
                <mml:mrow>
                  <mml:mi>p</mml:mi>
                  <mml:mo stretchy="false">(</mml:mo>
                  <mml:mstyle mathvariant="bold" mathsize="normal">
                    <mml:mi>y</mml:mi>
                  </mml:mstyle>
                  <mml:mo>|</mml:mo>
                  <mml:mstyle mathvariant="bold" mathsize="normal">
                    <mml:mi>x</mml:mi>
                  </mml:mstyle>
                  <mml:mo stretchy="false">)</mml:mo>
                  <mml:mo>=</mml:mo>
                  <mml:mfrac>
                    <mml:mn>1</mml:mn>
                    <mml:mrow>
                      <mml:mi>Z</mml:mi>
                      <mml:mo stretchy="false">(</mml:mo>
                      <mml:mstyle mathvariant="bold" mathsize="normal">
                        <mml:mi>x</mml:mi>
                      </mml:mstyle>
                      <mml:mo stretchy="false">)</mml:mo>
                    </mml:mrow>
                  </mml:mfrac>
                  <mml:mi>exp</mml:mi>
                  <mml:mo>⁡</mml:mo>
                  <mml:mstyle displaystyle="true">
                    <mml:munderover>
                      <mml:mo>∑</mml:mo>
                      <mml:mrow>
                        <mml:mi>t</mml:mi>
                        <mml:mo>=</mml:mo>
                        <mml:mn>1</mml:mn>
                      </mml:mrow>
                      <mml:mi>T</mml:mi>
                    </mml:munderover>
                    <mml:mrow>
                      <mml:mstyle displaystyle="true">
                        <mml:munderover>
                          <mml:mo>∑</mml:mo>
                          <mml:mrow>
                            <mml:mi>k</mml:mi>
                            <mml:mo>=</mml:mo>
                            <mml:mn>1</mml:mn>
                          </mml:mrow>
                          <mml:mi>K</mml:mi>
                        </mml:munderover>
                        <mml:mrow>
                          <mml:msub>
                            <mml:mi>λ</mml:mi>
                            <mml:mi>k</mml:mi>
                          </mml:msub>
                          <mml:msub>
                            <mml:mi>f</mml:mi>
                            <mml:mi>k</mml:mi>
                          </mml:msub>
                          <mml:mo stretchy="false">(</mml:mo>
                          <mml:mi>t</mml:mi>
                          <mml:mo>,</mml:mo>
                          <mml:msub>
                            <mml:mi>y</mml:mi>
                            <mml:mi>t</mml:mi>
                          </mml:msub>
                          <mml:mo>,</mml:mo>
                          <mml:msub>
                            <mml:mi>y</mml:mi>
                            <mml:mrow>
                              <mml:mi>t</mml:mi>
                              <mml:mo>−</mml:mo>
                              <mml:mn>1</mml:mn>
                            </mml:mrow>
                          </mml:msub>
                          <mml:mo>,</mml:mo>
                          <mml:msub>
                            <mml:mstyle mathvariant="bold" mathsize="normal">
                              <mml:mi>x</mml:mi>
                            </mml:mstyle>
                            <mml:mstyle mathvariant="bold" mathsize="normal">
                              <mml:mi>t</mml:mi>
                            </mml:mstyle>
                          </mml:msub>
                          <mml:mo stretchy="false">)</mml:mo>
                        </mml:mrow>
                      </mml:mstyle>
                    </mml:mrow>
                  </mml:mstyle>
                  <mml:mo>,</mml:mo>
                </mml:mrow>
              </mml:semantics>
            </mml:math>
          </disp-formula>
        </p>
        <p>where <italic>f</italic><sub><italic>k</italic></sub>(<italic>t</italic>, <italic>y</italic><sub><italic>t</italic></sub>, <italic>y</italic><sub><italic>t</italic>-1</sub>, <bold>x</bold><sub><bold>t</bold></sub>) is typically a binary function indicating the presence of feature <italic>k</italic>, <italic>λ</italic><sub><italic>k </italic></sub>is the weight of the feature, and <italic>Z</italic>(<italic>X</italic>) is a normalization function:</p>
        <p>
          <disp-formula>
            <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M2" name="1471-2105-9-S11-S8-i2" overflow="scroll">
              <mml:semantics>
                <mml:mrow>
                  <mml:mi>Z</mml:mi>
                  <mml:mo stretchy="false">(</mml:mo>
                  <mml:mstyle mathvariant="bold" mathsize="normal">
                    <mml:mi>x</mml:mi>
                  </mml:mstyle>
                  <mml:mo stretchy="false">)</mml:mo>
                  <mml:mo>=</mml:mo>
                  <mml:mstyle displaystyle="true">
                    <mml:munder>
                      <mml:mo>∑</mml:mo>
                      <mml:mi>y</mml:mi>
                    </mml:munder>
                    <mml:mrow>
                      <mml:mi>exp</mml:mi>
                      <mml:mo>⁡</mml:mo>
                    </mml:mrow>
                  </mml:mstyle>
                  <mml:mstyle displaystyle="true">
                    <mml:munderover>
                      <mml:mo>∑</mml:mo>
                      <mml:mrow>
                        <mml:mi>t</mml:mi>
                        <mml:mo>=</mml:mo>
                        <mml:mn>1</mml:mn>
                      </mml:mrow>
                      <mml:mi>T</mml:mi>
                    </mml:munderover>
                    <mml:mrow>
                      <mml:mstyle displaystyle="true">
                        <mml:munderover>
                          <mml:mo>∑</mml:mo>
                          <mml:mrow>
                            <mml:mi>k</mml:mi>
                            <mml:mo>=</mml:mo>
                            <mml:mn>1</mml:mn>
                          </mml:mrow>
                          <mml:mi>K</mml:mi>
                        </mml:munderover>
                        <mml:mrow>
                          <mml:msub>
                            <mml:mi>λ</mml:mi>
                            <mml:mi>k</mml:mi>
                          </mml:msub>
                          <mml:msub>
                            <mml:mi>f</mml:mi>
                            <mml:mi>k</mml:mi>
                          </mml:msub>
                          <mml:mo stretchy="false">(</mml:mo>
                          <mml:mi>t</mml:mi>
                          <mml:mo>,</mml:mo>
                          <mml:msub>
                            <mml:mi>y</mml:mi>
                            <mml:mi>t</mml:mi>
                          </mml:msub>
                          <mml:mo>,</mml:mo>
                          <mml:msub>
                            <mml:mi>y</mml:mi>
                            <mml:mrow>
                              <mml:mi>t</mml:mi>
                              <mml:mo>−</mml:mo>
                              <mml:mn>1</mml:mn>
                            </mml:mrow>
                          </mml:msub>
                          <mml:mo>,</mml:mo>
                          <mml:msub>
                            <mml:mstyle mathvariant="bold" mathsize="normal">
                              <mml:mi>x</mml:mi>
                            </mml:mstyle>
                            <mml:mstyle mathvariant="bold" mathsize="normal">
                              <mml:mi>t</mml:mi>
                            </mml:mstyle>
                          </mml:msub>
                          <mml:mo stretchy="false">)</mml:mo>
                        </mml:mrow>
                      </mml:mstyle>
                    </mml:mrow>
                  </mml:mstyle>
                  <mml:mo>.</mml:mo>
                </mml:mrow>
              </mml:semantics>
            </mml:math>
          </disp-formula>
        </p>
        <p>This modeling allows us to define features on states ("BIO" tags) and edges (pairs of adjacent "BIO" tags) combined with observations (e.g. words and part-of-speech (POS) tags).</p>
        <p>The weights of the features are determined in such a way that they maximize the conditional log-likelihood of the training data: <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M3" name="1471-2105-9-S11-S8-i3" overflow="scroll"><mml:semantics><mml:mrow><mml:mi>ℒ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>θ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mstyle displaystyle="true"><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>N</mml:mi></mml:msubsup><mml:mrow><mml:mi>log</mml:mi><mml:mo>⁡</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mi>θ</mml:mi></mml:msub></mml:mrow></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>y</mml:mi></mml:mstyle><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:mo>|</mml:mo><mml:msup><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>x</mml:mi></mml:mstyle><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:semantics></mml:math></inline-formula>. In the actual implementation, we also used the L2-norm penalty term to avoid overfitting of the model to the training data. We used the L-BFGS algorithm [<xref ref-type="bibr" rid="B12">12</xref>] to compute the parameters.</p>
        <p>Table <xref ref-type="table" rid="T2">2</xref> shows the feature templates used in the CRF tagger. We used unigrams of words/POS tags, and prefixes and suffixes of the current word. The current word is also normalized by lowering capital letters and converting all numerals into '#', and used as a feature. We created a word shape feature from the current word by converting consecutive capital letters into 'A', small letters 'a', and numerals '#'.</p>
        <table-wrap position="float" id="T2">
          <label>Table 2</label>
          <caption>
            <p>Feature templates used in the CRF tagger</p>
          </caption>
          <table frame="hsides" rules="groups">
            <tbody>
              <tr>
                <td align="left">Word Unigram</td>
                <td align="left"><italic>w</italic><sub><italic>i</italic></sub>, <italic>w</italic><sub><italic>i</italic>-1</sub>, <italic>w</italic><sub><italic>i</italic>+1</sub></td>
                <td align="right">&amp;<italic>y</italic><sub><italic>i</italic></sub></td>
              </tr>
              <tr>
                <td align="left">POS Unigram</td>
                <td align="left"><italic>p</italic><sub><italic>i</italic></sub>, <italic>p</italic><sub><italic>i</italic>-1</sub>, <italic>p</italic><sub><italic>i</italic>+1</sub></td>
                <td align="right">&amp;<italic>y</italic><sub><italic>i</italic></sub></td>
              </tr>
              <tr>
                <td align="left">Prefix, Suffix</td>
                <td align="left">prefixes of <italic>w</italic><sub><italic>i</italic></sub></td>
                <td align="right">&amp;<italic>y</italic><sub><italic>i</italic></sub></td>
              </tr>
              <tr>
                <td/>
                <td align="left">suffixes of <italic>w</italic><sub><italic>i</italic></sub></td>
                <td align="right">&amp;<italic>y</italic><sub><italic>i</italic></sub></td>
              </tr>
              <tr>
                <td/>
                <td align="left">(up to length 3)</td>
                <td/>
              </tr>
              <tr>
                <td align="left">Normalized Word</td>
                <td align="left">N(<italic>w</italic><sub><italic>i</italic></sub>)</td>
                <td align="right">&amp;<italic>y</italic><sub><italic>i</italic></sub></td>
              </tr>
              <tr>
                <td align="left">Word Shape</td>
                <td align="left">S(<italic>w</italic><sub><italic>i</italic></sub>)</td>
                <td align="right">&amp;<italic>y</italic><sub><italic>i</italic></sub></td>
              </tr>
              <tr>
                <td align="left">Tag Bi-gram</td>
                <td align="left">true</td>
                <td align="right">&amp;<italic>y</italic><sub><italic>i</italic>-1</sub><italic>y</italic><sub><italic>i</italic></sub></td>
              </tr>
            </tbody>
          </table>
        </table-wrap>
      </sec>
      <sec>
        <title>Computing the expected number of named entities</title>
        <p>To select sentences that are most likely to contain named entities of the target category, we need to obtain the <italic>expected number </italic>of named entities contained in each sentence. CRFs are well-suited for this task as the output is fully probabilistic – one can easily obtain probabilistic information on possible tag sequences using established algorithms (i.e. A* and forwrad-backward algorithms).</p>
        <p>Suppose, for example, that the sentence is "Transcription factor GATA-1 and the estrogen receptor". Table <xref ref-type="table" rid="T1">1</xref> shows an example of the 5-best sequences output by the CRF tagger. The sequences are represented by the aforementioned "BIO" representation. For example, the first sequence indicates that there is one named entity 'Transcription factor' in the sequence. By summing up these probabilistic sequences, we can compute the probabilities for possible named entities in a sentence. From the five sequences in Table <xref ref-type="table" rid="T1">1</xref>, we obtain the following three named entities and their corresponding probabilities.</p>
        <p>'Transcription factor' (0.677 + 0.242 = 0.916)</p>
        <p>'estrogen receptor' (0.242 + 0.009 = 0.251)</p>
        <p>'Transcription factor GATA-1' (0.012 + 0.009 = 0.021)</p>
        <p>The expected number of named entities in this sentence can then be calculated as 0.916 + 0.251 + 0.021 = 1.188.</p>
        <p>In this example, we used 5-best sequences as an approximation to all possible sequences needed to compute the exact expected number of entities. One possible way to achieve a good approximation is to use a large <italic>N </italic>for <italic>N</italic>-best sequences, but there is a simpler and more efficient way, which directly produces the exact expected number of entities. Recall that named entities are represented with the "BIO" tags. Since one entity always contains one "B" tag, we can compute the number of expected entities by simply summing up the marginal probabilities for the "B" tags on all tokens in the sentence. The marginal probabilities on each token can be computed by the forward-backward algorithm. This is normally more efficient than computing <italic>N</italic>-best sequences for a large <italic>N</italic>. For efficient implementation of the forward-backward algorithm, see [<xref ref-type="bibr" rid="B13">13</xref>].</p>
        <p>Once we compute the expected number of entities for every unannotated sentence in the corpus, we sort the sentences in descending order of the expected number of entities and choose the top <italic>n </italic>sentences to be presented to the human annotator.</p>
      </sec>
    </sec>
    <sec>
      <title>Coverage estimation</title>
      <p>To ensure the quality of the resulting annotated corpus, it is crucial to be able to know the current coverage of annotation at each iteration in the annotation process. To compute the coverage, however, one needs to know the total number of target named entities in the corpus. The problem is that it is not known until all sentences are annotated.</p>
      <p>In this paper, we solve this dilemma by using an estimated value for the total number of entities. Then, the estimated coverage can be computed as follows:</p>
      <p>
        <disp-formula id="bmcM1">
          <label>(1)</label>
          <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M4" name="1471-2105-9-S11-S8-i4" overflow="scroll">
            <mml:semantics>
              <mml:mrow>
                <mml:mrow>
                  <mml:mo>(</mml:mo>
                  <mml:mrow>
                    <mml:mi>e</mml:mi>
                    <mml:mi>s</mml:mi>
                    <mml:mi>t</mml:mi>
                    <mml:mi>i</mml:mi>
                    <mml:mi>m</mml:mi>
                    <mml:mi>a</mml:mi>
                    <mml:mi>t</mml:mi>
                    <mml:mi>e</mml:mi>
                    <mml:mi>d</mml:mi>
                    <mml:mtext>_</mml:mtext>
                    <mml:mi>c</mml:mi>
                    <mml:mi>o</mml:mi>
                    <mml:mi>v</mml:mi>
                    <mml:mi>e</mml:mi>
                    <mml:mi>r</mml:mi>
                    <mml:mi>a</mml:mi>
                    <mml:mi>g</mml:mi>
                    <mml:mi>e</mml:mi>
                  </mml:mrow>
                  <mml:mo>)</mml:mo>
                </mml:mrow>
                <mml:mo>=</mml:mo>
                <mml:mfrac>
                  <mml:mi>m</mml:mi>
                  <mml:mrow>
                    <mml:mi>m</mml:mi>
                    <mml:mo>+</mml:mo>
                    <mml:mstyle displaystyle="true">
                      <mml:msub>
                        <mml:mo>∑</mml:mo>
                        <mml:mrow>
                          <mml:mi>i</mml:mi>
                          <mml:mo>∈</mml:mo>
                          <mml:mi>U</mml:mi>
                        </mml:mrow>
                      </mml:msub>
                      <mml:mrow>
                        <mml:msub>
                          <mml:mi>E</mml:mi>
                          <mml:mi>i</mml:mi>
                        </mml:msub>
                      </mml:mrow>
                    </mml:mstyle>
                  </mml:mrow>
                </mml:mfrac>
              </mml:mrow>
            </mml:semantics>
          </mml:math>
        </disp-formula>
      </p>
      <p>where <italic>m </italic>is the number of entities actually annotated so far and <italic>E</italic><sub><italic>i </italic></sub>is the expected number of entities in sentence <italic>i</italic>, and <italic>U </italic>is the set of unannotated sentences in the corpus. At any iteration, <italic>m </italic>is always known and <italic>E</italic><sub><italic>i </italic></sub>is obtained from the output of the CRF tagger as explained in the previous section.</p>
    </sec>
  </sec>
  <sec>
    <title>Results and discussion</title>
    <p>We carried out experiments to see how our method can improve the efficiency of annotation process for sparse named entities. We evaluate our method by simulating the annotation process using existing named entity corpora. In other words, we use the gold-standard annotations in the corpus as the annotations that would be made by the human annotator during the annotation process.</p>
    <sec>
      <title>Corpus</title>
      <p>We used two named entity corpora for the experiments. One is the training data provided for the CoNLL-2003 shared task [<xref ref-type="bibr" rid="B1">1</xref>], which consists of 14,041 sentences and includes four named entity categories (LOC, MISC, ORG, and PER) for the general domain. The other is the training data provided for the NLPBA shared task [<xref ref-type="bibr" rid="B14">14</xref>], which consists of 18,546 sentences and five named entity categories (DNA, RNA, cell_line, cell_type, and protein) for the biomedical domain. This corpus is created from the GENIA corpus [<xref ref-type="bibr" rid="B4">4</xref>] by merging the original fine-grained named entity categories.</p>
      <p>Table <xref ref-type="table" rid="T3">3</xref> shows statistics of the named entities included in the corpora. The first column shows the number of named entities for each category. The second column shows the number of the sentences that contain the named entities of each category. We can see that some of the named entity categories are very sparse. For example, named entities of "RNA" appear only in 4.4% of the sentences in the corpus. In contrast, named entities of "protein" appear in more than 70% of the sentences in the corpus.</p>
      <table-wrap position="float" id="T3">
        <label>Table 3</label>
        <caption>
          <p>Statistics of named entities</p>
        </caption>
        <table frame="hsides" rules="groups">
          <thead>
            <tr>
              <td/>
              <td align="right"># Entities</td>
              <td align="right">Sentences (%)</td>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left">CoNLL: LOC</td>
              <td align="right">7,140</td>
              <td align="right">5,127 (36.5%)</td>
            </tr>
            <tr>
              <td align="left">CoNLL: MISC</td>
              <td align="right">3,438</td>
              <td align="right">2,698 (19.2%)</td>
            </tr>
            <tr>
              <td align="left">CoNLL: ORG</td>
              <td align="right">6,321</td>
              <td align="right">4,587 (32.7%)</td>
            </tr>
            <tr>
              <td align="left">CoNLL: PER</td>
              <td align="right">6,600</td>
              <td align="right">4,373 (31.1%)</td>
            </tr>
            <tr>
              <td colspan="3">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">GENIA: DNA</td>
              <td align="right">2,017</td>
              <td align="right">5,251 (28.3%)</td>
            </tr>
            <tr>
              <td align="left">GENIA: RNA</td>
              <td align="right">225</td>
              <td align="right">810 (4.4%)</td>
            </tr>
            <tr>
              <td align="left">GENIA: cell_line</td>
              <td align="right">835</td>
              <td align="right">2,880 (15.5%)</td>
            </tr>
            <tr>
              <td align="left">GENIA: cell_type</td>
              <td align="right">1,104</td>
              <td align="right">5,212 (28.1%)</td>
            </tr>
            <tr>
              <td align="left">GENIA: protein</td>
              <td align="right">5,272</td>
              <td align="right">13,040 (70.3%)</td>
            </tr>
          </tbody>
        </table>
      </table-wrap>
      <p>In the experiments reported in the following sections, we do not use the "protein" category because there is little merit of using our framework when most sentences are relevant to the target category.</p>
    </sec>
    <sec>
      <title>Accelerated annotation</title>
      <p>We carried out eight sets of experiments, each of which corresponds to one of those named entity categories shown in Table <xref ref-type="table" rid="T3">3</xref> (excluding the "protein" category). The number of sentences selected in each iteration (the value of <italic>n </italic>in Figure <xref ref-type="fig" rid="F1">1</xref>) was set to 100 throughout all experiments.</p>
      <p>Figures <xref ref-type="fig" rid="F2">2</xref> to <xref ref-type="fig" rid="F5">5</xref> show the results obtained on the CoNLL corpus. The figures show how the coverage increases as the annotation process proceeds. The x-axis shows the number of annotated sentences.</p>
      <fig position="float" id="F2">
        <label>Figure 2</label>
        <caption>
          <p>Annotation of LOC in the CoNLL corpus.</p>
        </caption>
        <graphic xlink:href="1471-2105-9-S11-S8-2"/>
      </fig>
      <fig position="float" id="F3">
        <label>Figure 3</label>
        <caption>
          <p>Annotation of MISC in the CoNLL corpus.</p>
        </caption>
        <graphic xlink:href="1471-2105-9-S11-S8-3"/>
      </fig>
      <fig position="float" id="F4">
        <label>Figure 4</label>
        <caption>
          <p>Annotation of ORG in the CoNLL corpus.</p>
        </caption>
        <graphic xlink:href="1471-2105-9-S11-S8-4"/>
      </fig>
      <fig position="float" id="F5">
        <label>Figure 5</label>
        <caption>
          <p>Annotation of PER in the CoNLL corpus.</p>
        </caption>
        <graphic xlink:href="1471-2105-9-S11-S8-5"/>
      </fig>
      <p>Each figure contains three lines. The normal line represents the coverage actually achieved, which is computed as follows:</p>
      <p>
        <disp-formula id="bmcM2">
          <label>(2)</label>
          <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M5" name="1471-2105-9-S11-S8-i5" overflow="scroll">
            <mml:semantics>
              <mml:mrow>
                <mml:mrow>
                  <mml:mo>(</mml:mo>
                  <mml:mrow>
                    <mml:mi>c</mml:mi>
                    <mml:mi>o</mml:mi>
                    <mml:mi>v</mml:mi>
                    <mml:mi>e</mml:mi>
                    <mml:mi>r</mml:mi>
                    <mml:mi>a</mml:mi>
                    <mml:mi>g</mml:mi>
                    <mml:mi>e</mml:mi>
                  </mml:mrow>
                  <mml:mo>)</mml:mo>
                </mml:mrow>
                <mml:mo>=</mml:mo>
                <mml:mfrac>
                  <mml:mrow>
                    <mml:mi>e</mml:mi>
                    <mml:mi>n</mml:mi>
                    <mml:mi>t</mml:mi>
                    <mml:mi>i</mml:mi>
                    <mml:mi>t</mml:mi>
                    <mml:mi>i</mml:mi>
                    <mml:mi>e</mml:mi>
                    <mml:mi>s</mml:mi>
                    <mml:mtext>_</mml:mtext>
                    <mml:mi>a</mml:mi>
                    <mml:mi>n</mml:mi>
                    <mml:mi>n</mml:mi>
                    <mml:mi>o</mml:mi>
                    <mml:mi>t</mml:mi>
                    <mml:mi>a</mml:mi>
                    <mml:mi>t</mml:mi>
                    <mml:mi>e</mml:mi>
                    <mml:mi>d</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>t</mml:mi>
                    <mml:mi>o</mml:mi>
                    <mml:mi>t</mml:mi>
                    <mml:mi>a</mml:mi>
                    <mml:mi>l</mml:mi>
                    <mml:mtext>_</mml:mtext>
                    <mml:mi>n</mml:mi>
                    <mml:mi>u</mml:mi>
                    <mml:mi>m</mml:mi>
                    <mml:mi>b</mml:mi>
                    <mml:mi>e</mml:mi>
                    <mml:mi>r</mml:mi>
                    <mml:mtext>_</mml:mtext>
                    <mml:mi>o</mml:mi>
                    <mml:mi>f</mml:mi>
                    <mml:mtext>_</mml:mtext>
                    <mml:mi>e</mml:mi>
                    <mml:mi>n</mml:mi>
                    <mml:mi>t</mml:mi>
                    <mml:mi>i</mml:mi>
                    <mml:mi>t</mml:mi>
                    <mml:mi>i</mml:mi>
                    <mml:mi>e</mml:mi>
                    <mml:mi>s</mml:mi>
                  </mml:mrow>
                </mml:mfrac>
                <mml:mo>.</mml:mo>
              </mml:mrow>
            </mml:semantics>
          </mml:math>
        </disp-formula>
      </p>
      <p>The dashed line represents the coverage estimated by using Equation 1. For the purpose of comparison, the dotted line shows the coverage achieved by the baseline annotation strategy in which sentences are selected sequentially from the beginning to the end in the corpus.</p>
      <p>The figures clearly show that our method can drastically accelerate the annotation process in comparison to the baseline annotation strategy. The improvement is most evident in Figure <xref ref-type="fig" rid="F3">3</xref>, in which named entities of the category "MISC" are annotated.</p>
      <p>We should also note that coverage estimation was surprisingly accurate. In all experiments, the difference between the estimated coverage and the real coverage was very small. This means that we can safely use the estimated coverage as the stopping condition for the annotation work.</p>
      <p>Figures <xref ref-type="fig" rid="F6">6</xref> to <xref ref-type="fig" rid="F9">9</xref> show the experimental results on the GENIA data. The figures show the same characteristics observed in the CoNLL data. The acceleration by our framework was most evident for the "RNA" category. Table <xref ref-type="table" rid="T4">4</xref> shows how much we can save the annotation cost if we stop the annotation process when the estimated coverage reaches 99%. The first column shows the coverage actually achieved, and the second and third columns show the number and percentage of the sentences annotated in the corpus. This result shows that, on average, we can achieve a coverage of 99.0% by annotating 52.4% of the sentences in the corpus. In other words, we could roughly halve the annotation cost by accepting the missing rate of 1.0%.</p>
      <table-wrap position="float" id="T4">
        <label>Table 4</label>
        <caption>
          <p>Coverage achieved when the estimated coverage reached 99%</p>
        </caption>
        <table frame="hsides" rules="groups">
          <thead>
            <tr>
              <td/>
              <td align="center">Coverage</td>
              <td align="right"># Sentences Annotated</td>
              <td align="right">Percentage in the Corpus</td>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left">CoNLL: LOC</td>
              <td align="center">99.1%</td>
              <td align="right">7,600</td>
              <td align="right">54.1%</td>
            </tr>
            <tr>
              <td align="left">CoNLL: MISC</td>
              <td align="center">96.9%</td>
              <td align="right">5,400</td>
              <td align="right">38.5%</td>
            </tr>
            <tr>
              <td align="left">CoNLL: ORG</td>
              <td align="center">99.7%</td>
              <td align="right">8,900</td>
              <td align="right">63.4%</td>
            </tr>
            <tr>
              <td align="left">CoNLL: PER</td>
              <td align="center">98.0%</td>
              <td align="right">6,200</td>
              <td align="right">44.2%</td>
            </tr>
            <tr>
              <td colspan="4">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">GENIA: DNA</td>
              <td align="center">99.8%</td>
              <td align="right">11,900</td>
              <td align="right">64.2%</td>
            </tr>
            <tr>
              <td align="left">GENIA: RNA</td>
              <td align="center">99.2%</td>
              <td align="right">2,500</td>
              <td align="right">13.5%</td>
            </tr>
            <tr>
              <td align="left">GENIA: cell_line</td>
              <td align="center">99.6%</td>
              <td align="right">9,400</td>
              <td align="right">50.7%</td>
            </tr>
            <tr>
              <td align="left">GENIA: cell_type</td>
              <td align="center">99.3%</td>
              <td align="right">8,600</td>
              <td align="right">46.4%</td>
            </tr>
            <tr>
              <td colspan="4">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">Average</td>
              <td align="center">99.0%</td>
              <td align="right">-</td>
              <td align="right">52.4%</td>
            </tr>
          </tbody>
        </table>
      </table-wrap>
      <fig position="float" id="F6">
        <label>Figure 6</label>
        <caption>
          <p>Annotation of DNA in the GENIA corpus.</p>
        </caption>
        <graphic xlink:href="1471-2105-9-S11-S8-6"/>
      </fig>
      <fig position="float" id="F7">
        <label>Figure 7</label>
        <caption>
          <p>Annotation of RNA in the GENIA corpus.</p>
        </caption>
        <graphic xlink:href="1471-2105-9-S11-S8-7"/>
      </fig>
      <fig position="float" id="F8">
        <label>Figure 8</label>
        <caption>
          <p>Annotation of cell_line in the GENIA corpus.</p>
        </caption>
        <graphic xlink:href="1471-2105-9-S11-S8-8"/>
      </fig>
      <fig position="float" id="F9">
        <label>Figure 9</label>
        <caption>
          <p>Annotation of cell_type in the GENIA corpus.</p>
        </caption>
        <graphic xlink:href="1471-2105-9-S11-S8-9"/>
      </fig>
      <p>As expected, the cost reduction was most drastic when "RNA", which is the most sparse named entity category (see Table <xref ref-type="table" rid="T3">3</xref>), was targeted. The cost reduction was more than seven-fold. These experimental results confirm that our annotation framework is particularly useful when applied to sparse named entities.</p>
      <p>One of the potential problems with this kind of active learning-like framework is the computation time required to retrain the tagger at each iteration. Since the human annotator has to wait while the tagger is being retrained, the computation time required for retraining the tagger should not be very long. Table <xref ref-type="table" rid="T5">5</xref> shows the time elapsed in the experiments. We used AMD Opteron 2.2 GHz servers for the experiments and our CRF tagger is implemented in C++. In our experiments, the worst case (i.e. DNA) required 443 seconds for retraining the tagger at the last iteration, but in most cases the training time for each iteration was kept under several minutes. We used the BFGS algorithm for training the CRF model in this work, but it is probably possible to further reduce the training time by using more recent parameter estimation algorithms such as exponentiated gradient algorithms [<xref ref-type="bibr" rid="B15">15</xref>].</p>
      <table-wrap position="float" id="T5">
        <label>Table 5</label>
        <caption>
          <p>Time elapsed when the estimated coverage reached 99%</p>
        </caption>
        <table frame="hsides" rules="groups">
          <thead>
            <tr>
              <td/>
              <td align="right">Cumulative Time (second)</td>
              <td align="right">Last Interval (second)</td>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left">CoNLL: LOC</td>
              <td align="right">3,362</td>
              <td align="right">92</td>
            </tr>
            <tr>
              <td align="left">CoNLL: MISC</td>
              <td align="right">1,818</td>
              <td align="right">61</td>
            </tr>
            <tr>
              <td align="left">CoNLL: ORG</td>
              <td align="right">5,201</td>
              <td align="right">104</td>
            </tr>
            <tr>
              <td align="left">CoNLL: PER</td>
              <td align="right">2,300</td>
              <td align="right">75</td>
            </tr>
            <tr>
              <td colspan="3">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">GENIA: DNA</td>
              <td align="right">33,464</td>
              <td align="right">443</td>
            </tr>
            <tr>
              <td align="left">GENIA: RNA</td>
              <td align="right">822</td>
              <td align="right">56</td>
            </tr>
            <tr>
              <td align="left">GENIA: cell_line</td>
              <td align="right">15,870</td>
              <td align="right">284</td>
            </tr>
            <tr>
              <td align="left">GENIA: cell_type</td>
              <td align="right">13,487</td>
              <td align="right">295</td>
            </tr>
          </tbody>
        </table>
      </table-wrap>
    </sec>
    <sec>
      <title>Suggesting annotation candidates</title>
      <p>In the previous section, we discussed how much we can reduce the number of sentences that need to be examined by the annotator, but we did not discuss the annotation cost for individual sentences presented to the annotator. Here we present some experimental results to show that the annotation cost for each sentence could be reduced if we take advantage of the N-best sequences output from the CRF tagger by using the idea presented in [<xref ref-type="bibr" rid="B16">16</xref>].</p>
      <p>The idea is to present the N-best sequences from the CRF tagger to the annotator as the annotation candidates, so that the annotator does not have to make the annotation for the sentence from scratch. In other words, all (s)he has to do is selecting the correct annotation for the sentence from the list of likely annotations suggested by the system.</p>
      <p>The effectiveness of this approach is almost exclusively dependent on the quality of the annotation candidates generated by the CRF tagger. To investigate their quality, we carried out additional experiments using the GENIA corpus and the RNA category.</p>
      <p>Table <xref ref-type="table" rid="T6">6</xref> shows the result. The first three columns show the number of iteration, the actual coverage achieved, and the estimated coverage respectively. These three columns simply show the same data presented in Figure <xref ref-type="fig" rid="F7">7</xref>. The fourth column shows the percentage of the sentences that contained at least one target named entity, among the 100 sentences presented in each iteration.</p>
      <table-wrap position="float" id="T6">
        <label>Table 6</label>
        <caption>
          <p>Detailed results of the annotation process for GENIA:RNA</p>
        </caption>
        <table frame="hsides" rules="groups">
          <thead>
            <tr>
              <td align="center">Iteration</td>
              <td align="center">Coverage</td>
              <td align="center">Estimated Coverage</td>
              <td align="center">Relevant Sentences</td>
              <td align="center">Coverage of Suggested Annotation</td>
              <td align="center">Average Rank of Suggested Annotation</td>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="center">1</td>
              <td align="center">0.4%</td>
              <td align="center">17.4%</td>
              <td align="center">85%</td>
              <td align="center">86%</td>
              <td align="center">2.64</td>
            </tr>
            <tr>
              <td align="center">2</td>
              <td align="center">11.8%</td>
              <td align="center">15.9%</td>
              <td align="center">90%</td>
              <td align="center">82%</td>
              <td align="center">2.12</td>
            </tr>
            <tr>
              <td align="center">3</td>
              <td align="center">27.9%</td>
              <td align="center">21.1%</td>
              <td align="center">58%</td>
              <td align="center">83%</td>
              <td align="center">2.54</td>
            </tr>
            <tr>
              <td align="center">4</td>
              <td align="center">35.6%</td>
              <td align="center">37.3%</td>
              <td align="center">87%</td>
              <td align="center">94%</td>
              <td align="center">1.48</td>
            </tr>
            <tr>
              <td align="center">5</td>
              <td align="center">45.4%</td>
              <td align="center">49.4%</td>
              <td align="center">89%</td>
              <td align="center">96%</td>
              <td align="center">1.50</td>
            </tr>
            <tr>
              <td align="center">6</td>
              <td align="center">55.6%</td>
              <td align="center">56.3%</td>
              <td align="center">79%</td>
              <td align="center">96%</td>
              <td align="center">1.65</td>
            </tr>
            <tr>
              <td align="center">7</td>
              <td align="center">64.2%</td>
              <td align="center">63.7%</td>
              <td align="center">74%</td>
              <td align="center">98%</td>
              <td align="center">1.60</td>
            </tr>
            <tr>
              <td align="center">8</td>
              <td align="center">72.6%</td>
              <td align="center">72.1%</td>
              <td align="center">55%</td>
              <td align="center">95%</td>
              <td align="center">2.00</td>
            </tr>
            <tr>
              <td align="center">9</td>
              <td align="center">78.7%</td>
              <td align="center">80.9%</td>
              <td align="center">56%</td>
              <td align="center">98%</td>
              <td align="center">1.78</td>
            </tr>
            <tr>
              <td align="center">10</td>
              <td align="center">84.8%</td>
              <td align="center">84.1%</td>
              <td align="center">36%</td>
              <td align="center">99%</td>
              <td align="center">1.54</td>
            </tr>
            <tr>
              <td align="center">11</td>
              <td align="center">88.6%</td>
              <td align="center">88.1%</td>
              <td align="center">18%</td>
              <td align="center">99%</td>
              <td align="center">1.48</td>
            </tr>
            <tr>
              <td align="center">12</td>
              <td align="center">90.7%</td>
              <td align="center">92.5%</td>
              <td align="center">21%</td>
              <td align="center">98%</td>
              <td align="center">1.31</td>
            </tr>
            <tr>
              <td align="center">13</td>
              <td align="center">93.2%</td>
              <td align="center">92.9%</td>
              <td align="center">12%</td>
              <td align="center">98%</td>
              <td align="center">1.21</td>
            </tr>
            <tr>
              <td align="center">14</td>
              <td align="center">94.6%</td>
              <td align="center">94.3%</td>
              <td align="center">12%</td>
              <td align="center">100%</td>
              <td align="center">1.24</td>
            </tr>
            <tr>
              <td align="center">15</td>
              <td align="center">96.0%</td>
              <td align="center">96.4%</td>
              <td align="center">12%</td>
              <td align="center">99%</td>
              <td align="center">1.27</td>
            </tr>
            <tr>
              <td align="center">16</td>
              <td align="center">97.5%</td>
              <td align="center">97.2%</td>
              <td align="center">4%</td>
              <td align="center">99%</td>
              <td align="center">1.03</td>
            </tr>
            <tr>
              <td align="center">17</td>
              <td align="center">97.9%</td>
              <td align="center">97.8%</td>
              <td align="center">5%</td>
              <td align="center">99%</td>
              <td align="center">1.11</td>
            </tr>
            <tr>
              <td align="center">18</td>
              <td align="center">98.6%</td>
              <td align="center">96.6%</td>
              <td align="center">2%</td>
              <td align="center">100%</td>
              <td align="center">1.15</td>
            </tr>
            <tr>
              <td align="center">19</td>
              <td align="center">98.8%</td>
              <td align="center">98.2%</td>
              <td align="center">3%</td>
              <td align="center">99%</td>
              <td align="center">1.02</td>
            </tr>
            <tr>
              <td align="center">20</td>
              <td align="center">99.2%</td>
              <td align="center">98.4%</td>
              <td align="center">0%</td>
              <td align="center">100%</td>
              <td align="center">1.00</td>
            </tr>
            <tr>
              <td align="center">21</td>
              <td align="center">99.2%</td>
              <td align="center">98.6%</td>
              <td align="center">0%</td>
              <td align="center">100%</td>
              <td align="center">1.00</td>
            </tr>
            <tr>
              <td align="center">22</td>
              <td align="center">99.2%</td>
              <td align="center">98.8%</td>
              <td align="center">0%</td>
              <td align="center">100%</td>
              <td align="center">1.00</td>
            </tr>
            <tr>
              <td align="center">23</td>
              <td align="center">99.2%</td>
              <td align="center">98.9%</td>
              <td align="center">0%</td>
              <td align="center">100%</td>
              <td align="center">1.00</td>
            </tr>
            <tr>
              <td align="center">24</td>
              <td align="center">99.2%</td>
              <td align="center">99.0%</td>
              <td align="center">0%</td>
              <td align="center">100%</td>
              <td align="center">1.00</td>
            </tr>
            <tr>
              <td align="center">25</td>
              <td align="center">99.2%</td>
              <td align="center">99.1%</td>
              <td align="center">0%</td>
              <td align="center">100%</td>
              <td align="center">1.00</td>
            </tr>
          </tbody>
        </table>
      </table-wrap>
      <p>In this experiment, we assumed that the CRF tagger generates 10 annotation candidates for each sentence. The fifth column in Table <xref ref-type="table" rid="T6">6</xref> shows the percentage of the cases where the correct annotation for the sentence was actually included in the candidates. The sixth column shows the average rank of the correct annotation in the candidates. The experimental results were promising – the correct annotation was included in the top 10 candidates in most cases and they are usually highly ranked in the list.</p>
    </sec>
    <sec>
      <title>Enriching an existing corpus</title>
      <p>In the experiments presented in the previous sections, we assumed that the annotation work for each named entity category is carried out independently from other categories. However, there are cases where we can take advantage of the information about named entities of other categories.</p>
      <p>Let us suppose a situation where we want to enrich an existing named entity corpus with a new named entity category. If named entities are not allowed to overlap, we can rule out the text regions that are already covered by the existing named entity categories when computing the expected numbers of target named entities, which should improve the accuracy of estimated coverage and lead to improved efficiency of annotation work.</p>
      <p>We carried out another set of experiments to simulate this kind of situation. We used the same eight categories that were used in the previous experiments, but we assumed the existence of the named entities of the other categories. For example, when we ran the experiments for the LOC category in the CoNLL corpus, we assumed that the corpus was already annotated with the other three categories (i.e. MISC, ORG, and PER) and named entities were not allowed to overlap.</p>
      <p>The results are shown in Table <xref ref-type="table" rid="T7">7</xref>. As expected, the numbers of sentences that needed to be examined were much smaller than those in the previous experiments shown in Table <xref ref-type="table" rid="T4">4</xref>.</p>
      <table-wrap position="float" id="T7">
        <label>Table 7</label>
        <caption>
          <p>Coverage achieved when the estimated coverage reached 99% (assuming the named entities of the other categories are already annotated in the corpus)</p>
        </caption>
        <table frame="hsides" rules="groups">
          <thead>
            <tr>
              <td/>
              <td align="center">Coverage</td>
              <td align="right"># Sentences Annotated</td>
              <td align="right">Percentage in the Corpus</td>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left">CoNLL: LOC</td>
              <td align="center">98.5%</td>
              <td align="right">5,500</td>
              <td align="right">39.2%</td>
            </tr>
            <tr>
              <td align="left">CoNLL: MISC</td>
              <td align="center">95.0%</td>
              <td align="right">3,200</td>
              <td align="right">22.8%</td>
            </tr>
            <tr>
              <td align="left">CoNLL: ORG</td>
              <td align="center">99.0%</td>
              <td align="right">5,400</td>
              <td align="right">38.5%</td>
            </tr>
            <tr>
              <td align="left">CoNLL: PER</td>
              <td align="center">97.9%</td>
              <td align="right">4,700</td>
              <td align="right">33.5%</td>
            </tr>
            <tr>
              <td colspan="4">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">GENIA: DNA</td>
              <td align="center">99.6%</td>
              <td align="right">8,200</td>
              <td align="right">44.2%</td>
            </tr>
            <tr>
              <td align="left">GENIA: RNA</td>
              <td align="center">99.5%</td>
              <td align="right">1,800</td>
              <td align="right">9.7%</td>
            </tr>
            <tr>
              <td align="left">GENIA: cell_line</td>
              <td align="center">99.3%</td>
              <td align="right">5,000</td>
              <td align="right">27.0%</td>
            </tr>
            <tr>
              <td align="left">GENIA: cell_type</td>
              <td align="center">99.2%</td>
              <td align="right">7,000</td>
              <td align="right">37.7%</td>
            </tr>
            <tr>
              <td colspan="4">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">Average</td>
              <td align="center">98.5%</td>
              <td align="right">-</td>
              <td align="right">31.6%</td>
            </tr>
          </tbody>
        </table>
      </table-wrap>
    </sec>
  </sec>
  <sec>
    <title>Discussion and related work</title>
    <p>Our annotation framework is, by definition, not something that can ensure a coverage of 100%. The seriousness of a missing rate of, for example, 1% is not entirely clear – it depends on the application and the purpose of annotation. In general, however, it is hard to achieve a coverage of 100% in real annotation work even if the human annotator scans through all sentences, because there is often ambiguity in deciding whether a particular named entity should be annotated or not. Previous studies report that inter-annotator agreement rates with regards to gene/protein name annotation are f-scores around 90% [<xref ref-type="bibr" rid="B17">17</xref>,<xref ref-type="bibr" rid="B18">18</xref>]. We believe that the missing rate of 1% can be an acceptable level of sacrifice, given the cost reduction achieved and the unavoidable discrepancy made by the human annotator.</p>
    <p>At the same time, we should also note that our framework could be used in conjunction with existing methods for semi-supervised learning to improve the performance of the CRF tagger, which in turn will improve the coverage. It is also possible to improve the performance of the tagger by using external dictionaries or using more sophisticated probabilistic models such as semi-Markov CRFs [<xref ref-type="bibr" rid="B19">19</xref>]. These enhancements should further improve the coverage, keeping the same degree of cost reduction.</p>
    <p>The idea of improving the efficiency of annotation work by using automatic taggers is certainly not new. Tanabe et al. [<xref ref-type="bibr" rid="B6">6</xref>] applied a gene/protein name tagger to the target sentences and modified the results manually. Culotta and McCallum [<xref ref-type="bibr" rid="B16">16</xref>] proposed to have the human annotator select the correct annotation from multiple choices produced by a CRF tagger for each sentence. Tomanek et al. [<xref ref-type="bibr" rid="B20">20</xref>] discuss the reusability of named entity-annotated corpora created by an active learning approach and show that it is possible to build a corpus that is useful to different machine learning algorithms to a certain degree.</p>
    <p>The limitation of our framework is that it is useful only when the target named entities are sparse because the upper bound of cost saving is limited by the proportion of the relevant sentences in the corpus. Our framework may therefore not be suitable for a situation where one wants to make annotations for named entities of many categories simultaneously (e.g. creating a corpus like GENIA from scratch). In contrast, our framework should be useful in a situation where one needs to modify or enrich named entity annotations in an existing corpus, because the target named entities are almost always sparse in such cases. We should also note that named entities in full papers, which recently started to attract much attention, tend to be more sparse than those in abstracts.</p>
  </sec>
  <sec>
    <title>Conclusion</title>
    <p>We have presented a simple but powerful framework for reducing the human effort for making name entity annotations in a corpus. The proposed framework allows us to annotate <italic>almost </italic>all named entities of the target category in the given corpus without having to scan through all the sentences. The framework also allows us to know when to stop the annotation process by consulting the estimated coverage of annotation.</p>
    <p>Experimental results demonstrated that the framework can reduce the number of sentences to be annotated almost by half, achieving a coverage of 99.0%. Our framework was particularly effective when the target named entities were very sparse.</p>
    <p>Unlike active learning, this work enables us to create a named entity corpus that is free from the sampling bias introduced by the active learning strategy. This work will therefore be especially useful when one needs to enrich an existing linguistic corpus (e.g. WSJ, GENIA, or PennBioIE) with named entity annotations for a new semantic category.</p>
  </sec>
  <sec>
    <title>Competing interests</title>
    <p>The authors declare that they have no competing interests.</p>
  </sec>
  <sec>
    <title>Authors' contributions</title>
    <p>YT developed the algorithm, carried out the experiments and drafted the manuscript. JT and SA conceived the study and participated in its design and coordination. All authors read and approved the final manuscript.</p>
  </sec>
</body>
<back>
  <ack>
    <sec>
      <title>Acknowledgements</title>
      <p>We thank the anonymous reviewers of this paper (including earlier manuscripts) for useful ideas, comments and suggestions, which greatly helped improve the paper. This work is supported by the REFINE project (BBSRC grant BB/E004431/1). The UK National Centre for Text Mining is sponsored by the JISC/BBSRC/EPSRC.</p>
      <p>This article has been published as part of <italic>BMC Bioinformatics </italic>Volume 9 Supplement 11, 2008: Proceedings of the BioNLP 08 ACL Workshop: Themes in biomedical language processing. The full contents of the supplement are available online at <ext-link ext-link-type="uri" xlink:href="http://www.biomedcentral.com/1471-2105/9?issue=S11"/></p>
    </sec>
  </ack>
  <ref-list>
    <ref id="B1">
      <citation citation-type="other">
        <person-group person-group-type="author">
          <name>
            <surname>Tjong Kim Sang</surname>
            <given-names>EF</given-names>
          </name>
          <name>
            <surname>De Meulder</surname>
            <given-names>F</given-names>
          </name>
        </person-group>
        <article-title>Introduction to the CoNLL-2003 Shared Task: Language-Independent Named Entity Recognition</article-title>
        <source>Proceedings of CoNLL-2003</source>
        <year>2003</year>
        <fpage>142</fpage>
        <lpage>147</lpage>
      </citation>
    </ref>
    <ref id="B2">
      <citation citation-type="other">
        <person-group person-group-type="author">
          <name>
            <surname>Settles</surname>
            <given-names>B</given-names>
          </name>
        </person-group>
        <article-title>Biomedical Named Entity Recognition using Conditional Random Fields and Rich Feature Sets</article-title>
        <source>COLING 2004 International Joint workshop on Natural Language Processing in Biomedicine and its Applications (NLPBA/BioNLP) 2004</source>
        <year>2004</year>
        <fpage>107</fpage>
        <lpage>110</lpage>
      </citation>
    </ref>
    <ref id="B3">
      <citation citation-type="other">
        <person-group person-group-type="author">
          <name>
            <surname>Okanohara</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Miyao</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Tsuruoka</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Tsujii</surname>
            <given-names>J</given-names>
          </name>
        </person-group>
        <article-title>Improving the Scalability of Semi-Markov Conditional Random Fields for Named Entity Recognition</article-title>
        <source>Proceedings of COLING/ACL</source>
        <year>2006</year>
        <fpage>465</fpage>
        <lpage>472</lpage>
      </citation>
    </ref>
    <ref id="B4">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Kim</surname>
            <given-names>JD</given-names>
          </name>
          <name>
            <surname>Ohta</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Tateisi</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Tsujii</surname>
            <given-names>J</given-names>
          </name>
        </person-group>
        <article-title>GENIA corpus-a semantically annotated corpus for bio-textmining</article-title>
        <source>Bioinformatics</source>
        <year>2003</year>
        <volume>19</volume>
        <fpage>i180</fpage>
        <lpage>i182</lpage>
        <pub-id pub-id-type="pmid">12855455</pub-id>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btg1023</pub-id>
      </citation>
    </ref>
    <ref id="B5">
      <citation citation-type="other">
        <person-group person-group-type="author">
          <name>
            <surname>Kulick</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Bies</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Libeman</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Mandel</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>McDonald</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Palmer</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Schein</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Ungar</surname>
            <given-names>L</given-names>
          </name>
        </person-group>
        <article-title>Integrated Annotation for Biomedical Information Extraction</article-title>
        <source>Proceedings of HLT-NAACL 2004 Workshop: Biolink 2004</source>
        <year>2004</year>
        <fpage>61</fpage>
        <lpage>68</lpage>
      </citation>
    </ref>
    <ref id="B6">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Tanabe</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Xie</surname>
            <given-names>N</given-names>
          </name>
          <name>
            <surname>Thom</surname>
            <given-names>LH</given-names>
          </name>
          <name>
            <surname>Matten</surname>
            <given-names>W</given-names>
          </name>
          <name>
            <surname>Wilbur</surname>
            <given-names>WJ</given-names>
          </name>
        </person-group>
        <article-title>GENETAG: a tagged corpus for gene/protein named entity recognition</article-title>
        <source>BMC Bioinformatics</source>
        <year>2005</year>
        <volume>6</volume>
        <fpage>S3</fpage>
        <pub-id pub-id-type="pmid">15960837</pub-id>
        <pub-id pub-id-type="doi">10.1186/1471-2105-6-S1-S3</pub-id>
      </citation>
    </ref>
    <ref id="B7">
      <citation citation-type="other">
        <person-group person-group-type="author">
          <name>
            <surname>Dagan</surname>
            <given-names>I</given-names>
          </name>
          <name>
            <surname>Engelson</surname>
            <given-names>SP</given-names>
          </name>
        </person-group>
        <article-title>Committee-Based Sampling For Training Probabilistic Classifiers</article-title>
        <source>Proceedings of ICML</source>
        <year>1995</year>
        <fpage>150</fpage>
        <lpage>157</lpage>
      </citation>
    </ref>
    <ref id="B8">
      <citation citation-type="other">
        <person-group person-group-type="author">
          <name>
            <surname>Engelson</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Dagan</surname>
            <given-names>I</given-names>
          </name>
        </person-group>
        <article-title>Minimizing Manual Annotation Cost in Supervised Training from Corpora</article-title>
        <source>Proceedings of ACL</source>
        <year>1996</year>
        <fpage>319</fpage>
        <lpage>326</lpage>
      </citation>
    </ref>
    <ref id="B9">
      <citation citation-type="other">
        <person-group person-group-type="author">
          <name>
            <surname>Thompson</surname>
            <given-names>CA</given-names>
          </name>
          <name>
            <surname>Califf</surname>
            <given-names>ME</given-names>
          </name>
          <name>
            <surname>Mooney</surname>
            <given-names>RJ</given-names>
          </name>
        </person-group>
        <article-title>Active learning for natural language parsing and information extraction</article-title>
        <source>Proceedings of ICML</source>
        <year>1999</year>
        <fpage>406</fpage>
        <lpage>414</lpage>
      </citation>
    </ref>
    <ref id="B10">
      <citation citation-type="other">
        <person-group person-group-type="author">
          <name>
            <surname>Shen</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Zhang</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Su</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Zhou</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Tan</surname>
            <given-names>CL</given-names>
          </name>
        </person-group>
        <article-title>Multi-Criteria-based Active Learning for Named Entity Recognition</article-title>
        <source>Proceedings of ACL, Barcelona, Spain</source>
        <year>2004</year>
        <fpage>589</fpage>
        <lpage>596</lpage>
      </citation>
    </ref>
    <ref id="B11">
      <citation citation-type="other">
        <person-group person-group-type="author">
          <name>
            <surname>Lafferty</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>McCallum</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Pereira</surname>
            <given-names>F</given-names>
          </name>
        </person-group>
        <article-title>Conditional Random Fields: Probabilistic Models for Segmenting and Labeling Sequence Data</article-title>
        <source>Proceedings of ICML</source>
        <year>2001</year>
        <fpage>282</fpage>
        <lpage>289</lpage>
      </citation>
    </ref>
    <ref id="B12">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Nocedal</surname>
            <given-names>J</given-names>
          </name>
        </person-group>
        <article-title>Updating Quasi-Newton Matrices With Limited Storage</article-title>
        <source>Mathematics of Computation</source>
        <year>1980</year>
        <volume>35</volume>
        <fpage>773</fpage>
        <lpage>782</lpage>
        <pub-id pub-id-type="doi">10.2307/2006193</pub-id>
      </citation>
    </ref>
    <ref id="B13">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Rabiner</surname>
            <given-names>LR</given-names>
          </name>
        </person-group>
        <article-title>A tutorial on hidden Markov models and selected applications inspeech recognition</article-title>
        <source>Proceedings of the IEEE</source>
        <year>1989</year>
        <volume>77</volume>
        <fpage>257</fpage>
        <lpage>286</lpage>
        <pub-id pub-id-type="doi">10.1109/5.18626</pub-id>
      </citation>
    </ref>
    <ref id="B14">
      <citation citation-type="other">
        <person-group person-group-type="author">
          <name>
            <surname>Kim</surname>
            <given-names>JD</given-names>
          </name>
          <name>
            <surname>Ohta</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Tsuruoka</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Tateisi</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Collier</surname>
            <given-names>N</given-names>
          </name>
        </person-group>
        <article-title>Introduction to the bio-entity recognition task at JNLPBA</article-title>
        <source>Proceedings of the International Joint Workshop on Natural Language Processing in Biomedicine and its Applications (JNLPBA)</source>
        <year>2004</year>
        <fpage>70</fpage>
        <lpage>75</lpage>
      </citation>
    </ref>
    <ref id="B15">
      <citation citation-type="other">
        <person-group person-group-type="author">
          <name>
            <surname>Globerson</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Koo</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Carreras</surname>
            <given-names>X</given-names>
          </name>
          <name>
            <surname>Collins</surname>
            <given-names>M</given-names>
          </name>
        </person-group>
        <article-title>Exponentiated gradient algorithms for log-linear structured prediction</article-title>
        <source>Proceedings of ICML</source>
        <year>2007</year>
        <fpage>305</fpage>
        <lpage>312</lpage>
      </citation>
    </ref>
    <ref id="B16">
      <citation citation-type="other">
        <person-group person-group-type="author">
          <name>
            <surname>Culotta</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>McCallum</surname>
            <given-names>A</given-names>
          </name>
        </person-group>
        <article-title>Reducing Labeling Effort for Structured Prediction Tasks</article-title>
        <source>Proceedings of AAAI-05</source>
        <year>2005</year>
        <fpage>746</fpage>
        <lpage>751</lpage>
      </citation>
    </ref>
    <ref id="B17">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Morgan</surname>
            <given-names>AA</given-names>
          </name>
          <name>
            <surname>Hirschman</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Colosimo</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Yeh</surname>
            <given-names>AS</given-names>
          </name>
          <name>
            <surname>Colombe</surname>
            <given-names>JB</given-names>
          </name>
        </person-group>
        <article-title>Gene name identification and normalization using a model organism database</article-title>
        <source>Journal of Biomedical Informatics</source>
        <year>2004</year>
        <volume>37</volume>
        <fpage>396</fpage>
        <lpage>410</lpage>
        <pub-id pub-id-type="pmid">15542014</pub-id>
        <pub-id pub-id-type="doi">10.1016/j.jbi.2004.08.010</pub-id>
      </citation>
    </ref>
    <ref id="B18">
      <citation citation-type="other">
        <person-group person-group-type="author">
          <name>
            <surname>Vlachos</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Gasperin</surname>
            <given-names>C</given-names>
          </name>
        </person-group>
        <article-title>Bootstrapping and Evaluating Named Entity Recognition in the Biomedical Domain</article-title>
        <source>Proceedings of the HLT-NAACL BioNLP Workshop on Linking Natural Language and Biology</source>
        <year>2006</year>
        <fpage>138</fpage>
        <lpage>145</lpage>
      </citation>
    </ref>
    <ref id="B19">
      <citation citation-type="other">
        <person-group person-group-type="author">
          <name>
            <surname>Sarawagi</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Cohen</surname>
            <given-names>WW</given-names>
          </name>
        </person-group>
        <article-title>Semi-Markov Conditional Random Fields for Information Extraction</article-title>
        <source>Proceedings of NIPS</source>
        <year>2004</year>
      </citation>
    </ref>
    <ref id="B20">
      <citation citation-type="other">
        <person-group person-group-type="author">
          <name>
            <surname>Tomanek</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Wermter</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Hahn</surname>
            <given-names>U</given-names>
          </name>
        </person-group>
        <article-title>An Approach to Text Corpus Construction which Cuts Annotation Costs and Maintains Reusability of Annotated Data</article-title>
        <source>Proceedings of EMNLP-CoNLL</source>
        <year>2007</year>
        <fpage>486</fpage>
        <lpage>495</lpage>
      </citation>
    </ref>
  </ref-list>
</back>
