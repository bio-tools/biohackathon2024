<?DTDIdentifier.IdentifierValue article.dtd?>
<?DTDIdentifier.IdentifierType system?>
<?SourceDTD.DTDName article.dtd?>
<?SourceDTD.Version 1.0?>
<?ConverterInfo.XSLTName bmc2nlmx2.xsl?>
<?ConverterInfo.Version 2?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">BMC Syst Biol</journal-id>
    <journal-id journal-id-type="iso-abbrev">BMC Syst Biol</journal-id>
    <journal-title-group>
      <journal-title>BMC Systems Biology</journal-title>
    </journal-title-group>
    <issn pub-type="epub">1752-0509</issn>
    <publisher>
      <publisher-name>BioMed Central</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">3403322</article-id>
    <article-id pub-id-type="publisher-id">1752-0509-6-S1-S19</article-id>
    <article-id pub-id-type="doi">10.1186/1752-0509-6-S1-S19</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Research</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>A novel neural response algorithm for protein function prediction</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" id="A1">
        <name>
          <surname>Yalamanchili</surname>
          <given-names>Hari Krishna</given-names>
        </name>
        <xref ref-type="aff" rid="I1">1</xref>
        <xref ref-type="aff" rid="I2">2</xref>
        <email>hari@hku.hk</email>
      </contrib>
      <contrib contrib-type="author" id="A2">
        <name>
          <surname>Xiao</surname>
          <given-names>Quan-Wu</given-names>
        </name>
        <xref ref-type="aff" rid="I3">3</xref>
        <email>qwxiao@live.com</email>
      </contrib>
      <contrib contrib-type="author" corresp="yes" id="A3">
        <name>
          <surname>Wang</surname>
          <given-names>Junwen</given-names>
        </name>
        <xref ref-type="aff" rid="I1">1</xref>
        <xref ref-type="aff" rid="I2">2</xref>
        <xref ref-type="aff" rid="I4">4</xref>
        <email>junwen@hku.hk </email>
      </contrib>
    </contrib-group>
    <aff id="I1"><label>1</label>Department of Biochemistry, LKS Faculty of Medicine, The University of Hong Kong, Hong Kong SAR, China</aff>
    <aff id="I2"><label>2</label>Shenzhen Institute of Research and Innovation, The University of Hong Kong, Shenzhen, China</aff>
    <aff id="I3"><label>3</label>Department of Mathematics, City University of Hong Kong, Hong Kong SAR, China</aff>
    <aff id="I4"><label>4</label>Centre for Genomic Sciences, LKS Faculty of Medicine, The University of Hong Kong, Hong Kong SAR, China</aff>
    <pub-date pub-type="collection">
      <year>2012</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>16</day>
      <month>7</month>
      <year>2012</year>
    </pub-date>
    <volume>6</volume>
    <issue>Suppl 1</issue>
    <supplement>
      <named-content content-type="supplement-title">Selected articles from The 5th IEEE International Conference on Systems Biology (ISB 2011)</named-content>
      <named-content content-type="supplement-editor">Luonan Chen, Xiang-Sun Zhang and Yong Wang</named-content>
    </supplement>
    <fpage>S19</fpage>
    <lpage>S19</lpage>
    <permissions>
      <copyright-statement>Copyright ©2012 Yalamanchili et al.; licensee BioMed Central Ltd.</copyright-statement>
      <copyright-year>2012</copyright-year>
      <copyright-holder>Yalamanchili et al.; licensee BioMed Central Ltd.</copyright-holder>
      <license license-type="open-access" xlink:href="http://creativecommons.org/licenses/by/2.0">
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/2.0">http://creativecommons.org/licenses/by/2.0</ext-link>), which permits unrestricted use, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="http://www.biomedcentral.com/1752-0509/6/S1/S19"/>
    <abstract>
      <sec>
        <title>Background</title>
        <p>Large amounts of data are being generated by high-throughput genome sequencing methods. But the rate of the experimental functional characterization falls far behind. To fill the gap between the number of sequences and their annotations, fast and accurate automated annotation methods are required. Many methods, such as GOblet, GOFigure, and Gotcha, are designed based on the BLAST search. Unfortunately, the sequence coverage of these methods is low as they cannot detect the remote homologues. Adding to this, the lack of annotation specificity advocates the need to improve automated protein function prediction.</p>
      </sec>
      <sec>
        <title>Results</title>
        <p>We designed a novel automated protein functional assignment method based on the neural response algorithm, which simulates the neuronal behavior of the visual cortex in the human brain. Firstly, we predict the most similar target protein for a given query protein and thereby assign its GO term to the query sequence. When assessed on test set, our method ranked the actual leaf GO term among the top 5 probable GO terms with accuracy of 86.93%.</p>
      </sec>
      <sec>
        <title>Conclusions</title>
        <p>The proposed algorithm is the first instance of neural response algorithm being used in the biological domain. The use of HMM profiles along with the secondary structure information to define the neural response gives our method an edge over other available methods on annotation accuracy. Results of the 5-fold cross validation and the comparison with PFP and FFPred servers indicate the prominent performance by our method. The program, the dataset, and help files are available at <ext-link ext-link-type="uri" xlink:href="http://www.jjwanglab.org/NRProF/">http://www.jjwanglab.org/NRProF/</ext-link>.</p>
      </sec>
    </abstract>
    <conference>
      <conf-date>02-04 September 2011</conf-date>
      <conf-name>The 5th IEEE International Conference on Computational Systems Biology (ISB 2011)</conf-name>
      <conf-loc>Zhuhai, China</conf-loc>
    </conference>
  </article-meta>
</front>
<body>
  <sec>
    <title>Background</title>
    <p>Recent advances in high-throughput sequencing technologies have enabled the scientific community to sequence a large number of genomes. Currently there are 1,390 complete genomes [<xref ref-type="bibr" rid="B1">1</xref>] annotated in the KEGG genome repository and many more are in progress. However, experimental functional characterization of these genes cannot match the data production rate. Adding to this, more than 50% of functional annotations are enigmatic [<xref ref-type="bibr" rid="B2">2</xref>]. Even the well studied genomes, such as <italic>E. coli </italic>and <italic>C. elegans</italic>, have 51.17% and 87.92% ambiguous annotations (putative, probable and unknown) respectively [<xref ref-type="bibr" rid="B2">2</xref>]. To fill the gap between the number of sequences and their (quality) annotations, we need fast, yet accurate automated functional annotation methods. Such computational annotation methods are also critical in analyzing, interpreting and characterizing large complex data sets from high-throughput experimental methods, such as protein-protein interactions (PPI) [<xref ref-type="bibr" rid="B3">3</xref>] and gene expression data by clustering similar genes and proteins.</p>
    <p>The definition of biological function itself is enigmatic in biology and highly context dependent [<xref ref-type="bibr" rid="B4">4</xref>-<xref ref-type="bibr" rid="B6">6</xref>]. This is part of the reason why more than 50% of functional annotations are ambiguous. The functional scope of a protein in an organism differs depending on the aspects under consideration. Proteins can be annotated based on their mode of action, i.e. Enzyme Commission (EC) number [<xref ref-type="bibr" rid="B7">7</xref>] (physiological aspect) or their association with a disease (phenotypic aspect). The lack of functional coherence increases the complexity of automated functional annotation. Another major barrier is the use of different vocabulary by different annotations. A function can be described differently in different organisms [<xref ref-type="bibr" rid="B8">8</xref>]. This problem can be solved by using ontologies, which serve as universal functional definitions. Enzyme Commission (E.C) [<xref ref-type="bibr" rid="B9">9</xref>], MIPS Functional Catalogue (FunCat) [<xref ref-type="bibr" rid="B10">10</xref>] and Gene Ontology (GO) [<xref ref-type="bibr" rid="B11">11</xref>] are such ontologies. With GO being the most recently and widely used, many automated annotation methods use GO for functional annotation.</p>
    <p>Protein function assignment methods can be divided into two main categories - structure-based methods and sequence-based methods. A protein's function is highly related to its structure. Protein structure tends to be more conserved than the amino acid sequence in the course of evolution [<xref ref-type="bibr" rid="B12">12</xref>,<xref ref-type="bibr" rid="B13">13</xref>]. Thus a variety of structure-based function prediction methods [<xref ref-type="bibr" rid="B14">14</xref>,<xref ref-type="bibr" rid="B15">15</xref>] rely on structure similarities. These methods start with a predicted structure of the query protein and search for similar structural motifs in various structural classification databases such as CATH [<xref ref-type="bibr" rid="B16">16</xref>] and SCOP [<xref ref-type="bibr" rid="B17">17</xref>] for function prediction. Structural alignments can reveal the remote homology for 80-90% of the entries in Protein Data Bank [<xref ref-type="bibr" rid="B18">18</xref>] even if no significant sequence similarity was found for the two proteins [<xref ref-type="bibr" rid="B19">19</xref>]. However, these methods are limited by the accuracy of the initial query structure prediction and the availability of the homologous structures in the structural databases. Despite of being highly accurate, the big gap between the number of sequences and their solved structures restricts the use of structure-based methods. Therefore, sequence-based methods are needed.</p>
    <p>The main idea behind sequence-based methods is to compare the query protein to the proteins that are well characterized, and the function of the best hit is directly assigned to the query sequence. GO annotations are assigned to the BLAST search results [<xref ref-type="bibr" rid="B20">20</xref>] for the first time by GOblet [<xref ref-type="bibr" rid="B21">21</xref>] which maps the sequence hits to their GO terms. Later on the GO terms are given weights based on the <italic>E-value </italic>of the BLAST search by Ontoblast [<xref ref-type="bibr" rid="B22">22</xref>]. This was further refined in GOfigure [<xref ref-type="bibr" rid="B23">23</xref>] and GOtcha [<xref ref-type="bibr" rid="B24">24</xref>] by communicating the scores from one level to the other in the GO hierarchy tree. All these methods are based on the BLAST search results; thus they fail to identify the remote homologues with a higher <italic>E-value</italic>. This problem is tackled by the Protein Function Prediction (PFP) server [<xref ref-type="bibr" rid="B25">25</xref>], which replaces the BLAST with PSI-BLAST [<xref ref-type="bibr" rid="B26">26</xref>] and thus can detect remote homologues. The PFP server can predict the generalized function of protein sequences with remote homology, but with a trade-off of low specificity. FFPred [<xref ref-type="bibr" rid="B27">27</xref>] is the most recent protein function prediction server that builds Support Vector Machine (SVM) classifiers based on the extracted sequence features of the query sequence and thus it does not require prior identification of protein sequence homologues. However the server needs one SVM classifier for each GO term, which makes it computationally expensive. Furthermore, the server only provides classifiers for 111 Molecular function and 86 Biological Process categories that represent more general annotations, which limits its usage in deciphering specific annotations. The lack of annotation specificity and high complexity of the existing methods advocate the need of improvement in the automated protein function prediction.</p>
    <p>Here we present a novel automated protein functional assignment method based on the neural response algorithm [<xref ref-type="bibr" rid="B28">28</xref>]. The algorithm simulates the neuronal behavior of human's image recognition, and has been successfully applied for image classification. The main idea of this algorithm is to define a distance metric that corresponds to the similarity of small patches of the images and reflects how the human brain can distinguish different images. This algorithm uses a multi-layer framework with spatial scale, and size increasing as we move from the one layer to the other in a bottom-up fashion. The bottom layer consists of templates (sub-patches) of the images and the intermediate layers consist of secondary templates formed by the assembly of the templates in the lower layers. The whole image is in the topmost layer. For example consider a three layered architecture of templates (patches) <italic>p</italic>, <italic>q </italic>and <italic>r </italic>(whole image), with <italic>p </italic>⊂ <italic>q </italic>⊂ <italic>r </italic>as shown in Figure <xref ref-type="fig" rid="F1">1</xref>. Let <italic>Im(p)</italic>, <italic>Im(q) </italic>and <italic>Im(r) </italic>be the function spaces corresponding to the similarity of the templates in the layers <italic>p</italic>, <italic>q </italic>and <italic>r </italic>respectively. <italic>Im(x) </italic>gives the similarity between any two patches in the layer <italic>x </italic>and a mapping set <italic>m</italic>: that maps the templates from the bottom most layer to the templates in the next layer i.e. <italic>m<sub>p</sub>: p → q</italic>, and similarly <italic>m<sub>q</sub>: q → r</italic>. Having defined the layers (<italic>p, q and r</italic>) and the initial layers similarity function <italic>Im(p)</italic>, the algorithm builds a derived kernel on the top of layer <italic>r </italic>in a bottom-up fashion. The process starts with the calculation of initial reproducing kernel <italic>k<sub>p </sub></italic>on the bottom most layer <italic>p </italic>as the inner product of its functional space <italic>Im(p)×Im(p)</italic>. Based on the this initial kernel <italic>k<sub>p</sub></italic>, intermediate derived kernel <italic>k<sub>q </sub></italic>is computed on top of the layer <italic>q </italic>and this in turn is used to compute the final derived kernel <italic>k<sub>r </sub></italic>on the top most layer <italic>r</italic>, which can help us in the classification of the whole images in layer <italic>r</italic>. Refer to [<xref ref-type="bibr" rid="B28">28</xref>], for the detailed mathematical formulation of the initial and the derived kernels. The computation of kernels forms the unsupervised preprocessing component and is key for the superior performance of the neural response algorithm as it can minimize the complexity of the corresponding image classification problem (supervised task)[<xref ref-type="bibr" rid="B28">28</xref>].</p>
    <fig id="F1" position="float">
      <label>Figure 1</label>
      <caption>
        <p><bold>Three layer mode for image classification</bold>.</p>
      </caption>
      <graphic xlink:href="1752-0509-6-S1-S19-1"/>
    </fig>
    <p>In the current context of protein functional characterization, the top layer represents the whole protein sequences and the subsequent layers are constituted of sequence motifs. At each layer similarity is computed between the templates of two successive layers, which are referred to as derived kernels by taking the maximum of the previously computed local kernels in a recursive fashion. Finally a mapping engine is built on the kernels derived from the neural response algorithm to map the query protein to its most probable GO term. A detailed description of the whole methodology is given in the Methods section.</p>
  </sec>
  <sec sec-type="results">
    <title>Results</title>
    <p>We used the GO terms with no further children (leaf nodes of the GO tree) and their corresponding proteins for the assessment of our method. The rationale for using leaf nodes is that these GO terms are functionally more specific than the GO terms at the higher levels, i.e. no two GO terms should share a common protein and thus can demonstrate the specific function prediction strength of our method. This also addresses the issue of redundancy in the training set. To further fortify our argument we had also addressed the redundancy problem at sequence level by eliminating the redundant sequences that are more than 80% similar in the training set. This was done by using CD-HIT [<xref ref-type="bibr" rid="B29">29</xref>], a program that removes redundant sequences and generates a database of only the representatives. From the extracted GO terms we enumerated all the protein pairs belonging to the same GO term and labeled them as positive dataset i.e. we assigned a label Y<italic><sub>(i, j) </sub></italic>as 1 and the protein pairs belonging to different GO terms were labeled as negative, Y<italic><sub>(i, j) </sub></italic>= 0. Among such labeled pairs, we randomly selected 3000 positive pairs and 3000 negative pairs and used these labeled protein pairs to train and validate our method. After training the final mapping function, <italic>f(N<sub>(i, j)</sub>) </italic>produced a value between 0 and 1 corresponding to the similarity between the proteins <italic>i </italic>and <italic>j </italic>in the validation set. Upon applying the threshold of 0.5, we predicted the labels Y<italic><sub>(i, j) </sub></italic>to 1 (share a GO term) if <italic>f(N<sub>(i, j)</sub>) ≥ 0.5</italic>, and predict Y<italic><sub>(i, j) </sub></italic>to 0 (do not share a GO term) if <italic>f(N<sub>(i, j)</sub>) &lt; 0.5</italic>.</p>
    <sec>
      <title>Cross validation</title>
      <p>To evaluate our method we performed 5-fold cross validation i.e. we randomly divided the pool of 6000 labeled protein pairs into five partitions with an equal number of positive and negative labeled pairs. Out of the five partitions, four were used to train the neural response algorithm, and the remaining one partition was used to test the algorithm. This process was repeated for five time (the <italic>folds</italic>), with each of the five partitions used exactly once as the validation data. The idea was to check whether our method can correctly classify the pairs, which were not used for training. The values of average accuracy, area under the curve (AUC) and training time of the 5-fold cross validation are reported in Table <xref ref-type="table" rid="T1">1</xref>, with respect to the template library and the mapping engine used (See Methods). The difference in the accuracies using the PROSITE and PFAM template libraries is due to the differences in the respective sequence coverage. Thus we combined the PFAM and PROSITE templates for a better sequence coverage, and indeed, the accuracy increased (Table <xref ref-type="table" rid="T1">1</xref>). Out of the two mapping engines Least Squares classifier is almost 3 folds faster than the SVM classifier with almost the same accuracy (Table <xref ref-type="table" rid="T1">1</xref>). Therefore we report the accuracy values using the Least Squares mapping engine.</p>
      <table-wrap id="T1" position="float">
        <label>Table 1</label>
        <caption>
          <p>5 Fold cross validation results with respect to the template library</p>
        </caption>
        <table frame="hsides" rules="groups">
          <thead>
            <tr>
              <th align="left">|S|</th>
              <th align="left">Template Library in layer 2</th>
              <th align="center" colspan="2">SVM</th>
              <th align="center" colspan="2">LS</th>
            </tr>
            <tr>
              <th/>
              <th/>
              <th colspan="4">
                <hr/>
              </th>
            </tr>
            <tr>
              <th/>
              <th/>
              <th align="left">Accuracy</th>
              <th align="left">AUC</th>
              <th align="left">Accuracy</th>
              <th align="left">AUC</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left">1</td>
              <td align="left">PROSITE</td>
              <td align="left">77.1%</td>
              <td align="left">0.851</td>
              <td align="left">76.4%</td>
              <td align="left">0.863</td>
            </tr>
            <tr>
              <td align="left">2</td>
              <td align="left">PFAM</td>
              <td align="left">80.5%</td>
              <td align="left">0.875</td>
              <td align="left">80.2%</td>
              <td align="left">0.881</td>
            </tr>
            <tr>
              <td align="left">3</td>
              <td align="left">PROSITE + PFAM</td>
              <td align="left">82.0%</td>
              <td align="left">0.882</td>
              <td align="left">81.70%</td>
              <td align="left">0.892</td>
            </tr>
            <tr>
              <td/>
              <td align="left">Training Time</td>
              <td align="left" colspan="2">151.9 Sec.*</td>
              <td align="left" colspan="2">54.9 Sec.*</td>
            </tr>
          </tbody>
        </table>
      </table-wrap>
    </sec>
    <sec>
      <title>Classification specificity with respect to the GO term distance</title>
      <p>As described in methods, the derived kernel classifies two proteins to be similar, if the pair is equivalent (similar) to a pair with two known similar proteins. To test the classification specificity of our method, we have selected 800 proteins (400 pairs) with the first 100 pairs sharing an immediate parent GO term (level 1); second 100 pairs sharing a common parent separated by an edge distance of 2 in the GO tree (level 2). Similarly we have level 3 and 4 datasets with an edge distance of 3 and 4 respectively. As the positive pairs in the training set share a common GO term, we expect our method to classify the protein pairs as positive whose GO terms are the same or the next one in the GO hierarchy and as negative if their respective GO terms are far away. The number of positively classified (similar) pairs in respective subsets is given the Figure <xref ref-type="fig" rid="F2">2</xref>. We observed that the proportion of positively classified (similar) pairs is 88% in the level 1 dataset as they are much closer in the GO tree and it gradually dropped to 9% in the level 4 dataset as the GO distance between them is increased. This suggests that our method is highly specific in classifying the similar proteins with respect to the relative distance between the respective GO terms.</p>
      <fig id="F2" position="float">
        <label>Figure 2</label>
        <caption>
          <p><bold>Classification specificity plot</bold>.</p>
        </caption>
        <graphic xlink:href="1752-0509-6-S1-S19-2"/>
      </fig>
    </sec>
    <sec>
      <title>Comparison of classification accuracy</title>
      <p>Having shown the predominant classification specificity and the 5 fold cross validation results, we further compare the classification accuracy of our method with the PFP and FFPred servers, which are the most sensitive protein function prediction server using GO vocabulary [<xref ref-type="bibr" rid="B3">3</xref>] to date. We had compiled a test set of 400 proteins constituting of 200 protein pairs, with 100 pairs sharing the same GO term (positive test set) i.e. the edge distance between the GO terms of a protein pair is zero and other 100 pairs sharing a distant root GO term (negative test set) i.e. the edge distance between the GO terms of a protein pair is ≥ 1. Each of the 200 protein pairs were classified as either positive (similar) or negative (non similar) by NRProF. Since PFP or FFPred server does not have a standalone software version, we had to submit our query directly to the online server manually for each of the 400 proteins. The PFP and FFPred servers list the probable GO terms for a query protein sequence with a confidence score associated with each of the GO terms. A classification is considered to be accurate if the servers predict the same GO term (rank 1) for both the proteins of a pair in the positive test set and different for the negative test set. On the other hand NRProF classification is considered to be accurate if it can classify the positive set as similar and negative set as dissimilar pairs. Out of 200 predictions, NRProF performed better than PFP and FFPred servers in 8 and 5 instances respectively. The accuracies are tabulated in Table <xref ref-type="table" rid="T2">2</xref>. We therefore conclude that NRProF has a better classification accuracy.</p>
      <table-wrap id="T2" position="float">
        <label>Table 2</label>
        <caption>
          <p>Classification Accuracy of the NRProF, FFPred and PFP server with respect to the compiled test set.</p>
        </caption>
        <table frame="hsides" rules="groups">
          <thead>
            <tr>
              <th align="left">|S|</th>
              <th align="center">Method</th>
              <th align="left">Accuracy</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left">1</td>
              <td align="center">NRProF</td>
              <td align="left">83.8%</td>
            </tr>
            <tr>
              <td align="left">2</td>
              <td align="center">FFPred</td>
              <td align="left">81.5%</td>
            </tr>
            <tr>
              <td align="left">3</td>
              <td align="center">PFP Server</td>
              <td align="left">80.5%</td>
            </tr>
          </tbody>
        </table>
      </table-wrap>
    </sec>
    <sec>
      <title>GO term predictability</title>
      <p>Next we demonstrate the GO term predictability of our method. Our method labels a protein pair <italic>p<sub>i </sub></italic>(query protein) and <italic>p<sub>j </sub></italic>(protein in the base dataset) as 1 if they are similar and thereby assigns the GO term of the protein <italic>p<sub>j </sub></italic>to the protein <italic>p<sub>i </sub></italic>based on the threshold applied on the function <italic>f(N<sub>(i, j)</sub>)</italic>. To overcome the threshold dependency and to make the results comparable with the PFP and FFPred servers, we had sorted the proteins in the base dataset in descending order based on their similarity (<italic>f(N<sub>(i, j)</sub>)</italic>) to the query protein, and assigned the GO term of the corresponding most similar (rank 1) protein to the query protein. For a better understanding of the methods, we present the stepwise workout of the algorithm for a human protein Chromodomain Helicase DNA binding protein 1 (Figure <xref ref-type="fig" rid="F3">3</xref>). Firstly the query sequence CHD1 was scanned for the potential template hits. We got 7 hits in the template library, with no hit occurring more than once thus a neural response vector can be computed with equation 4 (see Methods). The neural response vector computed was &lt; CHD1 |PS50013, 15.363 | PS50079, 4 | PS50313, 9.155 | PS50322, 9.138 | PS50324, 24.763 | PS51192, 25.932 | PS51194, 19.905 | &gt;. The first element in the vector is the query protein followed by the template ID (Prosite/Pfam) and its score respectively. However if the query sequence have repeats or if a template t has more than one hit in the query sequence we consider the hit with the maximum score (equation 3, Methods). We then calculated the pair wise neural response <italic>N(p, q<sub>j</sub>) </italic>(equation 5, Methods) where <italic>p </italic>is the query (CHD1) and <italic>q<sub>i </sub></italic>is the pre-computed neural response of the <italic>i<sup>th </sup></italic>protein sequence from the initial base set. For illustration here we show the calculation of 3 pair wise neural response vectors (CHD1-AAAS), (CHD1-CHD2) and (CHD1-CDV3) in the Figure <xref ref-type="fig" rid="F3">3</xref>. Next these pair wise neural response vectors together with the another pair wise neural response vector (which is known to be similar) were fed to the mapping function using a Gaussian kernel (equation 7, Methods) to generate a value ranging from 0 to 1 corresponding to the similarity between the proteins in the pair wise neural response. Then we sorted the proteins in the base dataset in a descending order based on their similarity (<italic>f(N<sub>(i, j)</sub>)</italic>) to the query protein. Since the <italic>f(N(<sub>CHD1-CHD2</sub>) </italic>is higher than the other two, we assigned the GO term of CHD2 to CHD1. In the GO tree, CHD2 has 22 associated GO terms. Since we considered only leaf GO terms for the higher annotation specificity, we assigned the GO term GO:0005524 (leaf GO term associated with CHD2) to CHD1. However, in addition to the current state of the algorithm if users wish to consider other non-leaf GO terms, we suggest the users to use the sequence diversity (simply the number of representative sequences after the CD-HIT filtration) in the GO terms associated with the most similar protein to the query protein, as a criteria for assigning the GO term i.e., the GO term with the least sequence diversity is assigned to the query protein. This can be advocated by the fact that the sequence diversity is inversely proportional to the specificity of the GO terms. In the current example by either ways our method had assigned the term GO:0005524 to the CHD1.</p>
      <fig id="F3" position="float">
        <label>Figure 3</label>
        <caption>
          <p><bold>Detailed workout of CHD1</bold>. (a) Query sequence CHD1 is scanned for the potential template hits. (b) Computation of the corresponding neural response. (c) Calculation of pair wise neural response <italic>N(p, q<sub>j</sub>) viz</italic>. (CHD1-AAAS), (CHD1-CHD2) and (CHD1-CDV3). (d) Database of pre-computed neural response for the base dataset. (e) The pair wise pair wise neural response vectors are fed to the mapping function using a Gaussian kernel to generate a value ranging from 0 to 1. (f) Proteins in the base dataset ate sorted in descending order based on their similarity (<italic>f(N<sub>(i, j)</sub>)</italic>) to the query protein. (g) GO term <italic>GO:0005524 </italic>of CHD2, with high mapping score is assigned to CHD1.</p>
        </caption>
        <graphic xlink:href="1752-0509-6-S1-S19-3"/>
      </fig>
    </sec>
    <sec>
      <title>Comparison with the existing methods</title>
      <p>We compared the GO term predictions of our method with PFP and FFPred servers, which are the most sensitive function prediction servers to date. PFP and FFPred servers predict the most probable GO terms for a query protein with a confidence score associated with each of the GO terms. A prediction is considered to be accurate if actual (most specific) GO term of the query protein is ranked among the top 5 probable GO terms by the respective methods. Lack of standalone versions of PFP and FFPred is a serious limitation on the dataset used for comparison. We compiled a dataset of 300 proteins each belonging to the leaf nodes of the GO tree. The prediction results from PFP and FFpred were obtained by manual submissions to the respective servers. Table <xref ref-type="table" rid="T3">3</xref> compares the GO terms predicted for the Human protein WDR55. PFP could not report the actual leaf GO term in its top 5 predictions. This is due to trade-off of annotation specificity to weak hits with High <italic>e </italic>value. FFPred could not predict any GO term because it is limited to only 111 Molecular function and 86 Biological Process categories. Whereas NRProF predicted top 3 similar proteins with the same GO term. The Overall accuracy on the set of 300 proteins is reported in the Table <xref ref-type="table" rid="T4">4</xref>.</p>
      <table-wrap id="T3" position="float">
        <label>Table 3</label>
        <caption>
          <p>GO terms predicted for the protein Q9H6Y2 by PFP, FFPred and NRProF.</p>
        </caption>
        <table frame="hsides" rules="groups">
          <thead>
            <tr>
              <th align="center">Protein Name/ID</th>
              <th align="left">WDR55/Q9H6Y2</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="center">
                <bold>Actual Leaf</bold>
                <break/>
                <bold>GO term</bold>
              </td>
              <td align="left">GO:0002039</td>
            </tr>
            <tr>
              <td colspan="2">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="center">
                <bold>Top 5 GO terms by PFP</bold>
              </td>
              <td align="left">GO:0005488, GO:0043169, GO:0003676, GO:0004977, GO:0046026</td>
            </tr>
            <tr>
              <td colspan="2">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="center">
                <bold>Top 5 GO terms by FFPred</bold>
              </td>
              <td align="left">No GO terms predicted for this sequence</td>
            </tr>
            <tr>
              <td colspan="2">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="center">
                <bold>Top 5 GO terms by NRProF</bold>
              </td>
              <td align="left">P51532, Q96S44, Q9HCK8 (GO:0002039), Q01638 (GO:0002114), Q13822 (GO:0047391)</td>
            </tr>
          </tbody>
        </table>
      </table-wrap>
      <table-wrap id="T4" position="float">
        <label>Table 4</label>
        <caption>
          <p>GO term prediction Accuracy of the NRProF and PFP server with respect to the test set.</p>
        </caption>
        <table frame="hsides" rules="groups">
          <thead>
            <tr>
              <th align="left">|S|</th>
              <th align="center">Method</th>
              <th align="left">Accuracy</th>
              <th align="left">AUC</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left">1</td>
              <td align="center">NRProF</td>
              <td align="left">86.93%</td>
              <td align="left">0.9453</td>
            </tr>
            <tr>
              <td align="left">2</td>
              <td align="center">PFP Server</td>
              <td align="left">83.33%</td>
              <td align="left">0.8892</td>
            </tr>
          </tbody>
        </table>
      </table-wrap>
      <p>From Table <xref ref-type="table" rid="T4">4</xref>, we can infer that our method NRProF performs reasonably better than the PFP server. We have not reported the accuracy of the FFPred, as it is limited to only 111 Molecular function categories, which makes it suitable for general rather than specific function annotations. There are other methods that use GO vocabulary for protein function prediction methods including GOblet, GOfigure and GOtcha. But the PFP server has already been proved to be superior to all the above mentioned methods [<xref ref-type="bibr" rid="B25">25</xref>]. Thus we have compared our method (NRProF) only with the PFP server.</p>
    </sec>
  </sec>
  <sec sec-type="discussion">
    <title>Discussion</title>
    <sec>
      <title>Mapping function threshold</title>
      <p>The mapping function, <italic>f(N<sub>(i, j)</sub>) </italic>produces a value between 0 and 1 corresponding to the similarity between the proteins <italic>i </italic>and <italic>j</italic>. Upon applying the threshold of 0.5, we assign the labels Y<italic><sub>(i, j) </sub></italic>to 1 (share a GO term) if <italic>f(N<sub>(i, j)</sub>) ≥ x</italic>, and to 0 (do not share a GO term) if <italic>f(N<sub>(i, j)</sub>) &lt; x</italic>. We tried different values of <italic>x </italic>to decide on the best threshold. Different threshold values and their corresponding accuracies are plotted in Figure <xref ref-type="fig" rid="F4">4</xref>. It can be observed that the accuracy is high for the threshold values ranging from <italic>0.5 </italic>to <italic>0.6</italic>. Thus we selected <italic>0.5 </italic>as the optimal cut-off.</p>
      <fig id="F4" position="float">
        <label>Figure 4</label>
        <caption>
          <p><bold>Accuracy plot for different threshold values</bold>.</p>
        </caption>
        <graphic xlink:href="1752-0509-6-S1-S19-4"/>
      </fig>
    </sec>
    <sec>
      <title>CD-HIT threshold</title>
      <p>Here all our validation and test data sets constitute of Human GO terms (same species) thus we need to take care of the redundancy. This was implicitly addressed by using GO nodes with no children; however we even address this issue at the protein sequence level by using CD-HIT with optimal cut-off, to ensure proper training. An optimal threshold should not be too high or too low, if so the predictions will be biased towards highly similar/dissimilar proteins respectively. In order to observe the influence of this cut-off on the accuracy, we compared the accuracy values on a test set of 2000 protein pairs, with 1000 positive and 1000 negative pairs with respect to five different cut-offs and the results are shown in the Table <xref ref-type="table" rid="T5">5</xref>. We can observe that the accuracies at 60% and 100% cut-offs are less when compared to others. This may be due to the biased training on negative and positive protein pairs respectively. The accuracies at 70% and 80% are almost as good as or higher than the other cut-offs. This supports the use of 80% as the cut-off to eliminate the redundancy. However this cut-off should be changed with the addition of sequences from the other species. Thus we advise to choose the cut-off based on the diversity of the dataset.</p>
      <table-wrap id="T5" position="float">
        <label>Table 5</label>
        <caption>
          <p>Impact of CD-Hit cut-off on the accuracy</p>
        </caption>
        <table frame="hsides" rules="groups">
          <thead>
            <tr>
              <th align="left">|S|</th>
              <th align="center">CD-Hit cut-off</th>
              <th align="left">Accuracy</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left">1</td>
              <td align="center">60%</td>
              <td align="left">78.3%</td>
            </tr>
            <tr>
              <td align="left">2</td>
              <td align="center">70%</td>
              <td align="left">83.6%</td>
            </tr>
            <tr>
              <td align="left">3</td>
              <td align="center">80%</td>
              <td align="left">84.2%</td>
            </tr>
            <tr>
              <td align="left">4</td>
              <td align="center">90%</td>
              <td align="left">81.7%</td>
            </tr>
            <tr>
              <td align="left">5</td>
              <td align="center">100%</td>
              <td align="left">80.4%</td>
            </tr>
          </tbody>
        </table>
      </table-wrap>
    </sec>
    <sec>
      <title>Similarity based on protein pairs</title>
      <p>We can simply calculate the similarity between a query protein and a known one to assign the corresponding GO term. However with this similarity, we can only use some naive algorithms like k-nearest neighborhood, whose accuracy is not quite satisfactory especially for biological data (proteins), which is essentially multi dimensional. In addition to this, we should artificially enforce a similarity cut-off between the query and the known protein to assign the query protein to its associated GO category. Considering the fact that the intra GO term similarity varies from GO term to GO term it is difficult to set such cut-offs. To conquer this, it is necessary to design a machine learning algorithm that can learn and chose the cut-off based on the similarity between the proteins sharing the same GO term i.e. the similarity cut-off should be high if the intra GO term similarity is high and vice versa. Here, our model assigns the query protein to its associated GO category (1<sup>st </sup>pair) based on the respective Intra GO term similarity, given by the similarity between the proteins constituting the 2<sup>nd </sup>pair, i.e. the 1<sup>st </sup>pair will be labeled as similar if its similarity is equivalent to the similarity of the 2<sup>nd </sup>pair (labeled as similar) and vice versa. By this we can bypass the cut-off that needs to be enforced on the simple similarity score for assigning GO terms.</p>
    </sec>
    <sec>
      <title>GO term mapping</title>
      <p>Mapping contains entities from external database system indexed to similar or related GO terms. Currently these mappings in the Gene Ontology database are made manually consuming a lot of resources and time. As a spin-off, our methodology can automate the process of mapping between the templates (Prosite/Pfam) and the GO terms, without compromising much on the accuracy. The neural response of a protein with respect to all the templates computed according to the equations 4 (Methods) is nothing but the mapping of a protein (GO term) to the respective templates (motifs). GO-Motif association scores for the same is given by:</p>
      <p>
        <disp-formula id="bmcM1">
          <label>(1)</label>
          <mml:math id="M1" name="1752-0509-6-S1-S19-i1" overflow="scroll">
            <mml:msub>
              <mml:mrow>
                <mml:mi>s</mml:mi>
              </mml:mrow>
              <mml:mrow>
                <mml:mi>i</mml:mi>
              </mml:mrow>
            </mml:msub>
            <mml:mo class="MathClass-rel">=</mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mfenced close=")" open="(">
                  <mml:mrow>
                    <mml:mi>N</mml:mi>
                    <mml:mi>M</mml:mi>
                  </mml:mrow>
                </mml:mfenced>
              </mml:mrow>
              <mml:mrow>
                <mml:mi>i</mml:mi>
              </mml:mrow>
            </mml:msub>
            <mml:mo class="MathClass-bin">×</mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mrow>
                  <mml:mo class="MathClass-open">(</mml:mo>
                  <mml:mrow>
                    <mml:mi>A</mml:mi>
                    <mml:mi>S</mml:mi>
                  </mml:mrow>
                  <mml:mo class="MathClass-close">)</mml:mo>
                </mml:mrow>
              </mml:mrow>
              <mml:mrow>
                <mml:mi>i</mml:mi>
              </mml:mrow>
            </mml:msub>
          </mml:math>
        </disp-formula>
      </p>
      <p>where <italic>NM<sub>i </sub></italic>is the number of proteins (after removing the redundancy by CD-HIT) having a specific motif <italic>i </italic>associated to a GO term (motif frequency) and <italic>AS<sub>i </sub></italic>is the alignment strength of the respective motif's. We use the product of <italic>NM<sub>i </sub></italic>and <italic>AS<sub>i </sub></italic>to achieve a trade-off between the overrepresentation of a motif to its alignment strength. The detailed calculation is shown in Figure <xref ref-type="fig" rid="F5">5</xref>. The computed GO-Motif association scores can be used to rank the multiple mappings to a GO term.</p>
      <fig id="F5" position="float">
        <label>Figure 5</label>
        <caption>
          <p><bold>GO tem mapping with respect to the template library</bold>.</p>
        </caption>
        <graphic xlink:href="1752-0509-6-S1-S19-5"/>
      </fig>
    </sec>
    <sec>
      <title>Proteins with multiple leaf GO terms</title>
      <p>Our test set is compiled of leaf GO terms and their corresponding proteins with no two GO terms sharing a common protein, to demonstrate the specific function prediction strength of our method. However, up on perusal we found that ~25% of the proteins belong to more than one leaf GO term under the category of molecular function. To analyse the effect of "not including such proteins" on the accuracy, we have compiled a new test set of the same size (300 proteins including proteins belonging to more than one leaf GO term). We perceive that considering proteins belonging to more than one leaf GO term has no negative effect on the GO term predictability. In fact the prediction accuracy is slightly better 89.63% when compared to 86.93% on the actual test set.</p>
    </sec>
  </sec>
  <sec sec-type="conclusions">
    <title>Conclusions</title>
    <p>Here we present a novel protein function prediction method, <italic>NRProF</italic>, based on the neural response algorithm using the Gene Ontology vocabulary. The neural response algorithm simulates the neuronal behavior of the visual cortex in the human brain. It defines a distance metric corresponding to the similarity by reflecting how the human brain can distinguish different sequences. It adopts a multi-layer structure, in which each layer can use one or multiple types of sequence/structure patterns.</p>
    <p><italic>NRProF </italic>is the first instance of neural response being used in the biological domain. It finds the most similar protein to the query protein based on the neural response <italic>N </italic>between the query and the target sequences; and thereby assigns the GO term(s) of the most similar protein to the query protein. This is a profound and composite method with the essence of sequential, structural and evolutionary based methods for protein function prediction. The templates from the PRINTS and PFAM database contribute to the functional profiles or signatures (sequence). The mismatch and deletion states in the HMM profiles of the PFAM templates account to the degeneracy due to evolution and the secondary structural information of the match states in the HHM profiles contribute to the structural part. The use of HMM profiles along with the secondary structure information of PROSITE and PFAM sequence motifs to define the neural response gives our method an edge over other available methods to identify the remote homologues, as profile-profile alignments are superior to PSI-BLAST based methods in detecting the remote homologues. Thus NRProF can complement most of the existing methods.</p>
    <p>Our method is computationally less complex compared with the other methods, as the initial neural response of the proteins in the base dataset with respect to the template library are computed only once and from there the neural response between the query and target is computed with the least computational effort unlike other BLAST/PSI-BLAST based methods. The simple derived kernel adds to the computational simplicity of our method. We validated our method in a 5-fold cross validation fashion and obtained an accuracy of 82%. Considering the criterion that a prediction is valid if and only if the actual GO term is top ranked (1<sup>st </sup>Rank) GO term by our method, 82% is quite a good accuracy. The classification accuracy of 83.8% on a test set of 400 proteins suggests that our method is highly specific in classifying the similar proteins with respect to the relative distance between the respective GO terms. Upon further caparison of our method with the PFP and FFPred servers which are the most sensitive function prediction servers to date, the GO term prediction accuracy of 86.93% evince that our method is more accurate in predicting the specific functions. Thus we conclude that our method is computationally simple yet accurate when compared with the other methods. This is achieved by simulating the neuronal behavior of the visual cortex in the human brain in the form of neural response.</p>
  </sec>
  <sec sec-type="methods">
    <title>Methods</title>
    <p>The neural response algorithm can be viewed as a multi-layered framework as described in the background section. Here we built a two layer model as shown in Figure <xref ref-type="fig" rid="F6">6</xref>, with the whole protein sequences in the top most layer and the templates (sequence motifs) in the subsequent layer. We used Gene Ontology (GO) vocabulary for protein functional assignment, i.e. we mapped the query protein to its corresponding GO term(s) that represent(s) the properties of the query sequence. GO terms covers three major domains: cellular component, molecular function, and biological process. We downloaded the ontology file (OBO) v1.2 from the GO resource.</p>
    <fig id="F6" position="float">
      <label>Figure 6</label>
      <caption>
        <p><bold>Two layers of the model and their respective data sources</bold>.</p>
      </caption>
      <graphic xlink:href="1752-0509-6-S1-S19-6"/>
    </fig>
    <p>To demonstrate our approach, we only used the molecular function domain with a total of 8,912 GO terms. Then we extracted the proteins and their sequences belonging to each of the GO terms. To address the issues of redundancy we had used CD-HIT [<xref ref-type="bibr" rid="B29">29</xref>], a program that removes redundant sequences and generate a database of only the representatives. These protein sequences and their respective GO terms were used as the base dataset for our model. We only used proteins from humans because we wanted to demonstrate the ability of our method to predict/characterize the function of the proteins even if they are remotely homologous to the pre-characterized proteins (human).</p>
    <p>We further trimmed our GO terms by screening out the terms with less than 5 proteins. The resultant GO terms form the base set for our method and their associated proteins form the top layer in the model. For the bottom layer (template library), we used the sequence motifs from PROSITE [<xref ref-type="bibr" rid="B30">30</xref>] version-20.68 and Pfam [<xref ref-type="bibr" rid="B31">31</xref>] version-24. The rationale behind choosing PROSITE and Pfam is that Pfam has the largest sequence coverage [<xref ref-type="bibr" rid="B3">3</xref>] and PROSIRE has small sequence motifs that can be useful in detecting remote homologues in the absence of a whole conserved domain. We downloaded the PROSITE patterns and Pfam domains as Hidden Markov Model (HMM) [<xref ref-type="bibr" rid="B32">32</xref>] files from the respective repositories. Here we built two kernels, one on the top of each layer. First an <italic>initial kernel </italic>is computed on top of the template layer, which can be used as a similarity function between the templates. Then a <italic>derived kernel </italic>is computed on top of the top layer by choosing the maximum neural response between the individual templates in bottom layer and the sequences in top layer. Computation of the initial kernel, the neural response and the derived kernel is explained in detail in the following subsections and the overall pipeline of the methodology is shown in Figure <xref ref-type="fig" rid="F7">7</xref>.</p>
    <fig id="F7" position="float">
      <label>Figure 7</label>
      <caption>
        <p><bold>Pipeline diagram showing the control flow of the method</bold>.</p>
      </caption>
      <graphic xlink:href="1752-0509-6-S1-S19-7"/>
    </fig>
    <sec>
      <title>Initial kernel</title>
      <p>Let there be m templates (sequence motifs) <italic>q<sub>1</sub>...q<sub>m </sub></italic>in the bottom layer. We need to define a non-negative similarity measure <italic>s(q<sub>i</sub>, q<sub>j</sub>) </italic>between any two motifs <italic>q<sub>i </sub></italic>and <italic>q<sub>j</sub></italic>. A natural condition for similarity is <italic>s(q<sub>i </sub>, q<sub>j</sub>) ≤ s(q<sub>i </sub>, q<sub>i</sub>) </italic>for any <italic>q<sub>i </sub>≠ q<sub>j</sub></italic>, which means a motif is always more similar to itself than to the others. Besides this, to ensure the validity of our algorithm, a mathematical requirement of the similarity is that for a set of motifs <italic>q<sub>1</sub>...q<sub>m</sub></italic>, the matrix <italic>S </italic>should be a positive definite matrix.</p>
      <p>
        <disp-formula id="bmcM2">
          <label>(2)</label>
          <mml:math id="M2" name="1752-0509-6-S1-S19-i2" overflow="scroll">
            <mml:mi>S</mml:mi>
            <mml:mo class="MathClass-rel">=</mml:mo>
            <mml:msubsup>
              <mml:mrow>
                <mml:mfenced close="]" open="[">
                  <mml:mrow>
                    <mml:mi>s</mml:mi>
                    <mml:mfenced close=")" open="(">
                      <mml:mrow>
                        <mml:msub>
                          <mml:mrow>
                            <mml:mi>q</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mi>i</mml:mi>
                          </mml:mrow>
                        </mml:msub>
                        <mml:mo class="MathClass-punc">,</mml:mo>
                        <mml:msub>
                          <mml:mrow>
                            <mml:mi>q</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mi>j</mml:mi>
                          </mml:mrow>
                        </mml:msub>
                      </mml:mrow>
                    </mml:mfenced>
                  </mml:mrow>
                </mml:mfenced>
              </mml:mrow>
              <mml:mrow>
                <mml:mi>i</mml:mi>
                <mml:mo class="MathClass-punc">,</mml:mo>
                <mml:mi>j</mml:mi>
                <mml:mo class="MathClass-rel">=</mml:mo>
                <mml:mn>1</mml:mn>
              </mml:mrow>
              <mml:mrow>
                <mml:mi>n</mml:mi>
              </mml:mrow>
            </mml:msubsup>
          </mml:math>
        </disp-formula>
      </p>
      <p>Our template library in bottom layer consists of HMM profiles from the Pfam database, thus we define the similarity between templates as profile-profile alignment scores. We had 10,257 profiles in the template library, making ~10<sup>6 </sup>profile-profile alignments. To align the template HMM profiles we used HHsearch which is the most sensitive profile-profile alignment tool to date [<xref ref-type="bibr" rid="B33">33</xref>-<xref ref-type="bibr" rid="B35">35</xref>]. As a refinement for better sensitivity and to capture the remote homology between the templates, we considered the secondary structure information of the templates as well, which is considered more conserved and provides additional information [<xref ref-type="bibr" rid="B36">36</xref>]. We have previously used secondary structure information to improve protein sequence alignment [<xref ref-type="bibr" rid="B37">37</xref>] and remote homologue identification [<xref ref-type="bibr" rid="B38">38</xref>]. Thus we converted the HMM profiles to HHM [<xref ref-type="bibr" rid="B34">34</xref>] profiles containing the secondary structure information of all the match states in the HMM profiles. We employed HHsearch which uses PSI-PRED [<xref ref-type="bibr" rid="B39">39</xref>] to predict the secondary structure and added them to the HMM profiles. By doing this we were able to capture the remote homologues templates. Profile-Profile alignments were proved to be more sensitive than PSI-BLAST in the identification of remote similarity [<xref ref-type="bibr" rid="B40">40</xref>]. Thus our method has the edge over the PFP server which is based on PSI-BLAST in detecting the remote homologues.</p>
    </sec>
    <sec>
      <title>Neural response</title>
      <p>Consider a protein <italic>p </italic>in top layer with <italic>k </italic>template hits denoted by <italic>q<sub>p1</sub>...q<sub>pk </sub></italic>in bottom layer. PrositeScan [<xref ref-type="bibr" rid="B41">41</xref>] and HMMER 3.0 [<xref ref-type="bibr" rid="B32">32</xref>] are used to scan the protein sequences in top layer with the templates from PROSITE and Pfam respectively. Both PrositeScan and HMMER 3.0 were used in the local alignment mode as here we intended to capture the existence of the locally conserved patterns. Then the neural response of the protein <italic>p </italic>with respect to a motif <italic>q </italic>is given by:</p>
      <p>
        <disp-formula id="bmcM3">
          <label>(3)</label>
          <mml:math id="M3" name="1752-0509-6-S1-S19-i3" overflow="scroll">
            <mml:mi>N</mml:mi>
            <mml:mfenced close=")" open="(">
              <mml:mrow>
                <mml:mi>p</mml:mi>
                <mml:mo class="MathClass-punc">,</mml:mo>
                <mml:mi>q</mml:mi>
              </mml:mrow>
            </mml:mfenced>
            <mml:mo class="MathClass-rel">=</mml:mo>
            <mml:mo class="qop">max</mml:mo>
            <mml:mfenced close="}" open="{">
              <mml:mrow>
                <mml:mi>s</mml:mi>
                <mml:mfenced close=")" open="(">
                  <mml:mrow>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>q</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>p</mml:mi>
                        <mml:mn>1</mml:mn>
                      </mml:mrow>
                    </mml:msub>
                    <mml:mo class="MathClass-punc">,</mml:mo>
                    <mml:mi>q</mml:mi>
                  </mml:mrow>
                </mml:mfenced>
                <mml:mo class="MathClass-op">…</mml:mo>
                <mml:mfenced close=")" open="(">
                  <mml:mrow>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>q</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>p</mml:mi>
                        <mml:mi>k</mml:mi>
                      </mml:mrow>
                    </mml:msub>
                    <mml:mo class="MathClass-punc">,</mml:mo>
                    <mml:mi>q</mml:mi>
                  </mml:mrow>
                </mml:mfenced>
              </mml:mrow>
            </mml:mfenced>
          </mml:math>
        </disp-formula>
      </p>
      <p>Now by considering all the <italic>m </italic>motifs in the template layer the information about the protein <italic>p </italic>given the templates can be represented by an <italic>m</italic>-dimensional vector:</p>
      <p>
        <disp-formula id="bmcM4">
          <label>(4)</label>
          <mml:math id="M4" name="1752-0509-6-S1-S19-i4" overflow="scroll">
            <mml:mstyle class="text">
              <mml:mtext class="textsf" mathvariant="sans-serif">N</mml:mtext>
            </mml:mstyle>
            <mml:mfenced close=")" open="(">
              <mml:mrow>
                <mml:mi>p</mml:mi>
              </mml:mrow>
            </mml:mfenced>
            <mml:mo class="MathClass-rel">=</mml:mo>
            <mml:mfenced close=")" open="(">
              <mml:mrow>
                <mml:mstyle class="text">
                  <mml:mtext class="textsf" mathvariant="sans-serif">N</mml:mtext>
                </mml:mstyle>
                <mml:mfenced close=")" open="(">
                  <mml:mrow>
                    <mml:mi>p</mml:mi>
                    <mml:mo class="MathClass-punc">,</mml:mo>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>q</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mn>1</mml:mn>
                      </mml:mrow>
                    </mml:msub>
                  </mml:mrow>
                </mml:mfenced>
                <mml:mo class="MathClass-punc">,</mml:mo>
                <mml:mo class="MathClass-op">…</mml:mo>
                <mml:mi>.</mml:mi>
                <mml:mstyle class="text">
                  <mml:mtext class="textsf" mathvariant="sans-serif">N</mml:mtext>
                </mml:mstyle>
                <mml:mfenced close=")" open="(">
                  <mml:mrow>
                    <mml:mi>p</mml:mi>
                    <mml:mo class="MathClass-punc">,</mml:mo>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>q</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>m</mml:mi>
                      </mml:mrow>
                    </mml:msub>
                  </mml:mrow>
                </mml:mfenced>
              </mml:mrow>
            </mml:mfenced>
          </mml:math>
        </disp-formula>
      </p>
      <p>Our goal is to learn the similarity between the query protein <italic>p<sub>i </sub></italic>and the proteins in the base dataset such that we can assign the query protein <italic>p<sub>i </sub></italic>to the GO term(s) associated with the most similar protein <italic>p<sub>j</sub></italic>. To quantize the similarity between pairs <italic>p<sub>i </sub></italic>and <italic>p<sub>j</sub></italic>, we encoded the pair <italic>(p<sub>i</sub>, p<sub>j</sub>) </italic>into a vector N<italic><sub>(i, j) </sub></italic>on which we can formulate the <italic>mapping engine </italic>to map the query protein to its most probable GO term. There are two ways to achieve this, by taking the difference between N(<italic>p<sub>i</sub></italic>) and N(<italic>p<sub>j</sub></italic>) or by simply concatenating them together. As we found that the former method always gives better performance in our algorithm, we thus let:</p>
      <p>
        <disp-formula id="bmcM5">
          <label>(5)</label>
          <mml:math id="M5" name="1752-0509-6-S1-S19-i5" overflow="scroll">
            <mml:msub>
              <mml:mrow>
                <mml:mstyle class="text">
                  <mml:mtext class="textsf" mathvariant="sans-serif">N</mml:mtext>
                </mml:mstyle>
              </mml:mrow>
              <mml:mrow>
                <mml:mrow>
                  <mml:mo class="MathClass-open">(</mml:mo>
                  <mml:mrow>
                    <mml:mi>i</mml:mi>
                    <mml:mo class="MathClass-punc">,</mml:mo>
                    <mml:mi>j</mml:mi>
                  </mml:mrow>
                  <mml:mo class="MathClass-close">)</mml:mo>
                </mml:mrow>
              </mml:mrow>
            </mml:msub>
            <mml:mo class="MathClass-rel">=</mml:mo>
            <mml:mfenced close="|" open="|">
              <mml:mrow>
                <mml:mstyle class="text">
                  <mml:mtext class="textsf" mathvariant="sans-serif">N</mml:mtext>
                </mml:mstyle>
                <mml:mfenced close=")" open="(">
                  <mml:mrow>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>p</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>i</mml:mi>
                      </mml:mrow>
                    </mml:msub>
                  </mml:mrow>
                </mml:mfenced>
                <mml:mo class="MathClass-bin">-</mml:mo>
                <mml:mstyle class="text">
                  <mml:mtext class="textsf" mathvariant="sans-serif">N</mml:mtext>
                </mml:mstyle>
                <mml:mfenced close=")" open="(">
                  <mml:mrow>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>p</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>j</mml:mi>
                      </mml:mrow>
                    </mml:msub>
                  </mml:mrow>
                </mml:mfenced>
              </mml:mrow>
            </mml:mfenced>
          </mml:math>
        </disp-formula>
      </p>
      <p>
        <disp-formula>
          <mml:math id="M6" name="1752-0509-6-S1-S19-i6" overflow="scroll">
            <mml:mo class="MathClass-rel">=</mml:mo>
            <mml:mrow>
              <mml:mo class="MathClass-open">(</mml:mo>
              <mml:mrow>
                <mml:mfenced close="|" open="|">
                  <mml:mrow>
                    <mml:mi>N</mml:mi>
                    <mml:mfenced close=")" open="(">
                      <mml:mrow>
                        <mml:msub>
                          <mml:mrow>
                            <mml:mi>p</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mi>i</mml:mi>
                          </mml:mrow>
                        </mml:msub>
                        <mml:mo class="MathClass-punc">,</mml:mo>
                        <mml:msub>
                          <mml:mrow>
                            <mml:mi>q</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mn>1</mml:mn>
                          </mml:mrow>
                        </mml:msub>
                      </mml:mrow>
                    </mml:mfenced>
                    <mml:mo class="MathClass-bin">-</mml:mo>
                    <mml:mi>N</mml:mi>
                    <mml:mfenced close=")" open="(">
                      <mml:mrow>
                        <mml:msub>
                          <mml:mrow>
                            <mml:mi>p</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mi>j</mml:mi>
                          </mml:mrow>
                        </mml:msub>
                        <mml:mo class="MathClass-punc">,</mml:mo>
                        <mml:msub>
                          <mml:mrow>
                            <mml:mi>q</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mn>1</mml:mn>
                          </mml:mrow>
                        </mml:msub>
                      </mml:mrow>
                    </mml:mfenced>
                  </mml:mrow>
                </mml:mfenced>
                <mml:mo class="MathClass-punc">,</mml:mo>
                <mml:mo class="MathClass-op">…</mml:mo>
                <mml:mo class="MathClass-punc">,</mml:mo>
                <mml:mfenced close="|" open="|">
                  <mml:mrow>
                    <mml:mi>N</mml:mi>
                    <mml:mfenced close=")" open="(">
                      <mml:mrow>
                        <mml:msub>
                          <mml:mrow>
                            <mml:mi>p</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mi>i</mml:mi>
                          </mml:mrow>
                        </mml:msub>
                        <mml:mo class="MathClass-punc">,</mml:mo>
                        <mml:msub>
                          <mml:mrow>
                            <mml:mi>q</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mi>m</mml:mi>
                          </mml:mrow>
                        </mml:msub>
                      </mml:mrow>
                    </mml:mfenced>
                    <mml:mo class="MathClass-bin">-</mml:mo>
                    <mml:mi>N</mml:mi>
                    <mml:mfenced close=")" open="(">
                      <mml:mrow>
                        <mml:msub>
                          <mml:mrow>
                            <mml:mi>p</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mi>j</mml:mi>
                          </mml:mrow>
                        </mml:msub>
                        <mml:mo class="MathClass-punc">,</mml:mo>
                        <mml:msub>
                          <mml:mrow>
                            <mml:mi>q</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mi>m</mml:mi>
                          </mml:mrow>
                        </mml:msub>
                      </mml:mrow>
                    </mml:mfenced>
                  </mml:mrow>
                </mml:mfenced>
              </mml:mrow>
              <mml:mo class="MathClass-close">)</mml:mo>
            </mml:mrow>
          </mml:math>
        </disp-formula>
      </p>
      <p>which is the neural response of the pair <italic>(p<sub>i</sub>, p<sub>j</sub>) </italic>on the templates set <italic>q<sub>1</sub>...q<sub>m</sub></italic>.</p>
    </sec>
    <sec>
      <title>Derived kernel</title>
      <p>We can derive a kernel <italic>K</italic>, which measures the similarity of two protein pairs, from the neural responses. This kernel also gives the similarity of two proteins. Two proteins are similar, if the pair constituted by them is similar to a pair with two similar proteins and vice visa. In the original paper of neural response [<xref ref-type="bibr" rid="B28">28</xref>], a linear kernel is defined by inner products of neural responses. Under our setting, the linear kernel for two pairs <italic>(p<sub>i</sub>, p<sub>j</sub>) </italic>and <italic>(p<sub>i</sub>, p<sub>j</sub>) </italic>can be written as</p>
      <p>
        <disp-formula id="bmcM6">
          <label>(6)</label>
          <mml:math id="M7" name="1752-0509-6-S1-S19-i7" overflow="scroll">
            <mml:mi>K</mml:mi>
            <mml:mfenced close=")" open="(">
              <mml:mrow>
                <mml:mfenced close=")" open="(">
                  <mml:mrow>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>p</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>i</mml:mi>
                      </mml:mrow>
                    </mml:msub>
                    <mml:mo class="MathClass-punc">,</mml:mo>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>p</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>j</mml:mi>
                      </mml:mrow>
                    </mml:msub>
                  </mml:mrow>
                </mml:mfenced>
                <mml:mo class="MathClass-punc">,</mml:mo>
                <mml:mfenced close=")" open="(">
                  <mml:mrow>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>p</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:msup>
                          <mml:mrow>
                            <mml:mi>i</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mo class="MathClass-op">″</mml:mo>
                          </mml:mrow>
                        </mml:msup>
                      </mml:mrow>
                    </mml:msub>
                    <mml:mo class="MathClass-punc">,</mml:mo>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>p</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:msup>
                          <mml:mrow>
                            <mml:mi>j</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mo class="MathClass-op">″</mml:mo>
                          </mml:mrow>
                        </mml:msup>
                      </mml:mrow>
                    </mml:msub>
                  </mml:mrow>
                </mml:mfenced>
              </mml:mrow>
            </mml:mfenced>
            <mml:mo class="MathClass-rel">=</mml:mo>
            <mml:mi>N</mml:mi>
            <mml:mfenced close="⟩" open="⟨">
              <mml:mrow>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>N</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mfenced close=")" open="(">
                      <mml:mrow>
                        <mml:mi>i</mml:mi>
                        <mml:mo class="MathClass-punc">,</mml:mo>
                        <mml:mi>j</mml:mi>
                      </mml:mrow>
                    </mml:mfenced>
                  </mml:mrow>
                </mml:msub>
                <mml:mo class="MathClass-punc">,</mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>N</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mrow>
                      <mml:mo class="MathClass-open">(</mml:mo>
                      <mml:mrow>
                        <mml:msup>
                          <mml:mrow>
                            <mml:mi>i</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mo class="MathClass-op">″</mml:mo>
                          </mml:mrow>
                        </mml:msup>
                        <mml:mo class="MathClass-punc">,</mml:mo>
                        <mml:msup>
                          <mml:mrow>
                            <mml:mi>j</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mo class="MathClass-op">″</mml:mo>
                          </mml:mrow>
                        </mml:msup>
                      </mml:mrow>
                      <mml:mo class="MathClass-close">)</mml:mo>
                    </mml:mrow>
                  </mml:mrow>
                </mml:msub>
              </mml:mrow>
            </mml:mfenced>
          </mml:math>
        </disp-formula>
      </p>
      <p>
        <disp-formula>
          <mml:math id="M8" name="1752-0509-6-S1-S19-i8" overflow="scroll">
            <mml:mo class="MathClass-rel">=</mml:mo>
            <mml:msubsup>
              <mml:mrow>
                <mml:mo class="MathClass-op"> ∑</mml:mo>
              </mml:mrow>
              <mml:mrow>
                <mml:mstyle class="text">
                  <mml:mtext class="textsf" mathvariant="sans-serif">k</mml:mtext>
                </mml:mstyle>
                <mml:mo class="MathClass-rel">=</mml:mo>
                <mml:mn>1</mml:mn>
              </mml:mrow>
              <mml:mrow>
                <mml:mstyle class="text">
                  <mml:mtext class="textsf" mathvariant="sans-serif">n</mml:mtext>
                </mml:mstyle>
              </mml:mrow>
            </mml:msubsup>
            <mml:mstyle class="text">
              <mml:mtext class="textsf" mathvariant="sans-serif">N</mml:mtext>
            </mml:mstyle>
            <mml:mrow>
              <mml:mo class="MathClass-open">(</mml:mo>
              <mml:mrow>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>p</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>i</mml:mi>
                    <mml:mo class="MathClass-punc">,</mml:mo>
                  </mml:mrow>
                </mml:msub>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>q</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>k</mml:mi>
                  </mml:mrow>
                </mml:msub>
              </mml:mrow>
              <mml:mo class="MathClass-close">)</mml:mo>
            </mml:mrow>
            <mml:mstyle class="text">
              <mml:mtext class="textsf" mathvariant="sans-serif">N</mml:mtext>
            </mml:mstyle>
            <mml:mfenced close=")" open="(">
              <mml:mrow>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>p</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:msup>
                      <mml:mrow>
                        <mml:mi>i</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mo class="MathClass-op">″</mml:mo>
                      </mml:mrow>
                    </mml:msup>
                  </mml:mrow>
                </mml:msub>
                <mml:mo class="MathClass-punc">,</mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>q</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>k</mml:mi>
                  </mml:mrow>
                </mml:msub>
              </mml:mrow>
            </mml:mfenced>
            <mml:mo class="MathClass-bin">+</mml:mo>
            <mml:msubsup>
              <mml:mrow>
                <mml:mo class="MathClass-op"> ∑</mml:mo>
              </mml:mrow>
              <mml:mrow>
                <mml:mstyle class="text">
                  <mml:mtext class="textsf" mathvariant="sans-serif">k</mml:mtext>
                </mml:mstyle>
                <mml:mo class="MathClass-rel">=</mml:mo>
                <mml:mn>1</mml:mn>
              </mml:mrow>
              <mml:mrow>
                <mml:mstyle class="text">
                  <mml:mtext class="textsf" mathvariant="sans-serif">n</mml:mtext>
                </mml:mstyle>
              </mml:mrow>
            </mml:msubsup>
            <mml:mstyle class="text">
              <mml:mtext class="textsf" mathvariant="sans-serif">N</mml:mtext>
            </mml:mstyle>
            <mml:mfenced close=")" open="(">
              <mml:mrow>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>p</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>j</mml:mi>
                  </mml:mrow>
                </mml:msub>
                <mml:mo class="MathClass-punc">,</mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>q</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>k</mml:mi>
                  </mml:mrow>
                </mml:msub>
              </mml:mrow>
            </mml:mfenced>
            <mml:mstyle class="text">
              <mml:mtext class="textsf" mathvariant="sans-serif">N</mml:mtext>
            </mml:mstyle>
            <mml:mfenced close=")" open="(">
              <mml:mrow>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>p</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:msup>
                      <mml:mrow>
                        <mml:mi>j</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mo class="MathClass-op">″</mml:mo>
                      </mml:mrow>
                    </mml:msup>
                  </mml:mrow>
                </mml:msub>
                <mml:mo class="MathClass-punc">,</mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>q</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>k</mml:mi>
                  </mml:mrow>
                </mml:msub>
              </mml:mrow>
            </mml:mfenced>
          </mml:math>
        </disp-formula>
      </p>
      <p>It is well established that the Gaussian kernel usually performs better than the linear kernel for various classification tasks. Thus we had derived a Gaussian kernel with a scale parameter σ, given by</p>
      <p>
        <disp-formula id="bmcM7">
          <label>(7)</label>
          <mml:math id="M9" name="1752-0509-6-S1-S19-i9" overflow="scroll">
            <mml:mi>K</mml:mi>
            <mml:mfenced close=")" open="(">
              <mml:mrow>
                <mml:mfenced close=")" open="(">
                  <mml:mrow>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>p</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>i</mml:mi>
                      </mml:mrow>
                    </mml:msub>
                    <mml:mo class="MathClass-punc">,</mml:mo>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>p</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>j</mml:mi>
                      </mml:mrow>
                    </mml:msub>
                  </mml:mrow>
                </mml:mfenced>
                <mml:mo class="MathClass-punc">,</mml:mo>
                <mml:mfenced close=")" open="(">
                  <mml:mrow>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>p</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:msup>
                          <mml:mrow>
                            <mml:mi>i</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mo class="MathClass-op">″</mml:mo>
                          </mml:mrow>
                        </mml:msup>
                      </mml:mrow>
                    </mml:msub>
                    <mml:mo class="MathClass-punc">,</mml:mo>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>p</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:msup>
                          <mml:mrow>
                            <mml:mi>j</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mo class="MathClass-op">″</mml:mo>
                          </mml:mrow>
                        </mml:msup>
                      </mml:mrow>
                    </mml:msub>
                  </mml:mrow>
                </mml:mfenced>
              </mml:mrow>
            </mml:mfenced>
            <mml:mo class="MathClass-rel">=</mml:mo>
            <mml:mo class="qop">exp</mml:mo>
            <mml:mfenced close="}" open="{">
              <mml:mrow>
                <mml:mo class="MathClass-bin">-</mml:mo>
                <mml:mfrac>
                  <mml:mrow>
                    <mml:msup>
                      <mml:mrow>
                        <mml:mfenced close="|" open="|">
                          <mml:mrow>
                            <mml:msub>
                              <mml:mrow>
                                <mml:mi>N</mml:mi>
                              </mml:mrow>
                              <mml:mrow>
                                <mml:mfenced close=")" open="(">
                                  <mml:mrow>
                                    <mml:mi>i</mml:mi>
                                    <mml:mo class="MathClass-punc">,</mml:mo>
                                    <mml:mi>j</mml:mi>
                                  </mml:mrow>
                                </mml:mfenced>
                              </mml:mrow>
                            </mml:msub>
                            <mml:mo class="MathClass-bin">-</mml:mo>
                            <mml:msub>
                              <mml:mrow>
                                <mml:mi>N</mml:mi>
                              </mml:mrow>
                              <mml:mrow>
                                <mml:mrow>
                                  <mml:mo class="MathClass-open">(</mml:mo>
                                  <mml:mrow>
                                    <mml:msup>
                                      <mml:mrow>
                                        <mml:mi>i</mml:mi>
                                      </mml:mrow>
                                      <mml:mrow>
                                        <mml:mo class="MathClass-op">″</mml:mo>
                                      </mml:mrow>
                                    </mml:msup>
                                    <mml:mo class="MathClass-punc">,</mml:mo>
                                    <mml:msup>
                                      <mml:mrow>
                                        <mml:mi>j</mml:mi>
                                      </mml:mrow>
                                      <mml:mrow>
                                        <mml:mo class="MathClass-op">″</mml:mo>
                                      </mml:mrow>
                                    </mml:msup>
                                  </mml:mrow>
                                  <mml:mo class="MathClass-close">)</mml:mo>
                                </mml:mrow>
                              </mml:mrow>
                            </mml:msub>
                          </mml:mrow>
                        </mml:mfenced>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mn>2</mml:mn>
                      </mml:mrow>
                    </mml:msup>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:msup>
                      <mml:mrow>
                        <mml:mi>σ</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mn>2</mml:mn>
                      </mml:mrow>
                    </mml:msup>
                  </mml:mrow>
                </mml:mfrac>
              </mml:mrow>
            </mml:mfenced>
          </mml:math>
        </disp-formula>
      </p>
    </sec>
    <sec>
      <title>Mapping engine</title>
      <p>Finally, a <italic>mapping engine </italic>was built, which defines a function "<italic>f" </italic>lying in the reproducing kernel Hilbert space [<xref ref-type="bibr" rid="B42">42</xref>] associated with a positive definite kernel <italic>K </italic>that is derived from the neural responses by inner products (linear kernel) or Gaussian radial basis functions (Gaussian kernel). First, we computed the neural response of all the proteins in the base dataset with respect to the template library in top layer. Similar neural response was computed for the query protein sequence as well. Next we computed the pair wise neural response N<italic><sub>(i, j) </sub></italic>between the query sequence <italic>i </italic>and the sequence <italic>j </italic>(<italic>1..n</italic>) in the base dataset. The mapping function <italic>f(N<sub>(i, j)</sub>) </italic>produces a value ranging between 0 to 1 corresponding to similarity between the proteins <italic>p<sub>i </sub></italic>and <italic>p<sub>j</sub></italic>. Thus, we can predict the label Y<italic><sub>(i, j) </sub></italic>to 1 (similar) if <italic>f(N<sub>(i, j)</sub>) ≥ 0.5</italic>, and Y<italic><sub>(i, j) </sub></italic>to 0 (non-similar) if <italic>f(N<sub>(i, j)</sub>) &lt; 0.5 </italic>. Other thresholds besides 0.5 are also allowed. We then assigned the query protein <italic>p<sub>i </sub></italic>to the GO term/s associated with the protein/s <italic>p<sub>j </sub></italic>whose label Y<italic><sub>(i, j) </sub></italic>was set to 1. In this case the sensitivity of GO term assignments varies with the threshold used (0.5). To overcome this dependency on the threshold, we sorted the proteins in the base dataset into descending order based on their similarity (<italic>f(N<sub>(i, j)</sub>)</italic>) to the query protein. We finally extracted the top 5 GO terms and assign them to the query protein. By doing so, we are not only overcoming the threshold dependency problem but also using the ranking (true value of the <italic>f(N<sub>(i, j)</sub>)</italic>) as the confidence scores for multiple GO terms associated with a single protein.</p>
      <p>We used two popular classification engines <italic>viz.</italic>, Support vector Machines (SVM) [<xref ref-type="bibr" rid="B43">43</xref>] and Least-Squares classifier [<xref ref-type="bibr" rid="B44">44</xref>] as the mapping engine. The main difference between them is, the <italic>loss function </italic>used for training. They use hinge loss and leastsquare loss respectively. The performance of two mapping engines is evaluated in the Results section.</p>
    </sec>
  </sec>
  <sec>
    <title>Competing interests</title>
    <p>No relevant disclosures.</p>
  </sec>
  <sec>
    <title>Authors' contributions</title>
    <p>HKY collected the data, designed the pipeline, performed evaluations, statistical analysis and wrote the paper. QWX designed and tested the Neural Response algorithm. JW conceptualized the idea, designed the study and wrote the paper. All authors have read and approved the final manuscript.</p>
  </sec>
</body>
<back>
  <sec>
    <title>Acknowledgement and funding</title>
    <p>We thank Prof. Steve Smale of City University of Hong Kong for valuable discussion, Alan Lai and Yan Wang of the University of Hong Kong for their critical comments.</p>
    <p>This study was supported by grants (781511M, 778609M, N_HKU752/10) from the Research Grants Council of Hong Kong.</p>
    <p>This article has been published as part of <italic>BMC Systems Biology </italic>Volume 6 Supplement 1, 2012: Selected articles from The 5th IEEE International Conference on Systems Biology (ISB 2011). The full contents of the supplement are available online at <ext-link ext-link-type="uri" xlink:href="http://www.biomedcentral.com/bmcsystbiol/supplements/6/S1">http://www.biomedcentral.com/bmcsystbiol/supplements/6/S1</ext-link>.</p>
  </sec>
  <ref-list>
    <ref id="B1">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Kanehisa</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Goto</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Kawashima</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Okuno</surname>
          <given-names>Y</given-names>
        </name>
        <name>
          <surname>Hattori</surname>
          <given-names>M</given-names>
        </name>
        <article-title>The KEGG resource for deciphering the genome</article-title>
        <source>Nucleic Acids Res</source>
        <year>2004</year>
        <volume>32</volume>
        <fpage>D277</fpage>
        <lpage>280</lpage>
        <pub-id pub-id-type="doi">10.1093/nar/gkh063</pub-id>
        <pub-id pub-id-type="pmid">14681412</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B2">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Hawkins</surname>
          <given-names>T</given-names>
        </name>
        <name>
          <surname>Kihara</surname>
          <given-names>D</given-names>
        </name>
        <article-title>Function prediction of uncharacterized proteins</article-title>
        <source>J Bioinform Comput Biol</source>
        <year>2007</year>
        <volume>5</volume>
        <issue>1</issue>
        <fpage>1</fpage>
        <lpage>30</lpage>
        <pub-id pub-id-type="doi">10.1142/S0219720007002503</pub-id>
        <pub-id pub-id-type="pmid">17477489</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B3">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Hawkins</surname>
          <given-names>T</given-names>
        </name>
        <name>
          <surname>Chitale</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Luban</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Kihara</surname>
          <given-names>D</given-names>
        </name>
        <article-title>PFP: Automated prediction of gene ontology functional annotations with confidence scores using protein sequence data</article-title>
        <source>Proteins</source>
        <year>2009</year>
        <volume>74</volume>
        <issue>3</issue>
        <fpage>566</fpage>
        <lpage>582</lpage>
        <pub-id pub-id-type="doi">10.1002/prot.22172</pub-id>
        <pub-id pub-id-type="pmid">18655063</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B4">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Whisstock</surname>
          <given-names>JC</given-names>
        </name>
        <name>
          <surname>Lesk</surname>
          <given-names>AM</given-names>
        </name>
        <article-title>Prediction of protein function from protein sequence and structure</article-title>
        <source>Q Rev Biophys</source>
        <year>2003</year>
        <volume>36</volume>
        <issue>3</issue>
        <fpage>307</fpage>
        <lpage>340</lpage>
        <pub-id pub-id-type="doi">10.1017/S0033583503003901</pub-id>
        <pub-id pub-id-type="pmid">15029827</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B5">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Skolnick</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Fetrow</surname>
          <given-names>JS</given-names>
        </name>
        <article-title>From genes to protein structure and function: novel applications of computational approaches in the genomic era</article-title>
        <source>Trends Biotechnol</source>
        <year>2000</year>
        <volume>18</volume>
        <issue>1</issue>
        <fpage>34</fpage>
        <lpage>39</lpage>
        <pub-id pub-id-type="doi">10.1016/S0167-7799(99)01398-0</pub-id>
        <pub-id pub-id-type="pmid">10631780</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B6">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Rost</surname>
          <given-names>B</given-names>
        </name>
        <name>
          <surname>Liu</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Nair</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Wrzeszczynski</surname>
          <given-names>KO</given-names>
        </name>
        <name>
          <surname>Ofran</surname>
          <given-names>Y</given-names>
        </name>
        <article-title>Automatic prediction of protein function</article-title>
        <source>Cell Mol Life Sci</source>
        <year>2003</year>
        <volume>60</volume>
        <issue>12</issue>
        <fpage>2637</fpage>
        <lpage>2650</lpage>
        <pub-id pub-id-type="doi">10.1007/s00018-003-3114-8</pub-id>
        <pub-id pub-id-type="pmid">14685688</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B7">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Doolittle</surname>
          <given-names>RF</given-names>
        </name>
        <article-title>The multiplicity of domains in proteins</article-title>
        <source>Annu Rev Biochem</source>
        <year>1995</year>
        <volume>64</volume>
        <fpage>287</fpage>
        <lpage>314</lpage>
        <pub-id pub-id-type="doi">10.1146/annurev.bi.64.070195.001443</pub-id>
        <pub-id pub-id-type="pmid">7574483</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B8">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Valencia</surname>
          <given-names>A</given-names>
        </name>
        <article-title>Automatic annotation of protein function</article-title>
        <source>Curr Opin Struct Biol</source>
        <year>2005</year>
        <volume>15</volume>
        <issue>3</issue>
        <fpage>267</fpage>
        <lpage>274</lpage>
        <pub-id pub-id-type="doi">10.1016/j.sbi.2005.05.010</pub-id>
        <pub-id pub-id-type="pmid">15922590</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B9">
      <mixed-citation publication-type="journal">
        <article-title>Nomenclature committee of the international union of biochemistry and molecular biology (NC-IUBMB), Enzyme Supplement 5 (1999)</article-title>
        <source>Eur J Biochem</source>
        <year>1999</year>
        <volume>264</volume>
        <issue>2</issue>
        <fpage>610</fpage>
        <lpage>650</lpage>
        <pub-id pub-id-type="pmid">10491110</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B10">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Ruepp</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Zollner</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Maier</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Albermann</surname>
          <given-names>K</given-names>
        </name>
        <name>
          <surname>Hani</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Mokrejs</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Tetko</surname>
          <given-names>I</given-names>
        </name>
        <name>
          <surname>Guldener</surname>
          <given-names>U</given-names>
        </name>
        <name>
          <surname>Mannhaupt</surname>
          <given-names>G</given-names>
        </name>
        <name>
          <surname>Munsterkotter</surname>
          <given-names>M</given-names>
        </name>
        <etal/>
        <article-title>The FunCat, a functional annotation scheme for systematic classification of proteins from whole genomes</article-title>
        <source>Nucleic Acids Res</source>
        <year>2004</year>
        <volume>32</volume>
        <issue>18</issue>
        <fpage>5539</fpage>
        <lpage>5545</lpage>
        <pub-id pub-id-type="doi">10.1093/nar/gkh894</pub-id>
        <pub-id pub-id-type="pmid">15486203</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B11">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Harris</surname>
          <given-names>MA</given-names>
        </name>
        <name>
          <surname>Clark</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Ireland</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Lomax</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Ashburner</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Foulger</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Eilbeck</surname>
          <given-names>K</given-names>
        </name>
        <name>
          <surname>Lewis</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Marshall</surname>
          <given-names>B</given-names>
        </name>
        <name>
          <surname>Mungall</surname>
          <given-names>C</given-names>
        </name>
        <etal/>
        <article-title>The Gene Ontology (GO) database and informatics resource</article-title>
        <source>Nucleic Acids Res</source>
        <year>2004</year>
        <volume>32</volume>
        <fpage>D258</fpage>
        <lpage>261</lpage>
        <pub-id pub-id-type="doi">10.1093/nar/gkh036</pub-id>
        <pub-id pub-id-type="pmid">14681407</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B12">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Gille</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Goede</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Preissner</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Rother</surname>
          <given-names>K</given-names>
        </name>
        <name>
          <surname>Frommel</surname>
          <given-names>C</given-names>
        </name>
        <article-title>Conservation of substructures in proteins: interfaces of secondary structural elements in proteasomal subunits</article-title>
        <source>J Mol Biol</source>
        <year>2000</year>
        <volume>299</volume>
        <issue>4</issue>
        <fpage>1147</fpage>
        <lpage>1154</lpage>
        <pub-id pub-id-type="doi">10.1006/jmbi.2000.3763</pub-id>
        <pub-id pub-id-type="pmid">10843865</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B13">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Wilson</surname>
          <given-names>CA</given-names>
        </name>
        <name>
          <surname>Kreychman</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Gerstein</surname>
          <given-names>M</given-names>
        </name>
        <article-title>Assessing annotation transfer for genomics: quantifying the relations between protein sequence, structure and function through traditional and probabilistic scores</article-title>
        <source>J Mol Biol</source>
        <year>2000</year>
        <volume>297</volume>
        <issue>1</issue>
        <fpage>233</fpage>
        <lpage>249</lpage>
        <pub-id pub-id-type="doi">10.1006/jmbi.2000.3550</pub-id>
        <pub-id pub-id-type="pmid">10704319</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B14">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Pal</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Eisenberg</surname>
          <given-names>D</given-names>
        </name>
        <article-title>Inference of protein function from protein structure</article-title>
        <source>Structure</source>
        <year>2005</year>
        <volume>13</volume>
        <issue>1</issue>
        <fpage>121</fpage>
        <lpage>130</lpage>
        <pub-id pub-id-type="doi">10.1016/j.str.2004.10.015</pub-id>
        <pub-id pub-id-type="pmid">15642267</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B15">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Ponomarenko</surname>
          <given-names>JV</given-names>
        </name>
        <name>
          <surname>Bourne</surname>
          <given-names>PE</given-names>
        </name>
        <name>
          <surname>Shindyalov</surname>
          <given-names>IN</given-names>
        </name>
        <article-title>Assigning new GO annotations to protein data bank sequences by combining structure and sequence homology</article-title>
        <source>Proteins</source>
        <year>2005</year>
        <volume>58</volume>
        <issue>4</issue>
        <fpage>855</fpage>
        <lpage>865</lpage>
        <pub-id pub-id-type="doi">10.1002/prot.20355</pub-id>
        <pub-id pub-id-type="pmid">15645518</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B16">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Orengo</surname>
          <given-names>CA</given-names>
        </name>
        <name>
          <surname>Michie</surname>
          <given-names>AD</given-names>
        </name>
        <name>
          <surname>Jones</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Jones</surname>
          <given-names>DT</given-names>
        </name>
        <name>
          <surname>Swindells</surname>
          <given-names>MB</given-names>
        </name>
        <name>
          <surname>Thornton</surname>
          <given-names>JM</given-names>
        </name>
        <article-title>CATH--a hierarchic classification of protein domain structures</article-title>
        <source>Structure</source>
        <year>1997</year>
        <volume>5</volume>
        <issue>8</issue>
        <fpage>1093</fpage>
        <lpage>1108</lpage>
        <pub-id pub-id-type="doi">10.1016/S0969-2126(97)00260-8</pub-id>
        <pub-id pub-id-type="pmid">9309224</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B17">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Murzin</surname>
          <given-names>AG</given-names>
        </name>
        <name>
          <surname>Brenner</surname>
          <given-names>SE</given-names>
        </name>
        <name>
          <surname>Hubbard</surname>
          <given-names>T</given-names>
        </name>
        <name>
          <surname>Chothia</surname>
          <given-names>C</given-names>
        </name>
        <article-title>SCOP: a structural classification of proteins database for the investigation of sequences and structures</article-title>
        <source>J Mol Biol</source>
        <year>1995</year>
        <volume>247</volume>
        <issue>4</issue>
        <fpage>536</fpage>
        <lpage>540</lpage>
        <pub-id pub-id-type="pmid">7723011</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B18">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Berman</surname>
          <given-names>HM</given-names>
        </name>
        <name>
          <surname>Westbrook</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Feng</surname>
          <given-names>Z</given-names>
        </name>
        <name>
          <surname>Gilliland</surname>
          <given-names>G</given-names>
        </name>
        <name>
          <surname>Bhat</surname>
          <given-names>TN</given-names>
        </name>
        <name>
          <surname>Weissig</surname>
          <given-names>H</given-names>
        </name>
        <name>
          <surname>Shindyalov</surname>
          <given-names>IN</given-names>
        </name>
        <name>
          <surname>Bourne</surname>
          <given-names>PE</given-names>
        </name>
        <article-title>The Protein Data Bank</article-title>
        <source>Nucleic Acids Res</source>
        <year>2000</year>
        <volume>28</volume>
        <issue>1</issue>
        <fpage>235</fpage>
        <lpage>242</lpage>
        <pub-id pub-id-type="doi">10.1093/nar/28.1.235</pub-id>
        <pub-id pub-id-type="pmid">10592235</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B19">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Orengo</surname>
          <given-names>CA</given-names>
        </name>
        <name>
          <surname>Pearl</surname>
          <given-names>FM</given-names>
        </name>
        <name>
          <surname>Bray</surname>
          <given-names>JE</given-names>
        </name>
        <name>
          <surname>Todd</surname>
          <given-names>AE</given-names>
        </name>
        <name>
          <surname>Martin</surname>
          <given-names>AC</given-names>
        </name>
        <name>
          <surname>Lo Conte</surname>
          <given-names>L</given-names>
        </name>
        <name>
          <surname>Thornton</surname>
          <given-names>JM</given-names>
        </name>
        <article-title>The CATH Database provides insights into protein structure/function relationships</article-title>
        <source>Nucleic Acids Res</source>
        <year>1999</year>
        <volume>27</volume>
        <issue>1</issue>
        <fpage>275</fpage>
        <lpage>279</lpage>
        <pub-id pub-id-type="doi">10.1093/nar/27.1.275</pub-id>
        <pub-id pub-id-type="pmid">9847200</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B20">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Altschul</surname>
          <given-names>SF</given-names>
        </name>
        <name>
          <surname>Gish</surname>
          <given-names>W</given-names>
        </name>
        <name>
          <surname>Miller</surname>
          <given-names>W</given-names>
        </name>
        <name>
          <surname>Myers</surname>
          <given-names>EW</given-names>
        </name>
        <name>
          <surname>Lipman</surname>
          <given-names>DJ</given-names>
        </name>
        <article-title>Basic local alignment search tool</article-title>
        <source>J Mol Biol</source>
        <year>1990</year>
        <volume>215</volume>
        <issue>3</issue>
        <fpage>403</fpage>
        <lpage>410</lpage>
        <pub-id pub-id-type="pmid">2231712</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B21">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Groth</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Lehrach</surname>
          <given-names>H</given-names>
        </name>
        <name>
          <surname>Hennig</surname>
          <given-names>S</given-names>
        </name>
        <article-title>GOblet: a platform for Gene Ontology annotation of anonymous sequence data</article-title>
        <source>Nucleic Acids Res</source>
        <year>2004</year>
        <volume>32</volume>
        <fpage>W313</fpage>
        <lpage>317</lpage>
        <pub-id pub-id-type="doi">10.1093/nar/gkh406</pub-id>
        <pub-id pub-id-type="pmid">15215401</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B22">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Zehetner</surname>
          <given-names>G</given-names>
        </name>
        <article-title>OntoBlast function: From sequence similarities directly to potential functional annotations by ontology terms</article-title>
        <source>Nucleic Acids Res</source>
        <year>2003</year>
        <volume>31</volume>
        <issue>13</issue>
        <fpage>3799</fpage>
        <lpage>3803</lpage>
        <pub-id pub-id-type="doi">10.1093/nar/gkg555</pub-id>
        <pub-id pub-id-type="pmid">12824422</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B23">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Khan</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Situ</surname>
          <given-names>G</given-names>
        </name>
        <name>
          <surname>Decker</surname>
          <given-names>K</given-names>
        </name>
        <name>
          <surname>Schmidt</surname>
          <given-names>CJ</given-names>
        </name>
        <article-title>GoFigure: automated Gene Ontology annotation</article-title>
        <source>Bioinformatics</source>
        <year>2003</year>
        <volume>19</volume>
        <issue>18</issue>
        <fpage>2484</fpage>
        <lpage>2485</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btg338</pub-id>
        <pub-id pub-id-type="pmid">14668239</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B24">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Martin</surname>
          <given-names>DM</given-names>
        </name>
        <name>
          <surname>Berriman</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Barton</surname>
          <given-names>GJ</given-names>
        </name>
        <article-title>GOtcha: a new method for prediction of protein function assessed by the annotation of seven genomes</article-title>
        <source>BMC Bioinformatics</source>
        <year>2004</year>
        <volume>5</volume>
        <fpage>178</fpage>
        <pub-id pub-id-type="doi">10.1186/1471-2105-5-178</pub-id>
        <pub-id pub-id-type="pmid">15550167</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B25">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Hawkins</surname>
          <given-names>T</given-names>
        </name>
        <name>
          <surname>Luban</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Kihara</surname>
          <given-names>D</given-names>
        </name>
        <article-title>Enhanced automated function prediction using distantly related sequences and contextual association by PFP</article-title>
        <source>Protein Science</source>
        <year>2006</year>
        <volume>15</volume>
        <issue>6</issue>
        <fpage>1550</fpage>
        <lpage>1556</lpage>
        <pub-id pub-id-type="doi">10.1110/ps.062153506</pub-id>
        <pub-id pub-id-type="pmid">16672240</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B26">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Altschul</surname>
          <given-names>SF</given-names>
        </name>
        <name>
          <surname>Madden</surname>
          <given-names>TL</given-names>
        </name>
        <name>
          <surname>Schaffer</surname>
          <given-names>AA</given-names>
        </name>
        <name>
          <surname>Zhang</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Zhang</surname>
          <given-names>Z</given-names>
        </name>
        <name>
          <surname>Miller</surname>
          <given-names>W</given-names>
        </name>
        <name>
          <surname>Lipman</surname>
          <given-names>DJ</given-names>
        </name>
        <article-title>Gapped BLAST and PSI-BLAST: a new generation of protein database search programs</article-title>
        <source>Nucleic Acids Res</source>
        <year>1997</year>
        <volume>25</volume>
        <issue>17</issue>
        <fpage>3389</fpage>
        <lpage>3402</lpage>
        <pub-id pub-id-type="doi">10.1093/nar/25.17.3389</pub-id>
        <pub-id pub-id-type="pmid">9254694</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B27">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Lobley</surname>
          <given-names>AE</given-names>
        </name>
        <name>
          <surname>Nugent</surname>
          <given-names>T</given-names>
        </name>
        <name>
          <surname>Orengo</surname>
          <given-names>CA</given-names>
        </name>
        <name>
          <surname>Jones</surname>
          <given-names>DT</given-names>
        </name>
        <article-title>FFPred: an integrated feature-based function prediction server for vertebrate proteomes</article-title>
        <source>Nucleic Acids Res</source>
        <year>2008</year>
        <volume>36</volume>
        <fpage>W297</fpage>
        <lpage>302</lpage>
        <pub-id pub-id-type="doi">10.1093/nar/gkn193</pub-id>
        <pub-id pub-id-type="pmid">18463141</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B28">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Smale</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Rosasco</surname>
          <given-names>L</given-names>
        </name>
        <name>
          <surname>Bouvrie</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Caponnetto</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Poggio</surname>
          <given-names>T</given-names>
        </name>
        <article-title>Mathematics of the Neural Response</article-title>
        <source>Foundations of Computational Mathematics</source>
        <year>2010</year>
        <volume>10</volume>
        <issue>1</issue>
        <fpage>67</fpage>
        <lpage>91</lpage>
        <pub-id pub-id-type="doi">10.1007/s10208-009-9049-1</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B29">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Huang</surname>
          <given-names>Y</given-names>
        </name>
        <name>
          <surname>Niu</surname>
          <given-names>B</given-names>
        </name>
        <name>
          <surname>Gao</surname>
          <given-names>Y</given-names>
        </name>
        <name>
          <surname>Fu</surname>
          <given-names>L</given-names>
        </name>
        <name>
          <surname>Li</surname>
          <given-names>W</given-names>
        </name>
        <article-title>CD-HIT Suite: a web server for clustering and comparing biological sequences</article-title>
        <source>Bioinformatics</source>
        <year>2010</year>
        <volume>26</volume>
        <issue>5</issue>
        <fpage>680</fpage>
        <lpage>682</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btq003</pub-id>
        <pub-id pub-id-type="pmid">20053844</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B30">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Bairoch</surname>
          <given-names>A</given-names>
        </name>
        <article-title>PROSITE: a dictionary of sites and patterns in proteins</article-title>
        <source>Nucleic Acids Res</source>
        <year>1991</year>
        <volume>19</volume>
        <issue>Suppl</issue>
        <fpage>2241</fpage>
        <lpage>2245</lpage>
        <pub-id pub-id-type="pmid">2041810</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B31">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Sonnhammer</surname>
          <given-names>EL</given-names>
        </name>
        <name>
          <surname>Eddy</surname>
          <given-names>SR</given-names>
        </name>
        <name>
          <surname>Durbin</surname>
          <given-names>R</given-names>
        </name>
        <article-title>Pfam: a comprehensive database of protein domain families based on seed alignments</article-title>
        <source>Proteins</source>
        <year>1997</year>
        <volume>28</volume>
        <issue>3</issue>
        <fpage>405</fpage>
        <lpage>420</lpage>
        <pub-id pub-id-type="doi">10.1002/(SICI)1097-0134(199707)28:3&lt;405::AID-PROT10&gt;3.0.CO;2-L</pub-id>
        <pub-id pub-id-type="pmid">9223186</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B32">
      <mixed-citation publication-type="book">
        <name>
          <surname>Durbin</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Eddy</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Krogh</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Mitchison</surname>
          <given-names>G</given-names>
        </name>
        <source>Biological sequence analysis: probabilistic models of proteins and nucleic acids</source>
        <year>1998</year>
        <publisher-name>Cambridge University Press</publisher-name>
      </mixed-citation>
    </ref>
    <ref id="B33">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Sadreyev</surname>
          <given-names>RI</given-names>
        </name>
        <name>
          <surname>Baker</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Grishin</surname>
          <given-names>NV</given-names>
        </name>
        <article-title>Profile-profile comparisons by COMPASS predict intricate homologies between protein families</article-title>
        <source>Protein Sci</source>
        <year>2003</year>
        <volume>12</volume>
        <issue>10</issue>
        <fpage>2262</fpage>
        <lpage>2272</lpage>
        <pub-id pub-id-type="pmid">14500884</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B34">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Soding</surname>
          <given-names>J</given-names>
        </name>
        <article-title>Protein homology detection by HMM-HMM comparison</article-title>
        <source>Bioinformatics</source>
        <year>2005</year>
        <volume>21</volume>
        <issue>7</issue>
        <fpage>951</fpage>
        <lpage>960</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/bti125</pub-id>
        <pub-id pub-id-type="pmid">15531603</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B35">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Dunbrack</surname>
          <given-names>RL</given-names>
          <suffix>Jr</suffix>
        </name>
        <article-title>Sequence comparison and protein structure prediction</article-title>
        <source>Curr Opin Struct Biol</source>
        <year>2006</year>
        <volume>16</volume>
        <issue>3</issue>
        <fpage>374</fpage>
        <lpage>384</lpage>
        <pub-id pub-id-type="doi">10.1016/j.sbi.2006.05.006</pub-id>
        <pub-id pub-id-type="pmid">16713709</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B36">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Wang</surname>
          <given-names>JW</given-names>
        </name>
        <name>
          <surname>Feng</surname>
          <given-names>JA</given-names>
        </name>
        <article-title>Exploring the sequence patterns in the alpha-helices of proteins</article-title>
        <source>Protein Engineering</source>
        <year>2003</year>
        <volume>16</volume>
        <issue>11</issue>
        <fpage>799</fpage>
        <lpage>807</lpage>
        <pub-id pub-id-type="doi">10.1093/protein/gzg101</pub-id>
        <pub-id pub-id-type="pmid">14631069</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B37">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Wang</surname>
          <given-names>JW</given-names>
        </name>
        <name>
          <surname>Feng</surname>
          <given-names>JA</given-names>
        </name>
        <article-title>NdPASA: A novel pairwise protein sequence alignment algorithm that incorporates neighbor-dependent amino acid propensities</article-title>
        <source>Proteins</source>
        <year>2005</year>
        <volume>58</volume>
        <issue>3</issue>
        <fpage>628</fpage>
        <lpage>637</lpage>
        <pub-id pub-id-type="pmid">15616964</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B38">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Li</surname>
          <given-names>W</given-names>
        </name>
        <name>
          <surname>Wang</surname>
          <given-names>JW</given-names>
        </name>
        <name>
          <surname>Feng</surname>
          <given-names>JA</given-names>
        </name>
        <article-title>NdPASA: a pairwise sequence alignment server for distantly related proteins</article-title>
        <source>Bioinformatics</source>
        <year>2005</year>
        <volume>21</volume>
        <issue>19</issue>
        <fpage>3803</fpage>
        <lpage>3805</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/bti619</pub-id>
        <pub-id pub-id-type="pmid">16105904</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B39">
      <mixed-citation publication-type="journal">
        <name>
          <surname>McGuffin</surname>
          <given-names>LJ</given-names>
        </name>
        <name>
          <surname>Bryson</surname>
          <given-names>K</given-names>
        </name>
        <name>
          <surname>Jones</surname>
          <given-names>DT</given-names>
        </name>
        <article-title>The PSIPRED protein structure prediction server</article-title>
        <source>Bioinformatics</source>
        <year>2000</year>
        <volume>16</volume>
        <issue>4</issue>
        <fpage>404</fpage>
        <lpage>405</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/16.4.404</pub-id>
        <pub-id pub-id-type="pmid">10869041</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B40">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Soding</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Biegert</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Lupas</surname>
          <given-names>AN</given-names>
        </name>
        <article-title>The HHpred interactive server for protein homology detection and structure prediction</article-title>
        <source>Nucleic Acids Res</source>
        <year>2005</year>
        <volume>33</volume>
        <fpage>W244</fpage>
        <lpage>248</lpage>
        <pub-id pub-id-type="doi">10.1093/nar/gki408</pub-id>
        <pub-id pub-id-type="pmid">15980461</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B41">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Gattiker</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Gasteiger</surname>
          <given-names>E</given-names>
        </name>
        <name>
          <surname>Bairoch</surname>
          <given-names>A</given-names>
        </name>
        <article-title>ScanProsite: a reference implementation of a PROSITE scanning tool</article-title>
        <source>Appl Bioinformatics</source>
        <year>2002</year>
        <volume>1</volume>
        <issue>2</issue>
        <fpage>107</fpage>
        <lpage>108</lpage>
        <pub-id pub-id-type="pmid">15130850</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B42">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Aronszajn</surname>
          <given-names>N</given-names>
        </name>
        <article-title>Theory of Reproducing Kernels</article-title>
        <source>Transactions of the American Mathematical Society</source>
        <year>1950</year>
        <volume>68</volume>
        <issue>3</issue>
        <fpage>337</fpage>
        <lpage>404</lpage>
        <pub-id pub-id-type="doi">10.1090/S0002-9947-1950-0051437-7</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B43">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Corinna</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Vapnik</surname>
          <given-names>V</given-names>
        </name>
        <article-title>Support-Vector Networks</article-title>
        <source>Machine Learning</source>
        <year>1995</year>
        <volume>20</volume>
      </mixed-citation>
    </ref>
    <ref id="B44">
      <mixed-citation publication-type="other">
        <name>
          <surname>Suykens</surname>
          <given-names>JAK</given-names>
        </name>
        <name>
          <surname>Van Gestel</surname>
          <given-names>T</given-names>
        </name>
        <name>
          <surname>De Brabanter</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>De Moor</surname>
          <given-names>B</given-names>
        </name>
        <name>
          <surname>Vandewalle</surname>
          <given-names>J</given-names>
        </name>
        <article-title>Least Squares Support Vector Machines</article-title>
        <source>World Scientific</source>
        <year>2002</year>
      </mixed-citation>
    </ref>
  </ref-list>
</back>
