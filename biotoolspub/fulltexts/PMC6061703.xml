<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.1 20151215//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 1.1?>
<?ConverterInfo.XSLTName jp2nlmx2.xsl?>
<?ConverterInfo.Version 1?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">6061703</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/bty157</article-id>
    <article-id pub-id-type="publisher-id">bty157</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Original Papers</subject>
        <subj-group subj-group-type="category-toc-heading">
          <subject>Sequence Analysis</subject>
        </subj-group>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Integrating long-range connectivity information into de Bruijn graphs</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Turner</surname>
          <given-names>Isaac</given-names>
        </name>
        <xref ref-type="aff" rid="bty157-aff1">1</xref>
        <xref ref-type="corresp" rid="bty157-cor1"/>
        <xref ref-type="author-notes" rid="bty157-FM2"/>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Garimella</surname>
          <given-names>Kiran V</given-names>
        </name>
        <xref ref-type="aff" rid="bty157-aff1">1</xref>
        <xref ref-type="aff" rid="bty157-aff2">2</xref>
        <xref ref-type="corresp" rid="bty157-cor1"/>
        <xref ref-type="author-notes" rid="bty157-FM2"/>
        <!--<email>kiran@well.ox.ac.uk</email>-->
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Iqbal</surname>
          <given-names>Zamin</given-names>
        </name>
        <xref ref-type="aff" rid="bty157-aff1">1</xref>
        <xref ref-type="aff" rid="bty157-aff3">3</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>McVean</surname>
          <given-names>Gil</given-names>
        </name>
        <xref ref-type="aff" rid="bty157-aff1">1</xref>
        <xref ref-type="aff" rid="bty157-aff2">2</xref>
      </contrib>
    </contrib-group>
    <contrib-group>
      <contrib contrib-type="editor">
        <name>
          <surname>Berger</surname>
          <given-names>Bonnie</given-names>
        </name>
        <role>Associate Editor</role>
      </contrib>
    </contrib-group>
    <aff id="bty157-aff1"><label>1</label> Wellcome Trust Centre for Human Genetics, University of Oxford, Oxford, UK</aff>
    <aff id="bty157-aff2"><label>2</label>Big Data Institute, Li Ka Shing Centre for Health Information and Discovery, University of Oxford, Oxford, UK</aff>
    <aff id="bty157-aff3"><label>3</label>European Bioinformatics Institute (EMBL-EBI), Wellcome Genome Campus, Hinxton, UK</aff>
    <author-notes>
      <fn id="bty157-FM2">
        <p>The authors wish it to be known that, in their opinion, Isaac Turner and Kiran V. Garimella authors should be regarded as Joint First Authors.</p>
      </fn>
      <corresp id="bty157-cor1">To whom correspondence should be addressed. Email: <email>kiran@well.ox.ac.uk</email> or <email>turner.isaac@gmail.com</email></corresp>
    </author-notes>
    <pub-date pub-type="ppub">
      <day>01</day>
      <month>8</month>
      <year>2018</year>
    </pub-date>
    <pub-date pub-type="epub" iso-8601-date="2018-03-15">
      <day>15</day>
      <month>3</month>
      <year>2018</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>15</day>
      <month>3</month>
      <year>2018</year>
    </pub-date>
    <!-- PMC Release delay is 0 months and 0 days and was based on the <pub-date pub-type="epub"/>. -->
    <volume>34</volume>
    <issue>15</issue>
    <fpage>2556</fpage>
    <lpage>2565</lpage>
    <history>
      <date date-type="received">
        <day>08</day>
        <month>6</month>
        <year>2017</year>
      </date>
      <date date-type="rev-recd">
        <day>25</day>
        <month>11</month>
        <year>2017</year>
      </date>
      <date date-type="accepted">
        <day>14</day>
        <month>3</month>
        <year>2018</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© The Author(s) 2018. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2018</copyright-year>
      <license license-type="cc-by" xlink:href="http://creativecommons.org/licenses/by/4.0/">
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</ext-link>), which permits unrestricted reuse, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="bty157.pdf"/>
    <abstract>
      <title>Abstract</title>
      <sec id="s1">
        <title>Motivation</title>
        <p>The de Bruijn graph is a simple and efficient data structure that is used in many areas of sequence analysis including genome assembly, read error correction and variant calling. The data structure has a single parameter <italic>k</italic>, is straightforward to implement and is tractable for large genomes with high sequencing depth. It also enables representation of multiple samples simultaneously to facilitate comparison. However, unlike the string graph, a de Bruijn graph does not retain long range information that is inherent in the read data. For this reason, applications that rely on de Bruijn graphs can produce sub-optimal results given their input data.</p>
      </sec>
      <sec id="s2">
        <title>Results</title>
        <p>We present a novel assembly graph data structure: the <italic>Linked de Bruijn Graph (LdBG)</italic>. Constructed by adding annotations on top of a de Bruijn graph, it stores long range connectivity information through the graph. We show that with error-free data it is possible to losslessly store and recover sequence from a Linked de Bruijn graph. With assembly simulations we demonstrate that the LdBG data structure outperforms both our de Bruijn graph and the String Graph Assembler (SGA). Finally we apply the LdBG to <italic>Klebsiella pneumoniae</italic> short read data to make large (12 kbp) variant calls, which we validate using PacBio sequencing data, and to characterize the genomic context of drug-resistance genes.</p>
      </sec>
      <sec id="s3">
        <title>Availability and implementation</title>
        <p>Linked de Bruijn Graphs and associated algorithms are implemented as part of McCortex, which is available under the MIT license at <ext-link ext-link-type="uri" xlink:href="https://github.com/mcveanlab/mccortex">https://github.com/mcveanlab/mccortex</ext-link>.</p>
      </sec>
      <sec id="s4">
        <title>Supplementary information</title>
        <p><xref ref-type="supplementary-material" rid="sup1">Supplementary data</xref> are available at <italic>Bioinformatics</italic> online.</p>
      </sec>
    </abstract>
    <funding-group>
      <award-group award-type="grant">
        <funding-source>
          <named-content content-type="funder-name">Wellcome Trust</named-content>
          <named-content content-type="funder-identifier">10.13039/100004440</named-content>
        </funding-source>
        <award-id>090532/Z/09/Z</award-id>
        <award-id>100956/Z/13/Z</award-id>
      </award-group>
      <award-group award-type="grant">
        <funding-source>
          <named-content content-type="funder-name">Wellcome Trust Research Studentship award</named-content>
        </funding-source>
        <award-id>097310/Z/11/Z</award-id>
      </award-group>
      <award-group award-type="grant">
        <funding-source>
          <named-content content-type="funder-name">BBSRC</named-content>
          <named-content content-type="funder-identifier">10.13039/501100000268</named-content>
        </funding-source>
      </award-group>
      <award-group award-type="grant">
        <funding-source>
          <named-content content-type="funder-name">Wellcome Trust</named-content>
          <named-content content-type="funder-identifier">10.13039/100004440</named-content>
        </funding-source>
      </award-group>
      <award-group award-type="grant">
        <funding-source>
          <named-content content-type="funder-name">Royal Society Sir Henry Dale Fellowship</named-content>
        </funding-source>
        <award-id>102541/Z/13/Z</award-id>
      </award-group>
    </funding-group>
    <counts>
      <page-count count="10"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec>
    <title>1 Introduction</title>
    <p>Most efforts to discover genetic variation in populations begin with alignment of high-throughput sequencing (HTS) data to a high-quality reference genome for the organism under study. This approach works well for regions with low divergence from the reference haplotype. However, many biologically interesting loci reside in regions of high divergence. For example, antigenic genes in <italic>Plasmodium falciparum</italic>, <italic>Trypanosoma brucei</italic> and other pathogens often exhibit non-allelic homologous recombination underlying mechanisms of immune escape (<xref rid="bty157-B2" ref-type="bibr">Artzy-Randrup <italic>et al.</italic>, 2012</xref>; <xref rid="bty157-B19" ref-type="bibr">Freitas-Junior <italic>et al.</italic>, 2000</xref>; <xref rid="bty157-B28" ref-type="bibr">Jackson <italic>et al.</italic>, 2012</xref>). Similarly, structural mutations, such as rearrangements and amplifications, can promote tumourigenesis through dysregulation of oncogenes or down-regulation of tumour suppressors (<xref rid="bty157-B1" ref-type="bibr">Aguilera and Gómez-González, 2008</xref>; <xref rid="bty157-B16" ref-type="bibr">Difilippantonio <italic>et al.</italic>, 2002</xref>). More generally, variants may be difficult to identify and characterize when the altered haplotype differs substantially from the reference, and other regions of interest reside in sequence absent from the reference sequence altogether. For example, in 13 isolates of the diploid coccolithophore <italic>Emiliania huxleyi</italic>, 8–40 Mbp of the approximately 142 Mbp genome were found to be isolate-specific; up to 25% of genes were found to be absent from the reference sequence (<xref rid="bty157-B47" ref-type="bibr">Read <italic>et al.</italic>, 2013</xref>). In these scenarios, reads may fail to map to the reference, preventing the analyst from inspecting biologically interesting variation. Alternatively, reads may map incorrectly, misleading the analyst to consider variation where none exists (<xref rid="bty157-B48" ref-type="bibr">Ribeiro <italic>et al.</italic>, 2015</xref>).</p>
    <p>One mitigation of this inadequate reference problem is to augment the reference with known variation and alternative alleles to improve read mapping (<xref rid="bty157-B17" ref-type="bibr">Dilthey <italic>et al.</italic>, 2015</xref>; <xref rid="bty157-B24" ref-type="bibr">Huang <italic>et al.</italic>, 2013</xref>; <xref rid="bty157-B51" ref-type="bibr">Schneeberger <italic>et al.</italic>, 2009</xref>; <xref rid="bty157-B56" ref-type="bibr">Weisenfeld <italic>et al.</italic>, 2014</xref>). Such approaches commonly convert flat reference genomes into a graph structure, effectively mapping reads to all references simultaneously and choosing the path that best fits the data. In a study mapping to a fragmented human assembly, <xref rid="bty157-B36" ref-type="bibr">Limasset <italic>et al.</italic> (2016)</xref> found that mapping to a reference graph instead of flat contigs led to a 22% increase in the number of reads that map uniquely.</p>
    <p><italic>De novo</italic> assembly offers a means to overcome some of the limitations of reference-based analyses. Rather than aligning reads to a reference, reads are aligned to one another. These alignments are encoded in a graph data structure, a collection of ‘vertices’ encapsulating sequence data and ‘edges’ representing overlaps of different sequences (<xref rid="bty157-B41" ref-type="bibr">Myers, 1995</xref>). Graphs from different samples (and any reference) can then be compared to discover variation directly (<xref rid="bty157-B4" ref-type="bibr">Bateman <italic>et al.</italic>, 2016</xref>). Should the variation be in a locus unrepresented in the reference genome, the graph-based comparison can still capture the event (<xref rid="bty157-B26" ref-type="bibr">Iqbal <italic>et al.</italic>, 2012</xref>).</p>
    <p>The most common sequencers in use today (second-generation) produce tens of millions of short reads (typically 75–150 bp in length) per sequencing run (<xref rid="bty157-B20" ref-type="bibr">Goodwin <italic>et al.</italic>, 2016</xref>). It is common to assemble such data using a so-called ‘de Bruijn’ graph approach (<xref rid="bty157-B15" ref-type="bibr">de Bruijn, 1946</xref>; <xref rid="bty157-B25" ref-type="bibr">Idury and Waterman, 1995</xref>; <xref rid="bty157-B44" ref-type="bibr">Pevzner, 1989</xref>). Vertices are constrained to be fixed-width substrings of length <italic>k</italic> (or ‘<italic>k</italic>-mers’). Edges represent observed sequence adjacencies in the reads. With sufficient coverage, overlaps are implicitly encoded because two reads which overlap will share <italic>k</italic>-mers. Thus the graph is built up one read at a time at the cost of storing the graph in memory. Graphs of multiple individuals can be compared in memory (<xref rid="bty157-B26" ref-type="bibr">Iqbal <italic>et al.</italic>, 2012</xref>). However, there is a penalty for this approach: long-range information in the read is sacrificed. This is particularly problematic as genomes tend to have many repetitive regions and without context it is often not possible to determine the origin of a random <italic>k</italic>-mer (<xref rid="bty157-B39" ref-type="bibr">Miller <italic>et al.</italic>, 2010</xref>; <xref rid="bty157-B45" ref-type="bibr">Pevzner, 2004</xref>). However, as <italic>k</italic> increases, so does the specificity of its location. String graphs address the issue of storing long-range information by avoiding the read fragmentation step and instead find explicit overlaps between reads. Unfortunately string graphs are not well suited to multi-sample comparison and have a high per-sample memory cost (<xref rid="bty157-B7" ref-type="bibr">Bonizzoni <italic>et al.</italic>, 2016</xref>).</p>
    <p>We start by describing the de Bruijn graph and its benefits compared to the string graph. We then describe an augmentation (LdBG) that allows long-range information to be kept. Theoretical results and simulations are used to characterize its properties. We demonstrate its value by application to variant discovery and characterization of genomic context for drug resistance genes in <italic>Klebsiella pneumoniae</italic>. Finally, we consider the possibility of using such structures for regular analysis of human-scale genomes.</p>
  </sec>
  <sec>
    <title>2 Background</title>
    <sec>
      <title>2.1 Definitions and notation</title>
      <p>DNA sequences are strings over the alphabet {A,C,G,T}. We denote a DNA sequence as <inline-formula id="IE1"><mml:math id="IM1"><mml:mrow><mml:mi>S</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mi>S</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>S</mml:mi><mml:mrow><mml:mo>|</mml:mo><mml:mi>S</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> where <inline-formula id="IE2"><mml:math id="IM2"><mml:mrow><mml:mo>|</mml:mo><mml:mi>S</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula> is the length of the sequence. <inline-formula id="IE3"><mml:math id="IM3"><mml:mrow><mml:mi>S</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> is sequence <inline-formula id="IE4"><mml:math id="IM4"><mml:mrow><mml:msub><mml:mi>S</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>S</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>. <inline-formula id="IE5"><mml:math id="IM5"><mml:mrow><mml:mi>S</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> is the reverse of <italic>S</italic> (<inline-formula id="IE6"><mml:math id="IM6"><mml:mrow><mml:msub><mml:mi>S</mml:mi><mml:mrow><mml:mo>|</mml:mo><mml:mi>S</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>S</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula>). <inline-formula id="IE7"><mml:math id="IM7"><mml:mrow><mml:mover accent="true"><mml:mi>S</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> is the reverse complement of S. A <italic>k</italic>-mer is a sequence of length <italic>k</italic> over the alphabet {A,C,G,T}.</p>
    </sec>
    <sec>
      <title>2.2 Assembly graphs</title>
      <p>An assembly graph is any graph where the vertices represent sequence and edges represent overlaps or adjacencies between those sequences. An assembly graph may not have parallel edges (not a multigraph). Traversing a vertex <italic>v</italic> backwards (<inline-formula id="IE8"><mml:math id="IM8"><mml:mrow><mml:mover accent="true"><mml:mi>v</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula>) gives the reverse complement of the sequence it represents. <inline-formula id="IE9"><mml:math id="IM9"><mml:mrow><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:msup><mml:mi>g</mml:mi><mml:mo>−</mml:mo></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is the indegree and <inline-formula id="IE10"><mml:math id="IM10"><mml:mrow><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:msup><mml:mi>g</mml:mi><mml:mo>+</mml:mo></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is the outdegree of vertex <italic>v</italic>. A path through the graph is a list of adjacent vertices with edges between them. The reverse of path <inline-formula id="IE11"><mml:math id="IM11"><mml:mrow><mml:mi>P</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> is <inline-formula id="IE12"><mml:math id="IM12"><mml:mrow><mml:mover accent="true"><mml:mi>P</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mo>=</mml:mo><mml:mrow><mml:mover accent="true"><mml:mrow><mml:msub><mml:mi>v</mml:mi><mml:mi>n</mml:mi></mml:msub></mml:mrow><mml:mo stretchy="false">¯</mml:mo></mml:mover></mml:mrow><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mrow><mml:mover accent="true"><mml:mrow><mml:msub><mml:mi>v</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo stretchy="false">¯</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:math></inline-formula>. A <italic>unitig</italic><inline-formula id="IE13"><mml:math id="IM13"><mml:mrow><mml:mi>U</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, is a maximal path such that <inline-formula id="IE14"><mml:math id="IM14"><mml:mrow><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:msup><mml:mi>g</mml:mi><mml:mo>−</mml:mo></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:msup><mml:mi>g</mml:mi><mml:mo>+</mml:mo></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> for <inline-formula id="IE15"><mml:math id="IM15"><mml:mrow><mml:mn>1</mml:mn><mml:mo>&lt;</mml:mo><mml:mi>i</mml:mi><mml:mo>&lt;</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE16"><mml:math id="IM16"><mml:mrow><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:msup><mml:mi>g</mml:mi><mml:mo>+</mml:mo></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:msup><mml:mi>g</mml:mi><mml:mo>−</mml:mo></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> if <italic>n</italic> &gt; 1. The maximal property means the path cannot be extended without violating these conditions.</p>
    </sec>
    <sec>
      <title>2.3 de Bruijn graphs</title>
      <p>A de Bruijn graph <italic>G</italic>(<italic>k</italic>) is an assembly graph, constructed from a set of sequence reads <italic>R</italic> and defined by <inline-formula id="IE17"><mml:math id="IM17"><mml:mrow><mml:mrow><mml:mo stretchy="false">{</mml:mo><mml:mrow><mml:mi>V</mml:mi><mml:mo>,</mml:mo><mml:mi>E</mml:mi></mml:mrow><mml:mo stretchy="false">}</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> where <italic>V</italic> is a set of vertices representing <italic>k</italic>-mers and <italic>E</italic> a set of edges between those <italic>k</italic>-mers. de Bruijn graphs are constructed by breaking input reads into overlapping <italic>k</italic>-mers that are added to the graph. With one <italic>k</italic>-mer starting at every base, a read of length <inline-formula id="IE18"><mml:math id="IM18"><mml:mrow><mml:mo>|</mml:mo><mml:msub><mml:mi>r</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula> will give <inline-formula id="IE19"><mml:math id="IM19"><mml:mrow><mml:mo>|</mml:mo><mml:msub><mml:mi>r</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>|</mml:mo><mml:mo>−</mml:mo><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula><italic>k</italic>-mers. A count is kept of how many times a given <italic>k</italic>-mer was seen in the input reads, called <italic>k</italic>-mer coverage. Edges are added between two <italic>k</italic>-mers if they share an overlap of <italic>k</italic> – 1 bases. Some implementations additionally require that <italic>k</italic>-mers are seen overlapping by <italic>k</italic> – 1 bases in the read data, in order to have an edge between them.</p>
      <p>Due to the double stranded nature of DNA and the fact that we do not know which strand a read originated from, storing all <italic>k</italic>-mers from reads results in <italic>k</italic>-mers occurring separately in the graph in both their forward and reverse complement orientations. To overcome this it is common to store only the lexically lower of each <italic>k</italic>-mer <italic>X</italic> and its reverse-complement <inline-formula id="IE20"><mml:math id="IM20"><mml:mrow><mml:mover accent="true"><mml:mi>X</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> (<xref rid="bty157-B57" ref-type="bibr">Zerbino, 2010</xref>). Requiring that <italic>k</italic> is odd prevents a <italic>k</italic>-mer from being its own reverse complement (a DNA palindrome). When visiting a vertex in the de Bruijn graph we can visit it in its forward or reverse complement orientation. The orientation in which we arrive at it determines if we leave by its out- or in- edges (forward, reverse respectively).</p>
      <p>A de Bruijn graph only stores connectivity information one base either side of a given <italic>k</italic>-mer. This means that for three adjacent <italic>k</italic>-mers in the graph (<inline-formula id="IE21"><mml:math id="IM21"><mml:mrow><mml:msub><mml:mi>v</mml:mi><mml:mi>a</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mi>b</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mi>c</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>), there is no information about how the first and third are connected if the middle <italic>k</italic>-mer has <inline-formula id="IE22"><mml:math id="IM22"><mml:mrow><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:msup><mml:mi>g</mml:mi><mml:mo>−</mml:mo></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mi>b</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>&gt;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE23"><mml:math id="IM23"><mml:mrow><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:msup><mml:mi>g</mml:mi><mml:mo>+</mml:mo></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mi>b</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>&gt;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>. This graph motif is known as a ‘tangle’ and is caused by the graph collapsing down at a repeat and splitting out again afterwards. de Bruijn graphs collapse down at repeats in the genome of lengths <inline-formula id="IE24"><mml:math id="IM24"><mml:mrow><mml:mo>≥</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula>. It is not possible to traverse a dBG past a tangle, even if the input reads are long enough to resolve it (i.e. pair-up <italic>k</italic>-mers going-into and coming-out of it). This makes analyses that use a de Bruijn graph sensitive to the parameter <italic>k</italic>.</p>
      <p>While increasing <italic>k</italic> can overcome the problem of short repeats, it also has the effect of reducing the number of <italic>k</italic>-mers given by each read and increases the number of <italic>k</italic>-mers lost to each sequencing error. Both these effects reduce <italic>k</italic>-mer coverage, which is determined by the <italic>k</italic>-mer size, the read length and the error rate (<xref rid="bty157-B26" ref-type="bibr">Iqbal <italic>et al.</italic>, 2012</xref>). As <italic>k</italic>-mer coverage drops, read overlaps are lost and gaps in coverage increase. Together with tangles, coverage gaps interrupt assembly and shorten contigs.</p>
      <p>Choosing a value for <italic>k</italic> is ultimately a trade-off. It is common to run analyses multiple times with different values of <italic>k</italic> and pick the best results according to a quality metric (e.g. assembly N50 or number of variants called) (<xref rid="bty157-B27" ref-type="bibr">Iqbal <italic>et al.</italic>, 2013</xref>). Alternatively the genome and read data can be sampled to estimate which value would be optimal (<xref rid="bty157-B57" ref-type="bibr">Zerbino, 2010</xref>).</p>
      <p>The dBG can be augmented to support multiple datasets, providing a single data structure to describe and compare the genomes of many individuals (<xref rid="bty157-B26" ref-type="bibr">Iqbal <italic>et al.</italic>, 2012</xref>). Graphs are built separately for each dataset <inline-formula id="IE25"><mml:math id="IM25"><mml:mrow><mml:mi>c</mml:mi><mml:mo>∈</mml:mo><mml:mi>C</mml:mi></mml:mrow></mml:math></inline-formula> and merged post-construction. The merge produces a union graph <inline-formula id="IE26"><mml:math id="IM26"><mml:mrow><mml:msub><mml:mi>G</mml:mi><mml:mi>u</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:msub><mml:mi>V</mml:mi><mml:mi>u</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>E</mml:mi><mml:mi>u</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>, where <inline-formula id="IE27"><mml:math id="IM27"><mml:mrow><mml:msub><mml:mi>V</mml:mi><mml:mi>u</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:munder><mml:mo>∪</mml:mo><mml:mrow><mml:mi>c</mml:mi><mml:mo>∈</mml:mo><mml:mi>C</mml:mi></mml:mrow></mml:munder><mml:mrow><mml:msub><mml:mi>V</mml:mi><mml:mi>c</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE28"><mml:math id="IM28"><mml:mrow><mml:msub><mml:mi>E</mml:mi><mml:mi>u</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:msub><mml:mi>E</mml:mi><mml:mi>c</mml:mi></mml:msub><mml:mo>:</mml:mo><mml:mi>c</mml:mi><mml:mo>∈</mml:mo><mml:mi>C</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>. Each <italic>k</italic>-mer stores which samples it was seen in. We refer to <italic>c</italic> as <italic>colour</italic>, a generic term that can mean a distinct individual, pooled population or a specific dataset on a single individual (e.g. tumour/normal), depending on analysis context. We shall refer to this structure as a <italic>multi-colour de Bruijn graph</italic>.</p>
      <p>de Bruijn graphs are used in many areas of sequence analysis, including in mapping-based calling, as in the local alignment step of the variant caller Platypus (<xref rid="bty157-B49" ref-type="bibr">Rimmer <italic>et al.</italic>, 2014</xref>), in de novo assembly as in Velvet (<xref rid="bty157-B58" ref-type="bibr">Zerbino and Birney, 2008</xref>) and ABySS (<xref rid="bty157-B54" ref-type="bibr">Simpson <italic>et al.</italic>, 2009</xref>), and in de novo assembly for variant calling (<xref rid="bty157-B26" ref-type="bibr">Iqbal <italic>et al.</italic>, 2012</xref>).</p>
      <p>Recently there has been work on implementing low memory dBG construction (<xref rid="bty157-B13" ref-type="bibr">Chikhi <italic>et al.</italic>, 2015</xref>), representations (<xref rid="bty157-B8" ref-type="bibr">Bowe <italic>et al.</italic>, 2012</xref>; <xref rid="bty157-B12" ref-type="bibr">Chikhi and Rizk, 2013</xref>; <xref rid="bty157-B14" ref-type="bibr">Conway and Bromage, 2011</xref>; <xref rid="bty157-B40" ref-type="bibr">Muggli <italic>et al.</italic>, 2017</xref>) and dBG-based compression (<xref rid="bty157-B5" ref-type="bibr">Benoit <italic>et al.</italic>, 2015</xref>; <xref rid="bty157-B23" ref-type="bibr">Holley <italic>et al.</italic>, 2017</xref>). These have both provided great improvements over the naive hash table based implementation, extending the contexts in which dBGs can be used.</p>
    </sec>
    <sec>
      <title>2.4 String graphs</title>
      <p>A String graph is an assembly graph where the vertices represent the input reads and the edges are maximal non-transitive overlaps between them (<xref rid="bty157-B42" ref-type="bibr">Myers, 2005</xref>). The set of reads is reduced to remove reads contained within other reads. A naïve String graph implementation would take <inline-formula id="IE29"><mml:math id="IM29"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>N</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> time to compare all pairs of reads to find overlaps, before removing contained reads and transitive edges. (<xref rid="bty157-B53" ref-type="bibr">Simpson and Durbin, 2010</xref>) showed that it is possible to construct a string graph in linear time, by first generating an FM-index (<xref rid="bty157-B18" ref-type="bibr">Ferragina and Manzini, 2000</xref>) of the input reads <italic>R</italic> and an FM-index of their reverse <inline-formula id="IE30"><mml:math id="IM30"><mml:mrow><mml:mi>R</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula>. Alternatively a single index can be constructed containing <italic>R</italic> and <inline-formula id="IE31"><mml:math id="IM31"><mml:mrow><mml:mover accent="true"><mml:mi>R</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> (<xref rid="bty157-B32" ref-type="bibr">Li, 2012</xref>).</p>
      <p>The FM-index is a data structure for compression and fast string searching. When the alphabet employed by the strings is small and constant-size (e.g. DNA nucleotides), the FM-index of a set of strings <italic>S</italic> facilitates searching for a query <italic>Q</italic> in time <inline-formula id="IE32"><mml:math id="IM32"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>|</mml:mo><mml:mi>Q</mml:mi><mml:mo>|</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and has construction time and memory complexity <inline-formula id="IE33"><mml:math id="IM33"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>|</mml:mo><mml:mi>S</mml:mi><mml:mo>|</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. The final index has roughly the same size <inline-formula id="IE34"><mml:math id="IM34"><mml:mrow><mml:mo>|</mml:mo><mml:mi>S</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula>, but can be efficiently compressed with run-length encoding.</p>
      <p>Since it is constructed from the reads without breaking them up, a String graph retains all connectivity information contained in the single-ended input reads (<xref rid="bty157-B42" ref-type="bibr">Myers, 2005</xref>). However, String graphs do not naturally lend themselves to storing information on read pairs, although one such data structure has been proposed (<xref rid="bty157-B11" ref-type="bibr">Chikhi and Lavenier, 2011</xref>).</p>
    </sec>
    <sec>
      <title>2.5 Other approaches for preserving connectivity</title>
      <p>Reference-guided assembly can help overcome deficiencies in short-read dBG-based assembly by providing a template sequence to merge contigs that are likely adjacent but could not be merged due to repeats, coverage dropout, or error. For example, the Columbus module in Velvet allows for the specification of one or more reference genomes to aid in reconstruction, though documentation suggests that closely related references and repetitive regions may not work well with this software (see <ext-link ext-link-type="uri" xlink:href="http://gensoft.pasteur.fr/docs/velvet/1.1.02/Columbus_manual.pdf">http://gensoft.pasteur.fr/docs/velvet/1.1.02/Columbus_manual.pdf</ext-link>). In contrast, RACA enables the use of a reference genome and multiple outgroups to guide the assembly of contigs and scaffolds from other assemblers (<xref rid="bty157-B29" ref-type="bibr">Kim <italic>et al.</italic>, 2013</xref>). However, RACA may introduce a reference bias as it computes synteny blocks by pairwise alignment solely against the single reference genome and omitting contigs that cannot be placed on the reference. Ragout addresses this concern by extending the syntenic block computation to multiple references, allowing for different block scales (<xref rid="bty157-B37" ref-type="bibr">Kolmogorov <italic>et al.</italic>, 2014</xref>).</p>
      <p>Another strategy for preserving connectivity information in graphs is to reduce the dependence of dBGs on the single parameter <italic>k</italic>. One approach is to construct assemblies at multiple values of <italic>k</italic>, cluster resulting contigs across all assemblies by sequence similarity, choose a representative contig for each cluster (e.g. longest) and merge representative contigs by alignment to form a final assembly (A detailed procedure is specified at <ext-link ext-link-type="uri" xlink:href="http://ged.msu.edu/angus/metag-assembly-2011/velvet-multik.html">http://ged.msu.edu/angus/metag-assembly-2011/velvet-multik.html</ext-link>.). Alternatively, IDBA performs iterative assemblies starting at low values of <italic>k</italic> and removing reads utilized in the assembly before increasing <italic>k</italic> and repeating the process (<xref rid="bty157-B43" ref-type="bibr">Peng <italic>et al.</italic>, 2010</xref>). MEGAHIT employs a similar approach, removing likely sequencing errors in the graph rather than discarding reads after each iteration (<xref rid="bty157-B31" ref-type="bibr">Li <italic>et al.</italic>, 2015</xref>). These methods capture increasing amounts of connectivity information as <italic>k</italic> increases, but do not incorporate paired-end information. SPAdes builds on the iterative multi-<italic>k</italic> approach and its authors have explored using paired-<italic>k</italic>-mers (or ‘<italic>k-bimer</italic>’) which encodes two <italic>k</italic>-mers and a distance estimate directly into the early stages of genome assembly (<xref rid="bty157-B3" ref-type="bibr">Bankevich <italic>et al.</italic>, 2012</xref>).</p>
      <p>Beyond these multi-<italic>k</italic> approaches, various annotation schemes on de Bruijn graphs have emerged. The DARRC tool for read compression from (<xref rid="bty157-B23" ref-type="bibr">Holley <italic>et al.</italic>, 2017</xref>) uses a guided de Bruijn graph (gdBG), a multi-color de Bruijn graph constructed on sets of read sequences. While decomposition of reads into <italic>k</italic>-mers may produce false edges (<italic>k</italic> – 1 overlaps present in the graph due to sequence similarity but not reflecting true genomic sequence), read information is stored as graph paths (effectively alignments) which disambiguate junction choices and provides a compressed representation of input data. Faucet, a two-pass streaming approach for <italic>de novo</italic> assembly graph construction, additionally records information from reads spanning adjacent junctions, used in the offline graph-simplification stage for disentangling repetitive graph regions (<xref rid="bty157-B50" ref-type="bibr">Rozov <italic>et al.</italic>, 2017</xref>). (<xref rid="bty157-B6" ref-type="bibr">Bolger <italic>et al.</italic>, 2017</xref>) have recently presented the LOGAN graph, which augments each vertex in a dBG with a routing table that pairs distant <italic>k</italic>-mers based on observation within the same read. This routing idea, adapted from pathfinding protocols in telecommunication networks, shares conceptual similarities to what we present below.</p>
    </sec>
  </sec>
  <sec>
    <title>3 Materials and methods</title>
    <sec>
      <title>3.1 The linked de Bruijn graph</title>
      <p>We propose a new assembly graph data structure called the Linked de Bruijn Graph (LdBG). Defined as <inline-formula id="IE35"><mml:math id="IM35"><mml:mrow><mml:mi>L</mml:mi><mml:mi>G</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>V</mml:mi><mml:mo>,</mml:mo><mml:mi>E</mml:mi><mml:mo>,</mml:mo><mml:mi>L</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> where <italic>V</italic>, <italic>E</italic> are defined as in a de Bruijn graph. <italic>L</italic>(<italic>v</italic>) is a set of paths through the graph that start at vertex <inline-formula id="IE36"><mml:math id="IM36"><mml:mrow><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:mi>V</mml:mi></mml:mrow></mml:math></inline-formula>. We call these paths <italic>links</italic>. Each of these links <inline-formula id="IE37"><mml:math id="IM37"><mml:mrow><mml:mi>l</mml:mi><mml:mo>∈</mml:mo><mml:mi>L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is stored as a list of junction choices that when followed, starting from vertex <italic>v</italic>, recreate the path. Graph traversal is the same as with a de Bruijn graph, with the extension that when we visit a vertex <italic>v</italic>, we pick up the links associated with it: <italic>L</italic>(<italic>v</italic>). The links held during traversal record how many edges ago they were picked up, a value we call link ‘age’. Only when we reach a bifurcation in the graph do we consult the links currently held. We follow the next junction choice of the oldest link as this provides the most context as to where we are in the genome. Younger links are discarded if they are inconsistent with the oldest link. Should we have more than one oldest link and they disagree, we halt traversal. An illustration of links resolving a cycle is shown in <xref ref-type="fig" rid="bty157-F1">Figure 1</xref>.
</p>
      <fig id="bty157-F1" orientation="portrait" position="float">
        <label>Fig. 1.</label>
        <caption>
          <p>Utility of link information in traversing a graph cycle. (<bold>a</bold>) A 32-bp genome and a 23-bp read, each containing three (colour-coded) repeats of the 5-mer, GATGC. (<bold>b</bold>) The resulting de Bruijn graph (<italic>k</italic> = 5) with a repeat cycle, constructed from the genome sequence. The <italic>k</italic>-mers grouped by dashed boxes indicate the result of graph traversals to emit unitigs, with final sequences written below and positioned along the input genome for clarity. (<bold>c</bold>) Reads are ‘threaded’ (aligned) through the graph (top); the repeated <italic>k</italic>-mers are colour-coded. The alignment information is distilled to a set of junction choices to make when navigating the graph and stored as annotations on <italic>k</italic>-mers preceding junctions (middle). Multiple links are separated by a comma. Uppercase (lowercase) links indicate the choices to be made when traversing forwards (backwards). A <italic>k</italic>-mer’s links are picked up when we visit it. When we reach a junction, the next edge suggested by the oldest link(s) is taken, links that disagree are dropped, all remaining links trim off a junction choice and exhausted links are also dropped. The resultant contig recapitulating the entire genome is shown (bottom). Highlighted bases indicate the junction choices originating from the left-most link</p>
        </caption>
        <graphic xlink:href="bty157f1"/>
      </fig>
      <p>As with a de Bruijn graph we can look up any <italic>k</italic>-mer or edge between <italic>k</italic>-mers in time <italic>O</italic>(1) and we can start graph traversal from any <italic>k</italic>-mer. As in a multi-coloured dBG, a multi-coloured LdBG stores which samples have which <italic>k</italic>-mers and links.</p>
      <p>A LdBG is a lossless representation of a genome when generated from error-free reads, as long as the genome starts and ends with unique <italic>k</italic>-mers, there are no <italic>k</italic>-mer coverage gaps and each repeat is spanned by at least one read (proof in <xref ref-type="supplementary-material" rid="sup1">Supplementary Material</xref>). This is true regardless of the value of <italic>k</italic>.</p>
      <p>In constructing a LdBG we are effectively compressing reads against the de Bruijn graph. However, since read start/end positions are not important for assembly we do not store them, so although it is possible to recover the underlying genome (losslessly) through assembly, it is not possible to recover the original set of input reads.</p>
      <p>An LdBG on single-end reads can also be viewed as equivalent to a string graph with minimum overlap of <inline-formula id="IE38"><mml:math id="IM38"><mml:mrow><mml:msub><mml:mo>τ</mml:mo><mml:mrow><mml:mi>m</mml:mi><mml:mi>i</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula> bases and maximum error rate <inline-formula id="IE39"><mml:math id="IM39"><mml:mrow><mml:msub><mml:mi mathvariant="normal">ϵ</mml:mi><mml:mrow><mml:mi>m</mml:mi><mml:mi>a</mml:mi><mml:mi>x</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula>.</p>
      <p>Reads used to annotate the graph do not need to have been used to construct the de Bruijn graph. Sets of links may be merged by loading them together at runtime. We give an example of the utility of such a construction in the applications section below.</p>
    </sec>
    <sec>
      <title>3.2 de Bruijn graph construction</title>
      <p>Each input read <italic>r</italic> is broken into <inline-formula id="IE40"><mml:math id="IM40"><mml:mrow><mml:mo>|</mml:mo><mml:mi>r</mml:mi><mml:mo>|</mml:mo><mml:mo>−</mml:mo><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> overlapping <italic>k</italic>-mers (<inline-formula id="IE41"><mml:math id="IM41"><mml:mrow><mml:msub><mml:mi>v</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>) which are added to the graph. If a <italic>k</italic>-mer already exists in the graph, we increment its coverage. Edges are added between <italic>v<sub>i</sub></italic> and <inline-formula id="IE42"><mml:math id="IM42"><mml:mrow><mml:msub><mml:mi>v</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> for all <inline-formula id="IE43"><mml:math id="IM43"><mml:mrow><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>i</mml:mi><mml:mo>&lt;</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:math></inline-formula>.</p>
      <p>To remove <italic>k</italic>-mers due to sequencing error, unitigs with median <italic>k</italic>-mer coverage below <italic>T</italic> are removed, where <italic>T</italic> is a user-specified threshold. If not specified, a threshold <italic>T</italic> is chosen such that the expectation of a <italic>k</italic>-mer with coverage <italic>T</italic> being an error is <inline-formula id="IE44"><mml:math id="IM44"><mml:mrow><mml:mo>&lt;</mml:mo><mml:msup><mml:mrow><mml:mn>10</mml:mn></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>3</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> (see <xref ref-type="supplementary-material" rid="sup1">Supplementary Section S1</xref> of <xref ref-type="supplementary-material" rid="sup1">Supplementary Material</xref>).</p>
      <p>Graph tips, that is unitigs of length <italic>n</italic> (i.e. <inline-formula id="IE45"><mml:math id="IM45"><mml:mrow><mml:msub><mml:mi>v</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>) with <inline-formula id="IE46"><mml:math id="IM46"><mml:mrow><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:msup><mml:mi>g</mml:mi><mml:mo>−</mml:mo></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:msup><mml:mi>g</mml:mi><mml:mo>+</mml:mo></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>&lt;</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inline-formula>, are the result of sequencing errors near the end of reads or gaps in coverage. Tips are removed if they are shorter than a user specified value, the default being <italic>k</italic>, the maximum number of erroneous <italic>k</italic>-mers generated by a single-base sequencing error near the end of a read.</p>
    </sec>
    <sec>
      <title>3.3 Read-to-graph alignment</title>
      <p>Reads are aligned to the de Bruijn graph one-at-a-time and in doing so are error-corrected. For a read <italic>r</italic>, we look up each of its <italic>k</italic>-mers, resulting in a list of <italic>k</italic>-mers that describe a path through the graph. There may be gaps in this path due to <italic>k</italic>-mers removed from the graph during <italic>k</italic>-mer error cleaning (or if the read was not used in dBG construction). Gaps are closed by walking the graph between the <italic>k</italic>-mers either side of the gap (<italic>v<sub>i</sub></italic> and <italic>v<sub>j</sub></italic>). If we cannot traverse from <italic>v<sub>i</sub></italic> to <italic>v<sub>j</sub></italic>, we attempt going from <italic>v<sub>j</sub></italic> to <italic>v<sub>i</sub></italic>. Should such a traversal succeed (giving <italic>k</italic>-mers <inline-formula id="IE47"><mml:math id="IM47"><mml:mrow><mml:msub><mml:mi>v</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mi>x</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>) and <inline-formula id="IE48"><mml:math id="IM48"><mml:mrow><mml:mi>x</mml:mi><mml:mo>∼</mml:mo><mml:mo>|</mml:mo><mml:mi>j</mml:mi><mml:mo>−</mml:mo><mml:mi>i</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula>, the <italic>k</italic>-mers <inline-formula id="IE49"><mml:math id="IM49"><mml:mrow><mml:msub><mml:mi>v</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mi>x</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> are used to fill in the gap in the path between <italic>v<sub>i</sub></italic> and <italic>v<sub>j</sub></italic>. This error step is sequence agnostic in that it does not compare the new <italic>k</italic>-mers (<inline-formula id="IE50"><mml:math id="IM50"><mml:mrow><mml:msub><mml:mi>v</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mi>x</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>) to the read <italic>k</italic>-mers it is replacing (<inline-formula id="IE51"><mml:math id="IM51"><mml:mrow><mml:msub><mml:mi>v</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mrow><mml:mi>j</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>). This speeds up the error correction step and ensures it does not make assumptions about the error process of the input sequence data. The output of the alignment step is a set of sequences that perfectly match the de Bruijn graph <italic>k</italic>-mers; i.e. they describe a path through the graph.</p>
      <p>Gaps between paired-end reads are treated like gaps in reads caused by sequencing errors. LdBG naturally captures information from paired end reads once the insert gap is filled. Links can be generated in two passes: first with single-end reads against a dBG to create a LdBG; then with paired-end reads against the LdBG. This allows the single-ended read links to be used to aid traversal between read pairs.</p>
    </sec>
    <sec>
      <title>3.4 Link annotation</title>
      <p>A link is a path, starting from a given <italic>k</italic>-mer and stored as a series of junction choices. The function <inline-formula id="IE52"><mml:math id="IM52"><mml:mrow><mml:mi>J</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> takes a path and returns the junction choices it describes.</p>
      <p>Given a path <inline-formula id="IE53"><mml:math id="IM53"><mml:mrow><mml:mi>P</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> through the graph, we identify the maximum <italic>j</italic> such that <inline-formula id="IE54"><mml:math id="IM54"><mml:mrow><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:msup><mml:mi>g</mml:mi><mml:mo>+</mml:mo></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>&gt;</mml:mo><mml:mn>1</mml:mn><mml:mo>;</mml:mo><mml:mn>1</mml:mn><mml:mo>&lt;</mml:mo><mml:mi>j</mml:mi><mml:mo>&lt;</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:math></inline-formula>. Then for each <italic>i</italic> such that <inline-formula id="IE55"><mml:math id="IM55"><mml:mrow><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:msup><mml:mi>g</mml:mi><mml:mo>−</mml:mo></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>&gt;</mml:mo><mml:mn>1</mml:mn><mml:mo>;</mml:mo><mml:mn>1</mml:mn><mml:mo>&lt;</mml:mo><mml:mi>i</mml:mi><mml:mo>≤</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:math></inline-formula>, we add a link to vertex <inline-formula id="IE56"><mml:math id="IM56"><mml:mrow><mml:msub><mml:mi>v</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>: <inline-formula id="IE57"><mml:math id="IM57"><mml:mrow><mml:mi>L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>←</mml:mo><mml:mi>L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>∪</mml:mo><mml:mi>J</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mrow><mml:mi>j</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Link annotation is repeated for the reverse path <inline-formula id="IE58"><mml:math id="IM58"><mml:mrow><mml:mover accent="true"><mml:mi>P</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula>. Link counts record how many times a given link is seen in a sample starting at a particular <italic>k</italic>-mer.</p>
      <p>A collection of links (i.e. the series of junction choices arising from different reads spanning the same genomic locus) is easily represented as a tree, <italic>L</italic>(<italic>v</italic>) (each node a junction, with possible outgoing edges A, C, G and T, with coverage incremented for each read supporting a junction choice). Cleaning links proceeds similarly to cleaning <italic>k</italic>-mers: junction choices with coverage below threshold <italic>T</italic> are discarded. This link cleaning threshold is determined by applying the same model as used for <italic>k</italic>-mer cleaning to the link coverage distribution of the first junction choice of all links (see <xref ref-type="supplementary-material" rid="sup1">Supplementary Section S1</xref> of <xref ref-type="supplementary-material" rid="sup1">Supplementary Material</xref>).</p>
    </sec>
    <sec>
      <title>3.5 Implementation</title>
      <p>We have implemented the LdBG data structure and associated algorithms as part of McCortex, a modular set of multi-threaded programs for manipulating assembly graphs written in C. McCortex succeeds our cortex_var software for genome assembly and variant discovery, producing identical construction of multi-colour graphs and adding improvements for graph manipulation and link construction (The program cortex_con for consensus assembly, while co-developed alongside cortex_var, is not related to this work and is now retired.). FASTA, FASTQ, SAM, BAM &amp; CRAM input file formats are supported. The software is released under the MIT license. McCortex has been used as the backend for sequence analysis by <xref rid="bty157-B9" ref-type="bibr">Bradley <italic>et al.</italic> (2015)</xref>.</p>
    </sec>
    <sec>
      <title>3.6 Multi-coloured linked de Bruijn graphs</title>
      <p>Multi-colour LdBGs can be constructed by building single sample LdBGs and loading them together into McCortex. Links are represented internally as linked lists for which the only practical limit is machine memory. They can therefore be generated for any read length, including short Illumina reads (∼100–200 bp), PacBio/MinION consensus sequences (∼10 000–1 00 000 bp) and even whole chromosomes from finished reference sequences (potentially <inline-formula id="IE59"><mml:math id="IM59"><mml:mrow><mml:mo>&gt;</mml:mo><mml:mn>1</mml:mn><mml:mi>e</mml:mi><mml:mn>8</mml:mn></mml:mrow></mml:math></inline-formula> bp). For graph traversal tasks, such as assembly, we only store a single bit per sample per <italic>k</italic>-mer and per sample per link to record which <italic>k</italic>-mers/links are present in each sample. These are stored in a packed bitset. Graph traversal of a colour through a multi-coloured LdBG proceeds as per for a single-sample LdBG, only using links and <italic>k</italic>-mers of the given colour. At coverage gaps, traversal can fall back to using any <italic>k</italic>-mers in the graph (but not other colour’s links).</p>
    </sec>
  </sec>
  <sec>
    <title>4 Results: simulations</title>
    <sec>
      <title>4.1 Equivalence of LdBG and input string</title>
      <p>To test the lossless recovery of a genome from the LdBG we generated a random 10 kbp haploid genome, ensuring it started and ended with unique 7-mers. We identified the length of longest repeat (<italic>LR</italic>) in our genome. We generated perfect error-free coverage of the genome with a read length of <italic>LR</italic> + 2 starting at each base. We then built a LdBG (<italic>k</italic> = 7) from the reads, assembled contigs and removed contained contigs (those that were substrings of other contigs). After checking that we were left with a single contig, we compared it for an exact match to the original genome. This simulation was run 100 times without fail. With <italic>k</italic> = 7, there are only <inline-formula id="IE60"><mml:math id="IM60"><mml:mrow><mml:msup><mml:mn>4</mml:mn><mml:mi mathvariant="normal">7</mml:mi></mml:msup><mml:mo>=</mml:mo><mml:mn>16</mml:mn><mml:mo> </mml:mo><mml:mn>384</mml:mn></mml:mrow></mml:math></inline-formula> possible <italic>k</italic>-mers, so a random 10 kbp genome will have many repeats that could not be traversed by the unannotated de Bruijn graph.</p>
    </sec>
    <sec>
      <title>4.2 Correcting errors in reads</title>
      <p>To assess the accuracy of our error correction step when aligning reads to the graph, we simulated a haploid 1 Mbp genome (from human GRCh37 chr22: 28 000 000–28 999 999). Single-ended 250 bp reads with 50× coverage were simulated with a 0.49% empirically distributed sequencing error (reads paired with real MiSeq data, FASTQ scores used as per base error rate). We built a dBG (<italic>k</italic> = 31) and removed tips and unitigs with coverage &lt; 7 (automatically chosen). Once reads were aligned to the graph we wrote them to disk instead of generating links. The input reads had 247 075 (0.49%) errors, the output had 30 148 (0.06%) errors. Of the bases changed by the error correction step, 99.19% changes were correct.</p>
    </sec>
    <sec>
      <title>4.3 Sensitivity to word length</title>
      <p>Lowering the value of <italic>k</italic> in a dBG raises <italic>k</italic>-mer coverage and reduces coverage gaps but it also reduces the length of the longest repeats that can be traversed. If we improve the ability to resolve repeats with <italic>links</italic>, we hypothesized that we should reduce the assembly performance’s sensitivity to the parameter <italic>k</italic>. Therefore we simulated an assembly task with different <italic>k</italic> values.</p>
      <p>We simulated three haploid sequencing datasets from 1 Mbp of human (chr22: 28 000 000–28 999 999) using 100 bp single ended reads, each giving 100× coverage. First, we generated ‘perfect coverage’—an error-free read starting at every base. Second, we generated ‘stochastic coverage’—read starts distributed uniformly across the 1 Mbp genome. Third, we generated ‘reads with error’—stochastically sampled reads with a uniform 0.5% rate of single base errors.</p>
      <p>We assembled these three datasets using a dBG and LdBG at <inline-formula id="IE61"><mml:math id="IM61"><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>21</mml:mn><mml:mo>,</mml:mo><mml:mn>31</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mn>91</mml:mn></mml:mrow></mml:math></inline-formula>. To compare assemblies we applied the QUAST tool for quality assessment of genome assemblies (<xref rid="bty157-B21" ref-type="bibr">Gurevich <italic>et al.</italic>, 2013</xref>) and examined the NG50 metric, defined as the contig length <italic>C</italic> such that contigs longer than <italic>C</italic> sum to at least half of the genome size. The NG50 comparisons are shown in <xref ref-type="fig" rid="bty157-F2">Figure 2</xref>. In the <italic>‘perfect’</italic> datasets reconstructed without links, NG50 rises as <italic>k</italic>-mer size increases. This is to be expected as a longer <italic>k</italic>-mer size essentially encodes more connectivity information. Links, however, encode all available connectivity information at any value of <italic>k</italic>. Thus the linked NG50 value (solid green line) is equal to the best unlinked NG50 (dashed green line) over all values of <italic>k</italic>. The <italic>‘stochastic’</italic> datasets (orange) follow a similar pattern, with the exception that the top value of <italic>k</italic> = 91 does not necessarily yield better NG50. As read starts are not available at every single base, some read overlaps are not present and the resulting contig is thus truncated. Finally, the <italic>‘error’</italic> dataset (blue) shows improved NG50 results when link information is used. When faced with sequencing error, our algorithms are not as readily capable of delivering <italic>k</italic>-independent reconstructions, although using links does improve performance at all values of <italic>k</italic>.
</p>
      <fig id="bty157-F2" orientation="portrait" position="float">
        <label>Fig. 2.</label>
        <caption>
          <p>Assembly length metric NG50 on raw de Bruijn graphs (i.e. without links, dashed lines) and linked de Bruijn graphs (i.e. with links, solid lines), as a function of <italic>k</italic>-mer size. Assembling 1 Mbp of sequence (human GRCh37 chr22: 28 000 000–28 999 999) with three simulated 100× read datasets: error free 100 bp reads, one read starting at every base (<italic>‘perfect’</italic>, green); error free stochastic coverage (uniformly distributed read starts) (<italic>‘stochastic’</italic>, orange); an error rate of 0.5% and stochastic coverage (<italic>‘error’</italic>, purple)</p>
        </caption>
        <graphic xlink:href="bty157f2"/>
      </fig>
      <p>To explain this behaviour, we note that at low <italic>k</italic>, sequencing errors introduce false edges between true <italic>k</italic>-mers. Since error correction on dBGs use <italic>k</italic>-mer counts rather than edge counts, these false edges do not get cleaned off. We estimated the number of false edges induced at various <italic>k</italic> to be <inline-formula id="IE62"><mml:math id="IM62"><mml:mrow><mml:mn>604</mml:mn><mml:mo>,</mml:mo><mml:mn>139</mml:mn><mml:mo>,</mml:mo><mml:mn>30</mml:mn><mml:mo>,</mml:mo><mml:mn>7</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula> for <inline-formula id="IE63"><mml:math id="IM63"><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>21</mml:mn><mml:mo>,</mml:mo><mml:mn>31</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mn>91</mml:mn></mml:mrow></mml:math></inline-formula>. Each false edge introduces a new bifurcation that may halt traversal. dBG implementations that use counts on edges instead of <italic>k</italic>-mers [as described in <xref rid="bty157-B14" ref-type="bibr">Conway and Bromage (2011</xref>)] may overcome this issue.</p>
    </sec>
    <sec>
      <title>4.4 Comparison to other assemblers</title>
      <p>McCortex is primarily intended for multi-sample comparison, rather than pure <italic>de novo</italic> assembly of organisms lacking reference sequence, and thus tends to be very conservative in its assembly procedure. However, its modular and flexible design does enable this usage, and thus we evaluated assembly performance between our LdBG implementation and other assemblers with different repeat resolution strategies. Velvet’s ‘Breadcrumb’ module exploits read information to extend and connect contigs through repeats (<xref rid="bty157-B58" ref-type="bibr">Zerbino and Birney, 2008</xref>). The String Graph Assembler (SGA) (<xref rid="bty157-B53" ref-type="bibr">Simpson and Durbin, 2010</xref>) is able to use the full length of the read during assembly and should thus be able to assemble repeats shorter than a read length. SPAdes’s ExSPAnder algorithm analyzes reads pairs that map to either side of an ambiguous junction, computing a confidence score based on the mapped versus expected insert sizes (<xref rid="bty157-B46" ref-type="bibr">Prjibelski <italic>et al.</italic>, 2014</xref>).</p>
      <p>We compared all assemblers using the <italic>E.coli</italic> MG1655 dataset provided on the Illumina website (4.6 Mbp genome, 150 bp paired-end reads, 365 coverage). As evident in <xref ref-type="fig" rid="bty157-F2">Figure 2</xref>, McCortex is sensitive to sequencing error. We applied the bfc error correction tool (<xref rid="bty157-B31" ref-type="bibr">Li, 2015</xref>) to the reads before assembling. Other assemblers have built-in error correction procedures, and bfc was therefore not applied. We did not carry out scaffolding for any tool. Detailed pipeline listings for the de Bruijn graph-based assemblers (McCortex, Velvet and SPAdes) and the string graph-based assembler (SGA) are provided in <xref ref-type="supplementary-material" rid="sup1">Supplementary Material</xref> Sections S3.2–S3.5.</p>
      <p>All assemblers were run at values of <italic>k</italic> between 21 and 141 (except for SPAdes, which does not support <italic>k</italic>-mer sizes beyond 121) and compared using QUAST’s NG50 metric. The results are shown in <xref ref-type="fig" rid="bty157-F3">Figure 3</xref>. McCortex and SPAdes have fairly consistent performance across values of <italic>k</italic>; Velvet and SGA hit their optimums between <italic>k</italic> = 91 and sharp drop-offs before this value. With single-end reads alone, McCortex’s performance is comparable to SGA, which is only capable of leveraging connectivity information inherent in single-end reads. We further improve performance through an iterative assembly procedure, e.g. by trimming 50 bp off both ends of contigs (as assembly errors will tend to appear at contig boundaries) and reassembling the results with the same procedure used for single-end reads. This iterative procedure enables McCortex to produce assemblies on par with SPAdes’s performance.
</p>
      <fig id="bty157-F3" orientation="portrait" position="float">
        <label>Fig. 3.</label>
        <caption>
          <p>Assembly NG50 results on an Illumina paired-end <inline-formula id="IE64"><mml:math id="IM64"><mml:mrow><mml:mi>E</mml:mi><mml:mo>.</mml:mo><mml:mo> </mml:mo><mml:mi>c</mml:mi><mml:mi>o</mml:mi><mml:mi>l</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:math></inline-formula> dataset (150 bp paired-end reads, 365× coverage) for McCortex, SPAdes, SGA, Velvet at various values of <italic>k</italic> (or <italic>τ</italic> for SGA). All assemblies are performed using single-end information only; paired-end data (threading or scaffolding) is not applied for any approach. For SPAdes, no results are available past <italic>k</italic> = 121, the software’s maximum allowable setting. McCortex results are computed using single-end read threading, and an iterative scheme wherein the results from the single-ended assembly are further refined (‘iterative’)</p>
        </caption>
        <graphic xlink:href="bty157f3"/>
      </fig>
    </sec>
  </sec>
  <sec>
    <title>5 Results: applications</title>
    <p>To assess LdBG on real data, we examined short read data from <italic>K.pneumoniae</italic>, a gram-negative bacteria that usually lives harmlessly in the mouth and gut of humans. However in the event of a weakened immune system, it can establish pathogenic colonies in the lung leading to inflammation and bleeding. It is also found in some cases of urinary tract infections. Antibiotic resistant strains of <italic>K.pneumoniae</italic> have been found in patients. We used McCortex for two tasks where long-range information is likely to be beneficial—finding large differences from a reference and analysis of genomic context for drug resistance genes, which we validated using a PacBio reference assembled for the sample (<xref rid="bty157-B52" ref-type="bibr">Sheppard <italic>et al.</italic>, 2016</xref>).</p>
    <sec>
      <title>5.1 Large-variant discovery</title>
      <p>As links should provide useful guidance to navigating junctions in a graph, we examined their utility in calling large variants (insertions or deletions greater than 100 bp in length). We implemented a ‘bubble caller’ (named for the characteristic motif produced by a biallelic mutation in a graph wherein paths diverge from one <italic>k</italic>-mer and rejoin at another) and tested it by calling variants in CAV1016, a <italic>K.pneumoniae</italic> isolate for which a high-quality PacBio sequence was available for validation. We constructed dBGs of the canonical reference sequence (GCF_000016305.1_ASM1630v1) and Illumina data for CAV1016. From these, we built LdBGs using the single-end Illumina reads for link construction. We applied our bubble caller to the dBG and LdBGs, allowing for a minimum event size of 100 bp and maximum of 200 kbp, and removing duplicate events. We validated called alleles by aligning the reference and alternate alleles to the canonical reference sequence and CAV1016 PacBio sequence, respectively. The resulting callsets without and with link information are presented in <xref ref-type="supplementary-material" rid="sup1">Supplementary Table S1</xref>.</p>
      <p>Using the dnadiff tool from the MUMmer package, we determined the canonical reference sequence and CAV1016 PacBio sequence had 35 141 SNPs and 779 indels (note however that as the dominant error mode of the PacBio instrument is indels, it is possible that many of the indels are false-positives). In the Illumina data, our bubble caller identified 27 706 SNPs and 550 indels, overlapping with the PacBio calls by 27 044 and 84 respectively. Examining the large events, 55 large indels were present in the dBG callset and 59 indels were in the LdBG callset. All 55 variants from the dBG callset were recovered in the LdBG callset. The four remaining variants exclusive to the LdBG callset are insertions of varying size (134; 246; 7952; and 11 946 bp).</p>
      <p>That the LdBG-exclusive events should all be insertions (particularly large ones) is perhaps not surprising; in a graphical framework, calling insertions against a high-quality reference sequence with comparatively lower quality Illumina data is expected to be more difficult than calling deletions. With insertions, sequencing error in the study sample will produce spurious paths in the graph, not all of which can be removed successfully, and thus graph traversal from the 5′ to the 3′ end of the alternate allele has many opportunities to fail. With deletions, the graph navigation burden is on the reference allele which should have substantially fewer errors (and thus fewer spurious paths) to confound traversal. Link-informed traversal helps alleviate this insertion/deletion detection bias, enabling the recovery of large events like the 8 and 12 kb events listed above. This improves our access to large variants underrepresented in current variant call sets (<xref rid="bty157-B34" ref-type="bibr">Li, 2014b</xref>; <xref rid="bty157-B56" ref-type="bibr">Weisenfeld <italic>et al.</italic>, 2014</xref>).</p>
    </sec>
    <sec>
      <title>5.2 Reference-link guided assembly</title>
      <p>Finally, we show that with links, we can use a panel of reference contigs derived from multiple sources to improve drug resistance locus characterization in <italic>K.pneumoniae</italic> isolates. As the underlying graphs are considered immutable after construction, links derived from this panel cannot add <italic>k</italic>-mers to a sample. We hypothesized that the links panel could still provide valuable connectivity information where they were consistent with the graph without misleading the assembler in regions where they were divergent. We selected 21 <italic>K.pneumoniae</italic> isolates with known drug resistance status and that carry combinations of two alleles and two plasmid backgrounds at the <italic>K.pneumoniae</italic> carbapenemase (KPC) resistance locus, see <xref rid="bty157-T1" ref-type="table">Table 1</xref>. As references, we constructed links from a panel of four plasmid backgrounds carrying three different KPC alleles: PacBio sequences from two of the 21 isolates (carrying allele KPC-2), a KPC-harbouring plasmid from <italic>E.coli</italic> (carrying allele KPC-3) and a fourth <italic>K.pneumoniae</italic> plasmid known to harbour a resistance allele and background absent from the 21 isolates (carrying allele KPC-5). All accessions are described in <xref ref-type="supplementary-material" rid="sup1">Supplementary Table S2</xref>. Three assemblies were generated per isolate: one without links, one with links and one with the Columbus module in Velvet, using the links panel as input for reference-guided reconstruction.
<table-wrap id="bty157-T1" orientation="portrait" position="float"><label>Table 1.</label><caption><p>Comparison of KPC-containing contigs to validation data, inferred without/with links and with Velvet’s Columbus module</p></caption><table frame="hsides" rules="groups"><thead><tr><th rowspan="1" colspan="1"/><th rowspan="1" colspan="1"/><th colspan="3" rowspan="1">LdBG without link information<hr/></th><th colspan="3" rowspan="1">LdBG with link information<hr/></th><th colspan="3" rowspan="1">Velvet with Columbus<hr/></th></tr><tr><th rowspan="1" colspan="1">Isolate</th><th rowspan="1" colspan="1">Known plasmid and KPC allele</th><th rowspan="1" colspan="1">Length (bp)</th><th rowspan="1" colspan="1">Matches uniquely and correctly</th><th rowspan="1" colspan="1">Mismatches, gaps</th><th rowspan="1" colspan="1">Length (bp)</th><th rowspan="1" colspan="1">Matches uniquely and correctly</th><th rowspan="1" colspan="1">Mismatches, gaps</th><th rowspan="1" colspan="1">Length (bp)</th><th rowspan="1" colspan="1">Matches uniquely and correctly</th><th rowspan="1" colspan="1">Mismatches, gaps</th></tr></thead><tbody><tr><td rowspan="1" colspan="1">CAV1016</td><td rowspan="1" colspan="1">1, KPC-2</td><td rowspan="1" colspan="1">3893</td><td rowspan="1" colspan="1">Non-unique</td><td rowspan="1" colspan="1">0, 0</td><td rowspan="1" colspan="1">43 630</td><td rowspan="1" colspan="1">Yes</td><td rowspan="1" colspan="1">0, 0</td><td rowspan="1" colspan="1">34 240</td><td rowspan="1" colspan="1">Yes</td><td rowspan="1" colspan="1">7, 1</td></tr><tr><td rowspan="1" colspan="1">CAV1017</td><td rowspan="1" colspan="1">1, KPC-2</td><td rowspan="1" colspan="1">3895</td><td rowspan="1" colspan="1">Non-unique</td><td rowspan="1" colspan="1">0, 0</td><td rowspan="1" colspan="1">43 628</td><td rowspan="1" colspan="1">Yes</td><td rowspan="1" colspan="1">0, 0</td><td rowspan="1" colspan="1">10 001</td><td rowspan="1" colspan="1">Non-unique</td><td rowspan="1" colspan="1">0, 0</td></tr><tr><td rowspan="1" colspan="1">CAV1042</td><td rowspan="1" colspan="1">1, KPC-2</td><td rowspan="1" colspan="1">2557</td><td rowspan="1" colspan="1">Non-unique</td><td rowspan="1" colspan="1">0, 0</td><td rowspan="1" colspan="1">43 669</td><td rowspan="1" colspan="1">Yes</td><td rowspan="1" colspan="1">0, 0</td><td rowspan="1" colspan="1">9978</td><td rowspan="1" colspan="1">Non-unique</td><td rowspan="1" colspan="1">0, 0</td></tr><tr><td rowspan="1" colspan="1">CAV1077</td><td rowspan="1" colspan="1">1, KPC-2</td><td rowspan="1" colspan="1">3708</td><td rowspan="1" colspan="1">Non-unique</td><td rowspan="1" colspan="1">0, 1</td><td rowspan="1" colspan="1">15 796</td><td rowspan="1" colspan="1">Yes</td><td rowspan="1" colspan="1">0, 1</td><td rowspan="1" colspan="1">9879</td><td rowspan="1" colspan="1">Non-unique</td><td rowspan="1" colspan="1">0, 0</td></tr><tr><td rowspan="1" colspan="1">CAV1142</td><td rowspan="1" colspan="1">1, KPC-2</td><td rowspan="1" colspan="1">3892</td><td rowspan="1" colspan="1">Non-unique</td><td rowspan="1" colspan="1">0, 0</td><td rowspan="1" colspan="1">43 612</td><td rowspan="1" colspan="1">Yes</td><td rowspan="1" colspan="1">2, 0</td><td rowspan="1" colspan="1">9900</td><td rowspan="1" colspan="1">Non-unique</td><td rowspan="1" colspan="1">0, 0</td></tr><tr><td rowspan="1" colspan="1">CAV1145</td><td rowspan="1" colspan="1">1, KPC-2</td><td rowspan="1" colspan="1">5158</td><td rowspan="1" colspan="1">Yes</td><td rowspan="1" colspan="1">0, 0</td><td rowspan="1" colspan="1">43 643</td><td rowspan="1" colspan="1">Yes</td><td rowspan="1" colspan="1">1, 0</td><td rowspan="1" colspan="1">39 604</td><td rowspan="1" colspan="1">Yes</td><td rowspan="1" colspan="1">4, 2</td></tr><tr><td rowspan="1" colspan="1">CAV1182</td><td rowspan="1" colspan="1">1, KPC-2</td><td rowspan="1" colspan="1">2558</td><td rowspan="1" colspan="1">Non-unique</td><td rowspan="1" colspan="1">0, 0</td><td rowspan="1" colspan="1">9722</td><td rowspan="1" colspan="1">Yes</td><td rowspan="1" colspan="1">1, 0</td><td rowspan="1" colspan="1">9892</td><td rowspan="1" colspan="1">Non-unique</td><td rowspan="1" colspan="1">0, 0</td></tr><tr><td rowspan="1" colspan="1">CAV1203</td><td rowspan="1" colspan="1">1, KPC-2</td><td rowspan="1" colspan="1">3911</td><td rowspan="1" colspan="1">Non-unique</td><td rowspan="1" colspan="1">0, 0</td><td rowspan="1" colspan="1">43 670</td><td rowspan="1" colspan="1">Yes</td><td rowspan="1" colspan="1">0, 0</td><td rowspan="1" colspan="1">9993</td><td rowspan="1" colspan="1">Non-unique</td><td rowspan="1" colspan="1">0, 0</td></tr><tr><td rowspan="1" colspan="1">CAV1205</td><td rowspan="1" colspan="1">2, KPC-2</td><td rowspan="1" colspan="1">5978</td><td rowspan="1" colspan="1">Yes</td><td rowspan="1" colspan="1">0, 0</td><td rowspan="1" colspan="1">14 019</td><td rowspan="1" colspan="1">Yes</td><td rowspan="1" colspan="1">2, 1</td><td rowspan="1" colspan="1">52 582</td><td rowspan="1" colspan="1">Yes</td><td rowspan="1" colspan="1">24, 1</td></tr><tr><td rowspan="1" colspan="1">CAV1207</td><td rowspan="1" colspan="1">2, KPC-2</td><td rowspan="1" colspan="1">13 249</td><td rowspan="1" colspan="1">Yes</td><td rowspan="1" colspan="1">0, 0</td><td rowspan="1" colspan="1">13 991</td><td rowspan="1" colspan="1">Yes</td><td rowspan="1" colspan="1">3, 1</td><td rowspan="1" colspan="1">11 519</td><td rowspan="1" colspan="1">Yes</td><td rowspan="1" colspan="1">3, 0</td></tr><tr><td rowspan="1" colspan="1">CAV1237</td><td rowspan="1" colspan="1">1, KPC-2</td><td rowspan="1" colspan="1">20 444</td><td rowspan="1" colspan="1">Yes</td><td rowspan="1" colspan="1">1, 0</td><td rowspan="1" colspan="1">43 613</td><td rowspan="1" colspan="1">Yes</td><td rowspan="1" colspan="1">2, 1</td><td rowspan="1" colspan="1">34 177</td><td rowspan="1" colspan="1">Yes</td><td rowspan="1" colspan="1">7, 1</td></tr><tr><td rowspan="1" colspan="1">CAV1290</td><td rowspan="1" colspan="1">1, KPC-2</td><td rowspan="1" colspan="1">5099</td><td rowspan="1" colspan="1">Yes</td><td rowspan="1" colspan="1">0, 0</td><td rowspan="1" colspan="1">29 340</td><td rowspan="1" colspan="1">Yes</td><td rowspan="1" colspan="1">4, 1</td><td rowspan="1" colspan="1">9953</td><td rowspan="1" colspan="1">Yes</td><td rowspan="1" colspan="1">0, 0</td></tr><tr><td rowspan="1" colspan="1">CAV1292</td><td rowspan="1" colspan="1">1, KPC-2</td><td rowspan="1" colspan="1">5094</td><td rowspan="1" colspan="1">Yes</td><td rowspan="1" colspan="1">0, 0</td><td rowspan="1" colspan="1">29 337</td><td rowspan="1" colspan="1">Yes</td><td rowspan="1" colspan="1">1, 1</td><td rowspan="1" colspan="1">29 395</td><td rowspan="1" colspan="1">Yes</td><td rowspan="1" colspan="1">9, 3</td></tr><tr><td rowspan="1" colspan="1">CAV1338</td><td rowspan="1" colspan="1">2, KPC-2</td><td rowspan="1" colspan="1">5963</td><td rowspan="1" colspan="1">Yes</td><td rowspan="1" colspan="1">0, 0</td><td rowspan="1" colspan="1">14 003</td><td rowspan="1" colspan="1">Yes</td><td rowspan="1" colspan="1">2, 1</td><td rowspan="1" colspan="1">14 515</td><td rowspan="1" colspan="1">Yes</td><td rowspan="1" colspan="1">4, 0</td></tr><tr><td rowspan="1" colspan="1">CAV1344</td><td rowspan="1" colspan="1">1, KPC-2</td><td rowspan="1" colspan="1">4839</td><td rowspan="1" colspan="1">Yes</td><td rowspan="1" colspan="1">0, 0</td><td rowspan="1" colspan="1">9694</td><td rowspan="1" colspan="1">Yes</td><td rowspan="1" colspan="1">1, 0</td><td rowspan="1" colspan="1">9991</td><td rowspan="1" colspan="1">Non-unique</td><td rowspan="1" colspan="1">0, 0</td></tr><tr><td rowspan="1" colspan="1">CAV1351</td><td rowspan="1" colspan="1">1, KPC-3</td><td rowspan="1" colspan="1">3898</td><td rowspan="1" colspan="1">Incorrect</td><td rowspan="1" colspan="1">0, 0</td><td rowspan="1" colspan="1">43 616</td><td rowspan="1" colspan="1">Yes</td><td rowspan="1" colspan="1">1, 1</td><td rowspan="1" colspan="1">9953</td><td rowspan="1" colspan="1">Non-unique</td><td rowspan="1" colspan="1">0, 0</td></tr><tr><td rowspan="1" colspan="1">CAV1360</td><td rowspan="1" colspan="1">1, KPC-2</td><td rowspan="1" colspan="1">734</td><td rowspan="1" colspan="1">Non-unique</td><td rowspan="1" colspan="1">0, 0</td><td rowspan="1" colspan="1">43 621</td><td rowspan="1" colspan="1">Yes</td><td rowspan="1" colspan="1">1, 0</td><td rowspan="1" colspan="1">9922</td><td rowspan="1" colspan="1">Non-unique</td><td rowspan="1" colspan="1">0, 0</td></tr><tr><td rowspan="1" colspan="1">CAV1391</td><td rowspan="1" colspan="1">1, KPC-2</td><td rowspan="1" colspan="1">5106</td><td rowspan="1" colspan="1">Yes</td><td rowspan="1" colspan="1">0, 0</td><td rowspan="1" colspan="1">9726</td><td rowspan="1" colspan="1">Yes</td><td rowspan="1" colspan="1">1, 0</td><td rowspan="1" colspan="1">9918</td><td rowspan="1" colspan="1">Non-unique</td><td rowspan="1" colspan="1">0, 0</td></tr><tr><td rowspan="1" colspan="1">CAV1576</td><td rowspan="1" colspan="1">2, KPC-2</td><td rowspan="1" colspan="1">9161</td><td rowspan="1" colspan="1">Yes</td><td rowspan="1" colspan="1">0, 0</td><td rowspan="1" colspan="1">14 003</td><td rowspan="1" colspan="1">Yes</td><td rowspan="1" colspan="1">2, 1</td><td rowspan="1" colspan="1">10 105</td><td rowspan="1" colspan="1">Incorrect</td><td rowspan="1" colspan="1">0, 0</td></tr><tr><td rowspan="1" colspan="1">CAV1578</td><td rowspan="1" colspan="1">2, KPC-2</td><td rowspan="1" colspan="1">5243</td><td rowspan="1" colspan="1">Yes</td><td rowspan="1" colspan="1">0, 0</td><td rowspan="1" colspan="1">8956</td><td rowspan="1" colspan="1">Yes</td><td rowspan="1" colspan="1">0, 0</td><td rowspan="1" colspan="1">10 133</td><td rowspan="1" colspan="1">Incorrect</td><td rowspan="1" colspan="1">0, 0</td></tr><tr><td rowspan="1" colspan="1">CAV1597</td><td rowspan="1" colspan="1">2, KPC-2</td><td rowspan="1" colspan="1">12 627</td><td rowspan="1" colspan="1">Yes</td><td rowspan="1" colspan="1">0, 0</td><td rowspan="1" colspan="1">14 009</td><td rowspan="1" colspan="1">Yes</td><td rowspan="1" colspan="1">2, 1</td><td rowspan="1" colspan="1">14 037</td><td rowspan="1" colspan="1">Yes</td><td rowspan="1" colspan="1">19, 4</td></tr></tbody></table></table-wrap></p>
      <p>Contigs harbouring the KPC sequence within the 21 isolates were identified by aligning to the KPC-2 allele sequence with LASTZ (<xref rid="bty157-B22" ref-type="bibr">Harris, 2007</xref>) and extracting the longest such contig from each assembly. These were aligned back to both the reference data sources and the validation data (<xref rid="bty157-B38" ref-type="bibr">Mathers <italic>et al.</italic>, 2015</xref>). For alignments that ran off the end of a sequence owing to the circular nature of the plasmids, we attempted to shift the contig sequence such that a linear alignment of maximum length was achieved; where this was not possible we have reported the length of the aligned region. The contig selected from each assembly was evaluated for correct KPC allele recovery, correct identification of plasmid background (i.e. sequence context of KPC allele), and mismatches/gaps to the relevant reference sequence. These results are shown in <xref rid="bty157-T1" ref-type="table">Table 1</xref>.</p>
      <p>Without link information, we find that in 57% of cases the plasmid background on which the KPC allele resides cannot be identified. In such cases, LASTZ reports alignments of the short contigs with 100% sequence identity to plasmids 1 and 2. Moreover, for the CAV1360 isolate, the aligner determines the background incorrectly as the <italic>E.coli</italic> plasmid due to the presence of KPC-3.</p>
      <p>Reconstruction with the link panel provides an order of magnitude increase in contig length over the link-uninformed reconstructions and the inferred plasmid membership matches the <xref rid="bty157-B38" ref-type="bibr">Mathers <italic>et al.</italic> (2015)</xref> determination in all 21 cases. In contrast, the Velvet reconstructions are longer than the link-uninformed contigs, but only resolve the plasmid background correctly in two additional cases. It fails to determine a unique membership in two cases, and establishes an incorrect background in two other cases. The much higher mismatch and gap rate of the Velvet contigs suggest that these assemblies are more errorful. This is perhaps expected, as the Columbus module is designed for guided assembly with a single reference, rather than a panel of references. With considerable homology between the supplied sequences, the initial step of mapping reads to the reference panel is likely to produce erroneous alignments, confounding Velvet’s ability to leverage the panel properly. We attempted to overcome this limitation by using Ragout to refine the Velvet and link-uninformed assemblies with multiple references. This effort failed as Ragout would not accept panel members having limited synteny with the assembled contigs.</p>
      <p>Reconstructions from two isolates stand out. CAV1351 was known to carry the KPC-3 allele, while all other isolates carried the KPC-2 allele. The link-uninformed assembly produces a contig that maps to the <italic>E.coli</italic> KPC-3 sequence perfectly, but infers the wrong plasmid membership. The link-informed reconstruction, however, produces both the correct plasmid membership and correct allele. In another case, <xref rid="bty157-B38" ref-type="bibr">Mathers <italic>et al.</italic> (2015)</xref> reported CAV1077 to possess plasmid 1, but with an unspecified sequence alteration. Our reconstruction is able to establish both the correct plasmid membership and identify a 188 bp deletion in the intergenic region upstream from the transposase and downstream from the KPC genes (detected with and without links, but not with Velvet). Combined, these analyses demonstrate how using external data sources as a means to guide assembly through ‘reference links’ can lead to highly accurate reconstruction of even complex regions of the genome.</p>
    </sec>
    <sec>
      <title>5.3 Scalability</title>
      <p>Finally, to assess the scalability of LdBG to larger genomes, we constructed LdBGs (<italic>k</italic> = 47) from paired-end data for genomes ranging from <inline-formula id="IE65"><mml:math id="IM65"><mml:mrow><mml:mo>∼</mml:mo><mml:mn>5</mml:mn></mml:mrow></mml:math></inline-formula> Mbp (<italic>E.coli</italic>) to 3200 Mbp (<italic>H.sapiens</italic>). The full results are presented in <xref ref-type="supplementary-material" rid="sup1">Supplementary Table S3</xref>, using SGA’s performance on the same datasets as a point of comparison (with the exception of the human dataset, due to high computational burden). In all cases, McCortex memory usage substantially exceeds that of SGA, while concomitant runtime is lower. The design choices between the two tools are clearly evident in the runtime results, with SGA explicitly optimized to reduce memory usage at the expense of CPU time, and McCortex opting to keep graphs and link information in memory to reduce CPU time. On the largest dataset tested, paired-end data from human sample NA12878, construction had a peak memory usage of 400 GiB (required to store the entire graph, including sequencing errors). After error cleaning, loading the dataset requires 70 GiB of RAM (50 GiB for the dBG, 20 GiB for links). Link construction is easily parallelized (the alignment of reads to the graph has no dependency on other reads). Using 32 threads for single- and paired-end link construction, a human genome covered to 25× is completed in under 72 h.</p>
    </sec>
  </sec>
  <sec>
    <title>6 Discussion</title>
    <p>We have presented a de novo assembly method that addresses the most important limitation of de Bruijn graphs: the ability to leverage long-range connectivity information inherent in read data. While cutting reads into small <italic>k</italic>-mers has long been a useful way of simultaneously computing read-to-read overlaps and overcoming high rates of sequencing error, increasing sequencing quality and read lengths have rendered de Bruijn assembly methods less attractive. String graphs have been successful in incorporating long-range data into assemblies, but sacrifice desirable computational properties of de Bruijn graphs. Our solution, Linked de Bruijn Graphs, combine the connectivity properties of string graphs with the rapid lookup of specific (multi-coloured) <italic>k</italic>-mers. Due to the wide range of uses of dBGs in sequence analysis, we believe this offers a potential improvement to many existing algorithms. Path encoding of reads has been suggested for read compression before (<xref rid="bty157-B14" ref-type="bibr">Conway and Bromage, 2011</xref>; <xref rid="bty157-B30" ref-type="bibr">Kingsford and Patro, 2015</xref>). However we believe this is the first implementation to use it for multi-colour assembly that can scale up to large mammalian genomes on modern computer hardware.</p>
    <p>We have shown that read error correction and graph annotation can improve assembly performance of de Bruijn graphs and that this can be seen with the recovery of large (12 kbp) events in short read sequences. Moreover, through application to real data we have shown that links can be generated from a wide range of sequencing technologies including data not used to construct the underlying dBG, and that this can be exploited to identify sequences of biological interest. LdBGs can also naturally represent paired-end connectivity (where we treat filling in sequence between paired-end reads as the equivalent problem to closing gaps in alignment) and chimeric reads (e.g. chimeric reads spanning a translocation breakpoint would yield <italic>k</italic>-mers not necessarily present in a reference sequence, and alignment of these reads back to the graph would provide connectivity across the breakpoint) information. We have proven that in the error-free setting, Linked de Bruijn Graphs losslessly store the genome sequence, even when constructed from short reads and agnostic of <italic>k</italic>.</p>
    <p>Our method is useful for reconstructing complex loci across multiple samples using a common panel of pre-determined haplotypes. Link information derived from a haplotype panel cannot add <italic>k</italic>-mers or edges to the graph that were not observed in the original dataset. Nevertheless, assembly is enhanced in regions where the links are consistent with the graph, and naturally defaults to link-uninformed navigation in regions of discrepancy. Threading a panel of haplotypes from multiple samples through each graph thus identifies only the relevant sections of each donor haplotype.</p>
    <p>One shortcoming of long links is the accumulated probability of encountering an error during traversal. If a link takes the wrong branch of an error-induced bubble, cleaning that junction choice trims off all the remaining information about the junction choices made beyond the bubble. This shortcoming results in link coverage dropping off quicker than expected as links get longer, resulting in truncated links. This could be addressed by error-correcting groups of links that start at the same <italic>k</italic>-mer.</p>
    <p>We have implemented a very simple read mapping, which trusts all <italic>k</italic>-mers from a read if there is a perfect match in the graph, and which only attempts to fill gaps using linear time graph traversal. Optimal mapping is ultimately NP-hard, but more advanced heuristic methods are available which may perform better than our approach (<xref rid="bty157-B36" ref-type="bibr">Limasset <italic>et al.</italic>, 2016</xref>). Improvement may be most noticeable for high error rate sequencing data and in low complexity regions of the graph.</p>
    <p>More sophisticated graphical alignment approaches may also enable the use of uncorrected (i.e. low accuracy) reads from third generation sequencing for alignment, graph construction, or both. High error rate reads pose a problem in our current framework as the alignment is predicated on exact matches between a number of read and graph <italic>k</italic>-mers, under the assumption that the <italic>k</italic>-mers in the graph are correct. Even if the graph is built with a small <italic>k</italic>-mer size (e.g. 31 bp), uncorrected long reads may not contain enough perfect <italic>k</italic>-mers for alignment. Reducing the <italic>k</italic>-mer size of the graph may not solve this problem, as the number of false edges arising from homology would be expected to increase substantially, impeding our ability to traverse the graph to fill in error-induced gaps. Finally, construction of both the graph and links from uncorrected long reads is likely not possible using our method. Our error cleaning steps are not suited to this data type, and a naïve application of our software might simply ratify the errors inherent in the read data. We leave the pursuit of a LdBG implementation appropriate to uncorrected long read datasets to future work.</p>
    <p>There is scope for reducing memory consumption, given very few <italic>k</italic>-mers actually have links attached (see <xref ref-type="supplementary-material" rid="sup1">Supplementary Fig. S6</xref>) and could be further reduced with better encoding in memory of the junction choice tree held by a <italic>k</italic>-mer (i.e. <italic>L</italic>(<italic>v</italic>)). For example, using a binary encoding of the tree of junction choices, or generative path encoding proposed to compress sequence data (<xref rid="bty157-B30" ref-type="bibr">Kingsford and Patro, 2015</xref>).</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material content-type="local-data" id="sup1">
      <label>Supplementary Data</label>
      <media xlink:href="bty157_supp_proof_kvg.pdf">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
  </sec>
</body>
<back>
  <ack>
    <title>Acknowledgements</title>
    <p>We thank Jerome Kelleher for his many useful comments and edits, Rachel Norris for her pointers and insight into the <italic>K.pneumoniae</italic> dataset, and the other members of the McVean lab for useful discussions during the preparation of this manuscript. We are grateful to our Bioinformatics reviewers (Rayan Chikhi and Erik Garrison) and BioRxiv preprint reviewers (Camille Scott, Titus Brown and Pall Melsted).</p>
    <sec>
      <title>Funding</title>
      <p>This work was supported by the Wellcome Trust (grant numbers 090532/Z/09/Z and 100956/Z/13/Z). K.V.G. was supported by Wellcome Trust Research Studentship award (097310/Z/11/Z). I.T. was supported by a PhD studentship from the BBSRC. Z.I. was funded by a Wellcome Trust/Royal Society Sir Henry Dale Fellowship (grant 102541/Z/13/Z).</p>
      <p><italic>Conflict of Interest</italic>: none declared.</p>
    </sec>
  </ack>
  <ref-list>
    <title>References</title>
    <ref id="bty157-B1">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Aguilera</surname><given-names>A.</given-names></name>, <name name-style="western"><surname>Gómez-González</surname><given-names>B.</given-names></name></person-group> (<year>2008</year>) 
<article-title>Genome instability: a mechanistic view of its causes and consequences</article-title>. <source>Nat. Rev. Genet</source>., <volume>9</volume>, <fpage>204</fpage>–<lpage>217</lpage>.<pub-id pub-id-type="pmid">18227811</pub-id></mixed-citation>
    </ref>
    <ref id="bty157-B2">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Artzy-Randrup</surname><given-names>Y.</given-names></name></person-group><etal>et al</etal> (<year>2012</year>) 
<article-title>Population structuring of multi-copy, antigen-encoding genes in <italic>Plasmodium falciparum</italic></article-title>. <source>eLife</source>, <volume>1</volume>, <fpage>e00093</fpage>.<pub-id pub-id-type="pmid">23251784</pub-id></mixed-citation>
    </ref>
    <ref id="bty157-B3">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Bankevich</surname><given-names>A.</given-names></name></person-group><etal>et al</etal> (<year>2012</year>) 
<article-title>SPAdes: a new genome assembly algorithm and its applications to single-cell sequencing</article-title>. <source>J. Comput. Biol. J. Comput. Mol. Cell Biol</source>., <volume>19</volume>, <fpage>455</fpage>–<lpage>477</lpage>.</mixed-citation>
    </ref>
    <ref id="bty157-B4">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><name name-style="western"><surname>Bateman</surname><given-names>A.</given-names></name></person-group><etal>et al</etal> (<year>2016</year>) Limitations of current approaches for reference-free, graph-based variant detection. In: <italic>Proceedings of the 7th ACM International Conference on Bioinformatics, Computational Biology, and Health Informatics</italic>, New York, NY, USA. ACM, pp. <fpage>499</fpage>–<lpage>500</lpage>.</mixed-citation>
    </ref>
    <ref id="bty157-B5">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Benoit</surname><given-names>G.</given-names></name></person-group><etal>et al</etal> (<year>2015</year>) 
<article-title>Reference-free compression of high throughput sequencing data with a probabilistic de Bruijn graph</article-title>. <source>BMC Bioinformatics</source>, <volume>16</volume>, <fpage>288.</fpage><pub-id pub-id-type="pmid">26370285</pub-id></mixed-citation>
    </ref>
    <ref id="bty157-B6">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><name name-style="western"><surname>Bolger</surname><given-names>A.M.</given-names></name></person-group><etal>et al</etal> (<year>2017</year>). LOGAN: a framework for LOssless Graph-based ANalysis of high throughput sequence data. <italic>bioRxiv</italic>, p. 175976.</mixed-citation>
    </ref>
    <ref id="bty157-B7">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Bonizzoni</surname><given-names>P.</given-names></name></person-group><etal>et al</etal> (<year>2016</year>) 
<article-title>An external-memory algorithm for string graph construction</article-title>. <source>Algorithmica</source>, <volume>78</volume>, <fpage>394</fpage>–<lpage>424</lpage>.</mixed-citation>
    </ref>
    <ref id="bty157-B8">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name name-style="western"><surname>Bowe</surname><given-names>A.</given-names></name></person-group><etal>et al</etal> (<year>2012</year>) <chapter-title>Succinct de Bruijn Graphs</chapter-title> In: <person-group person-group-type="editor"><name name-style="western"><surname>Raphael</surname><given-names>B.</given-names></name>, <name name-style="western"><surname>Tang</surname><given-names>J.</given-names></name></person-group> (eds.) <source>Algorithms in Bioinformatics</source>. 
<publisher-name>Springer</publisher-name>, 
<publisher-loc>Berlin</publisher-loc>, pp. <fpage>225</fpage>–<lpage>235</lpage>.</mixed-citation>
    </ref>
    <ref id="bty157-B9">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Bradley</surname><given-names>P.</given-names></name></person-group><etal>et al</etal> (<year>2015</year>) 
<article-title>Rapid antibiotic-resistance predictions from genome sequence data for <italic>Staphylococcus aureus</italic> and <italic>Mycobacterium tuberculosis</italic></article-title>. <source>Nat. Commun.</source>, <volume>6</volume>, <fpage>10063</fpage>–<lpage>10063</lpage>.<pub-id pub-id-type="pmid">26686880</pub-id></mixed-citation>
    </ref>
    <ref id="bty157-B10">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Bradnam</surname><given-names>K.R.</given-names></name></person-group><etal>et al</etal> (<year>2013</year>) 
<article-title>Assemblathon 2: evaluating de novo methods of genome assembly in three vertebrate species</article-title>. <source>GigaScience</source>, <volume>2</volume>, <fpage>10</fpage>–<lpage>10</lpage>.<pub-id pub-id-type="pmid">23870653</pub-id></mixed-citation>
    </ref>
    <ref id="bty157-B11">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name name-style="western"><surname>Chikhi</surname><given-names>R.</given-names></name>, <name name-style="western"><surname>Lavenier</surname><given-names>D.</given-names></name></person-group> (<year>2011</year>). <chapter-title>Localized genome assembly from reads to scaffolds: practical traversal of the paired string graph</chapter-title> In: <person-group person-group-type="editor"><name name-style="western"><surname>Przytycka</surname><given-names>T.</given-names></name>, <name name-style="western"><surname>Sagot</surname><given-names>M.-F.</given-names></name></person-group> (eds.) <source>Algorithms in Bioinformatics</source>. 
<publisher-name>Springer</publisher-name>, 
<publisher-loc>Berlin</publisher-loc>, pp. <fpage>39</fpage>–<lpage>48</lpage>.</mixed-citation>
    </ref>
    <ref id="bty157-B12">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Chikhi</surname><given-names>R.</given-names></name>, <name name-style="western"><surname>Rizk</surname><given-names>G.</given-names></name></person-group> (<year>2013</year>) 
<article-title>Space-efficient and exact de Bruijn graph representation based on a Bloom filter</article-title>. <source>Algorithms Mol. Biol.</source>, <volume>8</volume>, <fpage>22</fpage>.<pub-id pub-id-type="pmid">24040893</pub-id></mixed-citation>
    </ref>
    <ref id="bty157-B13">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Chikhi</surname><given-names>R.</given-names></name></person-group><etal>et al</etal> (<year>2015</year>) 
<article-title>On the representation of de Bruijn graphs</article-title>. <source>J. Comput. Biol</source>., <volume>22</volume>, <fpage>336</fpage>–<lpage>352</lpage>.<pub-id pub-id-type="pmid">25629448</pub-id></mixed-citation>
    </ref>
    <ref id="bty157-B14">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Conway</surname><given-names>T.C.</given-names></name>, <name name-style="western"><surname>Bromage</surname><given-names>A.J.</given-names></name></person-group> (<year>2011</year>) 
<article-title>Succinct data structures for assembling large genomes</article-title>. <source>Bioinformatics</source>, <volume>27</volume>, <fpage>479</fpage>–<lpage>486</lpage>.<pub-id pub-id-type="pmid">21245053</pub-id></mixed-citation>
    </ref>
    <ref id="bty157-B15">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>de Bruijn</surname><given-names>N.G.</given-names></name></person-group> (<year>1946</year>) 
<article-title>A Combinatorial Problem</article-title>. <source>Koninklijke Nederlandsche Akademie Van Wetenschappen</source>, <volume>49</volume>, <fpage>758</fpage>–<lpage>764</lpage>.</mixed-citation>
    </ref>
    <ref id="bty157-B16">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Difilippantonio</surname><given-names>M.J.</given-names></name></person-group><etal>et al</etal> (<year>2002</year>) 
<article-title>Evidence for replicative repair of DNA double-strand breaks leading to oncogenic translocation and gene amplification</article-title>. <source>J. Exp. Med</source>., <volume>196</volume>, <fpage>469</fpage>–<lpage>480</lpage>.<pub-id pub-id-type="pmid">12186839</pub-id></mixed-citation>
    </ref>
    <ref id="bty157-B17">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Dilthey</surname><given-names>A.</given-names></name></person-group><etal>et al</etal> (<year>2015</year>) 
<article-title>Improved genome inference in the MHC using a population reference graph</article-title>. <source>Nat. Genet</source>., <volume>47</volume>, <fpage>682</fpage>–<lpage>688</lpage>.<pub-id pub-id-type="pmid">25915597</pub-id></mixed-citation>
    </ref>
    <ref id="bty157-B18">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><name name-style="western"><surname>Ferragina</surname><given-names>P.</given-names></name>, <name name-style="western"><surname>Manzini</surname><given-names>G.</given-names></name></person-group> (<year>2000</year>). Opportunistic data structures with applications. In: <italic>Proceedings. 41st Annual Symposium on Foundations of Computer Science, 2000</italic>, Los Alamitos, CA, USA. IEEE, pp. <fpage>390</fpage>–<lpage>398</lpage>.</mixed-citation>
    </ref>
    <ref id="bty157-B19">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Freitas-Junior</surname><given-names>L.H.</given-names></name></person-group><etal>et al</etal> (<year>2000</year>) 
<article-title>Frequent ectopic recombination of virulence factor genes in telomeric chromosome clusters of <italic>P. falciparum</italic></article-title>. <source>Nature</source>, <volume>407</volume>, <fpage>1018</fpage>–<lpage>1022</lpage>.<pub-id pub-id-type="pmid">11069183</pub-id></mixed-citation>
    </ref>
    <ref id="bty157-B20">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Goodwin</surname><given-names>S.</given-names></name></person-group><etal>et al</etal> (<year>2016</year>) 
<article-title>Coming of age: ten years of next-generation sequencing technologies</article-title>. <source>Nat. Rev. Genet</source>., <volume>17</volume>, <fpage>333</fpage>–<lpage>351</lpage>.<pub-id pub-id-type="pmid">27184599</pub-id></mixed-citation>
    </ref>
    <ref id="bty157-B21">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Gurevich</surname><given-names>A.</given-names></name></person-group><etal>et al</etal> (<year>2013</year>) 
<article-title>QUAST: quality assessment tool for genome assemblies</article-title>. <source>Bioinformatics (Oxford, England)</source>, <volume>29</volume>, <fpage>1072</fpage>–<lpage>1075</lpage>.</mixed-citation>
    </ref>
    <ref id="bty157-B22">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><name name-style="western"><surname>Harris</surname><given-names>R.S.</given-names></name></person-group> (<year>2007</year>) <italic>Improved Pairwise Alignment of Genomic DNA</italic>. PhD thesis, Pennsylvania State Univ.</mixed-citation>
    </ref>
    <ref id="bty157-B23">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name name-style="western"><surname>Holley</surname><given-names>G.</given-names></name></person-group><etal>et al</etal> (<year>2017</year>) <chapter-title>Dynamic alignment-free and reference-free read compression</chapter-title> In: <source>Research in Computational Molecular Biology</source>. 
<publisher-name>Springer</publisher-name>, 
<publisher-loc>Cham</publisher-loc>, pp. <fpage>50</fpage>–<lpage>65</lpage>.</mixed-citation>
    </ref>
    <ref id="bty157-B24">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Huang</surname><given-names>L.</given-names></name></person-group><etal>et al</etal> (<year>2013</year>) 
<article-title>Short read alignment with populations of genomes</article-title>. <source>Bioinformatics</source>, <volume>29</volume>, <fpage>i361</fpage>–<lpage>i370</lpage>.<pub-id pub-id-type="pmid">23813006</pub-id></mixed-citation>
    </ref>
    <ref id="bty157-B25">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Idury</surname><given-names>R.M.</given-names></name>, <name name-style="western"><surname>Waterman</surname><given-names>M.S.</given-names></name></person-group> (<year>1995</year>) 
<article-title>A new algorithm for DNA sequence assembly</article-title>. <source>J. Comput. Biol</source>., <volume>2</volume>, <fpage>291</fpage>–<lpage>306</lpage>.<pub-id pub-id-type="pmid">7497130</pub-id></mixed-citation>
    </ref>
    <ref id="bty157-B26">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Iqbal</surname><given-names>Z.</given-names></name></person-group><etal>et al</etal> (<year>2012</year>) 
<article-title>De novo assembly and genotyping of variants using colored de Bruijn graphs</article-title>. <source>Nat. Genet</source>., <volume>44</volume>, <fpage>226</fpage>–<lpage>232</lpage>.<pub-id pub-id-type="pmid">22231483</pub-id></mixed-citation>
    </ref>
    <ref id="bty157-B27">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Iqbal</surname><given-names>Z.</given-names></name></person-group><etal>et al</etal> (<year>2013</year>) 
<article-title>High-throughput microbial population genomics using the Cortex variation assembler</article-title>. <source>Bioinformatics</source>, <volume>29</volume>, <fpage>275</fpage>–<lpage>276</lpage>.<pub-id pub-id-type="pmid">23172865</pub-id></mixed-citation>
    </ref>
    <ref id="bty157-B28">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Jackson</surname><given-names>A.P.</given-names></name></person-group><etal>et al</etal> (<year>2012</year>) 
<article-title>Antigenic diversity is generated by distinct evolutionary mechanisms in African trypanosome species</article-title>. <source>Proc. Natl. Acad. Sci. USA</source>, <volume>109</volume>, <fpage>3416</fpage>–<lpage>3421</lpage>.<pub-id pub-id-type="pmid">22331916</pub-id></mixed-citation>
    </ref>
    <ref id="bty157-B29">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Kim</surname><given-names>J.</given-names></name></person-group><etal>et al</etal> (<year>2013</year>) 
<article-title>Reference-assisted chromosome assembly</article-title>. <source>Proc. Natl. Acad. Sci. USA</source>, <volume>110</volume>, <fpage>1785</fpage>–<lpage>1790</lpage>.<pub-id pub-id-type="pmid">23307812</pub-id></mixed-citation>
    </ref>
    <ref id="bty157-B30">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Kingsford</surname><given-names>C.</given-names></name>, <name name-style="western"><surname>Patro</surname><given-names>R.</given-names></name></person-group> (<year>2015</year>) 
<article-title>Reference-based compression of short-read sequences using path encoding</article-title>. <source>Bioinformatics</source>, <volume>31</volume>, <fpage>1920</fpage>–<lpage>1928</lpage>.<pub-id pub-id-type="pmid">25649622</pub-id></mixed-citation>
    </ref>
    <ref id="bty157-B31">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Li</surname><given-names>D.</given-names></name></person-group><etal>et al</etal> (<year>2015</year>) 
<article-title>MEGAHIT: an ultra-fast single-node solution for large and complex metagenomics assembly via succinct de Bruijn graph</article-title>. <source>Bioinformatics (Oxford, England)</source>, <volume>31</volume>, <fpage>1674</fpage>–<lpage>1676</lpage>.</mixed-citation>
    </ref>
    <ref id="bty157-B32">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Li</surname><given-names>H.</given-names></name></person-group> (<year>2012</year>) 
<article-title>Exploring single-sample SNP and INDEL calling with whole-genome de novo assembly</article-title>. <source>Bioinformatics</source>, <volume>28</volume>, <fpage>1838</fpage>–<lpage>1844</lpage>.<pub-id pub-id-type="pmid">22569178</pub-id></mixed-citation>
    </ref>
    <ref id="bty157-B33">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Li</surname><given-names>H.</given-names></name></person-group> (<year>2014a</year>) 
<article-title>Fast construction of FM-index for long sequence reads</article-title>. <source>Bioinformatics</source>, <volume>30</volume>, <fpage>3274</fpage>–<lpage>3275</lpage>.<pub-id pub-id-type="pmid">25107872</pub-id></mixed-citation>
    </ref>
    <ref id="bty157-B34">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Li</surname><given-names>H.</given-names></name></person-group> (<year>2014b</year>) 
<article-title>Toward better understanding of artifacts in variant calling from high-coverage samples</article-title>. <source>Bioinformatics</source>, <volume>30</volume>, <fpage>2843</fpage>–<lpage>2851</lpage>.<pub-id pub-id-type="pmid">24974202</pub-id></mixed-citation>
    </ref>
    <ref id="bty157-B35">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Li</surname><given-names>H.</given-names></name></person-group> (<year>2015</year>) 
<article-title>BFC: correcting Illumina sequencing errors</article-title>. <source>Bioinformatics</source>, <volume>31</volume>, <fpage>2885</fpage>–<lpage>2887</lpage>.<pub-id pub-id-type="pmid">25953801</pub-id></mixed-citation>
    </ref>
    <ref id="bty157-B36">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Limasset</surname><given-names>A.</given-names></name></person-group><etal>et al</etal> (<year>2016</year>) 
<article-title>Read mapping on de Bruijn graphs</article-title>. <source>BMC Bioinformatics</source>, <volume>17</volume>, <fpage>237</fpage>–<lpage>237</lpage>.<pub-id pub-id-type="pmid">27306641</pub-id></mixed-citation>
    </ref>
    <ref id="bty157-B37">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Kolmogorov</surname><given-names>M.</given-names></name></person-group><etal>et al</etal> (<year>2014</year>) 
<article-title>Ragout—a reference-assisted assembly tool for bacterial genomes</article-title>. <source>Bioinformatics</source>, <volume>30</volume>, <fpage>i302</fpage>–<lpage>i309</lpage>.<pub-id pub-id-type="pmid">24931998</pub-id></mixed-citation>
    </ref>
    <ref id="bty157-B38">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Mathers</surname><given-names>A.J.</given-names></name></person-group><etal>et al</etal> (<year>2015</year>) 
<article-title><italic>Klebsiella pneumoniae</italic> carbapenemase (KPC) producing <italic>K. pneumoniae</italic> at a Single Institution: insights into Endemicity from Whole Genome Sequencing</article-title>. <source>Antimicrob. Agents Chemother</source>., <volume>59</volume>, <fpage>1656</fpage>–<lpage>1663</lpage>.<pub-id pub-id-type="pmid">25561339</pub-id></mixed-citation>
    </ref>
    <ref id="bty157-B39">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Miller</surname><given-names>J.R.</given-names></name></person-group><etal>et al</etal> (<year>2010</year>) 
<article-title>Assembly algorithms for next-generation sequencing data</article-title>. <source>Genomics</source>, <volume>95</volume>, <fpage>315</fpage>–<lpage>327</lpage>.<pub-id pub-id-type="pmid">20211242</pub-id></mixed-citation>
    </ref>
    <ref id="bty157-B40">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Muggli</surname><given-names>M.D.</given-names></name></person-group><etal>et al</etal> (<year>2017</year>) 
<article-title>Succinct colored de Bruijn graphs</article-title>. <source>Bioinformatics</source>, <volume>33</volume>, <fpage>3181</fpage>–<lpage>3187</lpage>.<pub-id pub-id-type="pmid">28200001</pub-id></mixed-citation>
    </ref>
    <ref id="bty157-B41">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Myers</surname><given-names>E.W.</given-names></name></person-group> (<year>1995</year>) 
<article-title>Toward simplifying and accurately formulating fragment assembly</article-title>. <source>J. Comput. Biol</source>., <volume>2</volume>, <fpage>275</fpage>–<lpage>290</lpage>.<pub-id pub-id-type="pmid">7497129</pub-id></mixed-citation>
    </ref>
    <ref id="bty157-B42">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Myers</surname><given-names>E.W.</given-names></name></person-group> (<year>2005</year>) 
<article-title>The fragment assembly string graph</article-title>. <source>Bioinformatics</source>, <volume>21</volume>, <fpage>ii79</fpage>–<lpage>ii85</lpage>.<pub-id pub-id-type="pmid">16204131</pub-id></mixed-citation>
    </ref>
    <ref id="bty157-B43">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Peng</surname><given-names>Y.</given-names></name></person-group><etal>et al</etal> (<year>2010</year>) 
<article-title>IDBA – a practical iterative de Bruijn graph de novo assembler</article-title>. <source>RECOMB</source>, <volume>6044</volume>, <fpage>426</fpage>.</mixed-citation>
    </ref>
    <ref id="bty157-B44">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Pevzner</surname><given-names>P.A.</given-names></name></person-group> (<year>1989</year>) 
<article-title>l-Tuple DNA sequencing: computer analysis</article-title>. <source>J. Biomol. Struct. Dyn</source>., <volume>7</volume>, <fpage>63</fpage>–<lpage>73</lpage>.<pub-id pub-id-type="pmid">2684223</pub-id></mixed-citation>
    </ref>
    <ref id="bty157-B45">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Pevzner</surname><given-names>P.A.</given-names></name></person-group> (<year>2004</year>) 
<article-title>De novo repeat classification and fragment assembly</article-title>. <source>Genome Res</source>., <volume>14</volume>, <fpage>1786</fpage>–<lpage>1796</lpage>.<pub-id pub-id-type="pmid">15342561</pub-id></mixed-citation>
    </ref>
    <ref id="bty157-B46">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Prjibelski</surname><given-names>A.D.</given-names></name></person-group><etal>et al</etal> (<year>2014</year>) 
<article-title>ExSPAnder: a universal repeat resolver for DNA fragment assembly</article-title>. <source>Bioinformatics</source>, <volume>30</volume>, <fpage>i293</fpage>–<lpage>i301</lpage>.<pub-id pub-id-type="pmid">24931996</pub-id></mixed-citation>
    </ref>
    <ref id="bty157-B47">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Read</surname><given-names>B.A.</given-names></name></person-group><etal>et al</etal> (<year>2013</year>) 
<article-title>Pan genome of the phytoplankton <italic>Emiliania underpins</italic> its global distribution</article-title>. <source>Nature</source>, <volume>499</volume>, <fpage>209</fpage>–<lpage>213</lpage>.<pub-id pub-id-type="pmid">23760476</pub-id></mixed-citation>
    </ref>
    <ref id="bty157-B48">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Ribeiro</surname><given-names>A.</given-names></name></person-group><etal>et al</etal> (<year>2015</year>) 
<article-title>An investigation of causes of false positive single nucleotide polymorphisms using simulated reads from a small eukaryote genome</article-title>. <source>BMC Bioinformatics</source>, <volume>16</volume>, <fpage>382.</fpage><pub-id pub-id-type="pmid">26558718</pub-id></mixed-citation>
    </ref>
    <ref id="bty157-B49">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Rimmer</surname><given-names>A.</given-names></name></person-group><etal>et al</etal> (<year>2014</year>) 
<article-title>Integrating mapping-, assembly- and haplotype-based approaches for calling variants in clinical sequencing applications</article-title>. <source>Nat. Genet</source>., <volume>46</volume>, <fpage>912</fpage>–<lpage>918</lpage>.<pub-id pub-id-type="pmid">25017105</pub-id></mixed-citation>
    </ref>
    <ref id="bty157-B50">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Rozov</surname><given-names>R.</given-names></name></person-group><etal>et al</etal> (<year>2017</year>) Faucet: streaming de novo assembly graph construction. bioRxiv, <volume>34</volume>, <fpage>147</fpage>–<lpage>154</lpage>.</mixed-citation>
    </ref>
    <ref id="bty157-B51">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Schneeberger</surname><given-names>K.</given-names></name></person-group><etal>et al</etal> (<year>2009</year>) 
<article-title>Simultaneous alignment of short reads against multiple genomes</article-title>. <source>Genome Biol</source>., <volume>10</volume>, <fpage>R98.</fpage><pub-id pub-id-type="pmid">19761611</pub-id></mixed-citation>
    </ref>
    <ref id="bty157-B52">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Sheppard</surname><given-names>A.E.</given-names></name></person-group><etal>et al</etal> (<year>2016</year>) 
<article-title>Nested Russian doll-like genetic mobility drives rapid dissemination of the carbapenem resistance gene blaKPC</article-title>. <source>Antimicrob. Agents Chemother</source>., <volume>60</volume>, <fpage>3767</fpage>–<lpage>3778</lpage>.<pub-id pub-id-type="pmid">27067320</pub-id></mixed-citation>
    </ref>
    <ref id="bty157-B53">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Simpson</surname><given-names>J.T.</given-names></name>, <name name-style="western"><surname>Durbin</surname><given-names>R.</given-names></name></person-group> (<year>2010</year>) 
<article-title>Efficient construction of an assembly string graph using the FM-index</article-title>. <source>Bioinformatics</source>, <volume>26</volume>, <fpage>i367</fpage>–<lpage>i373</lpage>.<pub-id pub-id-type="pmid">20529929</pub-id></mixed-citation>
    </ref>
    <ref id="bty157-B54">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Simpson</surname><given-names>J.T.</given-names></name></person-group><etal>et al</etal> (<year>2009</year>) 
<article-title>ABySS: a parallel assembler for short read sequence data</article-title>. <source>Genome Res</source>., <volume>19</volume>, <fpage>1117</fpage>–<lpage>1123</lpage>.<pub-id pub-id-type="pmid">19251739</pub-id></mixed-citation>
    </ref>
    <ref id="bty157-B56">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Weisenfeld</surname><given-names>N.I.</given-names></name></person-group><etal>et al</etal> (<year>2014</year>) 
<article-title>Comprehensive variation discovery in single human genomes</article-title>. <source>Nat. Genet</source>., <volume>46</volume>, <fpage>1350</fpage>–<lpage>1355</lpage>.<pub-id pub-id-type="pmid">25326702</pub-id></mixed-citation>
    </ref>
    <ref id="bty157-B57">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Zerbino</surname><given-names>D.R.</given-names></name></person-group> (<year>2010</year>) 
<article-title>Using the Velvet de novo assembler for short-read sequencing technologies</article-title>. <source>Curr. Protoc. Bioinf</source>., <volume>31</volume>, <fpage>11.5.1</fpage>–<lpage>11.5.12</lpage>.</mixed-citation>
    </ref>
    <ref id="bty157-B58">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Zerbino</surname><given-names>D.R.</given-names></name>, <name name-style="western"><surname>Birney</surname><given-names>E.</given-names></name></person-group> (<year>2008</year>) 
<article-title>Velvet: algorithms for de novo short read assembly using de Bruijn graphs</article-title>. <source>Genome Res</source>., <volume>18</volume>, <fpage>821</fpage>–<lpage>829</lpage>.<pub-id pub-id-type="pmid">18349386</pub-id></mixed-citation>
    </ref>
  </ref-list>
</back>
