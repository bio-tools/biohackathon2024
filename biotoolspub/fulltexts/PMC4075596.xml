<?DTDIdentifier.IdentifierValue http://www.biomedcentral.com/xml/article.dtd?>
<?DTDIdentifier.IdentifierType system?>
<?SourceDTD.DTDName article.dtd?>
<?SourceDTD.Version 1.0?>
<?ConverterInfo.XSLTName bmc2nlmx2.xsl?>
<?ConverterInfo.Version 2?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Source Code Biol Med</journal-id>
    <journal-id journal-id-type="iso-abbrev">Source Code Biol Med</journal-id>
    <journal-title-group>
      <journal-title>Source Code for Biology and Medicine</journal-title>
    </journal-title-group>
    <issn pub-type="epub">1751-0473</issn>
    <publisher>
      <publisher-name>BioMed Central</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">4075596</article-id>
    <article-id pub-id-type="publisher-id">1751-0473-9-13</article-id>
    <article-id pub-id-type="doi">10.1186/1751-0473-9-13</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Software Review</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>biobambam: tools for read pair collation based algorithms on BAM files</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" corresp="yes" id="A1">
        <name>
          <surname>Tischler</surname>
          <given-names>German</given-names>
        </name>
        <xref ref-type="aff" rid="I1">1</xref>
        <email>german.tischler@sanger.ac.uk</email>
      </contrib>
      <contrib contrib-type="author" id="A2">
        <name>
          <surname>Leonard</surname>
          <given-names>Steven</given-names>
        </name>
        <xref ref-type="aff" rid="I1">1</xref>
        <email>steven.leonard@sanger.ac.uk</email>
      </contrib>
    </contrib-group>
    <aff id="I1"><label>1</label>The Wellcome Trust Sanger Institute, Wellcome Trust Genome Campus, Hinxton, Cambridge, CB10 1SA, UK</aff>
    <pub-date pub-type="collection">
      <year>2014</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>20</day>
      <month>6</month>
      <year>2014</year>
    </pub-date>
    <volume>9</volume>
    <fpage>13</fpage>
    <lpage>13</lpage>
    <history>
      <date date-type="received">
        <day>6</day>
        <month>6</month>
        <year>2013</year>
      </date>
      <date date-type="accepted">
        <day>11</day>
        <month>6</month>
        <year>2014</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>Copyright © 2014 Tischler and Leonard; licensee BioMed Central Ltd.</copyright-statement>
      <copyright-year>2014</copyright-year>
      <copyright-holder>Tischler and Leonard; licensee BioMed Central Ltd.</copyright-holder>
      <license license-type="open-access" xlink:href="http://creativecommons.org/licenses/by/2.0">
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (
<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/2.0">http://creativecommons.org/licenses/by/2.0</ext-link>), which permits unrestricted use, distribution, and reproduction in any medium, provided the original work is properly credited.</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="http://www.scfbm.org/content/9/1/13"/>
    <abstract>
      <sec>
        <title>Background</title>
        <p>Sequence alignment data is often ordered by coordinate (id of the reference sequence plus position on the sequence where the fragment was mapped) when stored in BAM files, as this simplifies the extraction of variants between the mapped data and the reference or of variants within the mapped data. In this order paired reads are usually separated in the file, which complicates some other applications like duplicate marking or conversion to the FastQ format which require to access the full information of the pairs.</p>
      </sec>
      <sec>
        <title>Results</title>
        <p>In this paper we introduce biobambam, a set of tools based on the efficient collation of alignments in BAM files by read name. The employed collation algorithm avoids time and space consuming sorting of alignments by read name where this is possible without using more than a specified amount of main memory. Using this algorithm tasks like duplicate marking in BAM files and conversion of BAM files to the FastQ format can be performed very efficiently with limited resources. We also make the collation algorithm available in the form of an API for other projects. This API is part of the libmaus package.</p>
      </sec>
      <sec>
        <title>Conclusions</title>
        <p>In comparison with previous approaches to problems involving the collation of alignments by read name like the BAM to FastQ or duplication marking utilities our approach can often perform an equivalent task more efficiently in terms of the required main memory and run-time. Our BAM to FastQ conversion is faster than all widely known alternatives including Picard and bamUtil. Our duplicate marking is about as fast as the closest competitor bamUtil for small data sets and faster than all known alternatives on large and complex data sets.</p>
      </sec>
    </abstract>
    <kwd-group>
      <kwd>High throughput sequencing</kwd>
      <kwd>Collation by read name</kwd>
      <kwd>Duplicate marking</kwd>
      <kwd>File format conversion</kwd>
    </kwd-group>
  </article-meta>
</front>
<body>
  <sec>
    <title>Background</title>
    <p>The SAM (Sequence Alignment/Matching) and BAM (Binary Alignment/Matching) file formats have become the standard formats for storing sequence data which was obtained through high throughput sequencing and alignment of the resulting data to a reference genome. Both formats were introduced as part of the SAMtools package (cf.
[<xref ref-type="bibr" rid="B1">1</xref>]). SAM is a human readable text format whereas BAM is a more compact and compressed binary format. The current specification of the formats is available at
[<xref ref-type="bibr" rid="B2">2</xref>]. These files can be used for many applications including the detection of variants between the contained data and a reference, sequencing quality control and long term storage. Many programs have been created for the alignment of sequencing reads to reference sequences including SSAHA
[<xref ref-type="bibr" rid="B3">3</xref>], BWA
[<xref ref-type="bibr" rid="B4">4</xref>,<xref ref-type="bibr" rid="B5">5</xref>], Bowtie
[<xref ref-type="bibr" rid="B6">6</xref>,<xref ref-type="bibr" rid="B7">7</xref>], SOAP
[<xref ref-type="bibr" rid="B8">8</xref>,<xref ref-type="bibr" rid="B9">9</xref>] and SMALT
[<xref ref-type="bibr" rid="B10">10</xref>] and most of the recently published aligners are either capable of generating SAM or BAM output or come with a script for converting their output to SAM or BAM. Most sequence data produced at the time being is sequenced as paired end reads. Short linear DNA templates are sequenced from both ends. This produces a pair of reads for each template. Both ends of the pair are assigned the same read name in the resulting data files thus providing the information that both ends are most likely within a certain expected distance in the underlying genome. This information aids in correctly aligning the resulting short sequences to a reference or assembling the fragments to a new draft reference. In the data obtained from a sequencer the pairs are usually collated in some form, either the two ends of a pair directly follow each other in a file or appear in an equivalent position in two separate files such that each of the two holds only the information for one of the two ends. The order of reads aligned to a reference which is most suitable for calling variants between the reads and the reference or within the reads is however the one resulting from sorting the data by coordinate (id of the reference sequence plus position on the sequence where the fragment was mapped). Thus many SAM and BAM files are processed in this order. There are however some applications which require the complete information from each pair. This includes the conversion of BAM files to a FastQ format suitable for realignment or a de novo assembly for an alternative detection of variants (see e.g.
[<xref ref-type="bibr" rid="B11">11</xref>]) as well as the marking of duplicate reads. It is thus useful to have a quick, easy to use and reliable way of collating reads from a SAM/BAM file by their name without needing to resort to a full resorting of the file by read names. For the application of duplicate marking it is in addition desirable to keep the order after collation as close to the coordinate sorted order as possible, as clusters of read pairs mapped to the same coordinates need to be detected. In this paper we present <monospace>biobambam</monospace>, a set of tools for processing BAM files using an efficient read name collation algorithm.</p>
    <p>The contained tools <monospace>bamtofastq</monospace> and <monospace>bammark</monospace><monospace>duplicates2</monospace> are more efficient in terms of run-time and memory requirements then equivalent tools in the widely used Picard suite (see
[<xref ref-type="bibr" rid="B12">12</xref>]). <monospace>bammarkduplicates2</monospace> offers performance similar to that of the duplication detection tool of bamUtil (see
[<xref ref-type="bibr" rid="B13">13</xref>]) for small data sets and in contrast to bamUtil easily handles larger and more complex data sets. <monospace>bamtofastq</monospace> is faster than the bam2fastq component of bamUtil. In addition to our front end programs we also make the collation algorithm directly accessible as an API for use in other projects in the <monospace>libmaus</monospace> project.</p>
  </sec>
  <sec>
    <title>Implementation</title>
    <p>The code presented in this paper is split into two parts. The front-end tools <monospace>bamtofastq</monospace> and <monospace>bammarkduplicates2</monospace> show-casing some applications of fast collation of alignments by name can be found in the <monospace>biobambam</monospace> source package (cf.
[<xref ref-type="bibr" rid="B14">14</xref>]). The implementation of the collation code and the BAM file input and output routines are part of the larger <monospace>libmaus</monospace> project (see
[<xref ref-type="bibr" rid="B15">15</xref>]).</p>
    <p>There are various code bases and APIs available for SAM and BAM file input and output, including SAMtools (C), SeqAn (C++, cf.
[<xref ref-type="bibr" rid="B16">16</xref>]) and Bio-samtools (Ruby, cf.
[<xref ref-type="bibr" rid="B17">17</xref>]). We use our own implementation for reading BAM files, which can be found in the libmaus project (C++,
[<xref ref-type="bibr" rid="B15">15</xref>]). The libmaus project also contains various supporting data structures which we use, including the collation API in its namespace <monospace>libmaus::bambam</monospace>. The front-end programs can be found in the biobambam project. The tools can easily be extended to handle the newer CRAM format (cf.
[<xref ref-type="bibr" rid="B18">18</xref>]) via the <monospace>io_lib</monospace> part of the Staden package (cf.
[<xref ref-type="bibr" rid="B19">19</xref>,<xref ref-type="bibr" rid="B20">20</xref>]) which contains the Gap5 software (see
[<xref ref-type="bibr" rid="B21">21</xref>]).</p>
    <p>In the following we will describe the algorithms and data structures used for collating alignments by their name. The API making the functionality available to other users and the documentation of the front-end tools <monospace>bamtofastq</monospace> and <monospace>bammarkduplicates2</monospace> are presented in Additional file
<xref ref-type="supplementary-material" rid="S1">1</xref>: Appendix A.</p>
    <sec>
      <title>Algorithms and data structures for collation by read name</title>
      <p>Although the BAM file format can store alignments in any order, most BAM files will either have the alignments collated by the corresponding read names or will contain the alignments sorted by their coordinates on the reference the reads were aligned to. The first case will commonly appear as the output of alignment programs or if raw FastQ files coming from a sequencer are converted to the BAM format without aligning the contained reads to any reference. In this setting the output of the alignments in an order collated by read name to another format offering the same or less information is very simple. In the second case a straight-forward but often inefficient way is to first sort the input BAM file by query name using tools like SAMtools or Picard and then resort to a conversion as employed in the first case, as a BAM file sorted by query name will have the alignments collated by read name. For a BAM file sorted by alignment coordinates collating the alignments by read name can often be done more efficiently by observing that while the alignments paired by read name will commonly not be consecutive in the file, they are in most cases close together. If we denote the average coverage of a coordinate on the reference by <italic>d</italic> (i.e. each coordinate is covered by <italic>d</italic> reads/alignments on average), the average absolute template length of a pair with both ends mapped to the same sequence by <italic>t</italic> (e.g. the absolute value of the distance between the mapping positions of the 5<sup>′</sup> ends for Illumina paired-end reads) and the read length by <italic>l</italic>, then we would expect the distance between two such ends in the BAM file to be
<inline-formula><mml:math id="M1" name="1751-0473-9-13-i1" overflow="scroll"><mml:mfrac><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:mfrac><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>-</mml:mo><mml:mi>l</mml:mi><mml:mo>)</mml:mo></mml:math></inline-formula> on average. The mean number of read ends starting at each position on the forward strand is
<inline-formula><mml:math id="M2" name="1751-0473-9-13-i2" overflow="scroll"><mml:mfrac><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:mfrac></mml:math></inline-formula> and the distance between the two starting points on the forward strand is <italic>t</italic> - <italic>l</italic>. Mapping the data from the whole human genome sequencing study ERP001231 ([EMBL:ERP001231], cf
[<xref ref-type="bibr" rid="B22">22</xref>]) to the human genome (GRCh37, see
[<xref ref-type="bibr" rid="B23">23</xref>]) using the SMALT aligner (see
[<xref ref-type="bibr" rid="B10">10</xref>]) for instance, we observe an average sequencing depth of <italic>d</italic> = 45 with an average template length of <italic>t</italic> = 324 at a mean read length of <italic>l</italic> = 101 (100 base pairs were sequenced at one end of the templates and 102 from the other end). According to our formula this implies an average number of about 99 alignments between the two alignments of one pair in a BAM file containing the aligned reads. The actual median we observe in the file is 107. Due to some improperly mapped pairs in the file the weighted average value we see is not a meaningful number. Thus for the average case it would be sufficient to use any type of data structure which allows fast insertion, deletion and lookup of alignments by read name for a small set of alignments.</p>
      <p>One such data structure would be a hash table with collision resolution by separate chaining. In practice however we see cases where some read ends stay in this hash table for an extended time when we process a BAM file sorted by coordinates from start to end. This may happen for reads where the two ends map to different chromosomes (split reads). There are also often regions in a genome where the sequencing depth is much higher than on average, which can lead to a drastic increase in the amount of memory required to store the hash table at certain points. Instead of using a hash table with collision resolution we use a hash table <italic>H</italic> of fixed size <italic>h</italic> without collision resolution. If there is a collision because two alignments with different names are assigned the same hash value, then the alignment previously in the hash table is removed from the table and inserted into a list <italic>L</italic> of fixed size <italic>l</italic> of alignments to be handled later. Each time the list <italic>L</italic> runs out of space we sort the alignments in <italic>L</italic> by read name. This sorting may yield some new pairs, which we extract before storing the unpaired alignments still in <italic>L</italic> in a temporary file and emptying the list <italic>L</italic>. Pseudo code for the insertion of alignments into the hash table <italic>H</italic> and the list <italic>L</italic> is given in Figure
<xref ref-type="fig" rid="F1">1</xref> and
<xref ref-type="fig" rid="F2">2</xref> respectively. As soon as all alignments have been read from the source BAM file we move all the alignments remaining in <italic>H</italic> over to the list <italic>L</italic> and in the end flush the list <italic>L</italic> by sorting the remaining elements by name, extracting the resulting pairs and writing the remaining unpaired alignments to another temporary file. As all the temporary files are sorted by name, we can easily merge the files together to obtain a stream of alignments that is sorted by read name. In this stream it is again simple to detect and output pairs. A diagram of this data flow can be seen in Figure
<xref ref-type="fig" rid="F3">3</xref>. Using this kind of setup we are able to quickly process most of the reads which have both ends close together in the BAM file while avoiding the use of excessive amounts of main memory to handle those pairs which are not close together. For the discussion of the complexity of the algorithm we will assume that each single alignment can be processed in constant time and stored in constant space. This assumption is reasonable for short reads. For an input file containing <italic>n</italic> alignments let <italic>n</italic><sub><italic>H</italic></sub> denote the number of alignments processed without resorting to the list <italic>L</italic> and let <italic>n</italic><sub><italic>L</italic></sub> = <italic>n</italic>-<italic>n</italic><sub><italic>H</italic></sub>. Then the time complexity of the algorithm is <italic>O</italic>(<italic>n</italic><sub><italic>H</italic></sub> + <italic>n</italic><sub><italic>L</italic></sub> log <italic>n</italic><sub><italic>L</italic></sub>), where log without loss of generality denotes the base 2 logarithm. In the unlikely worst case we may have <italic>n</italic><sub><italic>H</italic></sub> = 0 and thus the worst case run-time of the algorithm would become <italic>O</italic>(<italic>n</italic> log<italic>n</italic>), i.e. the run-time would be equivalent to a full sorting of the input file by name. Let <italic>s</italic><sub><italic>L</italic></sub> denote the size of the list <italic>L</italic> in memory. Then we need <italic>O</italic>(<italic>s</italic><sub><italic>L</italic></sub>) space for sorting each single block of alignments written to a temporary file in memory and <italic>O</italic>(<italic>n</italic>/<italic>s</italic><sub><italic>L</italic></sub>) space for merging the blocks together. Choosing <italic>s</italic><sub><italic>L</italic></sub> in
<inline-formula><mml:math id="M3" name="1751-0473-9-13-i3" overflow="scroll"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:msqrt><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msqrt><mml:mo>)</mml:mo></mml:math></inline-formula> both of these become
<inline-formula><mml:math id="M4" name="1751-0473-9-13-i4" overflow="scroll"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:msqrt><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msqrt><mml:mo>)</mml:mo></mml:math></inline-formula>. The hash table <italic>H</italic> requires constant space, thus the total space complexity of the algorithm is
<inline-formula><mml:math id="M5" name="1751-0473-9-13-i5" overflow="scroll"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:msqrt><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msqrt><mml:mo>)</mml:mo></mml:math></inline-formula> (in fact we can make this
<inline-formula><mml:math id="M6" name="1751-0473-9-13-i6" overflow="scroll"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfrac></mml:mrow></mml:msup><mml:mo>)</mml:mo></mml:math></inline-formula> for any finite constant positive integer <italic>k</italic> by using <italic>k</italic> merging runs). The algorithm may use <italic>O</italic>(<italic>n</italic>) space in external memory in the unlikely worst case.</p>
      <fig id="F1" position="float">
        <label>Figure 1</label>
        <caption>
          <p><bold>Hash Table Insertion Pseudo Code.</bold> Pseudo code for hash table insertion applied to alignments read from the input file. If an alignment <italic>B</italic> with an identical hash value <italic>h</italic> to that of the new alignment <italic>A</italic> is present, then either a pair is detected and appended to the output list <italic>O</italic> or we have a collision between a previous alignment <italic>B</italic> and need to move <italic>B</italic> to the list <italic>L</italic> before we can insert <italic>A</italic> into <italic>H</italic>. If there is no alignment for the hash value <italic>h</italic> yet, then the new alignment is inserted into <italic>H</italic>.</p>
        </caption>
        <graphic xlink:href="1751-0473-9-13-1"/>
      </fig>
      <fig id="F2" position="float">
        <label>Figure 2</label>
        <caption>
          <p><bold>List Insertion Pseudo Code Pseudo code for insertion into the list</bold> <bold><italic>L</italic></bold><bold>.</bold> The new alignment <italic>A</italic> is inserted into the list <italic>L</italic>. If the size of <italic>L</italic> has reached a given threshold, then we sort <italic>L</italic>, move newly discovered pairs to the output list <italic>O</italic>, write the remaining unmatched alignments to a new temporary file and erase <italic>L</italic>.</p>
        </caption>
        <graphic xlink:href="1751-0473-9-13-2"/>
      </fig>
      <fig id="F3" position="float">
        <label>Figure 3</label>
        <caption>
          <p><bold>Data Flow during Collation.</bold> The collation process uses several layers of data structures for handling alignments. This includes the hash table <italic>H</italic> (see Figure
<xref ref-type="fig" rid="F4">4</xref>), the overflow list <italic>L</italic> (see Figure
<xref ref-type="fig" rid="F5">5</xref>), a set of temporary files <italic>T</italic><sub><italic>i</italic></sub> and a merged list <italic>M</italic> produced from the <italic>T</italic><sub><italic>i</italic></sub>.</p>
        </caption>
        <graphic xlink:href="1751-0473-9-13-3"/>
      </fig>
      <p>To avoid the overhead resulting from the allocation of a small block of memory for each single alignment, we implement the hash table <italic>H</italic> and the list <italic>L</italic> in the following way. The hash table <italic>H</italic> is implemented as a fixed size character array <italic>R</italic> which we use as a ring buffer, an array <italic>P</italic> of integers and a B-tree <italic>B</italic>. <italic>P</italic> is the actual hash table storing pointers into <italic>R</italic>, <italic>R</italic> is used to store alignments as uncompressed BAM entries and <italic>B</italic> contains the starting positions of all alignments currently stored in <italic>R</italic>. A pointer <italic>r</italic> which is initially set to 0 marks the current position in <italic>R</italic>. When a name <italic>q</italic> is to be searched in <italic>H</italic>, then we first compute the hash value <italic>h</italic> of the name and check whether position <italic>P</italic>[<italic>h</italic>] in <italic>R</italic> designates the start of an alignment and the stored alignment has the name <italic>q</italic>. An alignment with hash value <italic>h</italic> can be erased from <italic>H</italic> by first removing <italic>P</italic>[<italic>h</italic>] from <italic>B</italic> and then setting <italic>P</italic>[<italic>h</italic>] to a special value marking a free position in <italic>P</italic>. To insert a new alignment with hash value <italic>h</italic> into <italic>H</italic> we first need to make sure there is sufficient space. If <italic>P</italic>[<italic>h</italic>] is used, then the currently stored alignment for <italic>h</italic> needs to be moved to <italic>L</italic> and erased from <italic>H</italic>. Then we possibly need to remove more alignments from <italic>H</italic> until the difference between the current insert pointer <italic>r</italic> and the next higher value in <italic>B</italic> (considered in a circular way as <italic>R</italic> is a ring buffer) contains sufficient space to store the new alignment. As soon as sufficient space is available, we can copy the alignment data to position <italic>r</italic> in <italic>R</italic>, insert <italic>r</italic> into <italic>B</italic>, store <italic>P</italic>[<italic>h</italic>]=<italic>r</italic> and advance <italic>r</italic> by the length of the alignment data we have just stored. Figure
<xref ref-type="fig" rid="F4">4</xref> visualises the components of the hash table <italic>H</italic>. We store the list <italic>L</italic> as a byte array. The alignment data is filled in at the front end of the array. The pointers to the alignment starting positions in the byte array are filled in from the back of the array. The list runs full if we are no longer able to add the next alignment in the same way as the ones already stored. Figure
<xref ref-type="fig" rid="F5">5</xref> shows a list <italic>L</italic> containing 5 alignments <italic>A</italic><sub>0</sub>,<italic>A</italic><sub>1</sub>,…,<italic>A</italic><sub>4</sub>. A full list can be sorted by keeping the alignment data in place and reordering the pointers at the end of the byte array. Storing <italic>H</italic> and <italic>L</italic> in this way requires a very small amount of memory allocation and freeing operations for handling large sets of alignments.</p>
      <fig id="F4" position="float">
        <label>Figure 4</label>
        <caption>
          <p><bold>Collation Hash Table</bold> <bold><italic>H</italic></bold><bold>.</bold> The hash table <italic>H</italic> used for collation is composed of three components. The ring buffer <italic>R</italic> stores alignment data. In the picture it contains three alignments <italic>A</italic><sub><italic>i</italic></sub>,<italic>A</italic><sub><italic>j</italic></sub> and <italic>A</italic><sub><italic>k</italic></sub>. The insert pointer <italic>r</italic> is situated just after the alignment <italic>A</italic><sub><italic>j</italic></sub>. The hash table <italic>P</italic> stores pointers into <italic>R</italic>, where the position of the respective pointers is given by a hash value computed from the name of the stored alignment. The B-tree <italic>B</italic> stores the starting positions of alignments in <italic>R</italic> in sorted order.</p>
        </caption>
        <graphic xlink:href="1751-0473-9-13-4"/>
      </fig>
      <fig id="F5" position="float">
        <label>Figure 5</label>
        <caption>
          <p><bold>Overflow List </bold><bold><italic>L</italic></bold><bold>.</bold> The overflow list <italic>L</italic> is implemented as a byte array. Alignments are inserted from the start of the array. In the picture <italic>A</italic><sub>0</sub>,<italic>A</italic><sub>1</sub>,…<italic>A</italic><sub>4</sub> are contained. Pointers to the respective starting positions are inserted from the end of the byte array.</p>
        </caption>
        <graphic xlink:href="1751-0473-9-13-5"/>
      </fig>
    </sec>
  </sec>
  <sec>
    <title>Results and discussion</title>
    <p>In the following we will compare the performance of our new tools <monospace>bamtofastq</monospace> and <monospace>bammarkduplicates2</monospace> to available programs offering the same functionality. For <monospace>bamtofastq</monospace> we compared to </p>
    <p>• Picard’s SamToFastQ component,</p>
    <p>• bamUtil’s bam2fastq option (see
[<xref ref-type="bibr" rid="B13">13</xref>]),</p>
    <p>• bam2fastq (see
[<xref ref-type="bibr" rid="B24">24</xref>]) and</p>
    <p>• bampe2fqworphans (see
[<xref ref-type="bibr" rid="B25">25</xref>]).</p>
    <p>For <monospace>bammarkduplicates2</monospace> we compared to </p>
    <p>• Picard’s MarkDuplicates component and</p>
    <p>• bamUtil’s dedup option</p>
    <p>Comparisons were performed with the current versions of the programs when our benchmarking for this paper started. These versions are </p>
    <p>• 1.99 for Picard,</p>
    <p>• 1.09 for bamUtil and</p>
    <p>• 1.1.0 for bam2fastq.</p>
    <p>We used the corrected version of the bampe2fqworphans program as posted by Richard Finney on the SEQanswers forum on the 24th of September 2013. Picard was run using Oracle’s Java (Java SE 7u21).</p>
    <p>We have run two types of tests. In the first type we test the performance of the programs for a wide variety of input files using a small PC type and a large compute farm type system. These tests were generally run with multiple identical instances in parallel, which reduces the total amount of wall clock time required to obtain the at least ten run time values we measured for each setting to compute a mean run time and standard deviation. In the second type of test we measured the dependence of the run time on the number of concurrently running identical processes. This included the case of running a single instance of a program on an otherwise idle machine. As consequently the time required for each single program and data set was considerably longer we have run this test on a reduced number of input files.</p>
    <p>For the first type of test we have used two kinds of hardware configurations. The first was a standard PC equipped with an Intel Core i7-2700K four core processor running at a frequency of 3.5 GHz, 16 GB<sup>a</sup> of memory and a fast solid state type drive (SSD) for storing temporary files. The machine was running version 13.10 (Saucy Salamander) of Ubuntu Linux. We have run up to four jobs of the same kind in parallel whenever concurrency was not hindered by excessive memory requirements. The machine was completely dedicated to benchmarking during the experiments. We use this machine type as an example for a small system. Due to the absence interfering factors the measured run times should be relatively reliable. The second machine type were HP ProLiant BL465c Gen8 server blades equipped with two 16 core AMD Opteron 6272 processors running at 2.4 Ghz and 256 GB of memory. Files were stored on a high performance parallel network based file system (Lustre). These machines were running version 12.04 (Precise Pangolin) of Ubuntu Linux. We have run ten jobs of the same kind parallel. The machines were not processing other jobs during the benchmarking. The file system however was not fully dedicated to our benchmarking and may have shown punctual performance fluctuations during our testing. We use this machine type as an example for a large scale compute farm type system. For both machine types the times given below consist of an average and standard deviation over 10 runs of the programs with identical parameters. The memory usage given denotes the maximum resident set size (RSS) observed during the programs run. For running Picard we have adjusted the amount of memory available by setting the <monospace>-Xmx</monospace> switch of the virtual machine and chosen the serial garbage collector (switch -XX:+UseSerialGC). Available memory was generally set to a multiple of 64 MB. The amount of memory used (the RSS) by the virtual machine can exceed the desired value by a small amount. This explains why the values given below for memory used by Picard is generally not a multiple of 64 MB. Before starting the timing tests on the PC type system we have checked the capability of the programs to handle our test data sets on a machine equipped with 512 GB of memory. This machine uses Intel Xeon E7440 processors running at 2.4 GHz. We have considered a program on a data set as admissible for the PC system if it was capable of handling the data set using 10 GB of memory. On the server blades we have provided 240 GB of memory to the set of 10 concurrently running process (due to features of the employed job scheduling system 240 GB denotes 240·10<sup>9</sup> bytes in this context). Thus each single process had an implicit limit of 24 GB (i.e. 24·10<sup>9</sup> bytes). We have set a run-time limit of one day for each data set. Thus a program was considered not capable of handling a data set when it ran for more than one day or required more than 24 GB of memory. On both system types we used the programs were in no case slowed down by insufficient input speed. On the output side we generally did not write the resulting files to disk for any of the programs as we wanted to measure the speed of the algorithms without interference of output speed. For the case of duplicate marking in BAM files the output is generally not produced at a rate which would pose a challenge for commonly used current storage systems. On the PC system the output rate for the BAM to FastQ conversion of biobambam is for at least one of the input files we used exceeding 120 MB/s. This would be too much for a single conventional hard drive but not for the SSD storage or a high performance network file system. If the output speed in BAM to FastQ conversion is a limiting factor, then the option of <monospace>bamtofastq</monospace> for generating gzip compressed output may be helpful. Due to the long run-time for some data sets the set of input files we have used on the PC system is a subset of the files we have evaluated on the server blades as only a single PC system was available. On the PC system we have evaluated the dependence of program run-time on the amount of available RAM for programs which allowed setting any parameters controlling memory usage. On the server blades we have given all available memory of the machine to the set of 10 concurrently running processes of the same type. For Java we set the target memory per virtual machine to 16 GB as we needed to give a fixed amount at the start of the program. This was sufficient to not let run Picard out of memory on any data set. For cases where Picard was using close to all of the provided memory we also state the run-time for higher amounts of available memory.</p>
    <p>For the second type of test measuring the dependence of run time on the number of concurrently running identical processes we have also used two types of systems. The first type is the compute farm setting described above. Again the machines used were not processing other jobs during our benchmarking but the file system was not fully dedicated. We have tested the run time for each program when running 1,2,…,10,12,16,24 and 32 identical instances in parallel. We have replaced the PC type system for this type of test by a small server type machine with a higher number of processor cores to observe the behaviour of the programs for more than four parallel instances in a controlled input/output setting. This system was fitted with two Intel Xeon E5-2620 processors and 32 GB of RAM. Each of the processors has 6 cores and is capable of hyper threading, thus the total number of processes the machine can run in parallel is 24. The machine was running version 14.04 (Trusty Tahr) of Ubuntu Linux. Like the PC type system this machine was also fitted with a fast solid state drive for storing files. We have tested the run time for each program when running 1,2,…,10,12,16,20 and 24 identical instances in parallel. For both machine types the times given below consist of an average and standard deviation over at least 10 runs of the programs with identical parameters.</p>
    <sec>
      <title/>
      <sec>
        <title>Performance comparison for <monospace>bamtofastq</monospace> on the PC system</title>
        <p>For evaluating the performance of our approach for converting BAM to FastQ on the PC system in comparison with the other alternatives mentioned above we have used the following data sets, each stored in a single BAM file (a summary of the files’ characteristics is given in Table
<xref ref-type="table" rid="T1">1</xref>):</p>
        <p>1. The low depth single chromosome human data set HG03520 (see
[<xref ref-type="bibr" rid="B26">26</xref>]) from the 1000 genomes project (cf.
[<xref ref-type="bibr" rid="B27">27</xref>]) with a median depth value of 8 (the median of the sequence of the number of reads mapping to each reference base with any coverage). We have used the BAM file as provided by the project. We use this 1 GB file as an example of a relatively small file. The median of the distance between the two ends of a template in the file is 25. All the programs were able to handle this data set with less than 256 MB of memory. <monospace>bamtofastq</monospace> processed the file in 23±0.87 seconds and space 112 MB. All other programs were slower. bam2fastq used 57±2.9 seconds and 16 MB RAM, bampe2fqworphans 33±2.1 and 9 MB, SamToFastQ 106±5.8 and 137 MB and bamUtil bam2fastq 49±2.8 and 26 MB. All programs but <monospace>bamtofastq</monospace> and SamToFastQ have no options for controlling the available memory. The memory usage of <monospace>bamtofastq</monospace> can be lowered to 33 MB using non standard settings. The program then needs 22 seconds (all ten runs took 22 seconds). Most of this memory usage consists of program code. Even with default settings the memory usage of <monospace>bamtofastq</monospace> is so far below the memory per core on a current machine that we do not find a further reduction useful. Both <monospace>bamtofastq</monospace> and SamToFastQ did not benefit from using more memory.</p>
        <table-wrap position="float" id="T1">
          <label>Table 1</label>
          <caption>
            <p>Characteristics of test files used for PC test</p>
          </caption>
          <table frame="hsides" rules="groups" border="1">
            <colgroup>
              <col align="left"/>
              <col align="center"/>
              <col align="center"/>
              <col align="center"/>
              <col align="center"/>
            </colgroup>
            <thead valign="top">
              <tr>
                <th colspan="5" align="center">
                  <bold>Test file characteristics</bold>
                </th>
              </tr>
            </thead>
            <tbody valign="top">
              <tr>
                <td align="left" valign="bottom">
                  <bold>Name</bold>
                  <hr/>
                </td>
                <td align="left" valign="bottom">
                  <bold>HG03520</bold>
                  <hr/>
                </td>
                <td align="left" valign="bottom">
                  <bold>HG00096</bold>
                  <hr/>
                </td>
                <td align="left" valign="bottom">
                  <bold>ERP001231</bold>
                  <hr/>
                </td>
                <td align="left" valign="bottom">
                  <bold>SRP017681</bold>
                  <hr/>
                </td>
              </tr>
              <tr>
                <td align="left" valign="bottom">File size/GB<hr/></td>
                <td align="left" valign="bottom">1<hr/></td>
                <td align="left" valign="bottom">15<hr/></td>
                <td align="left" valign="bottom">95<hr/></td>
                <td align="left" valign="bottom">44<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom">Depth median<hr/></td>
                <td align="left" valign="bottom">8<hr/></td>
                <td align="left" valign="bottom">4<hr/></td>
                <td align="left" valign="bottom">45<hr/></td>
                <td align="left" valign="bottom">879<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom">Mate distance median<hr/></td>
                <td align="left" valign="bottom">25<hr/></td>
                <td align="left" valign="bottom">5<hr/></td>
                <td align="left" valign="bottom">107<hr/></td>
                <td align="left" valign="bottom">158240<hr/></td>
              </tr>
              <tr>
                <td align="left">Number of reads</td>
                <td align="left">10613096</td>
                <td align="left">145063589</td>
                <td align="left">1357751670</td>
                <td align="left">723287936</td>
              </tr>
            </tbody>
          </table>
          <table-wrap-foot>
            <p>Characteristics of test the files used for the PC test. The depth row states the median depth over all reference bases with any coverage. The mate distance row gives the median of the distance of mates in the input file. File sizes are rounded to integer GB.</p>
          </table-wrap-foot>
        </table-wrap>
        <p>2. The low depth human data set HG00096 (see
[<xref ref-type="bibr" rid="B28">28</xref>]) from the 1000 genomes project with a depth median value of 4. We have used the BAM file as provided by the project, the size of the file is 15 GB. The median of the distance between the two ends of a template in the file is 5 (due to some outliers the weighted average is 96220). All the programs are capable of processing this file using 256 MB of memory. <monospace>bamtofastq</monospace> requires 5.3±0.04 minutes using 132 MB of memory and 5.46±0.04 minutes using 64 MB. All the other programs have a higher run-time (bam2fastq 12.7±0.14 minutes using 238 MB, bampe2fqworphans 7.3±0.15 using 32 MB, SamToFastQ 20.6±0.17 with 226 MB and bamUtil bam2fastq 10.38±0.06 using 238 MB). None of <monospace>bamtofastq</monospace> and SamToFastQ gained significantly by using more main memory. SamToFastQ fails to process the data set given 128 MB of RAM.</p>
        <p>3. The high depth human data set ERP001231 ([EMBL:ERP001231], see
[<xref ref-type="bibr" rid="B22">22</xref>]) with a median depth value of 45. This data was downloaded as FastQ and mapped to the human reference
[<xref ref-type="bibr" rid="B23">23</xref>] using the SMALT aligner
[<xref ref-type="bibr" rid="B10">10</xref>]. The resulting BAM file was sorted by coordinate using SAMtools. The median of the distance between the two ends of a template in the file is 107 but due to some very pronounced peeks and outliers in the distribution the weighted average is 1.4·10<sup>7</sup>. The size of the resulting sorted BAM file is 95 GB. <monospace>bamtofastq</monospace> was able to handle the file in 44.53±0.62 minutes and 133 MB of RAM. Using more main memory resulted in only a slight decrease in run-time (42.99±0.36 minutes using 2.44 GB). Picard ran out of memory on the file when provided with 5 GB and less of main memory. It took 497.71±5.41 minutes using 6.05 GB of RAM. The run-time drops to 180.03±2.21 minutes for 8.07 GB and further to 169.69±0.98 minutes for 12.09 GB. The high run-time of Picard using 6 GB of main memory suggests that the employed memory management gets very inefficient when the program uses most of the provided memory. For 5 GB it fails after a run time of more than 8 hours. The moderate drop of the run-time between 10 and 12 GB suggests that a further increase in memory would not lead to a significant decrease in run-time. Indeed, a comparison of the run-time on the compute farm nodes when allowing 12 and 230 GB of RAM showed a gain of less than 1 percent (the run time measured was 374.48±4.66 minutes for 12 GB and 371.76±4.58 minutes for 230 GB, in both cases no concurrency was employed for the measurement). bamUtil failed the admissibility test for this data set. It aborted with an out of memory type error. On the Xeon E7440 type machine it ran for 58 hours before producing this error. Note that even if the program would be capable of handling the data set using more memory the run-time would still exceed the 58 hour mark on the Xeon E7440 machine. This suggests conceptual problems in the approach of the program for larger data sets. bam2fastq processed the file in time 144.20±1.11 minutes using 4.35 GB of RAM, bampe2fqworphans required 97.97±1.10 minutes using 3.48 GB. Thus <monospace>bamtofastq</monospace> outperforms the other tools while using less memory on this data set.</p>
        <p>4. The high depth E. coli data set from the study SRP017681 ([EMBL:SRP017681], see
[<xref ref-type="bibr" rid="B29">29</xref>]) with a median depth value of 879. This data was also downloaded as FastQ and mapped to the respective reference genome (see
[<xref ref-type="bibr" rid="B30">30</xref>]) using SMALT. The resulting BAM file was sorted by coordinate using SAMtools. The sorted BAM file has a size of 44 GB. The median of the distance between the two ends of a template in the file is 158240, the weighted average is 1.7·10<sup>7</sup>. <monospace>bamtofastq</monospace> is able to handle this file in 37.00 ± 0.29 minutes using 206 MB of main memory. In this memory setting a large amount of reads need to be handled by resorting to temporary files on secondary storage because of the high depth of the input data. Due to this effect the run-time decreases to 24.27 ± 0.16 minutes when we let the program use 2.45 GB of memory. Picard fails with an out of memory type error when given 8 GB of main memory. Using 9.18 GB of memory it processes the file in 236.54 ± 2.75 minutes. Increasing the main memory given to 12.29G and 13.28G decreases the run time to 111.93 ± 0.82 and 97.94 ± 0.65 minutes respectively. As above for the high depth human data set ERP001231 we have checked the effects of drastically increasing the amount of available memory using the compute farm node setting. Here an increase from 13 to 230 GB resulted in a speed gain of 6.5<italic>%</italic> (we measured 213.43 ± 2.61 minutes using 13 GB and 200.59 ± 2.75 minutes using 230 GB, in both cases no concurrency was employed for the measurement). Again as for the high depth human data set bamUtil fails the admissibility test for this data set. Given a limit of 10 GB the program fails with an out of memory type error after more than 36 hours on the Xeon E7440 machine. bam2fastq processed the file in 59.53 ± 1.03 minutes using 6.56 GB of memory. bampe2fqworphans took 37.19 ± 0.36 minutes using 5.20 GB. bamtofastq outperforms the other tools in every aspect on this data set.</p>
        <p>The left column of Figure
<xref ref-type="fig" rid="F6">6</xref> shows the run-time against internal memory tradeoffs as stated above in the form of plots. The error bars on the data points depict the standard deviation for the respective value. Picard uses Java’s <monospace>HashMap</monospace> class and keeps each end in this hash table until the other end of the read is found in the file. This explains its high memory requirements. The performance is also low due to frequent object allocation and implicit deallocation (garbage collection) processes, in particular when the memory used is close to the memory given. bamUtil, bam2fastq and bampe2fqworphans are similar in the sense that they also keep data structures containing all the reads whose mates have not been seen so far. In consequence they require more memory as the size and depth of the input file grows. <monospace>bamtofastq</monospace> can handle all the given files easily with its default small memory foot print. In particular it does not require the user to adjust the input parameters to process any of the files.</p>
        <fig id="F6" position="float">
          <label>Figure 6</label>
          <caption>
            <p><bold>Run-time against memory usage plots for PC system.</bold> Plots showing run-time against space comparisons of the biobambam tools <monospace>bamtofastq</monospace> and <monospace>bammarkduplicates2</monospace> with equivalent tools on the PC system for the four data sets HG03520, HG00096, ERP0012131 and SRP017681. <monospace>bamtofastq</monospace> is compared to Picard’s SamToFastQ, bamUtil’s bam2fastq, bampe2fqworphans and bam2fastq. <monospace>bammarkduplicates2</monospace> is compared to Picard’s MarkDuplicates and bamUtil’s dedup. bamUtil failed our admissibility tests for BAM to FastQ conversion as well as duplicate marking on ERP0012131 and SRP0176 81 and is thus not contained in the respective plots.</p>
          </caption>
          <graphic xlink:href="1751-0473-9-13-6"/>
        </fig>
      </sec>
      <sec>
        <title>Marking duplicate alignments</title>
        <p>Large sets of sequenced reads often contain reads or read pairs which are not unique, i.e. such reads and read pairs which map to the same coordinates on a given reference genome. This may happen for several reasons including artefacts of library preparation (e.g. duplication by PCR), sequencing artefacts (e.g. optical duplicates) or just by chance as the selection of sequenced molecules is usually a random process. For some data sets the number of duplicate reads can be very high. In the E. coli data set SRP017681 mentioned above (see
[<xref ref-type="bibr" rid="B29">29</xref>]) for instance more than 90% of the reads are duplicates. The presence of duplicates can significantly influence downstream analysis. Thus the detection and marking of duplicates is an important step in the analysis of sequenced data. The Picard tool suite contains a program for marking duplicates in BAM files. We will in the following provide a rough description of how it works. First the program constructs a list <italic>L</italic><sub><italic>P</italic></sub> of aligned pairs and a list of aligned reads (first or second mates of pairs and single) <italic>L</italic><sub><italic>S</italic></sub> in external memory. Both lists are sorted by coordinates, where the sorting of the list <italic>L</italic><sub><italic>P</italic></sub> is lexicographic in the coordinates of the two ends (i.e. the pairs are first sorted by the leftmost mapping end and then those which have the same leftmost mapping position are sorted by the mapping coordinate of the other end). The coordinates used denote the position of the 5<sup>′</sup> end of the read on the reference (i.e. the left end position on the reference for those mapped to the forward strand and the right end position on the reference for those mapped to the reverse strand). Pseudo code for this list generation stage is shown in Figure
<xref ref-type="fig" rid="F7">7</xref>. In sorted order it is very simple to partition the lists <italic>L</italic><sub><italic>P</italic></sub> and <italic>L</italic><sub><italic>S</italic></sub> into subsets of read pairs and single reads respectively which map to the same coordinates. In each such subset a single element with the highest score computed from the base qualities of the reads is selected as representant and the other elements are considered and marked as duplicates. In addition the current code also considers single ended reads and orphans as duplicates if they map to the same coordinate as one end of a mapped pair. Pseudo code for the deduction of reads to be marked as duplicates based on the lists <italic>L</italic><sub><italic>S</italic></sub> and <italic>L</italic><sub><italic>P</italic></sub> is shown in Figures
<xref ref-type="fig" rid="F8">8</xref> and
<xref ref-type="fig" rid="F9">9</xref> respectively.</p>
        <fig id="F7" position="float">
          <label>Figure 7</label>
          <caption>
            <p><bold>Pseudo code for pair and fragment list generation in duplicate marking algorithm.</bold> Pseudo code for list generation in duplicate marking algorithm. The input parameter <italic>C</italic> denotes a collating BAM file reader whose tryPair method fills the given pair and returns <monospace>true</monospace> if this operation was successful and <monospace>false</monospace> if no more reads could be obtained. The algorithm generates the lists <italic>L</italic><sub><italic>S</italic></sub> and <italic>L</italic><sub><italic>P</italic></sub> as described in the text. We assume that the tryPair method returns an unmapped read as the second component for orphan and single end reads.</p>
          </caption>
          <graphic xlink:href="1751-0473-9-13-7"/>
        </fig>
        <fig id="F8" position="float">
          <label>Figure 8</label>
          <caption>
            <p><bold>Pseudo code for fragment duplicate marking.</bold> Pseudo code for the deduction of reads to be marked as duplicates from the list <italic>L</italic><sub><italic>S</italic></sub> as described in the text. The method getRank applied to an alignment yields the rank (line number) of the alignment in the original input BAM file.</p>
          </caption>
          <graphic xlink:href="1751-0473-9-13-8"/>
        </fig>
        <fig id="F9" position="float">
          <label>Figure 9</label>
          <caption>
            <p><bold>Pseudo code for pair duplicate marking.</bold> Pseudo code for the deduction of reads to be marked as duplicates from the list <italic>L</italic><sub><italic>P</italic></sub> as described in the text. The method getRank applied to an alignment yields the rank (line number) of the alignment in the original input BAM file.</p>
          </caption>
          <graphic xlink:href="1751-0473-9-13-9"/>
        </fig>
        <p>The dedup option in bamUtil produces the same results as Picard’s MarkDuplicates component using different data structures in RAM and without resorting to the construction of the lists <italic>L</italic><sub><italic>S</italic></sub> and <italic>L</italic><sub><italic>P</italic></sub> in external memory. If the input file is given in coordinate sorted order it is relatively easy to detect when all reads mapping to a coordinate or all read pairs mapping to a pair of coordinates have been observed during a linear scan of the file. One approach is thus to keep lists of reads in memory for single coordinates and pairs of coordinates and process these lists as soon as it is clear that no more reads will be added down stream. As this does not require a full sorting the approach is faster in practice. For some files the size of the lists which need to be kept in memory can become very large and the approach suffers from similar problems than the collation of reads by name without resorting to external memory. In biobambam we have implemented a program <monospace>bammarkduplicates2</monospace> which combines the two approaches. We keep lists in memory like bamUtil, but whenever the the number of elements stored in these lists exceeds a given threshold we flush the list with the lowest coordinate out to disk and mark the coordinate for handling in external memory. While filling the lists in RAM we use our collation by read name approach to fill the lists for read pairs. This hybrid approach gives <monospace>bammarkduplicates2</monospace> a very stable and predictable memory footprint. This is different from Picard’s MarkDuplicates tool and bamUtil’s dedup, which use a large amount of main memory for some data sets featuring high coverage in some regions or as a whole and thus are harder to handle in automated sequencing pipelines, as they sometimes require manual intervention due to out of memory type errors.</p>
      </sec>
      <sec>
        <title>Performance comparison for <monospace>bammarkduplicates2</monospace> on the PC system</title>
        <p>We have evaluated the performance of <monospace>bammark</monospace><monospace>duplicates2</monospace> in comparison to Picard’s MarkDuplicates and bamUtil’s dedup option for the same BAM files as we have used above for the BAM to FastQ evaluation on the PC system.</p>
        <p>1. The small low coverage file HG03520 is processed by <monospace>bammarkduplicates2</monospace> in 2.43±0.013 minutes using 68 MB of RAM, MarkDuplicates requires 3.57±0.02 minutes with 113 MB and bamUtil dedup 2.31±0.01 using 29 MB. <monospace>bammarkduplicates2</monospace> and MarkDuplicates do not profit from using more memory. bamUtil dedup is the fastest program for this data set and about 5% faster than <monospace>bammarkduplicates2</monospace>.</p>
        <p>2. Like the smaller file HG03520 the low depth data set HG00096 can efficiently be handled by the three programs with small amounts of heap space. <monospace>bammarkduplicates2</monospace> handles the file in 33.90±0.37 minutes using 295 MB of RAM, MarkDuplicates in 48.06±0.39s using 302 MB and bamUtil dedup in 32.83±0.20 using 356 MB. <monospace>bammarkduplicates2</monospace> and MarkDuplicates do not benefit from using more memory. For this data set bamUtil dedup outperforms <monospace>bammarkduplicates2</monospace> in speed by about 3.3<italic>%</italic>.</p>
        <p>3. <monospace>bammarkduplicates2</monospace> processes the file obtained by mapping the reads from ERP001231 as described above in 306±2.9 minutes using 453 MB of main memory. Picard is not able to handle the file using 512 MB of RAM. With 832 MB it runs for 396±3.9 minutes. For 4.06 GB the run-time slightly decreases to 381±1.9 minutes. The experience with other data sets suggests that a further increase of the memory provided for the Java virtual machine will not lead to a drastic decrease in run-time once the slope of the run-time against space curve has reached a low value. For this reason and in the light of the fact that the comparison between biobambam and Picard is already biased by the reduced amount of parallelism available for Picard due to its high memory requirements (i.e. we had to reduce the number of concurrent Picard processes to get 4 GB for a single one. As we will see later on in the paper a reduction of the number of concurrently running processes leads to a speed up of the single processes) we have not tested Picard for higher amounts of memory on this machine type. Picard’s MarkDuplicates fails to process this file on the compute farm nodes due to I/O patterns which are not compatible with the employed file system (see below), so we were not able to test it with amounts of memory exceeding 16 GB. bamUtil dedup fails the admissibility test for this data set. On the Xeon E7440 type machine given 10 GB of RAM it fails with an out of memory type error after running for more than 53 hours.</p>
        <p>4. The BAM file obtained by mapping the reads from the study SRP017681 as stated above is handled by <monospace>bammarkduplicates2</monospace> in time 152±1.1 minutes using 311 MB of main memory. The run time decreases to 138±0.89 when the main memory provided is increased to 2.54 GB. Picard’s MarkDuplicates tool is not capable of handling the file given 3 GB of memory, it aborts with an out of memory type error. Given 4.05 GB it processes the file in time 176±0.97 minutes, where as for ERP001231 this already required a reduction of the concurrently running Picard processes in comparison with biobambam, thus leading to reduced comparability. Further increasing the main memory threshold to 8.06 GB and 12.07 GB decreases its run time to 163±0.92 and 161±1.60 minutes respectively. A test on the compute farm nodes shows that there is no further run-time improvement when increasing the amount of memory available from 12 to 64 GB (we measured 291±2.75 minutes for 12 GB and 290±1.6 minutes for 64 GB using 3 parallel instances respectively). Picard’s MarkDuplicates fails to run given 96 GB of memory as it attempts to allocate an array which is too large for the JVM system (Java limits the size of a single array to 2<sup>31</sup>-<italic>O</italic>(1) for architectural reasons). bamUtil dedup does not pass the admissibility test for this data set. It fails with an out of memory type error after more than 37 hours given 10 GB on the Xeon E7440 machine.</p>
        <p>The right column of Figure
<xref ref-type="fig" rid="F6">6</xref> shows the run-time against internal memory trade offs as stated above in the form of plots. If data sets containing a large number of reads or a high sequencing depth can be ruled out, then bamUtil dedup may be a viable choice which can be expected to be a few percent faster than <monospace>bammarkduplicates2</monospace>. In settings with variable types of data which may be large or feature high depth bamUtil dedup can fail on data sets which are easily handled by <monospace>bammarkduplicates2</monospace>. Picard’s MarkDuplicates cannot keep up with <monospace>bammarkduplicates2</monospace> in both respects, run-time and RAM requirements.</p>
      </sec>
      <sec>
        <title>Performance comparison for <monospace>bamtofastq</monospace> on server blades</title>
        <p>For the comparison of program performance on server blades we have used the data sets as specified in Table
<xref ref-type="table" rid="T2">2</xref>. The files ERR239642 ([EMBL:ERR239642],
[<xref ref-type="bibr" rid="B31">31</xref>]), ERR217514 ([EMBL:ERR217514],
[<xref ref-type="bibr" rid="B32">32</xref>]), ERR196957 ([EM BL:ERR196957],
[<xref ref-type="bibr" rid="B33">33</xref>]), ERR328876 ([EMBL:ERR328876],
[<xref ref-type="bibr" rid="B34">34</xref>]), ERR054938 ([EMBL:ERR054938],
[<xref ref-type="bibr" rid="B35">35</xref>]) and ERR328190 ([EMBL:ERR328190],
[<xref ref-type="bibr" rid="B36">36</xref>]) which were used in addition to the sets benchmarked on the PC system are all available as BAM files from the ENA web site. The set of data sets contains a large spectrum of file characteristics from small to very large files and from low to very high sequencing depth. The run-time and memory comparisons can be found in Tables
<xref ref-type="table" rid="T3">3</xref> and
<xref ref-type="table" rid="T4">4</xref>. bamUtil’s bam2fastq failed on the files ERR328876, ERR328190, SRP017681 and ERP001231 as it did not finish within the 24 hour limit. <monospace>bamtofastq</monospace> with default settings is the fastest program for all sets but SRP017681, where bampe2fqworphans is faster. When the memory usage of <monospace>bamtofastq</monospace> is increased to 2.5 GB, which is still smaller than the 5.2 GB used by bampe2fqworphans, then <monospace>bamtofastq</monospace> is also the fastest for this data set. The lower performance of <monospace>bamtofastq</monospace> with default settings can be attributed to the higher amount of data written to temporary files for this high depth input file. The influence of this effect on the server blades is more prominent than on the PC system due to the fast temporary space on the PC. As Picard runs in a Java virtual machine the memory stated in Tables
<xref ref-type="table" rid="T3">3</xref> and
<xref ref-type="table" rid="T4">4</xref> is generally more than the program would require as a minimum. For the data sets ERR328190 and SRP017681 the amount of memory used by Picard was close to the amount we have provided. For this reason we have determined the possible gains in speed by providing additional memory. We have run Picard on the data sets without concurrency using 16 and 230 GB of memory. For both data sets the speed up obtained was marginal (see Tables
<xref ref-type="table" rid="T3">3</xref> and
<xref ref-type="table" rid="T4">4</xref>).</p>
        <table-wrap position="float" id="T2">
          <label>Table 2</label>
          <caption>
            <p>Characteristics of test files used for compute farm test</p>
          </caption>
          <table frame="hsides" rules="groups" border="1">
            <colgroup>
              <col align="left"/>
              <col align="center"/>
              <col align="center"/>
              <col align="center"/>
              <col align="center"/>
            </colgroup>
            <thead valign="top">
              <tr>
                <th colspan="5" align="center" valign="bottom">
                  <bold>Test file characteristics of files used for compute farm</bold>
                  <hr/>
                </th>
              </tr>
              <tr>
                <th align="left">
                  <bold>Name</bold>
                </th>
                <th align="left">
                  <bold>File size/GB</bold>
                </th>
                <th align="left">
                  <bold>Depth</bold>
                </th>
                <th align="left">
                  <bold>Mate distance</bold>
                </th>
                <th align="left">
                  <bold>Number of reads</bold>
                </th>
              </tr>
            </thead>
            <tbody valign="top">
              <tr>
                <td align="left" valign="bottom">HG03520<hr/></td>
                <td align="left" valign="bottom">1<hr/></td>
                <td align="left" valign="bottom">8<hr/></td>
                <td align="left" valign="bottom">25<hr/></td>
                <td align="left" valign="bottom">10613096<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom">ERR239642<hr/></td>
                <td align="left" valign="bottom">2<hr/></td>
                <td align="left" valign="bottom">1<hr/></td>
                <td align="left" valign="bottom">3<hr/></td>
                <td align="left" valign="bottom">20024712<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom">ERR217514<hr/></td>
                <td align="left" valign="bottom">5<hr/></td>
                <td align="left" valign="bottom">2<hr/></td>
                <td align="left" valign="bottom">4<hr/></td>
                <td align="left" valign="bottom">49993736<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom">ERR196957<hr/></td>
                <td align="left" valign="bottom">7<hr/></td>
                <td align="left" valign="bottom">1<hr/></td>
                <td align="left" valign="bottom">148<hr/></td>
                <td align="left" valign="bottom">99923268<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom">HG00096<hr/></td>
                <td align="left" valign="bottom">15<hr/></td>
                <td align="left" valign="bottom">4<hr/></td>
                <td align="left" valign="bottom">5<hr/></td>
                <td align="left" valign="bottom">145063589<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom">ERR328876<hr/></td>
                <td align="left" valign="bottom">33<hr/></td>
                <td align="left" valign="bottom">12<hr/></td>
                <td align="left" valign="bottom">46<hr/></td>
                <td align="left" valign="bottom">359486910<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom">ERR054938<hr/></td>
                <td align="left" valign="bottom">32<hr/></td>
                <td align="left" valign="bottom">10<hr/></td>
                <td align="left" valign="bottom">30<hr/></td>
                <td align="left" valign="bottom">427080966<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom">ERR328190<hr/></td>
                <td align="left" valign="bottom">36<hr/></td>
                <td align="left" valign="bottom">14<hr/></td>
                <td align="left" valign="bottom">63<hr/></td>
                <td align="left" valign="bottom">427700148<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom">SRP017681<hr/></td>
                <td align="left" valign="bottom">44<hr/></td>
                <td align="left" valign="bottom">890<hr/></td>
                <td align="left" valign="bottom">158240<hr/></td>
                <td align="left" valign="bottom">723287936<hr/></td>
              </tr>
              <tr>
                <td align="left">ERP001231</td>
                <td align="left">95</td>
                <td align="left">45</td>
                <td align="left">107</td>
                <td align="left">1357751670</td>
              </tr>
            </tbody>
          </table>
          <table-wrap-foot>
            <p>Characteristics of test files used for compute farm test. The depth column states the median depth over all reference bases with any coverage. The mate distance column gives the median of the distance of mates in the input file. File sizes are rounded to integer GB.</p>
          </table-wrap-foot>
        </table-wrap>
        <table-wrap position="float" id="T3">
          <label>Table 3</label>
          <caption>
            <p>
              <bold>Run-time comparison of </bold>
              <monospace>
                <bold>bamtofastq</bold>
              </monospace>
              <bold> and alternatives on compute farm nodes (part a)</bold>
            </p>
          </caption>
          <table frame="hsides" rules="groups" border="1">
            <colgroup>
              <col align="left"/>
              <col align="center"/>
              <col align="center"/>
              <col align="center"/>
            </colgroup>
            <thead valign="top">
              <tr>
                <th colspan="4" align="center" valign="bottom">
                  <bold>Run-time comparison for BAM to FastQ conversion on server blades</bold>
                  <hr/>
                </th>
              </tr>
              <tr>
                <th align="left">
                  <bold>Data set</bold>
                </th>
                <th align="left">
                  <bold>Program</bold>
                </th>
                <th align="left">
                  <bold>Memory/GB</bold>
                </th>
                <th align="left">
                  <bold>Run-time/minutes</bold>
                </th>
              </tr>
            </thead>
            <tbody valign="top">
              <tr>
                <td align="left" valign="bottom">HG03520<hr/></td>
                <td align="left" valign="bottom">biobambam<hr/></td>
                <td align="left" valign="bottom">0.11<hr/></td>
                <td align="left" valign="bottom">0.86±0.08<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom"> <hr/></td>
                <td align="left" valign="bottom">bam2fastq<hr/></td>
                <td align="left" valign="bottom">0.017<hr/></td>
                <td align="left" valign="bottom">1.98±0.097<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom"> <hr/></td>
                <td align="left" valign="bottom">bampe2fqworphans<hr/></td>
                <td align="left" valign="bottom">0.0092<hr/></td>
                <td align="left" valign="bottom">1.18±0.15<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom"> <hr/></td>
                <td align="left" valign="bottom">Picard<hr/></td>
                <td align="left" valign="bottom">0.62<hr/></td>
                <td align="left" valign="bottom">3.86±0.23<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom"> <hr/></td>
                <td align="left" valign="bottom">bamUtil<hr/></td>
                <td align="left" valign="bottom">0.028<hr/></td>
                <td align="left" valign="bottom">1.67±0.24<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom">ERR239642<hr/></td>
                <td align="left" valign="bottom">biobambam<hr/></td>
                <td align="left" valign="bottom">0.13<hr/></td>
                <td align="left" valign="bottom">1.55±0.15<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom"> <hr/></td>
                <td align="left" valign="bottom">bam2fastq<hr/></td>
                <td align="left" valign="bottom">0.033<hr/></td>
                <td align="left" valign="bottom">3.89±0.12<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom"> <hr/></td>
                <td align="left" valign="bottom">bampe2fqworphans<hr/></td>
                <td align="left" valign="bottom">0.026<hr/></td>
                <td align="left" valign="bottom">2.49±0.12<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom"> <hr/></td>
                <td align="left" valign="bottom">Picard<hr/></td>
                <td align="left" valign="bottom">0.76<hr/></td>
                <td align="left" valign="bottom">7.45±0.27<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom"> <hr/></td>
                <td align="left" valign="bottom">bamUtil<hr/></td>
                <td align="left" valign="bottom">0.12<hr/></td>
                <td align="left" valign="bottom">30.92±0.92<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom">ERR217514<hr/></td>
                <td align="left" valign="bottom">biobambam<hr/></td>
                <td align="left" valign="bottom">0.13<hr/></td>
                <td align="left" valign="bottom">3.86±0.27<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom"> <hr/></td>
                <td align="left" valign="bottom">bam2fastq<hr/></td>
                <td align="left" valign="bottom">0.080<hr/></td>
                <td align="left" valign="bottom">9.52±0.35<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom"> <hr/></td>
                <td align="left" valign="bottom">bampe2fqworphans<hr/></td>
                <td align="left" valign="bottom">0.065<hr/></td>
                <td align="left" valign="bottom">6.07±0.075<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom"> <hr/></td>
                <td align="left" valign="bottom">Picard<hr/></td>
                <td align="left" valign="bottom">0.95<hr/></td>
                <td align="left" valign="bottom">18.83±0.44<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom"> <hr/></td>
                <td align="left" valign="bottom">bamUtil<hr/></td>
                <td align="left" valign="bottom">0.36<hr/></td>
                <td align="left" valign="bottom">295.12±4.43<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom">ERR196957<hr/></td>
                <td align="left" valign="bottom">biobambam<hr/></td>
                <td align="left" valign="bottom">0.13<hr/></td>
                <td align="left" valign="bottom">6.17±0.37<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom"> <hr/></td>
                <td align="left" valign="bottom">bam2fastq<hr/></td>
                <td align="left" valign="bottom">0.13<hr/></td>
                <td align="left" valign="bottom">17.74±0.45<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom"> <hr/></td>
                <td align="left" valign="bottom">bampe2fqworphans<hr/></td>
                <td align="left" valign="bottom">0.11<hr/></td>
                <td align="left" valign="bottom">11.63±0.30<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom"> <hr/></td>
                <td align="left" valign="bottom">Picard<hr/></td>
                <td align="left" valign="bottom">1.14<hr/></td>
                <td align="left" valign="bottom">33.99±0.79<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom"> <hr/></td>
                <td align="left" valign="bottom">bamUtil<hr/></td>
                <td align="left" valign="bottom">0.68<hr/></td>
                <td align="left" valign="bottom">758.39±8.35<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom">HG00096<hr/></td>
                <td align="left" valign="bottom">biobambam<hr/></td>
                <td align="left" valign="bottom">0.13<hr/></td>
                <td align="left" valign="bottom">11.71±0.28<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom"> <hr/></td>
                <td align="left" valign="bottom">bam2fastq<hr/></td>
                <td align="left" valign="bottom">0.23<hr/></td>
                <td align="left" valign="bottom">29.71±0.47<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom"> <hr/></td>
                <td align="left" valign="bottom">bampe2fqworphans<hr/></td>
                <td align="left" valign="bottom">0.032<hr/></td>
                <td align="left" valign="bottom">16.87±0.22<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom"> <hr/></td>
                <td align="left" valign="bottom">Picard<hr/></td>
                <td align="left" valign="bottom">1.01<hr/></td>
                <td align="left" valign="bottom">55.24±1.29<hr/></td>
              </tr>
              <tr>
                <td align="left"> </td>
                <td align="left">bamUtil</td>
                <td align="left">0.23</td>
                <td align="left">25.50±1.14</td>
              </tr>
            </tbody>
          </table>
          <table-wrap-foot>
            <p>Run-time comparison of biobambam’s <monospace><bold>bamtofastq</bold></monospace>, bam2fastq, bampe2fqworphans, Picard’s SamToFastQ and bamUtil’s bam2fastq for the data sets HG03520, ERR239642, ERR217514, ERR196957 and HG00096 described in Table
<xref ref-type="table" rid="T2">2</xref> on compute farm nodes.</p>
          </table-wrap-foot>
        </table-wrap>
        <table-wrap position="float" id="T4">
          <label>Table 4</label>
          <caption>
            <p>
              <bold>Run-time comparison of </bold>
              <monospace>
                <bold>bamtofastq</bold>
              </monospace>
              <bold> and alternatives on compute farm nodes (part b)</bold>
            </p>
          </caption>
          <table frame="hsides" rules="groups" border="1">
            <colgroup>
              <col align="left"/>
              <col align="center"/>
              <col align="center"/>
              <col align="center"/>
            </colgroup>
            <thead valign="top">
              <tr>
                <th colspan="4" align="center" valign="bottom">
                  <bold>Run-time comparison for BAM to FastQ conversion on server blades</bold>
                  <hr/>
                </th>
              </tr>
              <tr>
                <th align="left">
                  <bold>Data set</bold>
                </th>
                <th align="left">
                  <bold>Program</bold>
                </th>
                <th align="left">
                  <bold>Memory/GB</bold>
                </th>
                <th align="left">
                  <bold>Run-time/minutes</bold>
                </th>
              </tr>
            </thead>
            <tbody valign="top">
              <tr>
                <td align="left" valign="bottom">ERR328876<hr/></td>
                <td align="left" valign="bottom">biobambam<hr/></td>
                <td align="left" valign="bottom">0.13<hr/></td>
                <td align="left" valign="bottom">26.90±0.49<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom"> <hr/></td>
                <td align="left" valign="bottom">bam2fastq<hr/></td>
                <td align="left" valign="bottom">0.85<hr/></td>
                <td align="left" valign="bottom">74.55±0.60<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom"> <hr/></td>
                <td align="left" valign="bottom">bampe2fqworphans<hr/></td>
                <td align="left" valign="bottom">0.70<hr/></td>
                <td align="left" valign="bottom">51.10±0.61<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom"> <hr/></td>
                <td align="left" valign="bottom">Picard<hr/></td>
                <td align="left" valign="bottom">4.95<hr/></td>
                <td align="left" valign="bottom">137.98±1.58<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom"> <hr/></td>
                <td align="left" valign="bottom">bamUtil<hr/></td>
                <td align="left" valign="bottom"> <hr/></td>
                <td align="left" valign="bottom">≥1440<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom">ERR054938<hr/></td>
                <td align="left" valign="bottom">biobambam<hr/></td>
                <td align="left" valign="bottom">0.13<hr/></td>
                <td align="left" valign="bottom">29.42±0.57<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom"> <hr/></td>
                <td align="left" valign="bottom">bam2fastq<hr/></td>
                <td align="left" valign="bottom">0.98<hr/></td>
                <td align="left" valign="bottom">76.15±1.54<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom"> <hr/></td>
                <td align="left" valign="bottom">bampe2fqworphans<hr/></td>
                <td align="left" valign="bottom">0.84<hr/></td>
                <td align="left" valign="bottom">50.8±0.62<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom"> <hr/></td>
                <td align="left" valign="bottom">Picard<hr/></td>
                <td align="left" valign="bottom">6.69<hr/></td>
                <td align="left" valign="bottom">152.62±1.06<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom"> <hr/></td>
                <td align="left" valign="bottom">bamUtil<hr/></td>
                <td align="left" valign="bottom">6.13<hr/></td>
                <td align="left" valign="bottom">440.8±5.68<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom">ERR328190<hr/></td>
                <td align="left" valign="bottom">biobambam<hr/></td>
                <td align="left" valign="bottom">0.13<hr/></td>
                <td align="left" valign="bottom">51.70±0.60<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom"> <hr/></td>
                <td align="left" valign="bottom">bam2fastq<hr/></td>
                <td align="left" valign="bottom">4.21<hr/></td>
                <td align="left" valign="bottom">106.73±0.45<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom"> <hr/></td>
                <td align="left" valign="bottom">bampe2fqworphans<hr/></td>
                <td align="left" valign="bottom">3.45<hr/></td>
                <td align="left" valign="bottom">74.71±0.87<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom"> <hr/></td>
                <td align="left" valign="bottom">Picard<hr/></td>
                <td align="left" valign="bottom">16.12<hr/></td>
                <td align="left" valign="bottom">170.88±1.07<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom"> <hr/></td>
                <td align="left" valign="bottom">Picard<sub>1,16</sub><hr/></td>
                <td align="left" valign="bottom">16.12<hr/></td>
                <td align="left" valign="bottom">123.10±8.04<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom"> <hr/></td>
                <td align="left" valign="bottom">Picard<sub>1,230</sub><hr/></td>
                <td align="left" valign="bottom">30.94<hr/></td>
                <td align="left" valign="bottom">120.06±8.64<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom"> <hr/></td>
                <td align="left" valign="bottom">bamUtil<hr/></td>
                <td align="left" valign="bottom"> <hr/></td>
                <td align="left" valign="bottom">≥1440<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom">SRP017681<hr/></td>
                <td align="left" valign="bottom">biobambam<sub>18</sub><hr/></td>
                <td align="left" valign="bottom">0.18<hr/></td>
                <td align="left" valign="bottom">137.21±1.17<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom"> <hr/></td>
                <td align="left" valign="bottom">biobambam<sub>23</sub><hr/></td>
                <td align="left" valign="bottom">2.45<hr/></td>
                <td align="left" valign="bottom">61.49±0.68<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom"> <hr/></td>
                <td align="left" valign="bottom">bam2fastq<hr/></td>
                <td align="left" valign="bottom">6.56<hr/></td>
                <td align="left" valign="bottom">153.85±1.74<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom"> <hr/></td>
                <td align="left" valign="bottom">bampe2fqworphans<hr/></td>
                <td align="left" valign="bottom">5.20<hr/></td>
                <td align="left" valign="bottom">91.83±0.49<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom"> <hr/></td>
                <td align="left" valign="bottom">Picard<hr/></td>
                <td align="left" valign="bottom">16.10<hr/></td>
                <td align="left" valign="bottom">261.24±3.05<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom"> <hr/></td>
                <td align="left" valign="bottom">Picard<sub>1,16</sub><hr/></td>
                <td align="left" valign="bottom">16.10<hr/></td>
                <td align="left" valign="bottom">200.63±2.61<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom"> <hr/></td>
                <td align="left" valign="bottom">Picard<sub>1,230</sub><hr/></td>
                <td align="left" valign="bottom">28.45<hr/></td>
                <td align="left" valign="bottom">200.60±2.74<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom"> <hr/></td>
                <td align="left" valign="bottom">bamUtil<hr/></td>
                <td align="left" valign="bottom"> <hr/></td>
                <td align="left" valign="bottom">≥1440<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom">ERP001231<hr/></td>
                <td align="left" valign="bottom">biobambam<hr/></td>
                <td align="left" valign="bottom">0.13<hr/></td>
                <td align="left" valign="bottom">111.52±0.77<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom"> <hr/></td>
                <td align="left" valign="bottom">bam2fastq<hr/></td>
                <td align="left" valign="bottom">4.35<hr/></td>
                <td align="left" valign="bottom">349.38±1.18<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom"> <hr/></td>
                <td align="left" valign="bottom">bampe2fqworphans<hr/></td>
                <td align="left" valign="bottom">3.48<hr/></td>
                <td align="left" valign="bottom">229.80±1.30<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom"> <hr/></td>
                <td align="left" valign="bottom">Picard<hr/></td>
                <td align="left" valign="bottom">14.81<hr/></td>
                <td align="left" valign="bottom">489.11±4.40<hr/></td>
              </tr>
              <tr>
                <td align="left"> </td>
                <td align="left">bamUtil</td>
                <td align="left"> </td>
                <td align="left">≥1440</td>
              </tr>
            </tbody>
          </table>
          <table-wrap-foot>
            <p>Run-time comparison of biobambam’s <monospace>bamtofastq</monospace>, bam2fastq, bampe2fqworphans, Picard’s SamToFastQ and bamUtil’s bam2fastq for the data sets ERR328876, ERR054938, ERR328190, SRP017681 and ERP001231 described in Table
<xref ref-type="table" rid="T2">2</xref> on compute farm nodes. For the data set SRP017681 <monospace>bamtofastq</monospace> was run with a default hash table size of 2<sup>18</sup> and an increased size of 2<sup>23</sup> for comparison. bamUtil dedup failed to process the data sets ERR328876, ERR328190, SRP017681 and ERP001231 within the 24 hour limit. Picard used close to 16 GB of memory for the data sets ERR328190 and SRP017681. We have verified that no significant speed ups can be obtained by allowing more memory in a reduced concurrency setting, where we have run only a single process at a time using 16 or 230 GB of memory on an otherwise idle machine. For both data sets the maximum amount of memory used by Picard when provided with 230 GB was significantly less than what was available.</p>
          </table-wrap-foot>
        </table-wrap>
      </sec>
      <sec>
        <title>Performance comparison for <monospace>bammarkduplicates2</monospace> on server blades</title>
        <p>We have used the same data sets for comparing <monospace>bammarkduplicates2</monospace> on server blades as we have used for the comparisons concerning <monospace>bamtofastq</monospace>. As on the PC system we have compared with bamUtil’s dedup option and Picard’s MarkDuplicates program. The run-time comparisons are shown in the Tables
<xref ref-type="table" rid="T5">5</xref> and
<xref ref-type="table" rid="T6">6</xref>. <monospace>bammarkduplicates2</monospace> was the only of the programs which was capable of handling all the input files. bamUtil dedup failed on the files SRP017681 and ERP001231. For SRP017681 its run-time exceeded 24 hours, for ERP001231 it required more than 24 GB of memory. It is capable of processing the file ERP001231 with more memory (see Table
<xref ref-type="table" rid="T6">6</xref>) when the number of concurrently running processes is reduced from 10 to 8 and in consequence the amount of memory available per instance is higher. However the run-time obtained in this way is not competitive with biobambam. Picard’s MarkDuplicates failed to process the files ERR328190 and ERP001231, in both cases the run-time of the program exceeded 24 hours. For both files Picard was suffering from file access patterns which are very inefficient on the employed Lustre file system. A system call trace showed a very large number of small write operations with as little as a single byte per call. On the lower depth files HG03520, ERR239642, ERR217514, HG00096 and ERR328876 the average run-time of bamUtil dedup is slightly lower than the run-time of <monospace>bammarkduplicates2</monospace>. However the difference between the two programs is small for the two programs at a maximum of 5.2<italic>%</italic> on the smallest file HG03520 and even lower for the other files. For most of these cases (all but ERR328876) the confidence intervals for the run-time of the two programs overlap. For the files ERR196957, ERR054938, ERR328190 and ERP001231 <monospace>bammarkduplicates2</monospace> has the lowest average run-time using its default settings where for ERR196957 the confidence interval overlaps with bamUtil dedup. Picard MarkDuplicates is slightly (7%) faster than <monospace>bammarkduplicates2</monospace> running with default settings for the file SRP017681, but this changes when <monospace>bammarkduplicates2</monospace> is allowed to use more memory than by default. In summary <monospace>bammarkduplicates2</monospace> is the only program which is capable of handling all the files within the given limits of 24 hours and 24 GB of memory. bamUtil dedup has a slight run-time advantage of up to 5% for small and low depth larger files but fails for more complex higher depth files. Picard is consistently slower than <monospace>bammarkduplicates2</monospace> with default settings on all files but SRP017681 and slower on all files when the amount of used memory is at the same level. Some files trigger input/output patterns in Picard which are not suitable for network file systems. As Picard used close to all of the memory provided for some of the data sets, we have verified that no speed ups were available through the usage of more memory (see Table
<xref ref-type="table" rid="T6">6</xref>). This involved a reduction of the number of concurrently running instances from 10 to 3, where we increased the amount of available memory per process to 64 from 16 GB (as mentioned above Picard duplicate marking fails when given too much memory. In our setting 96 GB qualified as too much).</p>
        <table-wrap position="float" id="T5">
          <label>Table 5</label>
          <caption>
            <p>
              <bold>Run-time comparison of </bold>
              <monospace>
                <bold>bammarkduplicates2</bold>
              </monospace>
              <bold> and alternatives on compute farm nodes (part a)</bold>
            </p>
          </caption>
          <table frame="hsides" rules="groups" border="1">
            <colgroup>
              <col align="left"/>
              <col align="center"/>
              <col align="center"/>
              <col align="center"/>
            </colgroup>
            <thead valign="top">
              <tr>
                <th colspan="4" align="center" valign="bottom">
                  <bold>Run-time comparison for BAM duplicate marking on server blades</bold>
                  <hr/>
                </th>
              </tr>
              <tr>
                <th align="left">
                  <bold>Data set</bold>
                </th>
                <th align="left">
                  <bold>Program</bold>
                </th>
                <th align="left">
                  <bold>Memory/GB</bold>
                </th>
                <th align="left">
                  <bold>Run-time/minutes</bold>
                </th>
              </tr>
            </thead>
            <tbody valign="top">
              <tr>
                <td align="left" valign="bottom">HG03520<hr/></td>
                <td align="left" valign="bottom">biobambam<hr/></td>
                <td align="left" valign="bottom">0.33<hr/></td>
                <td align="left" valign="bottom">5.86±0.42<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom"> <hr/></td>
                <td align="left" valign="bottom">Picard<hr/></td>
                <td align="left" valign="bottom">7.96<hr/></td>
                <td align="left" valign="bottom">13.80±0.18<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom"> <hr/></td>
                <td align="left" valign="bottom">bamUtil<hr/></td>
                <td align="left" valign="bottom">0.030<hr/></td>
                <td align="left" valign="bottom">5.57±0.37<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom">ERR239642<hr/></td>
                <td align="left" valign="bottom">biobambam<hr/></td>
                <td align="left" valign="bottom">0.37<hr/></td>
                <td align="left" valign="bottom">13.37±0.51<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom"> <hr/></td>
                <td align="left" valign="bottom">Picard<hr/></td>
                <td align="left" valign="bottom">9.26<hr/></td>
                <td align="left" valign="bottom">26.25±0.30<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom"> <hr/></td>
                <td align="left" valign="bottom">bamUtil<hr/></td>
                <td align="left" valign="bottom">0.092<hr/></td>
                <td align="left" valign="bottom">13.18±0.35<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom">ERR217514<hr/></td>
                <td align="left" valign="bottom">biobambam<hr/></td>
                <td align="left" valign="bottom">0.39<hr/></td>
                <td align="left" valign="bottom">34.22±0.58<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom"> <hr/></td>
                <td align="left" valign="bottom">Picard<hr/></td>
                <td align="left" valign="bottom">13.15<hr/></td>
                <td align="left" valign="bottom">46.15±0.61<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom"> <hr/></td>
                <td align="left" valign="bottom">bamUtil<hr/></td>
                <td align="left" valign="bottom">0.19<hr/></td>
                <td align="left" valign="bottom">33.85±0.53<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom">ERR196957<hr/></td>
                <td align="left" valign="bottom">biobambam<hr/></td>
                <td align="left" valign="bottom">0.45<hr/></td>
                <td align="left" valign="bottom">52.43±0.92<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom"> <hr/></td>
                <td align="left" valign="bottom">Picard<hr/></td>
                <td align="left" valign="bottom">11.53<hr/></td>
                <td align="left" valign="bottom">90.74±1.00<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom"> <hr/></td>
                <td align="left" valign="bottom">bamUtil<hr/></td>
                <td align="left" valign="bottom">0.47<hr/></td>
                <td align="left" valign="bottom">52.45±1.56<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom">HG00096<hr/></td>
                <td align="left" valign="bottom">biobambam<hr/></td>
                <td align="left" valign="bottom">0.43<hr/></td>
                <td align="left" valign="bottom">78.76±0.99<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom"> <hr/></td>
                <td align="left" valign="bottom">Picard<hr/></td>
                <td align="left" valign="bottom">13.95<hr/></td>
                <td align="left" valign="bottom">126.64±1.37<hr/></td>
              </tr>
              <tr>
                <td align="left"> </td>
                <td align="left">bamUtil</td>
                <td align="left">0.35</td>
                <td align="left">76.18±1.96</td>
              </tr>
            </tbody>
          </table>
          <table-wrap-foot>
            <p>Run-time comparison of biobambam’s <monospace>bammarkduplicates2</monospace>, Picard’s MarkDuplicates and bamUtil’s dedup for the data sets HG03520, ERR239642, ERR217514, ERR196957 and HG00096 described in Table
<xref ref-type="table" rid="T2">2</xref> on compute farm nodes.</p>
          </table-wrap-foot>
        </table-wrap>
        <table-wrap position="float" id="T6">
          <label>Table 6</label>
          <caption>
            <p>
              <bold>Run-time comparison of </bold>
              <monospace>
                <bold>bammarkduplicates2</bold>
              </monospace>
              <bold> and alternatives on compute farm nodes (part b)</bold>
            </p>
          </caption>
          <table frame="hsides" rules="groups" border="1">
            <colgroup>
              <col align="left"/>
              <col align="center"/>
              <col align="center"/>
              <col align="center"/>
            </colgroup>
            <thead valign="top">
              <tr>
                <th colspan="4" align="center" valign="bottom">
                  <bold>Run-time comparison for BAM duplicate marking on server blades</bold>
                  <hr/>
                </th>
              </tr>
              <tr>
                <th align="left">
                  <bold>Data set</bold>
                </th>
                <th align="left">
                  <bold>Program</bold>
                </th>
                <th align="left">
                  <bold>Memory/GB</bold>
                </th>
                <th align="left">
                  <bold>Run-time/minutes</bold>
                </th>
              </tr>
            </thead>
            <tbody valign="top">
              <tr>
                <td align="left" valign="bottom">ERR328876<hr/></td>
                <td align="left" valign="bottom">biobambam<hr/></td>
                <td align="left" valign="bottom">0.45<hr/></td>
                <td align="left" valign="bottom">212.38±2.22<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom"> <hr/></td>
                <td align="left" valign="bottom">Picard<hr/></td>
                <td align="left" valign="bottom">15.74<hr/></td>
                <td align="left" valign="bottom">443.66±1.77<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom"> <hr/></td>
                <td align="left" valign="bottom">Picard<sub>3,16</sub><hr/></td>
                <td align="left" valign="bottom">15.74<hr/></td>
                <td align="left" valign="bottom">253.92±1.67<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom"> <hr/></td>
                <td align="left" valign="bottom">Picard<sub>3,64</sub><hr/></td>
                <td align="left" valign="bottom">52.41<hr/></td>
                <td align="left" valign="bottom">252.21±1.11<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom"> <hr/></td>
                <td align="left" valign="bottom">bamUtil<hr/></td>
                <td align="left" valign="bottom">1.20<hr/></td>
                <td align="left" valign="bottom">207.29±2.33<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom">ERR054938<hr/></td>
                <td align="left" valign="bottom">biobambam<hr/></td>
                <td align="left" valign="bottom">0.45<hr/></td>
                <td align="left" valign="bottom">210.16±2.62<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom"> <hr/></td>
                <td align="left" valign="bottom">Picard<hr/></td>
                <td align="left" valign="bottom">15.87<hr/></td>
                <td align="left" valign="bottom">575.35±3.07<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom"> <hr/></td>
                <td align="left" valign="bottom">Picard<sub>3,16</sub><hr/></td>
                <td align="left" valign="bottom">15.87<hr/></td>
                <td align="left" valign="bottom">287.02±2.19<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom"> <hr/></td>
                <td align="left" valign="bottom">Picard<sub>3,64</sub><hr/></td>
                <td align="left" valign="bottom">54.87<hr/></td>
                <td align="left" valign="bottom">285.06±1.27<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom"> <hr/></td>
                <td align="left" valign="bottom">bamUtil<hr/></td>
                <td align="left" valign="bottom">7.12<hr/></td>
                <td align="left" valign="bottom">401.90±1.92<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom">ERR328190<hr/></td>
                <td align="left" valign="bottom">biobambam<hr/></td>
                <td align="left" valign="bottom">0.45<hr/></td>
                <td align="left" valign="bottom">289.00±2.34<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom"> <hr/></td>
                <td align="left" valign="bottom">Picard<hr/></td>
                <td align="left" valign="bottom"> <hr/></td>
                <td align="left" valign="bottom">≥1440<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom"> <hr/></td>
                <td align="left" valign="bottom">bamUtil<hr/></td>
                <td align="left" valign="bottom">16.73<hr/></td>
                <td align="left" valign="bottom">914.81±6.16<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom">SRP017681<hr/></td>
                <td align="left" valign="bottom">biobambam<sub>20</sub><hr/></td>
                <td align="left" valign="bottom">0.45<hr/></td>
                <td align="left" valign="bottom">388.82±2.57<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom"> <hr/></td>
                <td align="left" valign="bottom">biobambam<sub>24</sub><hr/></td>
                <td align="left" valign="bottom">6.31<hr/></td>
                <td align="left" valign="bottom">332.38±3.32<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom"> <hr/></td>
                <td align="left" valign="bottom">Picard<hr/></td>
                <td align="left" valign="bottom">15.90<hr/></td>
                <td align="left" valign="bottom">363.18±2.63<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom"> <hr/></td>
                <td align="left" valign="bottom">Picard<sub>3,16</sub><hr/></td>
                <td align="left" valign="bottom">15.90<hr/></td>
                <td align="left" valign="bottom">288.95±1.32<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom"> <hr/></td>
                <td align="left" valign="bottom">Picard<sub>3,64</sub><hr/></td>
                <td align="left" valign="bottom">63.39<hr/></td>
                <td align="left" valign="bottom">290.72±1.62<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom"> <hr/></td>
                <td align="left" valign="bottom">bamUtil<hr/></td>
                <td align="left" valign="bottom"> <hr/></td>
                <td align="left" valign="bottom">≥1400<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom">ERP001231<hr/></td>
                <td align="left" valign="bottom">biobambam<hr/></td>
                <td align="left" valign="bottom">0.45<hr/></td>
                <td align="left" valign="bottom">729.98±3.36<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom"> <hr/></td>
                <td align="left" valign="bottom">biobambam<sub>8</sub><hr/></td>
                <td align="left" valign="bottom">0.45<hr/></td>
                <td align="left" valign="bottom">674.99±11.93<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom"> <hr/></td>
                <td align="left" valign="bottom">Picard<hr/></td>
                <td align="left" valign="bottom"> <hr/></td>
                <td align="left" valign="bottom">≥1440<hr/></td>
              </tr>
              <tr>
                <td align="left" valign="bottom"> <hr/></td>
                <td align="left" valign="bottom">bamUtil<hr/></td>
                <td align="left" valign="bottom">≥22.35<hr/></td>
                <td align="left" valign="bottom"> <hr/></td>
              </tr>
              <tr>
                <td align="left"> </td>
                <td align="left">bamUtil<sub>8</sub></td>
                <td align="left">23.85</td>
                <td align="left">916.62±4.71</td>
              </tr>
            </tbody>
          </table>
          <table-wrap-foot>
            <p>Run-time comparison of biobambam’s <monospace>bammarkduplicates2</monospace>, Picard’s MarkDuplicates and bamUtil’s dedup for the data sets ERR328876, ERR054938, ERR328190, SRP017681 and ERP001231 described in Table
<xref ref-type="table" rid="T2">2</xref> on compute farm nodes. For the data set SRP017681 <monospace>bammarkduplicates2</monospace> was run with a default hash table size of 2<sup>20</sup> and an increased size of 2<sup>24</sup> for comparison. For ERP001231 bamUtil was only capable of processing the file using 23.85 <italic>GB</italic><bold><italic>≈</italic></bold> 25.6 · 10<sup>9</sup><bold><italic>≥</italic></bold> 24 · 10<sup>9</sup> bytes of memory. In consequence we needed to reduce the number of concurrently running processes. We have reduced it to 8 instead of 10. For comparison the table also contains the run-time of <monospace>bammarkduplicates2</monospace> for 8 instances running in parallel. Picard failed to process the data sets ERR328190 and ERP001231 within the 24 hour limit due to inefficient I/O. We have verified that these issues persist for larger amounts of memory. Picard used close to the offered 16 GB of memory for the data sets ERR328876, ERR054938 and SRP017681. We have verified that no significant improvement in speed was available through the usage of more memory. For this purpose we have run Picard on these data sets with 16 and 64 GB of memory with a reduced concurrency of 3 parallel running identical processes.</p>
          </table-wrap-foot>
        </table-wrap>
      </sec>
      <sec>
        <title>Dependence of BAM to FastQ conversion time on the number of concurrently running instances</title>
        <p>We have used the files HG03520 and HG00096 as described above (see Table
<xref ref-type="table" rid="T1">1</xref>) to determine how the number of concurrently running program instances changes the run-time of our test programs in BAM to FastQ conversion. As above we have tested biobambam’s <monospace>bamtofastq</monospace>, Picard’s SamToFastq, bamUtil’s bam2fastq module, bampe2fqworphans and bam2fastq. Figure
<xref ref-type="fig" rid="F10">10</xref> shows how the run-time of the programs depends on the number of parallel instances on the Xeon E5-2620 machine for the two data sets. As the figure shows, the rank of each program in the performance order is identical for each number of concurrently running instances, i.e. biobambam’s <monospace>bamtofastq</monospace> is always the fastest, bampe2fqworphans is always second fastest etc. The ratios of the run-times of the programs between 24 concurrent instances and 1 concurrent instance are shown in Table
<xref ref-type="table" rid="T7">7</xref> (the entry 1.65 e.g. means when processing the file HG03520 each single instance of 24 concurrently running instances of biobambam’s <monospace>bamtofastq</monospace> was running by a factor of 1.65 slower than a single instance running alone on the machine). In this scenario Picard’s Java implementation was suffering the most from concurrently running instances with a slow down of 2.8 while biobambam’s <monospace>bamtofastq</monospace> is consistently the fastest solution and suffers the least from running in a busy environment.</p>
        <fig id="F10" position="float">
          <label>Figure 10</label>
          <caption>
            <p><bold>Dependence of BAM to FastQ run-time on number of concurrently running instances on the Xeon E5-2620 machine.</bold> Plots showing dependence of run-time on the number of concurrently running instances for biobambam’s <monospace>bamtofastq</monospace>, Picard’s SamToFastQ, bamUtil’s bam2fastq, bampe2fqworphans and bam2fastq for the data sets HG03520 and HG00096 on the Xeon E5-2620 system.</p>
          </caption>
          <graphic xlink:href="1751-0473-9-13-10"/>
        </fig>
        <table-wrap position="float" id="T7">
          <label>Table 7</label>
          <caption>
            <p>Slow down of BAM to FastQ conversion due to concurrency on the Xeon E5-2620 machine</p>
          </caption>
          <table frame="hsides" rules="groups" border="1">
            <colgroup>
              <col align="left"/>
              <col align="left"/>
              <col align="left"/>
              <col align="left"/>
              <col align="left"/>
              <col align="left"/>
            </colgroup>
            <thead valign="top">
              <tr>
                <th align="left">
                  <bold>Data set</bold>
                </th>
                <th align="left">
                  <bold>biobambam</bold>
                </th>
                <th align="left">
                  <bold>bam2fastq</bold>
                </th>
                <th align="left">
                  <bold>bampe2fqworphans</bold>
                </th>
                <th align="left">
                  <bold>Picard</bold>
                </th>
                <th align="left">
                  <bold>bamUtil</bold>
                </th>
              </tr>
            </thead>
            <tbody valign="top">
              <tr>
                <td align="left" valign="bottom">HG03520<hr/></td>
                <td align="left" valign="bottom">1.65<hr/></td>
                <td align="left" valign="bottom">1.68<hr/></td>
                <td align="left" valign="bottom">1.70<hr/></td>
                <td align="left" valign="bottom">2.80<hr/></td>
                <td align="left" valign="bottom">1.87<hr/></td>
              </tr>
              <tr>
                <td align="left">HG00096</td>
                <td align="left">1.64</td>
                <td align="left">1.70</td>
                <td align="left">1.74</td>
                <td align="left">2.78</td>
                <td align="left">1.87</td>
              </tr>
            </tbody>
          </table>
          <table-wrap-foot>
            <p>Ratio of run-time between24 and 1 concurrently running instances of biobambam’s <monospace>bamtofastq</monospace>, bam2fastq, bampe2fqworphans, Picard’s SamToFastq and bamUtil’s bam2fastq on the Xeon E5-2620 machine for the data sets HG03520 and HG00096.</p>
          </table-wrap-foot>
        </table-wrap>
        <p>Figure
<xref ref-type="fig" rid="F11">11</xref> shows a comparison of the same programs on the same data sets on compute farm nodes. The plots show runs ranging from 1 to 32 concurrently running instances. In these plots we observe sharp increases of the bampe2fqworphans program run-time when going from 24 to 32 concurrently running instances. It is beyond the scope of this paper to exactly determine the reason for this, but we consider it as likely that the program saturates the I/O system with read system calls of inefficiently small block sizes. Table
<xref ref-type="table" rid="T8">8</xref> shows the run-time ratios between 32 and 1 concurrently running program instances. In this case Picard has the smallest relative losses through concurrency with biobambam in second place. In absolute run-times however biobambam running on a full machine is faster than Picard running on an otherwise idle machine. Again biobambam’s <monospace>bamtofastq</monospace> is the fastest solution for any amount of concurrency.</p>
        <fig id="F11" position="float">
          <label>Figure 11</label>
          <caption>
            <p><bold>Dependence of BAM to FastQ run-time on number of concurrently running instances on compute farm nodes.</bold> Plots showing dependence of run-time on the number of concurrently running instances for biobambam’s <monospace>bamtofastq</monospace>, Picard’s SamToFastQ, bamUtil’s bam2fastq, bampe2fqworphans and bam2fastq for the data sets HG03520 and HG00096 on compute farm type system.</p>
          </caption>
          <graphic xlink:href="1751-0473-9-13-11"/>
        </fig>
        <table-wrap position="float" id="T8">
          <label>Table 8</label>
          <caption>
            <p>Slow down of BAM to FastQ conversion due to concurrency on compute farm nodes</p>
          </caption>
          <table frame="hsides" rules="groups" border="1">
            <colgroup>
              <col align="left"/>
              <col align="left"/>
              <col align="left"/>
              <col align="left"/>
              <col align="left"/>
              <col align="left"/>
            </colgroup>
            <thead valign="top">
              <tr>
                <th align="left">
                  <bold>Data set</bold>
                </th>
                <th align="left">
                  <bold>biobambam</bold>
                </th>
                <th align="left">
                  <bold>bam2fastq</bold>
                </th>
                <th align="left">
                  <bold>bampe2fqworphans</bold>
                </th>
                <th align="left">
                  <bold>Picard</bold>
                </th>
                <th align="left">
                  <bold>bamUtil</bold>
                </th>
              </tr>
            </thead>
            <tbody valign="top">
              <tr>
                <td align="left" valign="bottom">HG03520<hr/></td>
                <td align="left" valign="bottom">1.96<hr/></td>
                <td align="left" valign="bottom">2.88<hr/></td>
                <td align="left" valign="bottom">6.29<hr/></td>
                <td align="left" valign="bottom">1.73<hr/></td>
                <td align="left" valign="bottom">2.53<hr/></td>
              </tr>
              <tr>
                <td align="left">HG00096</td>
                <td align="left">1.96</td>
                <td align="left">2.61</td>
                <td align="left">5.19</td>
                <td align="left">1.74</td>
                <td align="left">2.56</td>
              </tr>
            </tbody>
          </table>
          <table-wrap-foot>
            <p>Ratio of run-time between 32 and 1 concurrently running instances of biobambam’s <monospace>bamtofastq</monospace>, bam2fastq, bampe2fqworphans, Picard’s SamToFastq and bamUtil’s bam2fastq on compute farm nodes for the data sets HG03520 and HG00096.</p>
          </table-wrap-foot>
        </table-wrap>
      </sec>
      <sec>
        <title>Dependence of BAM duplicate marking time on the number of concurrently running instances</title>
        <p>As above for BAM to FastQ conversion we have tested the effects of concurrently running instances on duplicate record marking in BAM files using biobambam’s <monospace>bammarkduplicates2</monospace>, Picard’s MarkDuplicates and bamUtil dedup on the data sets HG03520 and HG00096. The results are presented in the forms of plots in Figures
<xref ref-type="fig" rid="F12">12</xref> and
<xref ref-type="fig" rid="F13">13</xref> for the Xeon E5-2620 system and the compute farm nodes respectively. Tables
<xref ref-type="table" rid="T9">9</xref> and
<xref ref-type="table" rid="T10">10</xref> show the run-time ratios between running a maximum number of concurrent instances and running a single instance of a program for the respective settings. Most of the runs on the Xeon E5-2620 for 16 and 20 parallel instances show a high variance in run-time. This variance can be explained by observing that some of the running instances were sharing a hyper threading CPU core while others were running on an otherwise idle CPU core. Apparently hyper threading offers less of the required parallelism in this case as for the BAM to FastQ conversion case. On this system the slow down occurring due to concurrency is fairly consistent across all programs as shown in Table
<xref ref-type="table" rid="T9">9</xref>. On the compute farm nodes the systematic variance in run-time seen on the Xeon E5-2620 system does not occur as only full CPU cores are used. The run-time development for biobambam and bamUtil is almost identical. Picard suffers much more heavily from increased concurrency. One possible explanation is the larger amount of I/O performed by Picard due to list building and sorting in external memory.</p>
        <fig id="F12" position="float">
          <label>Figure 12</label>
          <caption>
            <p><bold>Dependence of BAM duplicate marking run-time on number of concurrently running instances on the Xeon E5-2620 machine.</bold> Plots showing dependence of run-time on the number of concurrently running instances for biobambam’s <monospace>bammarkduplicates2</monospace>, Picard’s MarkDuplicates and bamUtil’s dedup for the data sets HG03520 and HG00096 on the Xeon E5-2620 system.</p>
          </caption>
          <graphic xlink:href="1751-0473-9-13-12"/>
        </fig>
        <fig id="F13" position="float">
          <label>Figure 13</label>
          <caption>
            <p><bold>Dependence of BAM duplicate marking run-time on number of concurrently running instances on compute farm nodes.</bold> Plots showing dependence of run-time on the number of concurrently running instances for biobambam’s <monospace>bammarkduplicates2</monospace>, Picard’s MarkDuplicates and bamUtil’s dedup for the data sets HG03520 and HG00096 on the compute farm type system.</p>
          </caption>
          <graphic xlink:href="1751-0473-9-13-13"/>
        </fig>
        <table-wrap position="float" id="T9">
          <label>Table 9</label>
          <caption>
            <p>Slow down of BAM duplicate marking due to concurrency on the Xeon E5-2620 machine</p>
          </caption>
          <table frame="hsides" rules="groups" border="1">
            <colgroup>
              <col align="left"/>
              <col align="left"/>
              <col align="left"/>
              <col align="left"/>
            </colgroup>
            <thead valign="top">
              <tr>
                <th align="left">
                  <bold>Data set</bold>
                </th>
                <th align="left">
                  <bold>biobambam</bold>
                </th>
                <th align="left">
                  <bold>Picard</bold>
                </th>
                <th align="left">
                  <bold>bamUtil</bold>
                </th>
              </tr>
            </thead>
            <tbody valign="top">
              <tr>
                <td align="left" valign="bottom">HG03520<hr/></td>
                <td align="left" valign="bottom">1.61<hr/></td>
                <td align="left" valign="bottom">1.71<hr/></td>
                <td align="left" valign="bottom">1.62<hr/></td>
              </tr>
              <tr>
                <td align="left">HG00096</td>
                <td align="left">1.60</td>
                <td align="left">1.70</td>
                <td align="left">1.59</td>
              </tr>
            </tbody>
          </table>
          <table-wrap-foot>
            <p>Ratio of run-time between 24 and 1 concurrently running instances of biobambam’s <monospace>bammarkduplicates2</monospace>, Picard’s MarkDuplicates and bamUtil’s dedup on the Xeon E5-2620 machine for the data sets HG03520 and HG00096.</p>
          </table-wrap-foot>
        </table-wrap>
        <table-wrap position="float" id="T10">
          <label>Table 10</label>
          <caption>
            <p>Slow down of BAM duplicate marking due to concurrency on compute farm nodes</p>
          </caption>
          <table frame="hsides" rules="groups" border="1">
            <colgroup>
              <col align="left"/>
              <col align="left"/>
              <col align="left"/>
              <col align="left"/>
            </colgroup>
            <thead valign="top">
              <tr>
                <th align="left">
                  <bold>Data set</bold>
                </th>
                <th align="left">
                  <bold>biobambam</bold>
                </th>
                <th align="left">
                  <bold>Picard</bold>
                </th>
                <th align="left">
                  <bold>bamUtil</bold>
                </th>
              </tr>
            </thead>
            <tbody valign="top">
              <tr>
                <td align="left" valign="bottom">HG03520<hr/></td>
                <td align="left" valign="bottom">1.86<hr/></td>
                <td align="left" valign="bottom">3.90<hr/></td>
                <td align="left" valign="bottom">1.88<hr/></td>
              </tr>
              <tr>
                <td align="left">HG00096</td>
                <td align="left">1.88</td>
                <td align="left">2.60</td>
                <td align="left">1.91</td>
              </tr>
            </tbody>
          </table>
          <table-wrap-foot>
            <p>Ratio of run-time between 32 and 1 concurrently running instances of biobambam’s <monospace>bammarkduplicates2</monospace>, Picard’s MarkDuplicates and bamUtil’s dedup on compute farm nodes for the data sets HG03520 and HG00096.</p>
          </table-wrap-foot>
        </table-wrap>
      </sec>
    </sec>
  </sec>
  <sec sec-type="conclusions">
    <title>Conclusions</title>
    <p>In this paper we have presented efficient algorithms and data structures for name collated BAM file input. We have provided an implementation of these in libmaus, an open source programming library for C++. As part of the biobambam package we have developed two tools <monospace>bamtofastq</monospace> and <monospace>bammarkduplicates2</monospace> based on the API. <monospace>bamtofastq</monospace> is faster than all widely known competitors while using only small amounts of RAM. <monospace>bammarkduplicates2</monospace> is close the performance of bamUtil dedup on small data sets while easily handling larger and more complex data sets for which bamUtil dedup fails and it outperforms the duplication marking tool of Picard in both speed and memory aspects. biobambam is well suited for environments running many instances of the problems solved concurrently.</p>
  </sec>
  <sec>
    <title>Availability and requirements</title>
    <p><bold>Project name:</bold> biobambam/libmaus</p>
    <p><bold>Operating systems:</bold> Linux and MacOS X</p>
    <p><bold>Programming language:</bold> C++</p>
    <p><bold>Other requirements:</bold> none</p>
    <p><bold>License:</bold> GPL3</p>
    <p><bold>Any restrictions to use by non-academics:</bold> none</p>
  </sec>
  <sec>
    <title>Endnote</title>
    <p><sup>a</sup>unless otherwise stated we use MB and GB to denote 2<sup>20</sup> and 2<sup>30</sup> bytes respectively in this paper.</p>
  </sec>
  <sec>
    <title>Competing interests</title>
    <p>The authors declare that they have no competing interests.</p>
  </sec>
  <sec>
    <title>Authors’ contributions</title>
    <p>GT wrote the code, ran the tests and benchmarks and wrote the paper. SL contributed to the testing and provided patches for making the <monospace>bammarkduplicates2</monospace> tool more compatible with Picard’s MarkDuplicates module. Both authors read and approved the final manuscript.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material content-type="local-data" id="S1">
      <caption>
        <title>Additional file 1</title>
        <p>Appendix A.</p>
      </caption>
      <media xlink:href="1751-0473-9-13-S1.pdf">
        <caption>
          <p>Click here for file</p>
        </caption>
      </media>
    </supplementary-material>
  </sec>
</body>
<back>
  <sec>
    <title>Acknowledgements</title>
    <p>GT and SL are supported by the Wellcome Trust.</p>
  </sec>
  <ref-list>
    <ref id="B1">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Li</surname>
          <given-names>H</given-names>
        </name>
        <name>
          <surname>Handsaker</surname>
          <given-names>B</given-names>
        </name>
        <name>
          <surname>Wysoker</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Fennell</surname>
          <given-names>T</given-names>
        </name>
        <name>
          <surname>Ruan</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Homer</surname>
          <given-names>N</given-names>
        </name>
        <name>
          <surname>Marth</surname>
          <given-names>G</given-names>
        </name>
        <name>
          <surname>Abecasis</surname>
          <given-names>G</given-names>
        </name>
        <name>
          <surname>Durbin</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Subgroup</surname>
          <given-names>GPDP</given-names>
        </name>
        <article-title>The Sequence Alignment/Map format and SAMtools</article-title>
        <source>Bioinformatics</source>
        <year>2009</year>
        <volume>25</volume>
        <issue>16</issue>
        <fpage>2078</fpage>
        <lpage>2079</lpage>
        <comment>[
<ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/content/25/16/2078.abstract">http://bioinformatics.oxfordjournals.org/content/25/16/2078.abstract</ext-link>]</comment>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btp352</pub-id>
        <?supplied-pmid 19505943?>
        <pub-id pub-id-type="pmid">19505943</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B2">
      <mixed-citation publication-type="other">
        <article-title>The SAM file specification</article-title>
        <comment>[
<ext-link ext-link-type="uri" xlink:href="http://samtools.sourceforge.net/SAM1.pdf">http://samtools.sourceforge.net/SAM1.pdf</ext-link>]</comment>
      </mixed-citation>
    </ref>
    <ref id="B3">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Ning</surname>
          <given-names>Z</given-names>
        </name>
        <name>
          <surname>Cox</surname>
          <given-names>AJ</given-names>
        </name>
        <name>
          <surname>Mullikin</surname>
          <given-names>JC</given-names>
        </name>
        <article-title>SSAHA: a fast search method for large DNA databases</article-title>
        <source>Genome Res</source>
        <year>2001</year>
        <volume>11</volume>
        <issue>10</issue>
        <fpage>1725</fpage>
        <lpage>1729</lpage>
        <pub-id pub-id-type="doi">10.1101/gr.194201</pub-id>
        <?supplied-pmid 11591649?>
        <pub-id pub-id-type="pmid">11591649</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B4">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Li</surname>
          <given-names>H</given-names>
        </name>
        <name>
          <surname>Durbin</surname>
          <given-names>R</given-names>
        </name>
        <article-title>Fast and accurate short read alignment with Burrows-Wheeler transform</article-title>
        <source>Bioinformatics</source>
        <year>2009</year>
        <volume>25</volume>
        <issue>14</issue>
        <fpage>1754</fpage>
        <lpage>1760</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btp324</pub-id>
        <?supplied-pmid 19451168?>
        <pub-id pub-id-type="pmid">19451168</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B5">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Li</surname>
          <given-names>H</given-names>
        </name>
        <name>
          <surname>Durbin</surname>
          <given-names>R</given-names>
        </name>
        <article-title>Fast and accurate long-read alignment with Burrows-Wheeler transform</article-title>
        <source>Bioinformatics</source>
        <year>2010</year>
        <volume>26</volume>
        <issue>5</issue>
        <fpage>589</fpage>
        <lpage>595</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btp698</pub-id>
        <?supplied-pmid 20080505?>
        <pub-id pub-id-type="pmid">20080505</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B6">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Langmead</surname>
          <given-names>B</given-names>
        </name>
        <name>
          <surname>Trapnell</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Pop</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Salzberg</surname>
          <given-names>SL</given-names>
        </name>
        <article-title>Ultrafast and memory-efficient alignment of short DNA sequences to the human genome</article-title>
        <source>Genome Biol</source>
        <year>2009</year>
        <volume>10</volume>
        <issue>3</issue>
        <fpage>R25</fpage>
        <pub-id pub-id-type="doi">10.1186/gb-2009-10-3-r25</pub-id>
        <?supplied-pmid 19261174?>
        <pub-id pub-id-type="pmid">19261174</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B7">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Langmead</surname>
          <given-names>B</given-names>
        </name>
        <name>
          <surname>Salzberg</surname>
          <given-names>SL</given-names>
        </name>
        <article-title>Fast gapped-read alignment with Bowtie 2</article-title>
        <source>Nat Methods</source>
        <year>2012</year>
        <volume>9</volume>
        <issue>4</issue>
        <fpage>357</fpage>
        <lpage>359</lpage>
        <pub-id pub-id-type="doi">10.1038/nmeth.1923</pub-id>
        <?supplied-pmid 22388286?>
        <pub-id pub-id-type="pmid">22388286</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B8">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Li</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Li</surname>
          <given-names>Y</given-names>
        </name>
        <name>
          <surname>Kristiansen</surname>
          <given-names>K</given-names>
        </name>
        <name>
          <surname>Wang</surname>
          <given-names>J</given-names>
        </name>
        <article-title>SOAP: short oligonucleotide alignment program</article-title>
        <source>Bioinformatics</source>
        <year>2008</year>
        <volume>24</volume>
        <issue>5</issue>
        <fpage>713</fpage>
        <lpage>714</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btn025</pub-id>
        <?supplied-pmid 18227114?>
        <pub-id pub-id-type="pmid">18227114</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B9">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Li</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Yu</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Li</surname>
          <given-names>Y</given-names>
        </name>
        <name>
          <surname>Lam</surname>
          <given-names>TW</given-names>
        </name>
        <name>
          <surname>Yiu</surname>
          <given-names>SM</given-names>
        </name>
        <name>
          <surname>Kristiansen</surname>
          <given-names>K</given-names>
        </name>
        <name>
          <surname>Wang</surname>
          <given-names>J</given-names>
        </name>
        <article-title>SOAP2: an improved ultrafast tool for short read alignment</article-title>
        <source>Bioinformatics</source>
        <year>2009</year>
        <volume>25</volume>
        <issue>15</issue>
        <fpage>1966</fpage>
        <lpage>1967</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btp336</pub-id>
        <?supplied-pmid 19497933?>
        <pub-id pub-id-type="pmid">19497933</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B10">
      <mixed-citation publication-type="other">
        <article-title>SMALT</article-title>
        <comment>[
<ext-link ext-link-type="uri" xlink:href="http://www.sanger.ac.uk/resources/software/smalt/">http://www.sanger.ac.uk/resources/software/smalt/</ext-link>]</comment>
      </mixed-citation>
    </ref>
    <ref id="B11">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Li</surname>
          <given-names>H</given-names>
        </name>
        <article-title>Exploring single-sample SNP and INDEL calling with whole-genome de novo assembly</article-title>
        <source>Bioinformatics</source>
        <year>2012</year>
        <volume>28</volume>
        <issue>14</issue>
        <fpage>1838</fpage>
        <lpage>1844</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/bts280</pub-id>
        <?supplied-pmid 22569178?>
        <pub-id pub-id-type="pmid">22569178</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B12">
      <mixed-citation publication-type="other">
        <article-title>Picard</article-title>
        <comment>[
<ext-link ext-link-type="uri" xlink:href="http://picard.sourceforge.net/">http://picard.sourceforge.net/</ext-link>]</comment>
      </mixed-citation>
    </ref>
    <ref id="B13">
      <mixed-citation publication-type="other">
        <article-title>bamUtil</article-title>
        <comment>[
<ext-link ext-link-type="uri" xlink:href="http://genome.sph.umich.edu/wiki/BamUtil">http://genome.sph.umich.edu/wiki/BamUtil</ext-link>]</comment>
      </mixed-citation>
    </ref>
    <ref id="B14">
      <mixed-citation publication-type="other">
        <article-title>biobambam</article-title>
        <comment>[
<ext-link ext-link-type="uri" xlink:href="https://github.com/gt1/biobambam">https://github.com/gt1/biobambam</ext-link>]</comment>
      </mixed-citation>
    </ref>
    <ref id="B15">
      <mixed-citation publication-type="other">
        <article-title>libmaus</article-title>
        <comment>[
<ext-link ext-link-type="uri" xlink:href="https://github.com/gt1/libmaus">https://github.com/gt1/libmaus</ext-link>]</comment>
      </mixed-citation>
    </ref>
    <ref id="B16">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Döring</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Weese</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Rausch</surname>
          <given-names>T</given-names>
        </name>
        <name>
          <surname>Reinert</surname>
          <given-names>K</given-names>
        </name>
        <article-title>SeqAn an efficient, generic C++ library for sequence analysis</article-title>
        <source>BMC Bioinformatics</source>
        <year>2008</year>
        <volume>9</volume>
        <fpage>1</fpage>
        <lpage>9</lpage>
        <comment>[
<ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1186/1471-2105-9-11">http://dx.doi.org/10.1186/1471-2105-9-11</ext-link>]</comment>
        <pub-id pub-id-type="doi">10.1186/1471-2105-9-1</pub-id>
        <?supplied-pmid 18173834?>
        <pub-id pub-id-type="pmid">18173834</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B17">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Ramirez-Gonzalez</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Bonnal</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Caccamo</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>MacLean</surname>
          <given-names>D</given-names>
        </name>
        <article-title>Bio-samtools: ruby bindings for SAMtools, a library for accessing BAM files containing high-throughput sequence alignments</article-title>
        <source>Source Code Biol Med</source>
        <year>2012</year>
        <volume>7</volume>
        <issue>6</issue>
        <comment>[
<ext-link ext-link-type="uri" xlink:href="http://www.scfbm.org/content/7/1/6">http://www.scfbm.org/content/7/1/6</ext-link>]</comment>
      </mixed-citation>
    </ref>
    <ref id="B18">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Hsi-Yang Fritz</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Leinonen</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Cochrane</surname>
          <given-names>G</given-names>
        </name>
        <name>
          <surname>Birney</surname>
          <given-names>E</given-names>
        </name>
        <article-title>Efficient storage of high throughput DNA sequencing data using reference-based compression</article-title>
        <source>Genome Res</source>
        <year>2011</year>
        <volume>21</volume>
        <issue>5</issue>
        <fpage>734</fpage>
        <lpage>740</lpage>
        <comment>[
<ext-link ext-link-type="uri" xlink:href="http://genome.cshlp.org/content/21/5/734.abstract">http://genome.cshlp.org/content/21/5/734.abstract</ext-link>]</comment>
        <pub-id pub-id-type="doi">10.1101/gr.114819.110</pub-id>
        <?supplied-pmid 21245279?>
        <pub-id pub-id-type="pmid">21245279</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B19">
      <mixed-citation publication-type="other">
        <article-title><monospace>io_lib</monospace> in the Staden package</article-title>
        <comment>[
<ext-link ext-link-type="uri" xlink:href="http://sourceforge.net/projects/staden/files/io_lib/">http://sourceforge.net/projects/staden/files/io_lib/</ext-link>]</comment>
      </mixed-citation>
    </ref>
    <ref id="B20">
      <mixed-citation publication-type="other">
        <article-title>The Staden package</article-title>
        <comment>[
<ext-link ext-link-type="uri" xlink:href="http://staden.sourceforge.net/">http://staden.sourceforge.net/</ext-link>]</comment>
      </mixed-citation>
    </ref>
    <ref id="B21">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Bonfield</surname>
          <given-names>JK</given-names>
        </name>
        <name>
          <surname>Whitwham</surname>
          <given-names>A</given-names>
        </name>
        <article-title>Gap5-editing the billion fragment sequence assembly</article-title>
        <source>Bioinformatics</source>
        <year>2010</year>
        <volume>26</volume>
        <issue>14</issue>
        <fpage>1699</fpage>
        <lpage>1703</lpage>
        <comment>[
<ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/content/26/14/1699.abstract">http://bioinformatics.oxfordjournals.org/content/26/14/1699.abstract</ext-link>]</comment>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btq268</pub-id>
        <?supplied-pmid 20513662?>
        <pub-id pub-id-type="pmid">20513662</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B22">
      <mixed-citation publication-type="other">
        <article-title>[EMBL:ERP001231]</article-title>
        <comment>[
<ext-link ext-link-type="uri" xlink:href="http://www.ebi.ac.uk/ena/data/view/ERP001231">http://www.ebi.ac.uk/ena/data/view/ERP001231</ext-link>]</comment>
      </mixed-citation>
    </ref>
    <ref id="B23">
      <mixed-citation publication-type="other">
        <article-title>Genome Reference Consortium, human reference assembly release version 37</article-title>
        <comment>[
<ext-link ext-link-type="ftp" xlink:href="ftp://ftp.ncbi.nlm.nih.gov/genbank/genomes/Eukaryotes/vertebrates_mammals/Homo_sapiens/GRCh37/">ftp://ftp.ncbi.nlm.nih.gov/genbank/genomes/Eukaryotes/vertebrates_mammals/Homo_sapiens/GRCh37/</ext-link>]</comment>
      </mixed-citation>
    </ref>
    <ref id="B24">
      <mixed-citation publication-type="other">
        <article-title>bam2fastq</article-title>
        <comment>[
<ext-link ext-link-type="uri" xlink:href="http://gsl.hudsonalpha.org/information/software/bam2fastq">http://gsl.hudsonalpha.org/information/software/bam2fastq</ext-link>]</comment>
      </mixed-citation>
    </ref>
    <ref id="B25">
      <mixed-citation publication-type="other">
        <article-title>bampe2fqworphans</article-title>
        <comment>[
<ext-link ext-link-type="uri" xlink:href="http://seqanswers.com/forums/showpost.php?p=108412&amp;postcount=26">http://seqanswers.com/forums/showpost.php?p=108412&amp;postcount=26</ext-link>]</comment>
      </mixed-citation>
    </ref>
    <ref id="B26">
      <mixed-citation publication-type="other">
        <article-title>HG03520</article-title>
        <comment>[
<ext-link ext-link-type="ftp" xlink:href="ftp://ftp.1000genomes.ebi.ac.uk/vol1/ftp/data/HG03520/alignment/HG03520.chrom11.ILLUMINA.bwa.ESN.low_coverage.20130502.bam">ftp://ftp.1000genomes.ebi.ac.uk/vol1/ftp/data/HG03520/alignment/HG03520.chrom11.ILLUMINA.bwa.ESN.low_coverage.20130502.bam</ext-link>]</comment>
      </mixed-citation>
    </ref>
    <ref id="B27">
      <mixed-citation publication-type="journal">
        <name>
          <surname>1000 Genomes Project</surname>
          <given-names>Consortium</given-names>
        </name>
        <article-title>A map of human genome variation from population-scale sequencing</article-title>
        <source>Nature</source>
        <year>2010</year>
        <volume>467</volume>
        <issue>7319</issue>
        <fpage>1061</fpage>
        <lpage>1073</lpage>
        <pub-id pub-id-type="doi">10.1038/nature09534</pub-id>
        <?supplied-pmid 20981092?>
        <pub-id pub-id-type="pmid">20981092</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B28">
      <mixed-citation publication-type="other">
        <article-title>HG00096</article-title>
        <comment>[
<ext-link ext-link-type="ftp" xlink:href="ftp://ftp.1000genomes.ebi.ac.uk/vol1/ftp/data/HG00096/alignment/HG00096.mapped.ILLUMINA.bwa.GBR.low_coverage.20120522.bam">ftp://ftp.1000genomes.ebi.ac.uk/vol1/ftp/data/HG00096/alignment/HG00096.mapped.ILLUMINA.bwa.GBR.low_coverage.20120522.bam</ext-link>]</comment>
      </mixed-citation>
    </ref>
    <ref id="B29">
      <mixed-citation publication-type="other">
        <article-title>[EMBL:SRP017681]</article-title>
        <comment>[
<ext-link ext-link-type="uri" xlink:href="http://www.ebi.ac.uk/ena/data/view/SRP017681">http://www.ebi.ac.uk/ena/data/view/SRP017681</ext-link>]</comment>
      </mixed-citation>
    </ref>
    <ref id="B30">
      <mixed-citation publication-type="other">
        <article-title>Reference genome of Escherichia coli str. K-12 substr MG1655</article-title>
        <comment>[
<ext-link ext-link-type="ftp" xlink:href="ftp://ftp.ncbi.nih.gov/genomes/Bacteria/Escherichia_coli_K_12_substr__MG1655_uid57779/NC_000913.fna">ftp://ftp.ncbi.nih.gov/genomes/Bacteria/Escherichia_coli_K_12_substr__MG1655_uid57779/NC_000913.fna</ext-link>]</comment>
      </mixed-citation>
    </ref>
    <ref id="B31">
      <mixed-citation publication-type="other">
        <article-title>[EMBL:ERR239642]</article-title>
        <comment>[
<ext-link ext-link-type="uri" xlink:href="http://www.ebi.ac.uk/ena/data/view/ERR239642">http://www.ebi.ac.uk/ena/data/view/ERR239642</ext-link>]</comment>
      </mixed-citation>
    </ref>
    <ref id="B32">
      <mixed-citation publication-type="other">
        <article-title>[EMBL:ERR217514]</article-title>
        <comment>[
<ext-link ext-link-type="uri" xlink:href="http://www.ebi.ac.uk/ena/data/view/ERR217514">http://www.ebi.ac.uk/ena/data/view/ERR217514</ext-link>]</comment>
      </mixed-citation>
    </ref>
    <ref id="B33">
      <mixed-citation publication-type="other">
        <article-title>[EMBL:ERR196957]</article-title>
        <comment>[
<ext-link ext-link-type="uri" xlink:href="http://www.ebi.ac.uk/ena/data/view/ERR196957">http://www.ebi.ac.uk/ena/data/view/ERR196957</ext-link>]</comment>
      </mixed-citation>
    </ref>
    <ref id="B34">
      <mixed-citation publication-type="other">
        <article-title>[EMBL:ERR328876]</article-title>
        <comment>[
<ext-link ext-link-type="uri" xlink:href="http://www.ebi.ac.uk/ena/data/view/ERR328876">http://www.ebi.ac.uk/ena/data/view/ERR328876</ext-link>]</comment>
      </mixed-citation>
    </ref>
    <ref id="B35">
      <mixed-citation publication-type="other">
        <article-title>[EMBL:ERR054938]</article-title>
        <comment>[
<ext-link ext-link-type="uri" xlink:href="http://www.ebi.ac.uk/ena/data/view/ERR054938">http://www.ebi.ac.uk/ena/data/view/ERR054938</ext-link>]</comment>
      </mixed-citation>
    </ref>
    <ref id="B36">
      <mixed-citation publication-type="other">
        <article-title>[EMBL:ERR328190]</article-title>
        <comment>[
<ext-link ext-link-type="uri" xlink:href="http://www.ebi.ac.uk/ena/data/view/ERR328190">http://www.ebi.ac.uk/ena/data/view/ERR328190</ext-link>]</comment>
      </mixed-citation>
    </ref>
  </ref-list>
</back>
