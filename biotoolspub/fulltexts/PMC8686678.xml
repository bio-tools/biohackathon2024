<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.2 20190208//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 1.2?>
<?ConverterInfo.XSLTName jats2jats3.xsl?>
<?ConverterInfo.Version 1?>
<?properties open_access?>
<processing-meta base-tagset="archiving" mathml-version="3.0" table-model="xhtml" tagset-family="jats">
  <restricted-by>pmc</restricted-by>
</processing-meta>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">8686678</article-id>
    <article-id pub-id-type="pmid">34252936</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/btab286</article-id>
    <article-id pub-id-type="publisher-id">btab286</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Biomedical Informatics</subject>
      </subj-group>
      <subj-group subj-group-type="category-taxonomy-collection">
        <subject>AcademicSubjects/SCI01060</subject>
      </subj-group>
      <subj-group subj-group-type="category-taxonomy-collection">
        <subject>AcademicSubjects/SCI01060</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>CALLR: a semi-supervised cell-type annotation method for single-cell RNA sequencing data</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Wei</surname>
          <given-names>Ziyang</given-names>
        </name>
        <aff><institution>Department of Statistics, University of Chicago</institution>, Chicago, IL 60637, <country country="US">USA</country></aff>
        <aff><institution>School of Mathematical Sciences, Fudan University</institution>, Shanghai 200433, <country country="CN">China</country></aff>
      </contrib>
      <contrib contrib-type="author" corresp="yes">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0001-8223-844X</contrib-id>
        <name>
          <surname>Zhang</surname>
          <given-names>Shuqin</given-names>
        </name>
        <aff><institution>School of Mathematical Sciences, Fudan University</institution>, Shanghai 200433, <country country="CN">China</country></aff>
        <aff><institution>Laboratory of Mathematics for Nonlinear Science, Fudan University</institution>, Shanghai 200433, <country country="CN">China</country></aff>
        <aff><institution>Shanghai Key Laboratory for Contemporary Applied Mathematics, Fudan University</institution>, Shanghai 200433, <country country="CN">China</country></aff>
        <xref rid="btab286-cor1" ref-type="corresp"/>
        <!--zhangs@fudan.edu.cn-->
      </contrib>
    </contrib-group>
    <author-notes>
      <corresp id="btab286-cor1">To whom correspondence should be addressed. <email>zhangs@fudan.edu.cn</email></corresp>
    </author-notes>
    <pub-date pub-type="collection">
      <month>7</month>
      <year>2021</year>
    </pub-date>
    <pub-date pub-type="epub" iso-8601-date="2021-07-12">
      <day>12</day>
      <month>7</month>
      <year>2021</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>12</day>
      <month>7</month>
      <year>2021</year>
    </pub-date>
    <volume>37</volume>
    <issue>Suppl 1</issue>
    <issue-title>ISMB/ECCB 2021 Proceedings</issue-title>
    <fpage>i51</fpage>
    <lpage>i58</lpage>
    <permissions>
      <copyright-statement>© The Author(s) 2021. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2021</copyright-year>
      <license>
        <ali:license_ref xmlns:ali="http://www.niso.org/schemas/ali/1.0/" specific-use="textmining" content-type="ccbylicense">https://creativecommons.org/licenses/by/4.0/</ali:license_ref>
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</ext-link>), which permits unrestricted reuse, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="btab286.pdf"/>
    <abstract>
      <title>Abstract</title>
      <sec id="s1">
        <title>Motivation</title>
        <p>Single-cell RNA sequencing (scRNA-seq) technology has been widely applied to capture the heterogeneity of different cell types within complex tissues. An essential step in scRNA-seq data analysis is the annotation of cell types. Traditional cell-type annotation is mainly clustering the cells first, and then using the aggregated cluster-level expression profiles and the marker genes to label each cluster. Such methods are greatly dependent on the clustering results, which are insufficient for accurate annotation.</p>
      </sec>
      <sec id="s2">
        <title>Results</title>
        <p>In this article, we propose a semi-supervised learning method for cell-type annotation called CALLR. It combines unsupervised learning represented by the graph Laplacian matrix constructed from all the cells and supervised learning using sparse logistic regression. By alternately updating the cell clusters and annotation labels, high annotation accuracy can be achieved. The model is formulated as an optimization problem, and a computationally efficient algorithm is developed to solve it. Experiments on 10 real datasets show that CALLR outperforms the compared (semi-)supervised learning methods, and the popular clustering methods.</p>
      </sec>
      <sec id="s3">
        <title>Availability and implementation</title>
        <p>The implementation of CALLR is available at https://github.com/MathSZhang/CALLR.</p>
      </sec>
      <sec id="s5">
        <title>Supplementary information</title>
        <p>Supplementary data are available at <italic toggle="yes">Bioinformatics</italic> online.</p>
      </sec>
    </abstract>
    <funding-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>Science and Technology Commission of Shanghai Municipality</institution>
            <institution-id institution-id-type="DOI">10.13039/501100003399</institution-id>
          </institution-wrap>
          <!-- oupReleaseDelayRemoved from OA Article (00|0) -->
        </funding-source>
        <award-id>20ZR1407700</award-id>
      </award-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>Key Program of National Natural Science Foundation of China</institution>
          </institution-wrap>
          <!-- oupReleaseDelayRemoved from OA Article (00|0) -->
        </funding-source>
        <award-id>61932008</award-id>
      </award-group>
    </funding-group>
    <counts>
      <page-count count="8"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec>
    <title>1 Introduction</title>
    <p>Single-cell RNA sequencing (scRNA-seq) technology has been more and more widely applied in different scenarios in biomedical fields nowadays (<xref rid="btab286-B24" ref-type="bibr">Kolodziejczyk <italic toggle="yes">et al.</italic>, 2015</xref>; <xref rid="btab286-B38" ref-type="bibr">Tang <italic toggle="yes">et al.</italic>, 2009</xref>). It measures the gene expressions at each single-cell level. Thus by analyzing the transcriptome-wide cell-to-cell variations, we can study the heterogeneity of different cell types within complex tissues (<xref rid="btab286-B21" ref-type="bibr">Kelsey <italic toggle="yes">et al.</italic>, 2017</xref>; <xref rid="btab286-B28" ref-type="bibr">Liu and Trapnell, 2016</xref>; <xref rid="btab286-B36" ref-type="bibr">Stubbington <italic toggle="yes">et al.</italic>, 2017</xref>), explore the cell-state progression in the developing embryos (<xref rid="btab286-B26" ref-type="bibr">Li <italic toggle="yes">et al.</italic>, 2018</xref>; <xref rid="btab286-B43" ref-type="bibr">Wagner <italic toggle="yes">et al.</italic>, 2018</xref>), characterize the diversity of human brain cells (<xref rid="btab286-B9" ref-type="bibr">Darmanis <italic toggle="yes">et al.</italic>, 2015</xref>; <xref rid="btab286-B25" ref-type="bibr">Lake <italic toggle="yes">et al.</italic>, 2018</xref>), investigate the heterogeneity of the cancer ecosystems to study the disease progression and response to therapy (<xref rid="btab286-B12" ref-type="bibr">Friebel <italic toggle="yes">et al.</italic>, 2020</xref>; <xref rid="btab286-B40" ref-type="bibr">Tirosh <italic toggle="yes">et al.</italic>, 2016</xref>; <xref rid="btab286-B44" ref-type="bibr">Wagner <italic toggle="yes">et al.</italic>, 2019</xref>; <xref rid="btab286-B53" ref-type="bibr">Zheng <italic toggle="yes">et al.</italic>, 2018</xref>) and so on. With the fast development of single-cell sequencing platforms, such as Seqwell and 10X chromium3, scRNA-seq data composed of more and more cells are available.</p>
    <p>An essential step in scRNA-seq data analysis is the annotation of cell types. Traditional cell-type annotation methods mainly include two steps: clustering the cells using unsupervised learning method, and labeling each cluster manually based on aggregated cluster-level expression profiles and the marker genes (<xref rid="btab286-B51" ref-type="bibr">Zhang <italic toggle="yes">et al.</italic>, 2019b</xref>). Such methods can be cumbersome, and the accuracy relies on both the clustering accuracy and the prior knowledge on marker gene expression levels. Recently, several cell-type annotation methods using the reference database have been developed. These methods usually map the unannotated cells to the pre-annotated reference datasets using selected features (<xref rid="btab286-B1" ref-type="bibr">Aran <italic toggle="yes">et al.</italic>, 2019</xref>; <xref rid="btab286-B10" ref-type="bibr">de Kanter <italic toggle="yes">et al.</italic>, 2019</xref>; <xref rid="btab286-B23" ref-type="bibr">Kiselev <italic toggle="yes">et al.</italic>, 2018</xref>; <xref rid="btab286-B17" ref-type="bibr">Hou <italic toggle="yes">et al.</italic>, 2019</xref>; <xref rid="btab286-B35" ref-type="bibr">Shao <italic toggle="yes">et al.</italic>, 2020</xref>). Then, the cell types are assigned according to the cells’ nearest neighbors or some similarity measures. For example, ‘scCATCH’ selects the marker genes as features, and uses them to map the unannotated cells to the tissue-specific cell taxonomy reference databases to determine the cell types. The performance of such methods depends on the clustering results, and the expression profiles from experiments with different designs may not be directly comparable. Deep learning methods for cell-type annotation have also been proposed (<xref rid="btab286-B5" ref-type="bibr">Brbić <italic toggle="yes">et al.</italic>, 2020</xref>; <xref rid="btab286-B19" ref-type="bibr">Hu <italic toggle="yes">et al.</italic>, 2020</xref>). MARS was proposed to project all cells in a meta-dataset into a joint low-dimensional embedding space shared by both annotated and unannotated cells. By learning the cell-type-specific landmarks, it can discover cell types that have never been seen before and annotate experiments that are as yet unannotated (<xref rid="btab286-B5" ref-type="bibr">Brbić <italic toggle="yes">et al.</italic>, 2020</xref>). ItClust is an iterative transfer learning algorithm with neural network that utilizes external well-annotated source data as the initialization for the target data to better cluster the target cells (<xref rid="btab286-B18" ref-type="bibr">Hu <italic toggle="yes">et al.</italic>, 2020</xref>). All of these methods integrate the information across multiple datasets. A few automatic cell-type annotation methods were proposed for one single dataset using the marker genes. <xref rid="btab286-B50" ref-type="bibr">Zhang <italic toggle="yes">et al.</italic> (2019a</xref>) proposed a probabilistic cell-type assignment model ‘CellAssign’ to do the inference, which leverages the prior knowledge of cell-type marker genes to annotate the cells. Another method ‘Garnett’ first labels a number of cells by scoring the marker genes, then uses sparse logistic regression to classify the cells (<xref rid="btab286-B33" ref-type="bibr">Pliner <italic toggle="yes">et al.</italic>, 2019</xref>).</p>
    <p>According to the above analysis, clustering plays leading roles in most cell annotation methods. Though a large number of cell clustering methods have been proposed (Ding <italic toggle="yes">et al.</italic>, <xref rid="btab286-B11" ref-type="bibr">2018</xref>; <xref rid="btab286-B16" ref-type="bibr">Grun <italic toggle="yes">et al.</italic>, 2016</xref>; <xref rid="btab286-B20" ref-type="bibr">Ji and Ji, 2016</xref>; <xref rid="btab286-B19" ref-type="bibr">Huh <italic toggle="yes">et al.</italic>, 2020</xref>; <xref rid="btab286-B22" ref-type="bibr">Kiselev <italic toggle="yes">et al.</italic>, 2017</xref>; <xref rid="btab286-B27" ref-type="bibr">Lin <italic toggle="yes">et al.</italic>, 2017</xref>; <xref rid="btab286-B29" ref-type="bibr">Marco <italic toggle="yes">et al.</italic>, 2014</xref>; <xref rid="btab286-B30" ref-type="bibr">Ntranos <italic toggle="yes">et al.</italic>, 2016</xref>; <xref rid="btab286-B31" ref-type="bibr">Park and Zhao, 2018</xref>; <xref rid="btab286-B32" ref-type="bibr">Pierson and Yau, 2015</xref>; <xref rid="btab286-B39" ref-type="bibr">Tian <italic toggle="yes">et al.</italic>, 2019</xref>; <xref rid="btab286-B46" ref-type="bibr">Wang <italic toggle="yes">et al.</italic>, 2017</xref>; <xref rid="btab286-B48" ref-type="bibr">Yang <italic toggle="yes">et al.</italic>, 2019</xref>), they are still not sufficient for accurately annotating the cells. Semi-supervised learning, as a branch of machine learning, uses both labeled and unlabeled data to perform supervised or unsupervised learning tasks (<xref rid="btab286-B42" ref-type="bibr">Van Engelen and Hoos, 2020</xref>). It has been widely applied in many different fields, including single-cell data analysis (<xref rid="btab286-B47" ref-type="bibr">Wu <italic toggle="yes">et al.</italic>, 2020</xref>; <xref rid="btab286-B52" ref-type="bibr">Zhang <italic toggle="yes">et al.</italic>, 2019c</xref>). The advantage of semi-supervised learning is that it can make full use of the prior knowledge on the labeled and unlabeled data, which can lead to better data explanations.</p>
    <p>In this article, we present a transductive semi-supervised method called Cell type Annotation using Laplacian and Logistic Regression (CALLR) for annotating the cell types in one single scRNA-seq dataset. Given a dataset consisting of labeled and unlabeled cells with the corresponding subsets denoted as <italic toggle="yes">Z</italic> and <italic toggle="yes">Z</italic>′<inline-formula id="IE1"><mml:math id="IM1" display="inline" overflow="scroll"><mml:mrow><mml:mi>Z</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula>, we propose a model to produce predicted labels for the unlabeled cells in <italic toggle="yes">Z</italic>′<inline-formula id="IE2"><mml:math id="IM2" display="inline" overflow="scroll"><mml:mrow><mml:mi>Z</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula>. The model combines the supervised learning part, which uses sparse logistic regression, and the unsupervised learning part, which is represented as a graph Laplacian constructed from all the cells, to learn the unknown cell labels. It is formulated as an optimization problem, and the numerical algorithm for solving it is presented. Here, we suppose a small number of labeled cells are known in the dataset, which may be obtained manually as traditionally do, or learned using marker genes, such as the method developed in Garnett (<xref rid="btab286-B33" ref-type="bibr">Pliner <italic toggle="yes">et al.</italic>, 2019</xref>). We apply CALLR to several datasets to show its performance. We first compare with some existing clustering methods and (semi-) supervised learning methods. We then show that when a very small proportion of cells are annotated, high annotation accuracy can be achieved. Compared to clustering, higher clustering accuracy can be obtained and cell types can be directly assigned to the clusters at the same time. Compared to supervised learning methods, such as logistic regression, much fewer labeled cells are needed and much higher annotation accuracy is obtained. All these results show the advantages of our proposed method.</p>
  </sec>
  <sec>
    <title>2 Materials and methods</title>
    <sec>
      <title>2.1 The CALLR framework</title>
      <p>Given an <italic toggle="yes">m </italic>×<italic toggle="yes"> n</italic> scRNA-seq gene expression matrix <inline-formula id="IE3"><mml:math id="IM3" display="inline" overflow="scroll"><mml:mrow><mml:mi>X</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold-italic">x</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold-italic">x</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold-italic">x</mml:mi></mml:mrow><mml:mi>n</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> with <italic toggle="yes">m</italic> genes and <italic toggle="yes">n</italic> cells, where <italic toggle="yes">x</italic><sub>i</sub><inline-formula id="IE4"><mml:math id="IM4" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="bold-italic">x</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> is the gene expression corresponding to the cell <italic toggle="yes">i</italic>. We first remove the genes with zero expression across all the cells. <italic toggle="yes">X</italic> is then normalized by size factor to adjust for read depth, which is the same as that used in (<xref rid="btab286-B33" ref-type="bibr">Pliner <italic toggle="yes">et al.</italic>, 2019</xref>). Without confusion, we use <italic toggle="yes">X</italic> as the normalized data matrix. Suppose a small proportion of cells have been annotated, and the cell set is denoted as <italic toggle="yes">Z</italic>. The set of the remaining cells is denoted as <italic toggle="yes">Z</italic>′<inline-formula id="IE5"><mml:math id="IM5" display="inline" overflow="scroll"><mml:mrow><mml:mi>Z</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula>. We assume the putative number of cell types is given as <italic toggle="yes">K</italic>, which can be seen from <italic toggle="yes">Z</italic>. The cell sets for type <italic toggle="yes">k</italic> is denoted as <italic toggle="yes">C<sub>k</sub></italic>. Let the cell annotation matrix <inline-formula id="IE6"><mml:math id="IM6" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mi>K</mml:mi><mml:mo>×</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold-italic">u</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold-italic">u</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold-italic">u</mml:mi></mml:mrow><mml:mi>n</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> be defined as: <italic toggle="yes">u<sub>ki</sub></italic> = 1 if cell <italic toggle="yes">i</italic> belongs to cluster <italic toggle="yes">C<sub>k</sub></italic><inline-formula id="IE7"><mml:math id="IM7" display="inline" overflow="scroll"><mml:mrow><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, <italic toggle="yes">u<sub>ki</sub></italic> = 0 otherwise, where <inline-formula id="IE8"><mml:math id="IM8" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="bold-italic">u</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> denotes the annotation vector of the <italic toggle="yes">i</italic>-th cell. Let <italic toggle="yes">g<sub>i</sub></italic> denote the cell type that the cell <italic toggle="yes">i</italic> belongs to. For each cell <italic toggle="yes">i</italic> in <italic toggle="yes">Z</italic>, the corresponding <inline-formula id="IE9"><mml:math id="IM9" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>. We build a semi-supervised model to infer the cell types of those in <inline-formula id="IE10"><mml:math id="IM10" display="inline" overflow="scroll"><mml:mrow><mml:mi>Z</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
      <p>CALLR achieves the cell annotation matrix <italic toggle="yes">U</italic> through the following optimization framework:
<disp-formula id="E1"><mml:math id="M1" display="block" overflow="scroll"><mml:mtable><mml:mtr><mml:mtd><mml:munder><mml:mrow><mml:mi>min</mml:mi></mml:mrow><mml:mrow><mml:mo>α</mml:mo><mml:mo>,</mml:mo><mml:mi>β</mml:mi><mml:mo>,</mml:mo><mml:mi>U</mml:mi></mml:mrow></mml:munder><mml:mo> </mml:mo><mml:mo>−</mml:mo><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mi>Z</mml:mi></mml:mrow></mml:munder><mml:mrow><mml:mo> </mml:mo><mml:mtext>log</mml:mtext><mml:mo> </mml:mo></mml:mrow><mml:mi>P</mml:mi><mml:mi>r</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold-italic">x</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mi>Z</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:munder><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>K</mml:mi></mml:munderover><mml:mrow><mml:msub><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow><mml:mo> </mml:mo><mml:mtext>log</mml:mtext><mml:mo> </mml:mo><mml:mi>P</mml:mi><mml:mi>r</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi>k</mml:mi><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold-italic">x</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mo> </mml:mo><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mo>λ</mml:mo></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mtext>tr</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>U</mml:mi><mml:mi>L</mml:mi><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mi>T</mml:mi></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mo>λ</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>K</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:mrow><mml:mo>|</mml:mo><mml:mo>|</mml:mo></mml:mrow><mml:msub><mml:mrow><mml:mi>β</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mo>|</mml:mo></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mi mathvariant="normal">s</mml:mi><mml:mo>.</mml:mo><mml:mi mathvariant="normal">t</mml:mi><mml:mo>.</mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mtext>log</mml:mtext><mml:mo> </mml:mo><mml:mfrac><mml:mrow><mml:mi>P</mml:mi><mml:mi>r</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi>k</mml:mi><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold-italic">x</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mi>P</mml:mi><mml:mi>r</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi>K</mml:mi><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold-italic">x</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mfrac><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mo>α</mml:mo></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msubsup><mml:mrow><mml:mi>β</mml:mi></mml:mrow><mml:mi>k</mml:mi><mml:mi>T</mml:mi></mml:msubsup><mml:msub><mml:mrow><mml:mi mathvariant="bold-italic">x</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mo>∀</mml:mo><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>k</mml:mi><mml:mo>≤</mml:mo><mml:mi>K</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>∀</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:msub><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn><mml:mo> </mml:mo><mml:mtext>or</mml:mtext><mml:mo> </mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>K</mml:mi></mml:munderover><mml:mrow><mml:msub><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mo>∀</mml:mo><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mi>Z</mml:mi><mml:mo>′</mml:mo><mml:mo>,</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mo> </mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>K</mml:mi></mml:munderover><mml:mi>P</mml:mi><mml:mi>r</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi>k</mml:mi><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold-italic">x</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mo>∀</mml:mo><mml:mi>i</mml:mi><mml:mo>.</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula></p>
      <p>Here, <italic toggle="yes">λ</italic><sub>1</sub> and <italic toggle="yes">λ</italic><sub>2</sub> are non-negative tuning parameters. <italic toggle="yes">L</italic> is the Laplacian matrix corresponding to the adjacency matrix constructed from the gene expression matrix <italic toggle="yes">X</italic>. After obtaining the 0–1 <italic toggle="yes">K </italic>×<italic toggle="yes"> n</italic> matrix <italic toggle="yes">U</italic>, the label of each cell <italic toggle="yes">i</italic> is the position where the element in the column vector <inline-formula id="IE11"><mml:math id="IM11" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="bold-italic">u</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> equals to 1.</p>
      <p>The intuition of this optimization problem is to combine sparse logistic regression and spectral clustering, which correspond to the supervised and unsupervised part, respectively. The first term in the optimization problem comes from logistic regression for the annotated cells, with <italic toggle="yes">α</italic> being a <inline-formula id="IE12"><mml:math id="IM12" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>K</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>×</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> vector explaining the intercept, and <inline-formula id="IE13"><mml:math id="IM13" display="inline" overflow="scroll"><mml:mi>β</mml:mi></mml:math></inline-formula> being the coefficient matrix of the <italic toggle="yes">m</italic> genes with size <inline-formula id="IE14"><mml:math id="IM14" display="inline" overflow="scroll"><mml:mrow><mml:mi>m</mml:mi><mml:mo>×</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>K</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. The third term comes from spectral clustering, which clusters the cells based on their similarities. The second term establishes a connection between them, which tries to make the results of logistic regression and spectral clustering correspond with each other. The fourth term is a regularization penalty term for the coefficients to avoid the overfitting.</p>
      <p>Let <inline-formula id="IE15"><mml:math id="IM15" display="inline" overflow="scroll"><mml:mrow><mml:mi>P</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mo>…</mml:mo><mml:mo> </mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mi>n</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> be the probability matrix for all the cells being in each cell type, where <inline-formula id="IE16"><mml:math id="IM16" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>P</mml:mi><mml:mi>r</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold-italic">x</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo> </mml:mo><mml:mo>,</mml:mo><mml:mi>P</mml:mi><mml:mi>r</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi>K</mml:mi><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold-italic">x</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mi>T</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula>. Ideally for each cell <italic toggle="yes">i</italic>, <italic toggle="yes">P<sub>i</sub></italic> should have one position near 1 and the other positions near 0. So when we calculate <inline-formula id="IE17"><mml:math id="IM17" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="bold-italic">u</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, we expect it to take a larger value (near its maximum 1) if the result from logistic regression and spectral clustering are corresponded. Besides, the second term also utilizes the unlabeled cells in sparse logistic regression. Thus by solving this optimization problem, we expect there is a clear classification of the cells into different types.</p>
    </sec>
    <sec>
      <title>2.2 Optimization algorithm</title>
      <p>The objective function in the optimization problem is nonconvex, but the objective function for logistic regression and spectral clustering are both convex. Thus, we optimize both parts alternately.</p>
      <p><inline-formula id="IE18"><mml:math id="IM18" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">Laplacian</mml:mi><mml:mo> </mml:mo><mml:mi mathvariant="italic">Matrix</mml:mi></mml:mrow></mml:math></inline-formula>. Before the iteration steps, we first need to compute the Laplacian matrix of the gene expression data. We apply <italic toggle="yes">k</italic>-nearest neighbors method to the Euclidean distance to construct the adjacency matrix <italic toggle="yes">A</italic>. We require that cell <italic toggle="yes">j</italic> has a connection to cell <italic toggle="yes">i</italic> if and only if both cell <italic toggle="yes">j</italic> and cell <italic toggle="yes">i</italic> are within their <italic toggle="yes">k</italic>-nearest neighbors, and set <italic toggle="yes">A<sub>ij</sub></italic> = 1. Otherwise we have <italic toggle="yes">A<sub>ij</sub></italic> = 0. With this, we have the structure of the similarity graph. Then we use Gaussian kernels to generate the weights for the edges in <italic toggle="yes">A</italic>. For each edge with <italic toggle="yes">A<sub>ij</sub></italic> = 1, we calculate their similarity <italic toggle="yes">S<sub>ij</sub></italic> using the same kernel as that in SIMLR (<xref rid="btab286-B46" ref-type="bibr">Wang <italic toggle="yes">et al.</italic>, 2017</xref>). We set the variance in Gaussian kernel as 1 and set the number of neighbors being 17 as default to get the empirical performance. The results are stable when both parameters take small changes. The Laplacian matrix is computed in the same way as spectral clustering does.</p>
      <p><italic toggle="yes">Initialization</italic>. We run logistic regression on the labeled training data to get the initial <italic toggle="yes">α</italic> and <inline-formula id="IE19"><mml:math id="IM19" display="inline" overflow="scroll"><mml:mi>β</mml:mi></mml:math></inline-formula>. Then we predict the labels of the unlabeled cells to get the initial value of matrix <italic toggle="yes">U</italic>.</p>
      <p><inline-formula id="IE20"><mml:math id="IM20" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">Step</mml:mi><mml:mo> </mml:mo><mml:mn>1</mml:mn><mml:mo>:</mml:mo><mml:mo> </mml:mo><mml:mi mathvariant="italic">Fix</mml:mi><mml:mo> </mml:mo><mml:mo>α</mml:mo><mml:mo> </mml:mo><mml:mi mathvariant="italic">and</mml:mi><mml:mo> </mml:mo><mml:mi>β</mml:mi><mml:mo> </mml:mo><mml:mi>t</mml:mi><mml:mi>o</mml:mi><mml:mo> </mml:mo><mml:mi mathvariant="italic">update</mml:mi><mml:mo> </mml:mo><mml:mi>U</mml:mi></mml:mrow></mml:math></inline-formula>. We rewrite the objective function with respect to (w.r.t) the label matrix <italic toggle="yes">U</italic> as follows:
<disp-formula id="E2"><mml:math id="M2" display="block" overflow="scroll"><mml:mtable><mml:mtr><mml:mtd><mml:munder><mml:mrow><mml:mi>min</mml:mi></mml:mrow><mml:mi>U</mml:mi></mml:munder><mml:mo> </mml:mo><mml:mo>−</mml:mo><mml:mo>μ</mml:mo><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mi>Z</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:munder><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>K</mml:mi></mml:munderover><mml:mrow><mml:msub><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow><mml:mo> </mml:mo><mml:mtext>log</mml:mtext><mml:mo> </mml:mo><mml:mi>P</mml:mi><mml:mi>r</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi>k</mml:mi><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold-italic">x</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mtext>tr</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>U</mml:mi><mml:mi>L</mml:mi><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mi>T</mml:mi></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mi mathvariant="normal">s</mml:mi><mml:mo>.</mml:mo><mml:mi mathvariant="normal">t</mml:mi><mml:mo>.</mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:msub><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn><mml:mo> </mml:mo><mml:mtext>or</mml:mtext><mml:mo> </mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>K</mml:mi></mml:munderover><mml:mrow><mml:msub><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mo>∀</mml:mo><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mi>Z</mml:mi><mml:mo>′</mml:mo><mml:mo>,</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula>where we set <inline-formula id="IE21"><mml:math id="IM21" display="inline" overflow="scroll"><mml:mrow><mml:mo>μ</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mrow><mml:mo>λ</mml:mo></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:mfrac></mml:mrow></mml:math></inline-formula> in the original objective function.</p>
      <p>Since there are 0–1 constraints in this problem, and the dimension of <italic toggle="yes">U</italic> is quite large, it is inefficient to directly solve such optimization problem using binary optimization methods. We instead develop a projected gradient descent method and a thresholding step to approximate the solution iteratively. We solve the optimization problem by the following two steps.</p>
      <p>1. The gradient descent step:
<disp-formula id="E3"><mml:math id="M3" display="block" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>U</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mi>N</mml:mi></mml:msup><mml:mo>+</mml:mo><mml:mo>△</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>−</mml:mo><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mi>N</mml:mi></mml:msup><mml:mi>L</mml:mi><mml:mo>+</mml:mo><mml:mo>μ</mml:mo><mml:mo> </mml:mo><mml:mtext>log</mml:mtext><mml:mo> </mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula></p>
      <p>2. Projection and thresholding step:
<disp-formula id="E4"><mml:math id="M4" display="block" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi mathvariant="bold-italic">u</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mrow><mml:mi>N</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:mi mathvariant="italic">projectToVertex</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="italic">projectToSimplex</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="bold-italic">u</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>where <italic toggle="yes">projectToSimplex</italic> projects a given vector to the simplex, while <italic toggle="yes">projectToVertex</italic> maps a vector to its nearest standard unit vector. Specifically, <italic toggle="yes">projectToSimplex</italic> finds <bold><italic toggle="yes">w</italic></bold> for a given vector <inline-formula id="IE22"><mml:math id="IM22" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="bold-italic">v</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mi>K</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula>, and is defined as:
<disp-formula id="E5"><mml:math id="M5" display="block" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">projectToSimplex</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>arg</mml:mi><mml:munder><mml:mrow><mml:mi>min</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="bold-italic">w</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mo>Δ</mml:mo></mml:mrow><mml:mi>K</mml:mi></mml:msup></mml:mrow></mml:munder><mml:mo>|</mml:mo><mml:mo>|</mml:mo><mml:mi mathvariant="bold-italic">w</mml:mi><mml:mo>−</mml:mo><mml:mi mathvariant="bold-italic">v</mml:mi><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mo>|</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>where
<disp-formula id="E6"><mml:math id="M6" display="block" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mo>Δ</mml:mo></mml:mrow><mml:mi>K</mml:mi></mml:msup><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="bold-italic">w</mml:mi><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo> </mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mi>K</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mi>T</mml:mi></mml:msup><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mi>K</mml:mi></mml:msup><mml:mo>:</mml:mo><mml:mn>0</mml:mn><mml:mo>≤</mml:mo><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>≤</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mtext>and</mml:mtext><mml:mo> </mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>K</mml:mi></mml:munderover><mml:mrow><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>while
<disp-formula id="E7"><mml:math id="M7" display="block" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">projectToVertex</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>arg</mml:mi><mml:munder><mml:mrow><mml:mi>min</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="bold-italic">w</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mo>Δ</mml:mo></mml:mrow><mml:mi>K</mml:mi></mml:msup></mml:mrow></mml:munder><mml:mo>|</mml:mo><mml:mo>|</mml:mo><mml:mi mathvariant="bold-italic">w</mml:mi><mml:mo>−</mml:mo><mml:mi mathvariant="bold-italic">v</mml:mi><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mo>|</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>where
<disp-formula id="E8"><mml:math id="M8" display="block" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mo>Δ</mml:mo></mml:mrow><mml:mi>K</mml:mi></mml:msup><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="bold-italic">w</mml:mi><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo> </mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mi>K</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mi>T</mml:mi></mml:msup><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mi>K</mml:mi></mml:msup><mml:mo>:</mml:mo><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn><mml:mo> </mml:mo><mml:mtext>or</mml:mtext><mml:mo> </mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mtext>and</mml:mtext><mml:mo> </mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>K</mml:mi></mml:munderover><mml:mrow><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:mn>1.</mml:mn></mml:mrow></mml:math></disp-formula></p>
      <p>For <italic toggle="yes">projectToSimplex</italic>, we use a similar algorithm as that proposed in (<xref rid="btab286-B8" ref-type="bibr">Chen and Ye, 2011</xref>), and <italic toggle="yes">projectToVertex</italic> directly projects <bold><italic toggle="yes">v</italic></bold> to the standard unit vector of the same maximum value. <inline-formula id="IE23"><mml:math id="IM23" display="inline" overflow="scroll"><mml:mrow><mml:mo>△</mml:mo><mml:mi>t</mml:mi></mml:mrow></mml:math></inline-formula> is step size in projected gradient descent method satisfying <inline-formula id="IE24"><mml:math id="IM24" display="inline" overflow="scroll"><mml:mrow><mml:mo>△</mml:mo><mml:mi>t</mml:mi><mml:mo>≤</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mi>L</mml:mi></mml:mfrac></mml:mrow></mml:math></inline-formula> for an <italic toggle="yes">L</italic>-smooth convex function we optimize. In practice, we set <inline-formula id="IE25"><mml:math id="IM25" display="inline" overflow="scroll"><mml:mrow><mml:mo>Δ</mml:mo><mml:mi>t</mml:mi><mml:mo>=</mml:mo><mml:mn>0.005</mml:mn></mml:mrow></mml:math></inline-formula> as default. We repeat 1 and 2 until the results of the two consecutive steps are the same. Then we get the solution of <italic toggle="yes">U</italic> at Step 1.</p>
      <p><inline-formula id="IE26"><mml:math id="IM26" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">Step</mml:mi><mml:mo> </mml:mo><mml:mn>2</mml:mn><mml:mo>:</mml:mo><mml:mi mathvariant="italic">Fix</mml:mi><mml:mo> </mml:mo><mml:mi>U</mml:mi><mml:mo> </mml:mo><mml:mi>t</mml:mi><mml:mi>o</mml:mi><mml:mo> </mml:mo><mml:mi mathvariant="italic">update</mml:mi><mml:mo> </mml:mo><mml:mo>α</mml:mo><mml:mo> </mml:mo><mml:mi mathvariant="italic">and</mml:mi><mml:mo> </mml:mo><mml:mi>β</mml:mi></mml:mrow></mml:math></inline-formula>. We rewrite the objective function w.r.t the logistic regression coefficients <italic toggle="yes">α</italic> and <inline-formula id="IE27"><mml:math id="IM27" display="inline" overflow="scroll"><mml:mi>β</mml:mi></mml:math></inline-formula> as follows.
<disp-formula id="E9"><mml:math id="M9" display="block" overflow="scroll"><mml:mtable><mml:mtr><mml:mtd><mml:munder><mml:mrow><mml:mi>min</mml:mi></mml:mrow><mml:mrow><mml:mo>α</mml:mo><mml:mo>,</mml:mo><mml:mi>β</mml:mi></mml:mrow></mml:munder><mml:mo> </mml:mo><mml:mo>−</mml:mo><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mi>Z</mml:mi></mml:mrow></mml:munder><mml:mrow><mml:mo> </mml:mo><mml:mtext>log</mml:mtext><mml:mo> </mml:mo></mml:mrow><mml:mi>P</mml:mi><mml:mi>r</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold-italic">x</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mi>Z</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:munder><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>K</mml:mi></mml:munderover><mml:mrow><mml:msub><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow><mml:mo> </mml:mo><mml:mtext>log</mml:mtext><mml:mo> </mml:mo><mml:mi>P</mml:mi><mml:mi>r</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi>k</mml:mi><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold-italic">x</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo> </mml:mo><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mo>λ</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>K</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:mrow><mml:mo>|</mml:mo><mml:mo>|</mml:mo></mml:mrow><mml:msub><mml:mrow><mml:mi>β</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mo>|</mml:mo></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mi mathvariant="normal">s</mml:mi><mml:mo>.</mml:mo><mml:mi mathvariant="normal">t</mml:mi><mml:mo>.</mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mtext>log</mml:mtext><mml:mo> </mml:mo><mml:mfrac><mml:mrow><mml:mi>P</mml:mi><mml:mi>r</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi>k</mml:mi><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold-italic">x</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mi>P</mml:mi><mml:mi>r</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi>K</mml:mi><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold-italic">x</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mfrac><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mo>α</mml:mo></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msubsup><mml:mrow><mml:mi>β</mml:mi></mml:mrow><mml:mi>k</mml:mi><mml:mi>T</mml:mi></mml:msubsup><mml:msub><mml:mrow><mml:mi mathvariant="bold-italic">x</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mo>∀</mml:mo><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>k</mml:mi><mml:mo>≤</mml:mo><mml:mi>K</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>∀</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mo> </mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>K</mml:mi></mml:munderover><mml:mi>P</mml:mi><mml:mi>r</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi>k</mml:mi><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold-italic">x</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mo>∀</mml:mo><mml:mi>i</mml:mi><mml:mo>.</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula></p>
      <p>Given <italic toggle="yes">U</italic>, this optimization problem becomes the sparse logistic regression on all the cells. We use the R package glmnet to complete this step.</p>
      <p>CALLR iterates step 1 and step 2 until convergence. In practice, we stop the algorithm when the results of the two consecutive steps become very close. We put the whole computation process in <xref rid="btab286-BOX1" ref-type="boxed-text">Algorithm 1</xref>.</p>
      <p><boxed-text id="btab286-BOX1" position="float"><sec><title><bold>Algorithm 1</bold> CALLR: Cell Annotation using Laplacian and Logistic Regression</title><p><bold>Input:</bold></p><p> <italic toggle="yes">X</italic>: scRNA-seq matrix; <italic toggle="yes">Z</italic>: index set of the annotated cells;</p><p> <inline-formula id="IE28"><mml:math id="IM28" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="bold-italic">y</mml:mi></mml:mrow><mml:mi>Z</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>: labels of the annotated cells;</p><p> <italic toggle="yes">K</italic>: number of clusters given by the annotated dataset;</p><p> <italic toggle="yes">L</italic>: Laplacian matrix constructed from all the cells;</p><p> <inline-formula id="IE29"><mml:math id="IM29" display="inline" overflow="scroll"><mml:mrow><mml:mo>△</mml:mo><mml:mi>t</mml:mi></mml:mrow></mml:math></inline-formula>: step size in the descent step; <inline-formula id="IE30"><mml:math id="IM30" display="inline" overflow="scroll"><mml:mrow><mml:mo>μ</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mrow><mml:mo>λ</mml:mo></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:mfrac></mml:mrow></mml:math></inline-formula>: parameter;</p><p><bold>Output:</bold>  <inline-formula id="IE31"><mml:math id="IM31" display="inline" overflow="scroll"><mml:mi mathvariant="bold-italic">y</mml:mi></mml:math></inline-formula>: cell labels;
</p><list list-type="order"><list-item><p><inline-formula id="IE32"><mml:math id="IM32" display="inline" overflow="scroll"><mml:mrow><mml:mi>P</mml:mi><mml:mo>←</mml:mo><mml:mi mathvariant="italic">SparseLogisticRegression</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>X</mml:mi></mml:mrow><mml:mi>Z</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold-italic">y</mml:mi></mml:mrow><mml:mi>Z</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula></p></list-item><list-item><p><inline-formula id="IE33"><mml:math id="IM33" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="italic">old</mml:mi></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mn>0</mml:mn></mml:msup><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula></p></list-item><list-item><p><inline-formula id="IE34"><mml:math id="IM34" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="italic">new</mml:mi></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:mi mathvariant="italic">rand</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="bold-italic">u</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mrow><mml:mi mathvariant="italic">new</mml:mi></mml:mrow></mml:msubsup><mml:mo>←</mml:mo><mml:mi mathvariant="italic">projectToSimplex</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="bold-italic">u</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mrow><mml:mi mathvariant="italic">new</mml:mi></mml:mrow></mml:msubsup><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mo>∀</mml:mo><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mi>Z</mml:mi><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:msubsup><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="italic">new</mml:mi></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mo>∀</mml:mo><mml:mi>j</mml:mi><mml:mo>≠</mml:mo><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:msubsup><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="italic">new</mml:mi></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula></p></list-item><list-item><p><bold>while</bold>  <inline-formula id="IE35"><mml:math id="IM35" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:mo>|</mml:mo><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="italic">new</mml:mi></mml:mrow></mml:msup><mml:mo>−</mml:mo><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="italic">old</mml:mi></mml:mrow></mml:msup><mml:mo>|</mml:mo><mml:mo>|</mml:mo><mml:mo>&gt;</mml:mo><mml:msub><mml:mrow><mml:mo>ϵ</mml:mo></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula>  <bold>do</bold></p></list-item><list-item><p><inline-formula id="IE36"><mml:math id="IM36" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="italic">old</mml:mi></mml:mrow></mml:msup><mml:mo>←</mml:mo><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="italic">new</mml:mi></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msup><mml:mo>←</mml:mo><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="italic">new</mml:mi></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mi>N</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula></p></list-item><list-item><p> <bold>while</bold>  <inline-formula id="IE37"><mml:math id="IM37" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:mo>|</mml:mo><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mi>N</mml:mi></mml:msup><mml:mo>−</mml:mo><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mi>N</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mo>|</mml:mo><mml:mo>|</mml:mo><mml:mo>&gt;</mml:mo><mml:msub><mml:mrow><mml:mo>ϵ</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula>  <bold>do</bold></p></list-item><list-item><p>  <inline-formula id="IE38"><mml:math id="IM38" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>U</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>←</mml:mo><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mi>N</mml:mi></mml:msup><mml:mo>+</mml:mo><mml:mo>△</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>−</mml:mo><mml:mi>L</mml:mi><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mi>N</mml:mi></mml:msup><mml:mo>+</mml:mo><mml:mo>μ</mml:mo><mml:mo> </mml:mo><mml:mtext>log</mml:mtext><mml:mo> </mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula></p></list-item><list-item><p>  <bold>for</bold>  <inline-formula id="IE39"><mml:math id="IM39" display="inline" overflow="scroll"><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>:</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:math></inline-formula>  <bold>do</bold></p></list-item><list-item><p>   <inline-formula id="IE40"><mml:math id="IM40" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi mathvariant="bold-italic">u</mml:mi></mml:mrow><mml:mi>j</mml:mi><mml:mrow><mml:mi>N</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo>←</mml:mo><mml:mi mathvariant="italic">projectToSimplex</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="bold-italic">u</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula></p></list-item><list-item><p>   <inline-formula id="IE41"><mml:math id="IM41" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi mathvariant="bold-italic">u</mml:mi></mml:mrow><mml:mi>j</mml:mi><mml:mrow><mml:mi>N</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo>←</mml:mo><mml:mi mathvariant="italic">projectToVertex</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="bold-italic">u</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula></p></list-item><list-item><p>  <inline-formula id="IE42"><mml:math id="IM42" display="inline" overflow="scroll"><mml:mrow><mml:mi>N</mml:mi><mml:mo>←</mml:mo><mml:mi>N</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula></p></list-item><list-item><p> <inline-formula id="IE43"><mml:math id="IM43" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="italic">new</mml:mi></mml:mrow></mml:msup><mml:mo>←</mml:mo><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mi>N</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula></p></list-item><list-item><p> <bold>for</bold>  <inline-formula id="IE44"><mml:math id="IM44" display="inline" overflow="scroll"><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>:</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:math></inline-formula>  <bold>do</bold></p></list-item><list-item><p>  <inline-formula id="IE45"><mml:math id="IM45" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="bold-italic">y</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>←</mml:mo><mml:mi mathvariant="italic">which</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="bold-italic">u</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mi>N</mml:mi></mml:msubsup><mml:mo>=</mml:mo><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula></p></list-item><list-item><p> <inline-formula id="IE46"><mml:math id="IM46" display="inline" overflow="scroll"><mml:mrow><mml:mi>P</mml:mi><mml:mo>←</mml:mo><mml:mi mathvariant="italic">SparseLogisticRegression</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>X</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="bold-italic">y</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula></p></list-item><list-item><p><bold>return <italic toggle="yes">y</italic></bold></p></list-item></list></sec></boxed-text>For <xref rid="btab286-BOX1" ref-type="boxed-text">Algorithm 1</xref>, besides the outer iterations for alternately updating <italic toggle="yes">U</italic> and <italic toggle="yes">β</italic>, both steps include inner iterations. Step 1 involves the gradient descent step, which requires <inline-formula id="IE47"><mml:math id="IM47" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>K</mml:mi><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> operations, and the projection and thresholding step, which requires <inline-formula id="IE48"><mml:math id="IM48" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> operations. As <italic toggle="yes">K </italic>&lt;<italic toggle="yes"> n</italic>, the complexity of this step can be written as <inline-formula id="IE49"><mml:math id="IM49" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>×</mml:mo><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>K</mml:mi><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, where <italic toggle="yes">N</italic><sub>1</sub> is the number of inner iterations. Step 2 implements glmnet, which includes a so-called partial Newton algorithm and the coordinate descent step (<xref rid="btab286-B13" ref-type="bibr">Friedman <italic toggle="yes">et al.</italic>, 2010</xref>). This step is of computational complexity <inline-formula id="IE50"><mml:math id="IM50" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>×</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="italic">Knp</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mn>3</mml:mn></mml:msub><mml:mo>×</mml:mo><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="italic">Knp</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> (<xref rid="btab286-B49" ref-type="bibr">Yuan <italic toggle="yes">et al.</italic>, 2012</xref>), where <italic toggle="yes">N</italic><sub>2</sub>, <italic toggle="yes">N</italic><sub>3</sub> are the number of iterations for step 2 and coordinate descent within step 2. For the space complexity, step 1 requires the space of <inline-formula id="IE51"><mml:math id="IM51" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo>+</mml:mo><mml:mi>n</mml:mi><mml:mi>K</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, and step 2 requires the storage of <inline-formula id="IE52"><mml:math id="IM52" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mi>n</mml:mi><mml:mi>p</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
    </sec>
    <sec>
      <title>2.3 Preparation of the labeled cells</title>
      <p>In the proposed method CALLR, we assume that we have known a few number of annotated cells. These cells can be labeled manually as usually do (<xref rid="btab286-B51" ref-type="bibr">Zhang <italic toggle="yes">et al.</italic>, 2019b</xref>), and they can also be selected with some state of the art computational methods. Currently, we apply the scoring technique developed in Garnett (<xref rid="btab286-B33" ref-type="bibr">Pliner <italic toggle="yes">et al.</italic>, 2019</xref>) to select the representative cells. The scoring framework consists of 3 steps. First, the term frequency-inverse document frequency (TF-IDF) matrix is calculated, which is defined by
<disp-formula id="E10"><mml:math id="M10" display="block" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mrow><mml:mi>X</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>m</mml:mi></mml:munderover><mml:mrow><mml:msub><mml:mrow><mml:mi>X</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:mfrac><mml:mo>×</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mfrac><mml:mi>n</mml:mi><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:munderover><mml:mrow><mml:msub><mml:mrow><mml:mi>X</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:mfrac><mml:mo stretchy="true">)</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>where <inline-formula id="IE53"><mml:math id="IM53" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>X</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> is the normalized gene expression matrix defined above. Then we assign a cutoff <italic toggle="yes">C<sub>i</sub></italic> of each gene
<disp-formula id="E11"><mml:math id="M11" display="block" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mn>0.25</mml:mn><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>where <italic toggle="yes">q<sub>i</sub></italic> is the 95th percentile of <italic toggle="yes">T</italic> for gene <italic toggle="yes">i</italic>. Any value <inline-formula id="IE54"><mml:math id="IM54" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> below <italic toggle="yes">C<sub>i</sub></italic> will be set to 0. Finally, we define the marker score <inline-formula id="IE55"><mml:math id="IM55" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> for cell type <italic toggle="yes">c</italic> and cell <italic toggle="yes">j</italic> as
<disp-formula id="E12"><mml:math id="M12" display="block" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mi>c</mml:mi></mml:msub></mml:mrow></mml:munder><mml:mrow><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>where <italic toggle="yes">G<sub>c</sub></italic> is the list of marker genes for cell type <italic toggle="yes">c</italic>. In our example, cells in the 85th percentile and above for marker score <italic toggle="yes">S</italic> in only one cell type are chosen as representatives for that type. More details can be found in (<xref rid="btab286-B33" ref-type="bibr">Pliner <italic toggle="yes">et al.</italic>, 2019</xref>).</p>
    </sec>
  </sec>
  <sec>
    <title>3 Results</title>
    <p>In this section, we evaluate CALLR using the real-world datasets and present the results compared to other models.</p>
    <sec>
      <title>3.1 Datasets</title>
      <p>We downloaded 10 publicly available scRNA-seq datasets, and they are summarized in <xref rid="btab286-T1" ref-type="table">Table 1</xref>. We mainly chose the data generated using 10X, which can provide high-throughput data efficiently. Datasets of five mouse organs’ scRNA-seq from Tabula Muris generated using 10X were selected, which include bladder, kidney, lung, marrow and tongue (Tabula Muris Consortium <italic toggle="yes">et al.</italic>, 2018). For the dataset ‘Lung’, depending on the marker file used in Garnett (<xref rid="btab286-B33" ref-type="bibr">Pliner <italic toggle="yes">et al.</italic>, 2019</xref>), we selected four cell types. ‘Baron’ is a scRNA-seq dataset for human pancreatic islets (<xref rid="btab286-B2" ref-type="bibr">Baron <italic toggle="yes">et al.</italic>, 2016</xref>). We selected donor one of the four donors in this study. The cells were sequenced using inDrop. Two datasets of Peripheral Blood Mononuclear Cells (PBMC) are ‘PBMC10X’ and ‘PBMCSeqWell’, which were generated using 10X and SeqWell (<xref rid="btab286-B6" ref-type="bibr">Butler <italic toggle="yes">et al.</italic>, 2018</xref>; <xref rid="btab286-B15" ref-type="bibr">Gierahn <italic toggle="yes">et al.</italic>, 2017</xref>). ‘PBMC10X’ originally includes 2638 cells from 8 cell types. According to the marker file used in Garnett (<xref rid="btab286-B33" ref-type="bibr">Pliner <italic toggle="yes">et al.</italic>, 2019</xref>), we combined four types of them into two, and took six types finally. ‘Chen’ is a large dataset consisting of 23 284 genes and 14 437 cells in 47 cell types (<xref rid="btab286-B7" ref-type="bibr">Chen <italic toggle="yes">et al.</italic>, 2017</xref>). All the cells in these datasets have their true annotated labels.</p>
      <table-wrap position="float" id="btab286-T1">
        <label>Table 1</label>
        <caption>
          <p>Summary of the 10 real datasets</p>
        </caption>
        <table frame="hsides" rules="groups">
          <colgroup span="1">
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="char" char="×" span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="left" span="1"/>
          </colgroup>
          <thead>
            <tr>
              <th rowspan="1" colspan="1">Data/references</th>
              <th rowspan="1" colspan="1">Protocol</th>
              <th rowspan="1" colspan="1">
                <inline-formula id="IE56">
                  <mml:math id="IM56" display="inline" overflow="scroll">
                    <mml:mrow>
                      <mml:msub>
                        <mml:mrow>
                          <mml:mi>N</mml:mi>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi mathvariant="italic">gene</mml:mi>
                        </mml:mrow>
                      </mml:msub>
                      <mml:mo>×</mml:mo>
                      <mml:msub>
                        <mml:mrow>
                          <mml:mi>N</mml:mi>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi mathvariant="italic">cell</mml:mi>
                        </mml:mrow>
                      </mml:msub>
                    </mml:mrow>
                  </mml:math>
                </inline-formula>
              </th>
              <th rowspan="1" colspan="1">Cell types</th>
              <th rowspan="1" colspan="1">Tissues</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="1" colspan="1">Baron (<xref rid="btab286-B2" ref-type="bibr">Baron <italic toggle="yes">et al.</italic>, 2016</xref>)</td>
              <td rowspan="1" colspan="1">InDrop</td>
              <td rowspan="1" colspan="1">20 125 × 1937</td>
              <td rowspan="1" colspan="1">14</td>
              <td rowspan="1" colspan="1">Pancreatic islets</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Bladder (Consortium <italic toggle="yes">et al.</italic>, 2018)</td>
              <td rowspan="1" colspan="1">10X</td>
              <td rowspan="1" colspan="1">23 433 × 2500</td>
              <td rowspan="1" colspan="1">4</td>
              <td rowspan="1" colspan="1">Bladder</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Chen (<xref rid="btab286-B7" ref-type="bibr">Chen <italic toggle="yes">et al.</italic>, 2017</xref>)</td>
              <td rowspan="1" colspan="1">Drop-seq</td>
              <td rowspan="1" colspan="1">23 284 × 14 437</td>
              <td rowspan="1" colspan="1">47</td>
              <td rowspan="1" colspan="1">Hypothalamus</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Kidney (Consortium <italic toggle="yes">et al.</italic>, 2018)</td>
              <td rowspan="1" colspan="1">10X</td>
              <td rowspan="1" colspan="1">23 433 × 2781</td>
              <td rowspan="1" colspan="1">8</td>
              <td rowspan="1" colspan="1">Kidney</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Lung (Consortium <italic toggle="yes">et al.</italic>, 2018)</td>
              <td rowspan="1" colspan="1">10X</td>
              <td rowspan="1" colspan="1">23 433 × 835</td>
              <td rowspan="1" colspan="1">4</td>
              <td rowspan="1" colspan="1">Lung</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Marrow (Consortium <italic toggle="yes">et al.</italic>, 2018)</td>
              <td rowspan="1" colspan="1">10X</td>
              <td rowspan="1" colspan="1">23 433 × 1732</td>
              <td rowspan="1" colspan="1">14</td>
              <td rowspan="1" colspan="1">Marrow</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">PBMC10X (<xref rid="btab286-B6" ref-type="bibr">Butler <italic toggle="yes">et al.</italic>, 2018</xref>)</td>
              <td rowspan="1" colspan="1">10X</td>
              <td rowspan="1" colspan="1">32 738 × 2638</td>
              <td rowspan="1" colspan="1">6</td>
              <td rowspan="1" colspan="1">Blood</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">PBMCSeqWell (<xref rid="btab286-B15" ref-type="bibr">Gierahn <italic toggle="yes">et al.</italic>, 2017</xref>)</td>
              <td rowspan="1" colspan="1">SeqWell</td>
              <td rowspan="1" colspan="1">6173 × 3694</td>
              <td rowspan="1" colspan="1">6</td>
              <td rowspan="1" colspan="1">Blood</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Seger (<xref rid="btab286-B34" ref-type="bibr">Segerstolpe et al., 2016</xref>)</td>
              <td rowspan="1" colspan="1">Smart-Seq</td>
              <td rowspan="1" colspan="1">25 525 × 1099</td>
              <td rowspan="1" colspan="1">9</td>
              <td rowspan="1" colspan="1">Pancreatic islet</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Tongue (<xref rid="btab286-B37" ref-type="bibr">Tabula Muris Consortium <italic toggle="yes">et al.</italic>, 2018</xref>)</td>
              <td rowspan="1" colspan="1">10X</td>
              <td rowspan="1" colspan="1">23 433 × 7538</td>
              <td rowspan="1" colspan="1">3</td>
              <td rowspan="1" colspan="1">Tongue</td>
            </tr>
          </tbody>
        </table>
      </table-wrap>
    </sec>
    <sec>
      <title>3.2 Cell-type annotation results</title>
      <p>As CALLR is a semi-supervised learning method, it can give the exact labels for all the unannotated cells. We compared CALLR with both (semi-)supervised learning methods and unsupervised learning methods. For (semi-)supervised methods, as the problem is multi-class classification, we used accuracy to measure their performance. For both unsupervised and supervised learning methods, we used the criteria NMI and ARI to measure their performance. Adjusted Rand Index (ARI) and Normalized Mutual Information (NMI) are two widely used criteria to measure the performance of clustering. They measure the similarity between two distinct partitions (one corresponding to the true clusters in our case) over a same dataset. Suppose there are two sets of clusters <inline-formula id="IE57"><mml:math id="IM57" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">C</mml:mi></mml:mrow><mml:mi>A</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE58"><mml:math id="IM58" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">C</mml:mi></mml:mrow><mml:mi>B</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> for partitions <italic toggle="yes">A</italic> and <italic toggle="yes">B</italic> over the same dataset containing <italic toggle="yes">n</italic> data points. Let <inline-formula id="IE59"><mml:math id="IM59" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">C</mml:mi></mml:mrow><mml:mi>A</mml:mi></mml:msub><mml:mo>|</mml:mo><mml:mo>=</mml:mo><mml:mi>I</mml:mi></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE60"><mml:math id="IM60" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">C</mml:mi></mml:mrow><mml:mi>B</mml:mi></mml:msub><mml:mo>|</mml:mo><mml:mo>=</mml:mo><mml:mi>J</mml:mi><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">C</mml:mi></mml:mrow><mml:mi>A</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>A</mml:mi><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>A</mml:mi><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>A</mml:mi><mml:mi>I</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE61"><mml:math id="IM61" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">C</mml:mi></mml:mrow><mml:mi>B</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>B</mml:mi><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>B</mml:mi><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>B</mml:mi><mml:mi>J</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>. Let <italic toggle="yes">n<sub>ij</sub></italic> be the number of entries that belong to both <italic toggle="yes">C<sub>Ai</sub></italic> and <italic toggle="yes">C<sub>Bj</sub></italic>, that is, <inline-formula id="IE62"><mml:math id="IM62" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:mo>|</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>A</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>∩</mml:mo><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>B</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>|</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>. ARI is given as:
<disp-formula id="E13"><mml:math id="M13" display="block" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">ARI</mml:mi><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mi>R</mml:mi><mml:mi>I</mml:mi><mml:mo>−</mml:mo><mml:mi>E</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>R</mml:mi><mml:mi>I</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mi>max</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>R</mml:mi><mml:mi>I</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:mi>E</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>R</mml:mi><mml:mi>I</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mfrac><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>where Rand Index (RI) is defined as:
<disp-formula id="E14"><mml:math id="M14" display="block" overflow="scroll"><mml:mrow><mml:mi>R</mml:mi><mml:mi>I</mml:mi><mml:mo>=</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>I</mml:mi></mml:munderover><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>J</mml:mi></mml:munderover><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>2</mml:mn></mml:mtd></mml:mtr></mml:mtable></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mrow><mml:mo>/</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mi>n</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>2</mml:mn></mml:mtd></mml:mtr></mml:mtable></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p>
      <p>NMI is defined as:
<disp-formula id="E15"><mml:math id="M15" display="block" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">NMI</mml:mi><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mn>2</mml:mn><mml:mi>I</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">C</mml:mi></mml:mrow><mml:mi>A</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">C</mml:mi></mml:mrow><mml:mi>B</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mi>H</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">C</mml:mi></mml:mrow><mml:mi>A</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>H</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">C</mml:mi></mml:mrow><mml:mi>B</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mfrac><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>where
<disp-formula id="E16"><mml:math id="M16" display="block" overflow="scroll"><mml:mtable><mml:mtr><mml:mtd><mml:mi>I</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">C</mml:mi></mml:mrow><mml:mi>A</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">C</mml:mi></mml:mrow><mml:mi>B</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:munder><mml:mrow><mml:mfrac><mml:mrow><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mi>n</mml:mi></mml:mfrac></mml:mrow><mml:mo> </mml:mo><mml:mtext>log</mml:mtext><mml:mo> </mml:mo><mml:mfrac><mml:mrow><mml:mi>n</mml:mi><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>A</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>|</mml:mo><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>B</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>|</mml:mo></mml:mrow></mml:mfrac><mml:mo>,</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mi>H</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">C</mml:mi></mml:mrow><mml:mi>A</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo>−</mml:mo><mml:munder><mml:mo>∑</mml:mo><mml:mi>i</mml:mi></mml:munder><mml:mrow><mml:mfrac><mml:mrow><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>A</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>|</mml:mo></mml:mrow><mml:mi>n</mml:mi></mml:mfrac></mml:mrow><mml:mo> </mml:mo><mml:mtext>log</mml:mtext><mml:mo> </mml:mo><mml:mfrac><mml:mrow><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>A</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>|</mml:mo></mml:mrow><mml:mi>n</mml:mi></mml:mfrac><mml:mo>,</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula>and <inline-formula id="IE63"><mml:math id="IM63" display="inline" overflow="scroll"><mml:mrow><mml:mi>H</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">C</mml:mi></mml:mrow><mml:mi>B</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is defined similarly. For the (semi-)supervised learning methods, we considered sparse logistic regression in R package glmnet (<xref rid="btab286-B13" ref-type="bibr">Friedman <italic toggle="yes">et al.</italic>, 2010</xref>) and multiclass graph-based MBO method (<xref rid="btab286-B14" ref-type="bibr">Garcia-Cardona <italic toggle="yes">et al.</italic>, 2014</xref>), where sparse logistic regression is a popular supervised learning method, while MBO is a semi-supervised learning method. We also considered a deep learning method ‘ItClust’, which is a transfer learning algorithm with neural network and utilizes external well-annotated source data to better label the target data (Hu <italic toggle="yes">et al.</italic>, 2020). We took the annotated cells as the source data, and labeled the remaining cells. We randomly selected 5% of the cells with their true labels as the annotated subset, and ran the (semi-)supervised algorithms. For the unsupervised clustering methods, we considered SIMLR (Wang <italic toggle="yes">et al.</italic>, 2017), Seurat (Butler <italic toggle="yes">et al.</italic>, 2018), and SAME (Huh <italic toggle="yes">et al.</italic>, 2020). We selected SIMLR and Seurat because both are graph-based clustering methods, which have some similarities with spectral clustering. Furthermore, SIMLR integrates different kernel-based similarities to visualize and cluster the cells. Seurat performs clustering using different algorithms such as the Louvain algorithm (<xref rid="btab286-B4" ref-type="bibr">Blondel <italic toggle="yes">et al.</italic>, 2008</xref>), Smart Local Moving (SLM) algorithm (<xref rid="btab286-B45" ref-type="bibr">Waltman and van Eck, 2013</xref>), and Leiden algorithm (<xref rid="btab286-B41" ref-type="bibr">Traag <italic toggle="yes">et al.</italic>, 2019</xref>) to optimize the standard modularity function for the shared nearest neighbor graph, which is constructed from the <italic toggle="yes">k</italic>-nearest neighbor graph using Jaccard index. We applied the default method ‘Louvain algorithm’. SAME aggregates the clustering results from multiple methods via mixture model ensemble, thus it owns the advantages of various methods. Here, SAME aggregated the results from SIMLR, Seurat and tSNE + <italic toggle="yes">k</italic>-means (first do tSNE, then <italic toggle="yes">k</italic>-means clustering). For these methods, we directly used the R packages: SIMLR, Seurat, and SAME.</p>
      <p>We first compared CALLR with the clustering methods. Since the results from sparse logistic regression, MBO and ItClust can be taken as clusters, we also measured these three methods using ARI and NMI. All the results are shown in <xref rid="btab286-F2" ref-type="fig">Figure 1a</xref> and <xref rid="btab286-F2" ref-type="fig">b</xref>. According to both ARI and NMI, CALLR performs the best or second best in almost all datasets. Only ItClust performs slightly better than CALLR throughout 10 datasets. As ItClust is a deep learning framework, it may capture more effective details in some specific data than CALLR does. <xref rid="btab286-F2" ref-type="fig">Figure 1d</xref> plots the boxplot for the performance of the seven methods. We ranked each model according ARI and NMI for 10 datasets. There are a total of 20 ranks for each model. The boxplot shows each model’s ranks across all datasets. Lower rank represents better performance (one is the best and seven is the worst). It is clear that CALLR performs more stable than ItClust. We note that CALLR does not perform well in dataset ‘Chen’. This is because when we applied CALLR to ‘Chen’, we divided the dataset into several subsets to separately get the final labels based on the same labeled subset due to the large size of this dataset. This also motivates us to develop faster algorithms for our model.</p>
      <fig position="float" id="btab286-F1">
        <label>Fig. 1.</label>
        <caption>
          <p>Performance comparison on 10 benchmark datasets. (<bold>a</bold>) ARI. (<bold>b</bold>) NMI. (<bold>c</bold>) Classification accuracy. (<bold>d</bold>) Rank of all seven methods. (<bold>e</bold>) Rank of four (semi-)supervised methods</p>
        </caption>
        <graphic xlink:href="btab286f1" position="float"/>
      </fig>
      <fig position="float" id="btab286-F2">
        <label>Fig. 2.</label>
        <caption>
          <p>Visualization of the cells in ‘PBMC10X’</p>
        </caption>
        <graphic xlink:href="btab286f2" position="float"/>
      </fig>
      <p>We then compared CALLR with sparse logistic regression, MBO and ItClust. All of these four methods can give exact label for each cell. The accuracy of the classification is shown in <xref rid="btab286-F2" ref-type="fig">Figure 1c</xref>. In both ‘Bladder’ and ‘Lung’, four methods perform similarly because these two datasets only contain four types of cells. CALLR and ItClust achieve a little higher accuracy. For the dataset ‘Chen’, again, due to the separate subset labeling, CALLR does not perform well. For the remaining seven datasets, CALLR performs significantly better than the other three methods. In ‘Baron’, ‘Chen’ and ‘Marrow’, CALLR performs much better than ItClust because they are of more cell types. It indicates that CALLR has great adaptability to deal with large datasets with complex cell types compared to ItClust. We also show the boxplot of CALLR, MBO, glmnet and ItClust for all indexes. The results are shown in <xref rid="btab286-F2" ref-type="fig">Figure 1e</xref>. CALLR has an outstanding and robust performance compared to the other three.</p>
      <p>To clearly see the differences of these compared methods, we visualized the cells in a 2D space using umap (<xref rid="btab286-B3" ref-type="bibr">Becht <italic toggle="yes">et al.</italic>, 2019</xref>). We put the dataset ‘PBMC10X’ as the example. The results are shown in <xref rid="btab286-F2" ref-type="fig">Figure 2</xref>. It is clear that (semi-)supervised methods perform much better than pure clustering. For (semi-)supervised methods, CALLR assigns more cells to their types correctly. To be specific, CALLR can successfully separate NK cells and T cells while other methods fail to distinguish some cells from these two types.</p>
      <p>We further compared CALLR with Garnett, which uses marker genes to first determine the types of a small set of cells. We downloaded the marker gene files of ‘Lung’ and ‘PBMC10X’ directly from the Supplementary Materials of Garnett, and applied the same scoring technique developed in Garnett to first determine the labels of a small number of cells. In Garnett, cells having aggregated marker score greater than the 75th percentile in only one cell type are chosen as good representatives. For CALLR, we used two thresholds: the 75th percentile and the 85th percentile. The results are shown in <xref rid="btab286-F3" ref-type="fig">Figure 3</xref>. In both cases, CALLR have much better performance than Garnett. For ‘Lung’, CALLR gave similar performance in both cases. For ‘PBMC10X’, more known labeled cells gave better performance, which is consistent with our intuition. All the results show that even with fewer known labeled cells, CALLR greatly improves sparse logistic regression.</p>
      <fig position="float" id="btab286-F3">
        <label>Fig. 3.</label>
        <caption>
          <p>Cell-type annotation with the labeled cells determined by marker genes. ‘CALLR’ uses two thresholds the 75th and 85th percentile for representative cell selection</p>
        </caption>
        <graphic xlink:href="btab286f3" position="float"/>
      </fig>
      <p>We conducted the experiments in a Laptop with CPU 3.1 GHz Intel Core i5 and memory 8 GB 2133 MHz LPDDR3 to check the computational time. When the cell size is of 835 (dataset ‘Lung’), it took 3 min. When the cell size is of 2500 (dataset ‘Bladder’), it took 15 min. And when the sample size is of 7538 (dataset ‘Tongue’), it took about 2 h and a half. When the sample size is very large (dataset ‘Chen’), we divided the cells into several groups correspondingly, and ran the algorithm separately to cluster each group. This procedure can save time and space, but may lose some annotation accuracy.</p>
    </sec>
    <sec>
      <title>3.3 Effect of the number of labeled cells</title>
      <p>We did experiments to investigate the relationship between the labeled cells’ size and the performance of annotation. We denoted the ratio of the size of labeled cells to the total sample size as <inline-formula id="IE64"><mml:math id="IM64" display="inline" overflow="scroll"><mml:mrow><mml:mi>r</mml:mi><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow><mml:mi>n</mml:mi></mml:mfrac></mml:mrow></mml:math></inline-formula>. Here we show the results on the ‘Lung’ data matrix.</p>
      <p>We let <inline-formula id="IE65"><mml:math id="IM65" display="inline" overflow="scroll"><mml:mrow><mml:mi>r</mml:mi><mml:mo>=</mml:mo><mml:mn>0.02</mml:mn><mml:mo>,</mml:mo><mml:mn>0.05</mml:mn><mml:mo>,</mml:mo><mml:mn>0.1</mml:mn><mml:mo>,</mml:mo><mml:mn>0.2</mml:mn><mml:mo>,</mml:mo><mml:mn>0.3</mml:mn></mml:mrow></mml:math></inline-formula> to select the labeled cells randomly. For each value of <italic toggle="yes">r</italic>, we repeated the experiments for 10 times and calculated the accuracy of classification to the cell types. We recorded the accuracy means and standard deviations. The result is shown in <xref rid="btab286-F4" ref-type="fig">Figure 4</xref>. When <italic toggle="yes">r</italic> is very small, the results highly depend on the number of labeled cells. When <italic toggle="yes">r </italic>&gt;<italic toggle="yes"> </italic>0.05, the results become very stable. This shows that CALLR needs only a few labeled cells, and they can help improve the annotation greatly. In the vast majority of cases on different datasets, we have <inline-formula id="IE66"><mml:math id="IM66" display="inline" overflow="scroll"><mml:mrow><mml:mn>0.05</mml:mn><mml:mo>&lt;</mml:mo><mml:mi>r</mml:mi><mml:mo>&lt;</mml:mo><mml:mn>0.3</mml:mn></mml:mrow></mml:math></inline-formula> can give reliable results.</p>
      <fig position="float" id="btab286-F4">
        <label>Fig. 4.</label>
        <caption>
          <p>Classification accuracy for different ratios of labeled cells</p>
        </caption>
        <graphic xlink:href="btab286f4" position="float"/>
      </fig>
    </sec>
    <sec>
      <title>3.4 Parameter selection</title>
      <p>The optimization problem contains two tuning parameters: <italic toggle="yes">λ</italic><sub>1</sub> for balancing the effect of logistic regression term and the spectral clustering term, and <italic toggle="yes">λ</italic><sub>2</sub> for regularization in sparse logistic regression. For <italic toggle="yes">λ</italic><sub>2</sub>, it can be selected in the dataset with labels using leave-one-out cross validation. Based on the empirical results, in practice, we directly set <inline-formula id="IE67"><mml:math id="IM67" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mo>λ</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mn>0.004</mml:mn></mml:mrow></mml:math></inline-formula>.</p>
      <p>The selection of <italic toggle="yes">λ</italic><sub>1</sub> is equivalent to selecting <italic toggle="yes">μ</italic> as previously mentioned in step 1 of <xref rid="btab286-BOX1" ref-type="boxed-text">Algorithm 1</xref>, where the two terms in the objective function are corresponding to logistic regression and spectral clustering, respectively. There should be high consistency between the clusters obtained using both methods separately, and the number of borderline cells that affect the final classification results in logistic regression should be small. Thus the model should be robust to the choice of the parameters. In our setting, both terms are linear functions of the cell number <italic toggle="yes">n</italic>. The log-likelihood is a sum of about <italic toggle="yes">n</italic> terms, and the trace term is a sum of about <italic toggle="yes">nK<sub>nn</sub></italic> terms, where <italic toggle="yes">K<sub>nn</sub></italic> is the number of neighbors in the construction of the similarity graph. Thus to balance these two terms will not highly depend on <italic toggle="yes">n</italic>. In practice, we varied the parameter in different datasets to see the performance, and finally took <inline-formula id="IE68"><mml:math id="IM68" display="inline" overflow="scroll"><mml:mrow><mml:mo>μ</mml:mo><mml:mo>=</mml:mo><mml:mn>0.3</mml:mn></mml:mrow></mml:math></inline-formula> as the default.</p>
      <p>We took the dataset ‘Lung’ as an example to show the results for different values of parameter <italic toggle="yes">μ</italic>. First, we set <inline-formula id="IE69"><mml:math id="IM69" display="inline" overflow="scroll"><mml:mrow><mml:mo>μ</mml:mo><mml:mo>=</mml:mo><mml:mn>0.1</mml:mn><mml:mo>,</mml:mo><mml:mn>0.2</mml:mn><mml:mo>,</mml:mo><mml:mn>0.3</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mn>10</mml:mn></mml:mrow></mml:math></inline-formula> with step size 0.1 and ran the algorithm to investigate the variation of clustering performance. As we can see in the first row of <xref rid="btab286-F5" ref-type="fig">Figure 5</xref>, for either NMI, ARI or accuracy, the best performance happens when <inline-formula id="IE70"><mml:math id="IM70" display="inline" overflow="scroll"><mml:mrow><mml:mo>μ</mml:mo><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>, and as <italic toggle="yes">μ</italic> goes larger, the performance of CALLR is very stable, though it becomes a little worse. We further checked out the effect of <italic toggle="yes">μ</italic> more closely. Let <inline-formula id="IE71"><mml:math id="IM71" display="inline" overflow="scroll"><mml:mrow><mml:mo>μ</mml:mo><mml:mo>=</mml:mo><mml:mn>0.01</mml:mn><mml:mo>,</mml:mo><mml:mn>0.02</mml:mn><mml:mo>,</mml:mo><mml:mn>0.03</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> with step size 0.01, and ran the algorithm. The result is shown in the second row. Either NMI, ARI or accuracy reaches their highest value when <italic toggle="yes">μ</italic> is around 0.3, and the value of these measures changes quite small.</p>
      <fig position="float" id="btab286-F5">
        <label>Fig. 5.</label>
        <caption>
          <p>Performance of CALLR for different values of <italic toggle="yes">μ</italic> on the dataset ‘Lung’</p>
        </caption>
        <graphic xlink:href="btab286f5" position="float"/>
      </fig>
    </sec>
  </sec>
  <sec>
    <title>4 Discussion</title>
    <p>We presented CALLR, a semi-supervised learning framework, to annotate the cell types. It learns the labels of the unannotated cells from the log-likelihood function and Laplacian matrix. Based on a small number of labeled cells and the similarity graph between different cells, it can predict the probabilities of those unlabeled cells being in a particular type. The resulting information alternatively helps the clustering. As a result, CALLR combines the advantages of sparse logistic regression and spectral clustering to annotate each cell more accurately. For the representative cells of each type, with information of marker genes, we can conduct the selection using the existing data-driven approaches, which makes it easier to use our proposed method. We applied alternating optimization method and projected gradient descent method to solve the proposed optimization model. Such algorithms reduce the computational complexity of binary optimization, and thus improve the computational efficiency and capacity of the model. Furthermore, analyzing the effect of the labeled cells’ size on the annotation results shows the robustness of CALLR. The performance of the method is stable when parameter changes or labeled subset varies.</p>
    <p>Results across 10 real datasets show that CALLR provides more accurate and robust results. For either NMI, ARI or accuracy as assessment criteria, the performance of CALLR is the best compared to the traditional (semi-)supervised methods. And it is competitive compared to the up-to-date deep learning method ‘ItClust’ with more stable performance. According to NMI and ARI, it outperforms each single compared clustering method. And it outperforms SAME in 8 of the 10 datasets, where SAME integrates the advantages of various current clustering methods. We note that in CALLR, the number of cell types depends on the annotated cells, which is pre-specified. It may not detect the rare cell types since it is difficult to find the representative cells at the first stage due to their small sample size. However, some clustering methods, such as those in Seurat, learn the number of cell types automatically, which may help determine the number of cell types in advance. Taking advantages of such clustering methods and the increasing number of marker genes to label a number of reliable representative cells is of great importance, and is left as one of our future work.</p>
    <p>In our current formulation and experiments, we only used one Gaussian kernel function to construct the adjacency matrix of all the cells, which is based on the pairwise Euclidean distance. As there are many kernel-based similarity fusion methods developed, we may integrate more similarity measures to construct the adjacency matrix, which have shown better performance, such as SIMLR. At the same time, dimension reduction methods can also be applied before measuring the similarities between pairwise cells.</p>
    <p>The implementation of CALLR is based on general and rigorous theories behind logistic regression, spectral clustering and graph-based Merriman–Bence–Osher scheme. Thus, it is a useful classification framework not only for single cells but also for other fields, such as pattern recognition and image processing.</p>
  </sec>
  <sec>
    <title>Acknowledgements</title>
    <p>The authors thank Mr. Jinhu Li at Peking University and Mr. Biao Zhang at Fudan University for their helpful discussions related to the project.</p>
  </sec>
  <sec>
    <title>Funding</title>
    <p>This work was supported, in part, by Science and Technology Commission of Shanghai Municipality [No. 20ZR1407700] and Key Program of National Natural Science Foundation of China under Grant [No. 61932008].</p>
    <p><italic toggle="yes">Conflict of Interest</italic>: none declared.</p>
  </sec>
</body>
<back>
  <ref-list id="ref1">
    <title>References</title>
    <ref id="btab286-B1">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Aran</surname><given-names>D.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2019</year>) <article-title>Reference-based analysis of lung single-cell sequencing reveals a transitional profibrotic macrophage</article-title>. <source>Nat. Immunol</source>., <volume>20</volume>, <fpage>163</fpage>–<lpage>172</lpage>.<pub-id pub-id-type="pmid">30643263</pub-id></mixed-citation>
    </ref>
    <ref id="btab286-B2">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Baron</surname><given-names>M.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2016</year>) <article-title>A single-cell transcriptomic map of the human and mouse pancreas reveals inter- and intra-cell population structure</article-title>. <source>Cell Syst</source>., <volume>3</volume>, <fpage>346</fpage>–<lpage>360.e4.</lpage><pub-id pub-id-type="pmid">27667365</pub-id></mixed-citation>
    </ref>
    <ref id="btab286-B3">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Becht</surname><given-names>E.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2019</year>) <article-title>Dimensionality reduction for visualizing single-cell data using umap</article-title>. <source>Nat. Biotechnol</source>., <volume>37</volume>, <fpage>38</fpage>–<lpage>44</lpage>.</mixed-citation>
    </ref>
    <ref id="btab286-B4">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Blondel</surname><given-names>V.D.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2008</year>) <article-title>Fast unfolding of communities in large networks</article-title>. <source>J. Stat. Mech. Theory Exper</source>., <volume>2008</volume>, <fpage>PP10008</fpage>.</mixed-citation>
    </ref>
    <ref id="btab286-B5">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Brbić</surname><given-names>M.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2020</year>) <article-title>Mars: discovering novel cell types across heterogeneous single-cell experiments</article-title>. <source>Nat. Methods</source>, <volume>17</volume>, <fpage>1200</fpage>–<lpage>1206</lpage>.<pub-id pub-id-type="pmid">33077966</pub-id></mixed-citation>
    </ref>
    <ref id="btab286-B6">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Butler</surname><given-names>A.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2018</year>) <article-title>Integrating single-cell transcriptomic data across different conditions, technologies, and species</article-title>. <source>Nature Biotechnology</source>, <volume>36</volume>, <fpage>411</fpage>–<lpage>420</lpage>.</mixed-citation>
    </ref>
    <ref id="btab286-B7">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Chen</surname><given-names>R.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2017</year>) <article-title>Single-cell RNA-seq reveals hypothalamic cell diversity</article-title>. <source>Cell Rep</source>., <volume>18</volume>, <fpage>3227</fpage>–<lpage>3241</lpage>.<pub-id pub-id-type="pmid">28355573</pub-id></mixed-citation>
    </ref>
    <ref id="btab286-B8">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Chen</surname><given-names>Y.</given-names></string-name>, <string-name><surname>Ye</surname><given-names>X.</given-names></string-name></person-group> (<year>2011</year>) Projection onto a simplex. <italic toggle="yes">arXiv preprint arXiv:1101.6081.</italic></mixed-citation>
    </ref>
    <ref id="btab286-B9">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Darmanis</surname><given-names>S.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2015</year>) <article-title>A survey of human brain transcriptome diversity at the single cell level</article-title>. <source>Proc. Natl. Acad. Sci. USA</source>, <volume>112</volume>, <fpage>7285</fpage>–<lpage>7290</lpage>.<pub-id pub-id-type="pmid">26060301</pub-id></mixed-citation>
    </ref>
    <ref id="btab286-B10">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>de Kanter</surname><given-names>J.K.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2019</year>) <article-title>Chetah: a selective, hierarchical cell type identification method for single-cell RNA sequencing</article-title>. <source>Nucleic Acids Res</source>., <volume>47</volume>, <fpage>e95</fpage>.<pub-id pub-id-type="pmid">31226206</pub-id></mixed-citation>
    </ref>
    <ref id="btab286-B11">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Ding</surname><given-names>J.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2018</year>) <article-title>Interpretable dimensionality reduction of single cell transcriptome data with deep generative models</article-title>. <source>Nat. Commun</source>., <volume>9</volume>, <fpage>2002</fpage>.<pub-id pub-id-type="pmid">29784946</pub-id></mixed-citation>
    </ref>
    <ref id="btab286-B12">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Friebel</surname><given-names>E.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2020</year>) <article-title>Single-cell mapping of human brain cancer reveals tumor-specific instruction of tissue-invading leukocytes</article-title>. <source>Cell</source>, <volume>181</volume>, <fpage>1626</fpage>–<lpage>1642</lpage>.<pub-id pub-id-type="pmid">32470397</pub-id></mixed-citation>
    </ref>
    <ref id="btab286-B13">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Friedman</surname><given-names>J.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2010</year>) <article-title>Regularization paths for generalized linear models via coordinate descent</article-title>. <source>J. Stat. Software</source>, <volume>33</volume>, <fpage>1</fpage>–<lpage>22</lpage>.</mixed-citation>
    </ref>
    <ref id="btab286-B14">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Garcia-Cardona</surname><given-names>C.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2014</year>) <article-title>Multiclass data segmentation using diffuse interface methods on graphs</article-title>. <source>IEEE Trans. Pattern Analysis Machine Intell</source>., <volume>36</volume>, <fpage>1600</fpage>–<lpage>1613</lpage>.</mixed-citation>
    </ref>
    <ref id="btab286-B15">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Gierahn</surname><given-names>T.M.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2017</year>) <article-title>Seq-well: portable, low-cost RNA sequencing of single cells at high throughput</article-title>. <source>Nat. Methods</source>, <volume>14</volume>, <fpage>395</fpage>–<lpage>398</lpage>.<pub-id pub-id-type="pmid">28192419</pub-id></mixed-citation>
    </ref>
    <ref id="btab286-B16">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Grun</surname><given-names>D.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2016</year>) <article-title>De novo prediction of stem cell identity using single-cell transcriptome data</article-title>. <source>Cell Stem Cell</source>, <volume>19</volume>, <fpage>266</fpage>–<lpage>277</lpage>.<pub-id pub-id-type="pmid">27345837</pub-id></mixed-citation>
    </ref>
    <ref id="btab286-B17">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Hou</surname><given-names>R.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2019</year>) <article-title>scMatch: a single-cell gene expression profile annotation tool using reference datasets</article-title>. <source>Bioinformatics</source>, <volume>35</volume>, <fpage>4688</fpage>–<lpage>4695</lpage>.<pub-id pub-id-type="pmid">31028376</pub-id></mixed-citation>
    </ref>
    <ref id="btab286-B18">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Hu</surname><given-names>J.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2020</year>) <article-title>Iterative transfer learning with neural network for clustering and cell type classification in single-cell RNA-seq analysis</article-title>. <source>Nat. Mach. Intell</source>., <volume>2</volume>, <fpage>607</fpage>–<lpage>618</lpage>.<pub-id pub-id-type="pmid">33817554</pub-id></mixed-citation>
    </ref>
    <ref id="btab286-B19">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Huh</surname><given-names>R.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2020</year>) <article-title>Same-clustering: single-cell aggregated clustering via mixture model ensemble</article-title>. <source>Nucleic Acids Res</source>., <volume>48</volume>, <fpage>86</fpage>–<lpage>95</lpage>.<pub-id pub-id-type="pmid">31777938</pub-id></mixed-citation>
    </ref>
    <ref id="btab286-B20">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Ji</surname><given-names>Z.</given-names></string-name>, <string-name><surname>Ji</surname><given-names>H.K.</given-names></string-name></person-group> (<year>2016</year>) <article-title>Tscan: pseudo-time reconstruction and evaluation in single-cell RNA-seq analysis</article-title>. <source>Nucleic Acids Res</source>., <volume>44</volume>, <fpage>e117</fpage>.<pub-id pub-id-type="pmid">27179027</pub-id></mixed-citation>
    </ref>
    <ref id="btab286-B21">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Kelsey</surname><given-names>G.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2017</year>) <article-title>Single-cell epigenomics: recording the past and predicting the future</article-title>. <source>Science</source>, <volume>358</volume>, <fpage>69</fpage>–<lpage>75</lpage>.<pub-id pub-id-type="pmid">28983045</pub-id></mixed-citation>
    </ref>
    <ref id="btab286-B22">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Kiselev</surname><given-names>V.Y.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2017</year>) <article-title>Sc3: consensus clustering of single-cell RNA-seq data</article-title>. <source>Nat. Methods</source>, <volume>14</volume>, <fpage>483</fpage>–<lpage>486</lpage>.<pub-id pub-id-type="pmid">28346451</pub-id></mixed-citation>
    </ref>
    <ref id="btab286-B23">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Kiselev</surname><given-names>V.Y.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2018</year>) <article-title>Scmap: projection of single-cell RNA-seq data across data sets</article-title>. <source>Nat. Methods</source>, <volume>15</volume>, <fpage>359</fpage>–<lpage>362</lpage>.<pub-id pub-id-type="pmid">29608555</pub-id></mixed-citation>
    </ref>
    <ref id="btab286-B24">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Kolodziejczyk</surname><given-names>A.A.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2015</year>) <article-title>The technology and biology of single-cell rna sequencing</article-title>. <source>Mol. Cell</source>, <volume>58</volume>, <fpage>610</fpage>–<lpage>620</lpage>.<pub-id pub-id-type="pmid">26000846</pub-id></mixed-citation>
    </ref>
    <ref id="btab286-B25">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Lake</surname><given-names>B.B.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2018</year>) <article-title>Integrative single-cell analysis of transcriptional and epigenetic states in the human adult brain</article-title>. <source>Nat. Biotechnol</source>., <volume>36</volume>, <fpage>70</fpage>–<lpage>80</lpage>.<pub-id pub-id-type="pmid">29227469</pub-id></mixed-citation>
    </ref>
    <ref id="btab286-B26">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Li</surname><given-names>L.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2018</year>) <article-title>Single-cell multi-omics sequencing of human early embryos</article-title>. <source>Nature Cell Biol</source>., <volume>20</volume>, <fpage>847</fpage>–<lpage>858</lpage>.<pub-id pub-id-type="pmid">29915357</pub-id></mixed-citation>
    </ref>
    <ref id="btab286-B27">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Lin</surname><given-names>P.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2017</year>) <article-title>Cidr: ultrafast and accurate clustering through imputation for single-cell RNA-seq data</article-title>. <source>Genome Biol</source>., <volume>18</volume>, <fpage>59</fpage>.<pub-id pub-id-type="pmid">28351406</pub-id></mixed-citation>
    </ref>
    <ref id="btab286-B28">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Liu</surname><given-names>S.</given-names></string-name>, <string-name><surname>Trapnell</surname><given-names>C.</given-names></string-name></person-group> (<year>2016</year>) <article-title>Single-cell transcriptome sequencing: recent advances and remaining challenges</article-title>. <source>F1000Research</source>, <volume>5</volume>, <fpage>182</fpage>.</mixed-citation>
    </ref>
    <ref id="btab286-B29">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Marco</surname><given-names>E.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2014</year>) <article-title>Bifurcation analysis of single-cell gene expression data reveals epigenetic landscape</article-title>. <source>Proc. Natl. Acad. Sci. USA</source>, <volume>111</volume>, <fpage>201408993</fpage>.</mixed-citation>
    </ref>
    <ref id="btab286-B30">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Ntranos</surname><given-names>V.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2016</year>) <article-title>Fast and accurate single-cell RNA-seq analysis by clustering of transcript-compatibility counts</article-title>. <source>Genome Biol</source>., <volume>17</volume>, <fpage>112</fpage>.<pub-id pub-id-type="pmid">27230763</pub-id></mixed-citation>
    </ref>
    <ref id="btab286-B31">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Park</surname><given-names>S.</given-names></string-name>, <string-name><surname>Zhao</surname><given-names>H.</given-names></string-name></person-group> (<year>2018</year>) <article-title>Spectral clustering based on learning similarity matrix</article-title>. <source>Bioinformatics</source>, <volume>34</volume>, <fpage>2069</fpage>–<lpage>2076</lpage>.<pub-id pub-id-type="pmid">29432517</pub-id></mixed-citation>
    </ref>
    <ref id="btab286-B32">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Pierson</surname><given-names>E.</given-names></string-name>, <string-name><surname>Yau</surname><given-names>C.</given-names></string-name></person-group> (<year>2015</year>) <article-title>Zifa: dimensionality reduction for zero-inflated single-cell gene expression analysis</article-title>. <source>Genome Biol</source>., <volume>16</volume>, <fpage>241</fpage>–<lpage>241</lpage>.<pub-id pub-id-type="pmid">26527291</pub-id></mixed-citation>
    </ref>
    <ref id="btab286-B33">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Pliner</surname><given-names>H.A.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2019</year>) <article-title>Supervised classification enables rapid annotation of cell atlases</article-title>. <source>Nat. Methods</source>, <volume>16</volume>, <fpage>983</fpage>–<lpage>986</lpage>.<pub-id pub-id-type="pmid">31501545</pub-id></mixed-citation>
    </ref>
    <ref id="btab286-B34">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Segerstolpe</surname><given-names>A.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2016</year>) <article-title>Single-cell transcriptome profiling of human pancreatic islets in health and type 2 diabetes</article-title>. <source>Cell Metabolism</source>, <volume>24</volume>, <fpage>593</fpage>–<lpage>607</lpage>.<pub-id pub-id-type="pmid">27667667</pub-id></mixed-citation>
    </ref>
    <ref id="btab286-B35">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Shao</surname><given-names>X.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2020</year>) <article-title>scCatch: automatic annotation on cell types of clusters from single-cell RNA sequencing data</article-title>. <source>Iscience</source>, <volume>23</volume>, <fpage>100882</fpage>.<pub-id pub-id-type="pmid">32062421</pub-id></mixed-citation>
    </ref>
    <ref id="btab286-B36">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Stubbington</surname><given-names>M.J.T.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2017</year>) <article-title>Single-cell transcriptomics to explore the immune system in health and disease</article-title>. <source>Science</source>, <volume>358</volume>, <fpage>58</fpage>–<lpage>63</lpage>.<pub-id pub-id-type="pmid">28983043</pub-id></mixed-citation>
    </ref>
    <ref id="btab286-B37">
      <mixed-citation publication-type="journal">Tabula Muris Consortium <etal>et al</etal> (<year>2018</year>) <article-title>Single-cell transcriptomics of 20 mouse organs creates a Tabula Muris</article-title>. <source>Nature</source>, <volume>562</volume>, <fpage>367</fpage>–<lpage>372</lpage>.<pub-id pub-id-type="pmid">30283141</pub-id></mixed-citation>
    </ref>
    <ref id="btab286-B38">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Tang</surname><given-names>F.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2009</year>) <article-title>mRNA-seq whole-transcriptome analysis of a single cell</article-title>. <source>Nat. Methods</source>, <volume>6</volume>, <fpage>377</fpage>–<lpage>382</lpage>.<pub-id pub-id-type="pmid">19349980</pub-id></mixed-citation>
    </ref>
    <ref id="btab286-B39">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Tian</surname><given-names>T.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2019</year>) <article-title>Clustering single-cell RNA-seq data with a model-based deep learning approach</article-title>. <source>Nat. Mach. Intell</source>., <volume>1</volume>, <fpage>191</fpage>–<lpage>198</lpage>.</mixed-citation>
    </ref>
    <ref id="btab286-B40">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Tirosh</surname><given-names>I.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2016</year>) <article-title>Dissecting the multicellular ecosystem of metastatic melanoma by single-cell RNA-seq</article-title>. <source>Science</source>, <volume>352</volume>, <fpage>189</fpage>–<lpage>196</lpage>.<pub-id pub-id-type="pmid">27124452</pub-id></mixed-citation>
    </ref>
    <ref id="btab286-B41">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Traag</surname><given-names>V.A.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2019</year>) <article-title>From Louvain to Leiden: guaranteeing well-connected communities</article-title>. <source>Sci. Rep</source>., <volume>9</volume>, <fpage>5233</fpage>.<pub-id pub-id-type="pmid">30914743</pub-id></mixed-citation>
    </ref>
    <ref id="btab286-B42">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Van Engelen</surname><given-names>J.E.</given-names></string-name>, <string-name><surname>Hoos</surname><given-names>H.H.</given-names></string-name></person-group> (<year>2020</year>) <article-title>A survey on semi-supervised learning</article-title>. <source>Mach. Learn</source>., <volume>109</volume>, <fpage>373</fpage>–<lpage>440</lpage>.</mixed-citation>
    </ref>
    <ref id="btab286-B43">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Wagner</surname><given-names>D.E.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2018</year>) <article-title>Single-cell mapping of gene expression landscapes and lineage in the zebrafish embryo</article-title>. <source>Science</source>, <volume>360</volume>, <fpage>981</fpage>–<lpage>987</lpage>.<pub-id pub-id-type="pmid">29700229</pub-id></mixed-citation>
    </ref>
    <ref id="btab286-B44">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Wagner</surname><given-names>J.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2019</year>) <article-title>A single-cell atlas of the tumor and immune ecosystem of human breast cancer</article-title>. <source>Cell</source>, <volume>177</volume>, <fpage>1330</fpage>–<lpage>1345</lpage>.<pub-id pub-id-type="pmid">30982598</pub-id></mixed-citation>
    </ref>
    <ref id="btab286-B45">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Waltman</surname><given-names>L.</given-names></string-name>, <string-name><surname>van Eck</surname><given-names>N.J.</given-names></string-name></person-group> (<year>2013</year>) <article-title>A smart local moving algorithm for large-scale modularity-based community detection</article-title>. <source>Eur. Phys. J. B</source>, <volume>86</volume>, <fpage>471</fpage>.</mixed-citation>
    </ref>
    <ref id="btab286-B46">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Wang</surname><given-names>B.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2017</year>) <article-title>Visualization and analysis of single-cell RNA-seq data by kernel-based similarity learning</article-title>. <source>Nat. Methods</source>, <volume>14</volume>, <fpage>414</fpage>–<lpage>416</lpage>.<pub-id pub-id-type="pmid">28263960</pub-id></mixed-citation>
    </ref>
    <ref id="btab286-B47">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Wu</surname><given-names>P.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2020</year>) <article-title>A robust semi-supervised NMF model for single cell RNA-seq data</article-title>. <source>PeerJ</source>, <volume>8</volume>, <fpage>e10091</fpage>.<pub-id pub-id-type="pmid">33088619</pub-id></mixed-citation>
    </ref>
    <ref id="btab286-B48">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Yang</surname><given-names>Y.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2019</year>) <article-title>Safe-clustering: single-cell aggregated (from ensemble) clustering for single-cell RNA-seq data</article-title>. <source>Bioinformatics</source>, <volume>35</volume>, <fpage>1269</fpage>–<lpage>1277</lpage>.<pub-id pub-id-type="pmid">30202935</pub-id></mixed-citation>
    </ref>
    <ref id="btab286-B49">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Yuan</surname><given-names>G.-X.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2012</year>) <article-title>An improved glmnet for L1-regularized logistic regression</article-title>. <source>J. Mach. Learn. Res</source>., <volume>13</volume>, <fpage>1999</fpage>–<lpage>2030</lpage>.</mixed-citation>
    </ref>
    <ref id="btab286-B50">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Zhang</surname><given-names>A.W.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2019a</year>) <article-title>Probabilistic cell-type assignment of single-cell RNA-seq for tumor microenvironment profiling</article-title>. <source>Nat. Methods</source>, <volume>16</volume>, <fpage>1007</fpage>–<lpage>1015</lpage>.<pub-id pub-id-type="pmid">31501550</pub-id></mixed-citation>
    </ref>
    <ref id="btab286-B51">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Zhang</surname><given-names>X.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2019b</year>) <article-title>Cellmarker: a manually curated resource of cell markers in human and mouse</article-title>. <source>Nucleic Acids Res</source>., <volume>47</volume>, <fpage>D721</fpage>–<lpage>D728</lpage>.<pub-id pub-id-type="pmid">30289549</pub-id></mixed-citation>
    </ref>
    <ref id="btab286-B52">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Zhang</surname><given-names>Z.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2019c</year>). SCINA: a semi-supervised subtyping algorithm of single cells and bulk samples. <italic toggle="yes">Genes</italic>, <bold>10</bold>(7), 531.</mixed-citation>
    </ref>
    <ref id="btab286-B53">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Zheng</surname><given-names>H.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2018</year>) <article-title>Single-cell analysis reveals cancer stem cell heterogeneity in hepatocellular carcinoma</article-title>. <source>Hepatology</source>, <volume>68</volume>, <fpage>127</fpage>–<lpage>140</lpage>.<pub-id pub-id-type="pmid">29315726</pub-id></mixed-citation>
    </ref>
  </ref-list>
</back>
