<?DTDIdentifier.IdentifierValue article.dtd?>
<?DTDIdentifier.IdentifierType system?>
<?SourceDTD.DTDName article.dtd?>
<?SourceDTD.Version 1.0?>
<?ConverterInfo.XSLTName bmc2nlmx2.xsl?>
<?ConverterInfo.Version 2?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">BMC Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">BMC Bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>BMC Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="epub">1471-2105</issn>
    <publisher>
      <publisher-name>BioMed Central</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">3927682</article-id>
    <article-id pub-id-type="publisher-id">1471-2105-15-42</article-id>
    <article-id pub-id-type="pmid">24499321</article-id>
    <article-id pub-id-type="doi">10.1186/1471-2105-15-42</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Methodology Article</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Improving read mapping using additional prefix grams</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" id="A1">
        <name>
          <surname>Kim</surname>
          <given-names>Jongik</given-names>
        </name>
        <xref ref-type="aff" rid="I1">1</xref>
        <email>jongik@jbnu.ac.kr</email>
      </contrib>
      <contrib contrib-type="author" id="A2">
        <name>
          <surname>Li</surname>
          <given-names>Chen</given-names>
        </name>
        <xref ref-type="aff" rid="I2">2</xref>
        <email>chenli@ics.uci.edu</email>
      </contrib>
      <contrib contrib-type="author" corresp="yes" id="A3">
        <name>
          <surname>Xie</surname>
          <given-names>Xiaohui</given-names>
        </name>
        <xref ref-type="aff" rid="I2">2</xref>
        <email>xhx@ics.uci.edu</email>
      </contrib>
    </contrib-group>
    <aff id="I1"><label>1</label>Division of Computer Science &amp; Engineering, Chonbuk National University,
Jeonju, Republic of Korea</aff>
    <aff id="I2"><label>2</label>Department of Computer Science, University of California, Irvine, USA</aff>
    <pub-date pub-type="collection">
      <year>2014</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>5</day>
      <month>2</month>
      <year>2014</year>
    </pub-date>
    <volume>15</volume>
    <fpage>42</fpage>
    <lpage>42</lpage>
    <history>
      <date date-type="received">
        <day>12</day>
        <month>9</month>
        <year>2013</year>
      </date>
      <date date-type="accepted">
        <day>3</day>
        <month>2</month>
        <year>2014</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>Copyright © 2014 Kim et al.; licensee BioMed Central Ltd.</copyright-statement>
      <copyright-year>2014</copyright-year>
      <copyright-holder>Kim et al.; licensee BioMed Central Ltd.</copyright-holder>
      <license license-type="open-access" xlink:href="http://creativecommons.org/licenses/by/2.0">
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons
Attribution License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/2.0">http://creativecommons.org/licenses/by/2.0</ext-link>), which
permits unrestricted use, distribution, and reproduction in any medium, provided the
original work is properly cited.</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="http://www.biomedcentral.com/1471-2105/15/42"/>
    <abstract>
      <sec>
        <title>Background</title>
        <p>Next-generation sequencing (NGS) enables rapid production of billions of bases at
a relatively low cost. Mapping reads from next-generation sequencers to a given
reference genome is an important first step in many sequencing applications.
Popular read mappers, such as Bowtie and BWA, are optimized to return top one or a
few candidate locations of each read. However, identifying all mapping locations
of each read, instead of just one or a few, is also important in some sequencing
applications such as ChIP-seq for discovering binding sites in repeat regions, and
RNA-seq for transcript abundance estimation.</p>
      </sec>
      <sec>
        <title>Results</title>
        <p>Here we present Hobbes2, a software package designed for fast and accurate
alignment of NGS reads and specialized in identifying all mapping locations of
each read. Hobbes2 efficiently identifies all mapping locations of reads using a
novel technique that utilizes additional prefix <italic>q</italic>-grams to improve
filtering. We extensively compare Hobbes2 with state-of-the-art read mappers, and
show that Hobbes2 can be an order of magnitude faster than other read mappers
while consuming less memory space and achieving similar accuracy.</p>
      </sec>
      <sec>
        <title>Conclusions</title>
        <p>We propose Hobbes2 to improve the accuracy of read mapping, specialized in
identifying all mapping locations of each read. Hobbes2 is implemented in C++, and
the source code is freely available for download at
<ext-link ext-link-type="uri" xlink:href="http://hobbes.ics.uci.edu">http://hobbes.ics.uci.edu</ext-link>.</p>
      </sec>
    </abstract>
    <kwd-group>
      <kwd>Next-generation sequencing</kwd>
      <kwd>Read alignment</kwd>
      <kwd>All mapper</kwd>
      <kwd>Additional prefix <italic>q</italic>-gram</kwd>
      <kwd>Hobbes2</kwd>
    </kwd-group>
  </article-meta>
</front>
<body>
  <sec>
    <title>Background</title>
    <p>DNA sequencing has become an indispensable tool for basic biomedical research,
understanding disease mechanisms, and developing new and personalized treatments. Recent
advances in next-generation sequencing (NGS) technologies, such as those from Illumina
and Life Technologies, have enabled the rapid production of billions of bases at
relatively low cost. However, the reads returned by NGS sequencers are usually short (in
the range of 35 to 150 bps), and it is left to computational algorithms to extract
information from these reads.</p>
    <p>In many applications, mapping reads to a given reference genome sequence is an important
first step in analysis of sequencing data. Popular read mapping programs, such as Bowtie [<xref ref-type="bibr" rid="B1">1</xref>], Bowtie2 [<xref ref-type="bibr" rid="B2">2</xref>], and BWA [<xref ref-type="bibr" rid="B3">3</xref>], aim at identifying one or a few top mapping locations for each read. This
mapping strategy works well for many applications, and leads to a significant
improvement in mapping speed compared to programs aiming at identifying all candidate
locations. However, in many applications, it is often more desirable to identify all
candidate locations of reads. (We will call programs that can identify all candidate
locations <italic>all mappers</italic>). For instance, in ChIP-seq experiments, many binding
sites are located in the repeat regions of the genomes, and therefore, using read
mappers returning only one or a few mapping locations might miss many binding peaks
located within these repeat regions [<xref ref-type="bibr" rid="B4">4</xref>]. In RNA-seq transcript abundance quantification, due to the presence of
multiple transcript isoforms caused by alternative splicing, it is critical for a read
mapper to return all possible mapping locations. Otherwise, the accuracy of the
transcript abundance estimation can be significantly compromised [<xref ref-type="bibr" rid="B5">5</xref>,<xref ref-type="bibr" rid="B6">6</xref>].</p>
    <p>As the sequencing technology is progressing toward producing longer reads, it is also
very important to support insertion/deletion (indel) errors, which are caused by
sequencing errors and/or genetic variations. Hobbes [<xref ref-type="bibr" rid="B7">7</xref>] is a software package proposed to identify all mapping locations of a read.
It generates candidate locations efficiently using inverted lists of non-overlapping
<italic>q</italic>-grams with the help of bit vectors. In the presence of indel errors,
however, bit vectors may filter out true locations, which negatively affects the
accuracy of the results. Moreover, Hobbes may require a large amount of memory space for
bit vectors. Recently developed all mappers, such as RazerS3 [<xref ref-type="bibr" rid="B8">8</xref>] and Masai [<xref ref-type="bibr" rid="B9">9</xref>], have focused on supporting indel errors and improved the performance in
terms of accuracy and mapping time. RazerS3 can generate accurate mapping results by
controlling mapping sensitivity based on its error-estimation technique. However, it
requires a lot of time to produce high-quality results. Masai reduces mapping time
significantly by building an index on input reads and simultaneously generating
candidate locations for multiple reads. However, Masai does not support multi-threading
since it builds an index on input reads and it is not straightforward to split input
reads so that they can be processed by multiple threads.</p>
    <p>In this paper, we present Hobbes2, a software package designed to return all mapping
locations of long reads (e.g., 100bp or 150bp) containing indel errors as well as
mismatch errors. Hobbes2 is built on top of Hobbes but significantly improves the
performance in all aspects. Instead of using bit vectors, Hobbes2 makes use of another
inverted list of an additional <italic>q</italic>-gram to filter out false positives during the
generation of candidate locations. The filtering based on the additional <italic>q</italic>-gram
captures all true locations while we can produce substantially fewer candidate
locations. By eliminating bit vectors from memory, this approach also greatly saves
memory consumption. Hobbes2 aligns reads one by one and naturally scales well in a
multi-threaded environment. Because read mappers map a tremendous number of reads, good
multi-thread support is extremely important in read alignment. Through experimental
comparisons, we show that Hobbes2 is an order of magnitude faster than the best all
mappers, RazerS3 and Masai, while consuming less memory space and achieving a similar
accuracy.</p>
    <p>In the following sections, we briefly describe existing gram-based approaches to solve
the read mapping problem and introduce our approach with analysis. Then, we present how
to handle indel errors with the proposed approach. We finally discuss the implementation
issues to integrate the proposed technique with the existing Hobbes package.</p>
  </sec>
  <sec sec-type="methods">
    <title>Methods</title>
    <p>After we summarize <italic>q</italic>-gram-based approaches for mapping reads to a given
reference genome sequence, we propose a filtering technique using an additional prefix
<italic>q</italic>-gram. We first restrict our discussion to the read-mapping problem with
mismatch errors only. Then we explain how to extend the proposed technique to support
indel errors in a separate section.</p>
    <sec>
      <title>Generating candidate locations using <italic>q</italic>-grams</title>
      <p>A <italic>q</italic>-gram of a genome sequence <italic>s</italic> is a subsequence of <italic>s</italic> of
length <italic>q</italic>. The set of locationally overlapping <italic>q</italic>-grams of
<italic>s</italic>, which is denoted by <italic>G</italic>(<italic>s</italic>), is obtained by sliding a
window of length <italic>q</italic> over the bases of <italic>s</italic>. For example, the
overlapping 3-gram set of a sequence <italic>s</italic> = <monospace>ACCTACCT</monospace> is
<italic>G</italic>(<italic>s</italic>)={ACC,CCT,CTA,TAC,ACC,CCT}. Note that we use an ordered
multiset for <italic>q</italic>-grams, where the same <italic>q</italic>-grams are distinguished by
their locations in a sequence. Because a base of a sequence is included in at most
<italic>q</italic> overlapping <italic>q</italic>-grams of the sequence, a substitution of one
base modifies at most <italic>q</italic> overlapping <italic>q</italic>-grams of a sequence.
Therefore, if the maximum allowed mismatch errors between two sequences of <italic>r</italic>
and <italic>s</italic> are <italic>k</italic> bases, they should share at least the following number
of common overlapping <italic>q</italic>-grams (this technique is known as count filtering [<xref ref-type="bibr" rid="B10">10</xref>]).</p>
      <p>
        <disp-formula id="bmcM1">
          <label>(1)</label>
          <mml:math id="M1" name="1471-2105-15-42-i1" overflow="scroll">
            <mml:mi>T</mml:mi>
            <mml:mo>=</mml:mo>
            <mml:mtext mathvariant="monospace">max</mml:mtext>
            <mml:mo>{</mml:mo>
            <mml:mo>|</mml:mo>
            <mml:mi>G</mml:mi>
            <mml:mo>(</mml:mo>
            <mml:mi>r</mml:mi>
            <mml:mo>)</mml:mo>
            <mml:mo>|</mml:mo>
            <mml:mo>,</mml:mo>
            <mml:mo>|</mml:mo>
            <mml:mi>G</mml:mi>
            <mml:mo>(</mml:mo>
            <mml:mi>s</mml:mi>
            <mml:mo>)</mml:mo>
            <mml:mo>|</mml:mo>
            <mml:mo>}</mml:mo>
            <mml:mo>−</mml:mo>
            <mml:mi>k</mml:mi>
            <mml:mo>·</mml:mo>
            <mml:mi>q.</mml:mi>
          </mml:math>
        </disp-formula>
      </p>
      <p>As we look for a genome subsequence <italic>s</italic> whose length is the same as a read
<italic>r</italic>, we can simplify Equation 1 as follows (because
|<italic>G</italic>(<italic>r</italic>)|=|<italic>G</italic>(<italic>s</italic>)|).</p>
      <p>
        <disp-formula id="bmcM2">
          <label>(2)</label>
          <mml:math id="M2" name="1471-2105-15-42-i2" overflow="scroll">
            <mml:mi>T</mml:mi>
            <mml:mo>=</mml:mo>
            <mml:mo>|</mml:mo>
            <mml:mi>G</mml:mi>
            <mml:mo>(</mml:mo>
            <mml:mi>r</mml:mi>
            <mml:mo>)</mml:mo>
            <mml:mo>|</mml:mo>
            <mml:mo>−</mml:mo>
            <mml:mi>k</mml:mi>
            <mml:mo>·</mml:mo>
            <mml:mi>q</mml:mi>
            <mml:mo>=</mml:mo>
            <mml:mo>|</mml:mo>
            <mml:mi>r</mml:mi>
            <mml:mo>|</mml:mo>
            <mml:mo>−</mml:mo>
            <mml:mi>q</mml:mi>
            <mml:mo>+</mml:mo>
            <mml:mn>1</mml:mn>
            <mml:mo>−</mml:mo>
            <mml:mi>k</mml:mi>
            <mml:mo>·</mml:mo>
            <mml:mi>q.</mml:mi>
          </mml:math>
        </disp-formula>
      </p>
      <p>Many techniques generate candidate locations using inverted-list structures of
overlapping <italic>q</italic>-grams of a reference genome sequence. An inverted list of a
<italic>q</italic>-gram <italic>g</italic>, denoted by <italic>I</italic>(<italic>g</italic>), is a list of
locations within a genome sequence where the <italic>q</italic>-gram occurs. For instance,
the inverted list of 3-gram <monospace>CCT</monospace> in our previous example is
<italic>I</italic>(CCT)={1,4} because <monospace>CCT</monospace> occurs at locations 1 and
4 in the sequence <monospace>ACCTACCT</monospace>. To map <italic>q</italic>-grams into their
corresponding inverted lists, an inverted index is built on overlapping
<italic>q</italic>-grams of a genome sequence. Given a read <italic>r</italic> and a Hamming distance
threshold <italic>k</italic> (or a maximum number of allowed mismatches <italic>k</italic>), we can
generate candidate locations using an inverted index of a genome sequence as follows.
First, we decompose <italic>r</italic> into overlapping <italic>q</italic>-grams. For each
<italic>q</italic>-gram <italic>g</italic> in <italic>G</italic>(<italic>r</italic>) and its relative location
<italic>l</italic> in <italic>r</italic>, we retrieve an inverted list <italic>I</italic>(<italic>g</italic>) by
looking up the inverted index with the search key <italic>g</italic>. Because
<italic>I</italic>(<italic>g</italic>) contains starting locations of the <italic>q</italic>-gram
<italic>g</italic> in the genome sequence, we need to modify <italic>I</italic>(<italic>g</italic>) by
subtracting <italic>l</italic> from each element in <italic>I</italic>(<italic>g</italic>) to find the
locations of genome subsequences containing <italic>g</italic>. We call a modified inverted
list a <italic>normalized inverted list</italic> and denote it by
<italic>I</italic><sup><italic>n</italic></sup>(<italic>g</italic>). We finally select those locations as
candidates that appear in at least <italic>T</italic> normalized inverted lists.</p>
      <p>Figure <xref ref-type="fig" rid="F1">1</xref> shows an example of a reference genome sequence and
its 5-gram inverted index, which is taken from ([<xref ref-type="bibr" rid="B7">7</xref>]). To map a read <italic>r</italic> = ACGGTCTTCCCTACGGT with Hamming distance
threshold <italic>k</italic>=2 and <italic>T</italic>=17−5+1−2·5=3, we first look up
the read’s 5-grams in the inverted index. Notice that only the grams
<monospace>ACGGT</monospace> and <monospace>CGGTC</monospace> (underlined in the
read) are present in the index. We traverse their inverted lists, and normalize each
element relative to the location of the corresponding gram in the read. For example,
the 5-gram <monospace>CGGTC</monospace> appears at location 1 in the read, so the
relative location of the element on <monospace>CGGTC</monospace>’s inverted
list is 106−1=105.</p>
      <fig id="F1" position="float">
        <label>Figure 1</label>
        <caption>
          <p><bold>Excerpt of a reference sequence and a portion of its 5-gram inverted
index.</bold> The inverted lists of the 5-grams <monospace>ACGGT</monospace>,
<monospace>CGGTC</monospace>, and <monospace>ACCCT</monospace> are shown,
each containing a sorted list of locations in the reference sequence where the
respective 5-gram appears.</p>
        </caption>
        <graphic xlink:href="1471-2105-15-42-1"/>
      </fig>
      <p>In this way, we can count how many times the read’s grams are contained in the
subsequence of the reference sequence starting at a fixed location (location 105, in
this example). The gram <monospace>ACGGT</monospace> appears twice in the read, and
we treat each occurrence as a separate list. Its appearance at location 0 yields a
normalized list of {105−0=105,118−0=118}, and a normalized list
{105−13=92,118−13=105} for location 13. Next, we count the number of
occurrences of each element on the normalized lists. The locations 92 and 118 are
pruned according to the count filtering, because their number of occurrences do not
meet the lower bound of <italic>T</italic>=3. Location 105 has a count of 3, and therefore it
is a candidate answer whose Hamming distance to the read still needs to be
computed.</p>
      <p>In most techniques, the naïve count filtering method is not directly used to
generate candidates because it requires scanning all inverted lists of overlapping
<italic>q</italic>-grams in a read. To map a 100bp read using an 11-gram inverted index,
for example, we need to scan 100−11+1=90 inverted lists. Moreover, some
inverted lists are usually very long and this method would incur prohibitive scanning
costs. Instead, a simple variation of the count filtering known as the prefix
filtering [<xref ref-type="bibr" rid="B11">11</xref>] is widely used for generating candidates. Because a candidate genome
subsequence <italic>s</italic> needs to contain <italic>T</italic><italic>q</italic>-grams of a read
<italic>r</italic> according to the count filtering, <italic>s</italic> must contain at least one
<italic>q</italic>-gram among
|<italic>G</italic>(<italic>r</italic>)|−(<italic>T</italic>−1)=<italic>k</italic>·<italic>q</italic>+1<italic>q</italic>-grams
in <italic>G</italic>(<italic>r</italic>). Given an inverted index of a genome sequence, we retrieve
and normalize inverted lists of <italic>k</italic>·<italic>q</italic>+1<italic>q</italic>-grams in
<italic>G</italic>(<italic>r</italic>) and then generate candidates by taking the union of
locations in the normalized inverted lists. To minimize the number of candidates, we
sort <italic>q</italic>-grams in <italic>G</italic>(<italic>r</italic>) by their frequencies in the reference
genome and take <italic>k</italic>·<italic>q</italic>+1 low frequency <italic>q</italic>-grams (which
are called prefix <italic>q</italic>-grams).</p>
      <p>Recent techniques [<xref ref-type="bibr" rid="B7">7</xref>,<xref ref-type="bibr" rid="B12">12</xref>,<xref ref-type="bibr" rid="B13">13</xref>] have focused on deriving a tight lower bound of the number of prefix
<italic>q</italic>-grams. The basic idea behind these techniques is to use non-overlapping
<italic>q</italic>-grams [<xref ref-type="bibr" rid="B14">14</xref>] of a read. If we use non-overlapping <italic>q</italic>-grams, a substitution of
one base of a read affects only one <italic>q</italic>-gram. Hence, if a genome subsequence
<italic>s</italic> is different from a read <italic>r</italic> within <italic>k</italic> mismatches, the
overlapping <italic>q</italic>-gram set of <italic>s</italic> will contain at least one
non-overlapping <italic>q</italic>-gram among <italic>k</italic>+1 non-overlapping <italic>q</italic>-grams
of <italic>r</italic>. Based on the observation, we can generate candidates as follows. We
first select <italic>k</italic>+1 non-overlapping <italic>q</italic>-grams in <italic>G</italic>(<italic>r</italic>).
From the inverted index of overlapping <italic>q</italic>-grams of a reference genome
sequence, we then retrieve inverted lists of the selected <italic>q</italic>-grams and
normalize them. We finally produce candidates by taking the union of locations in the
normalized inverted lists. Existing techniques use the sum of frequencies of
<italic>q</italic>-grams to estimate the union size of inverted lists. Hobbes proposed a
dynamic programming algorithm to select prefix <italic>q</italic>-grams based on the
following recurrence so as to minimize the sum of frequencies of selected
<italic>q</italic>-grams [<xref ref-type="bibr" rid="B7">7</xref>].</p>
      <p>
        <disp-formula id="bmcM3">
          <label>(3)</label>
          <mml:math id="M3" name="1471-2105-15-42-i3" overflow="scroll">
            <mml:mi>M</mml:mi>
            <mml:mo>(</mml:mo>
            <mml:mi>i</mml:mi>
            <mml:mo>,</mml:mo>
            <mml:mi>j</mml:mi>
            <mml:mo>)</mml:mo>
            <mml:mo>=</mml:mo>
            <mml:mtext mathvariant="monospace">min</mml:mtext>
            <mml:mspace width=".5em"/>
            <mml:mo stretchy="true">{</mml:mo>
            <mml:mrow>
              <mml:mtable columnalign="left">
                <mml:mtr>
                  <mml:mtd>
                    <mml:mi>M</mml:mi>
                    <mml:mo>(</mml:mo>
                    <mml:mi>i</mml:mi>
                    <mml:mo>,</mml:mo>
                    <mml:mi>j</mml:mi>
                    <mml:mo>−</mml:mo>
                    <mml:mn>1</mml:mn>
                    <mml:mo>)</mml:mo>
                  </mml:mtd>
                </mml:mtr>
                <mml:mtr>
                  <mml:mtd>
                    <mml:mi>M</mml:mi>
                    <mml:mo>(</mml:mo>
                    <mml:mi>i</mml:mi>
                    <mml:mo>−</mml:mo>
                    <mml:mn>1</mml:mn>
                    <mml:mo>,</mml:mo>
                    <mml:mi>j</mml:mi>
                    <mml:mo>)</mml:mo>
                    <mml:mo>+</mml:mo>
                    <mml:mi>L</mml:mi>
                    <mml:mo>[</mml:mo>
                    <mml:mi>j</mml:mi>
                    <mml:mo>+</mml:mo>
                    <mml:mo>(</mml:mo>
                    <mml:mi>i</mml:mi>
                    <mml:mo>−</mml:mo>
                    <mml:mn>1</mml:mn>
                    <mml:mo>)</mml:mo>
                    <mml:mo>·</mml:mo>
                    <mml:mi>q</mml:mi>
                    <mml:mo>]</mml:mo>
                    <mml:mi>.len</mml:mi>
                    <mml:mo>,</mml:mo>
                  </mml:mtd>
                </mml:mtr>
              </mml:mtable>
            </mml:mrow>
          </mml:math>
        </disp-formula>
      </p>
      <p>where
<italic>i</italic>≤<italic>k</italic>+1,1≤<italic>j</italic>≤|<italic>G</italic>(<italic>r</italic>)|−<italic>k</italic>·<italic>q</italic>,
<italic>L</italic>[ <italic>n</italic>].<italic>l</italic><italic>e</italic><italic>n</italic> is the length of the
inverted list of the <italic>n</italic><sup><italic>t</italic><italic>h</italic></sup><italic>q</italic>-gram in
<italic>G</italic>(<italic>r</italic>), and <italic>M</italic>(<italic>i</italic>,<italic>j</italic>) is a lower bound on
the sum of the lengths of the inverted lists of <italic>i</italic> non-overlapping grams
starting from a location no greater than
<italic>j</italic>+(<italic>i</italic>−1)·<italic>q</italic>. In Equation 3,
<italic>M</italic>(0,<italic>j</italic>) is initialized to zero and <italic>M</italic>(<italic>i</italic>,0) is
initialized to infinity and the goal is to compute
<italic>M</italic>(<italic>k</italic>+1,|<italic>G</italic>(<italic>r</italic>)|−<italic>k</italic>·<italic>q</italic>).</p>
    </sec>
    <sec>
      <title>Exploiting an additional prefix <italic>q</italic>-gram of a read</title>
      <p>Despite of the effort of the recent work, the number of candidates generated by using
optimal prefix selection is still too large to refine and/or verify directly. Thus,
it is important to further filter out false positives while generating candidates.
Hobbes attaches a bit vector to each element in an inverted list and makes use of bit
vectors to remove false positives while generating candidates. However, bit vectors
greatly increase the size of an inverted index and thus consume a lot of memory
space. In this paper, we propose a powerful and memory efficient filtering method.
The proposed method does not require additional memory space while it can still
filter out more false positives than bit vectors. Our technique is based on the
following lemma.</p>
      <sec>
        <title><bold>Lemma</bold><bold>1</bold> (Additional prefix)</title>
        <p>Given an inverted index of a genome sequence and a read with a Hamming distance
threshold <italic>k</italic>, suppose we select <italic>k</italic>+2 non-overlapping
<italic>q</italic>-grams from the read. If we retrieve inverted lists of the selected
<italic>k</italic>+2<italic>q</italic>-grams from the index, we can select those locations as
candidates that come from at least two normalized inverted lists.</p>
        <p>The intuition of the lemma is that the set of overlapping <italic>q</italic>-grams in a
candidate genome subsequence <italic>s</italic> must contain at least 2 <italic>q</italic>-grams
among <italic>k</italic>+2 non-overlapping <italic>q</italic>-grams in a read <italic>r</italic>, because
otherwise the difference between <italic>r</italic> and <italic>s</italic> would be larger than
<italic>k</italic> bases. We analyze the lemma more precisely using an example as follows.
Assume a Hamming distance threshold <italic>k</italic> is 1 and we select <italic>k</italic>+2
non-overlapping <italic>q</italic>-grams
<italic>S</italic>={<italic>g</italic><sub>1</sub>,<italic>g</italic><sub>2</sub>,<italic>g</italic><sub>3</sub>}
from a read. If we enumerate all possible subsets of S whose cardinality is
<italic>k</italic>+1=2, we obtain three subsets,
<italic>S</italic><sub>1</sub>={<italic>g</italic><sub>1</sub>,<italic>g</italic><sub>2</sub>},
<italic>S</italic><sub>2</sub>={<italic>g</italic><sub>1</sub>,<italic>g</italic><sub>3</sub>}, and
<italic>S</italic><sub>3</sub>={<italic>g</italic><sub>2</sub>,<italic>g</italic><sub>3</sub>}. As
described in the previous section, we can generate candidates using any of three
subsets. Let <italic>C</italic>(<italic>S</italic><sub><italic>i</italic></sub>) be <inline-formula><mml:math id="M4" name="1471-2105-15-42-i4" overflow="scroll"><mml:msub><mml:mrow><mml:mo>∪</mml:mo></mml:mrow><mml:mrow><mml:mi>g</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:msup><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup><mml:mo>(</mml:mo><mml:mspace width="0.3em"/><mml:mi>g</mml:mi><mml:mo>)</mml:mo></mml:math></inline-formula>, the set of candidates generated using a subset
<italic>S</italic><sub><italic>i</italic></sub> of <italic>S</italic>. If a candidate location is a true
mapping, it should be contained in all of <italic>C</italic>(<italic>S</italic><sub>1</sub>),
<italic>C</italic>(<italic>S</italic><sub>2</sub>), and <italic>C</italic>(<italic>S</italic><sub>3</sub>).
Therefore, we can generate refined candidates by taking the intersection of
<italic>C</italic>(<italic>S</italic><sub>1</sub>), <italic>C</italic>(<italic>S</italic><sub>2</sub>), and
<italic>C</italic>(<italic>S</italic><sub>3</sub>). According to this observation, we formulate
the set of candidates as</p>
        <p>
          <disp-formula>
            <mml:math id="M5" name="1471-2105-15-42-i5" overflow="scroll">
              <mml:mrow>
                <mml:mo>(</mml:mo>
                <mml:msup>
                  <mml:mrow>
                    <mml:mi>I</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>n</mml:mi>
                  </mml:mrow>
                </mml:msup>
                <mml:mo>(</mml:mo>
                <mml:mspace width="2.77626pt"/>
                <mml:mspace width="0.3em"/>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>g</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mn>1</mml:mn>
                  </mml:mrow>
                </mml:msub>
                <mml:mo>)</mml:mo>
                <mml:mo>∪</mml:mo>
                <mml:msup>
                  <mml:mrow>
                    <mml:mi>I</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>n</mml:mi>
                  </mml:mrow>
                </mml:msup>
                <mml:mo>(</mml:mo>
                <mml:mspace width="2.77626pt"/>
                <mml:mspace width="0.3em"/>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>g</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mn>2</mml:mn>
                  </mml:mrow>
                </mml:msub>
                <mml:mo>)</mml:mo>
                <mml:mo>)</mml:mo>
                <mml:mo>∩</mml:mo>
                <mml:mo>(</mml:mo>
                <mml:msup>
                  <mml:mrow>
                    <mml:mi>I</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>n</mml:mi>
                  </mml:mrow>
                </mml:msup>
                <mml:mo>(</mml:mo>
                <mml:mspace width="2.77626pt"/>
                <mml:mspace width="0.3em"/>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>g</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mn>1</mml:mn>
                  </mml:mrow>
                </mml:msub>
                <mml:mo>)</mml:mo>
                <mml:mo>∪</mml:mo>
                <mml:msup>
                  <mml:mrow>
                    <mml:mi>I</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>n</mml:mi>
                  </mml:mrow>
                </mml:msup>
                <mml:mo>(</mml:mo>
                <mml:mspace width="2.77626pt"/>
                <mml:mspace width="0.3em"/>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>g</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mn>3</mml:mn>
                  </mml:mrow>
                </mml:msub>
                <mml:mo>)</mml:mo>
                <mml:mo>)</mml:mo>
                <mml:mo>∩</mml:mo>
                <mml:msup>
                  <mml:mrow>
                    <mml:mo>(</mml:mo>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>n</mml:mi>
                  </mml:mrow>
                </mml:msup>
                <mml:mo>(</mml:mo>
                <mml:mspace width="2.77626pt"/>
                <mml:mspace width="0.3em"/>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>g</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mn>2</mml:mn>
                  </mml:mrow>
                </mml:msub>
                <mml:mo>)</mml:mo>
                <mml:mo>∪</mml:mo>
                <mml:msup>
                  <mml:mrow>
                    <mml:mi>I</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>n</mml:mi>
                  </mml:mrow>
                </mml:msup>
                <mml:mo>(</mml:mo>
                <mml:mspace width="2.77626pt"/>
                <mml:mspace width="0.3em"/>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>g</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mn>3</mml:mn>
                  </mml:mrow>
                </mml:msub>
                <mml:mo>)</mml:mo>
                <mml:mo>)</mml:mo>
                <mml:mi>.</mml:mi>
              </mml:mrow>
            </mml:math>
          </disp-formula>
        </p>
        <p>Using the distributive, associative, absorption, and idempotent properties of sets,
we can rewrite the formula to </p>
        <p>
          <disp-formula>
            <mml:math id="M6" name="1471-2105-15-42-i6" overflow="scroll">
              <mml:mrow>
                <mml:mo>(</mml:mo>
                <mml:msup>
                  <mml:mrow>
                    <mml:mi>I</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>n</mml:mi>
                  </mml:mrow>
                </mml:msup>
                <mml:mo>(</mml:mo>
                <mml:mspace width="2.77626pt"/>
                <mml:mspace width="0.3em"/>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>g</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mn>1</mml:mn>
                  </mml:mrow>
                </mml:msub>
                <mml:mo>)</mml:mo>
                <mml:mo>∩</mml:mo>
                <mml:msup>
                  <mml:mrow>
                    <mml:mi>I</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>n</mml:mi>
                  </mml:mrow>
                </mml:msup>
                <mml:mo>(</mml:mo>
                <mml:mspace width="2.77626pt"/>
                <mml:mspace width="0.3em"/>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>g</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mn>2</mml:mn>
                  </mml:mrow>
                </mml:msub>
                <mml:mo>)</mml:mo>
                <mml:mo>)</mml:mo>
                <mml:mo>∪</mml:mo>
                <mml:mo>(</mml:mo>
                <mml:msup>
                  <mml:mrow>
                    <mml:mi>I</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>n</mml:mi>
                  </mml:mrow>
                </mml:msup>
                <mml:mo>(</mml:mo>
                <mml:mspace width="2.77626pt"/>
                <mml:mspace width="0.3em"/>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>g</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mn>1</mml:mn>
                  </mml:mrow>
                </mml:msub>
                <mml:mo>)</mml:mo>
                <mml:mo>∩</mml:mo>
                <mml:msup>
                  <mml:mrow>
                    <mml:mi>I</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>n</mml:mi>
                  </mml:mrow>
                </mml:msup>
                <mml:mo>(</mml:mo>
                <mml:mspace width="2.77626pt"/>
                <mml:mspace width="0.3em"/>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>g</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mn>3</mml:mn>
                  </mml:mrow>
                </mml:msub>
                <mml:mo>)</mml:mo>
                <mml:mo>)</mml:mo>
                <mml:mo>∪</mml:mo>
                <mml:mo>(</mml:mo>
                <mml:msup>
                  <mml:mrow>
                    <mml:mi>I</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>n</mml:mi>
                  </mml:mrow>
                </mml:msup>
                <mml:mo>(</mml:mo>
                <mml:mspace width="2.77626pt"/>
                <mml:mspace width="0.3em"/>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>g</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mn>2</mml:mn>
                  </mml:mrow>
                </mml:msub>
                <mml:mo>)</mml:mo>
                <mml:mo>∩</mml:mo>
                <mml:msup>
                  <mml:mrow>
                    <mml:mi>I</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>n</mml:mi>
                  </mml:mrow>
                </mml:msup>
                <mml:mo>(</mml:mo>
                <mml:mspace width="2.77626pt"/>
                <mml:mspace width="0.3em"/>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>g</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mn>3</mml:mn>
                  </mml:mrow>
                </mml:msub>
                <mml:mo>)</mml:mo>
                <mml:mo>)</mml:mo>
                <mml:mo>,</mml:mo>
              </mml:mrow>
            </mml:math>
          </disp-formula>
        </p>
        <p>which is illustrated in a diagram in Figure <xref ref-type="fig" rid="F2">2</xref>(a). If we compare
it with the candidate set generated by <italic>k</italic>+1 prefix <italic>q</italic>-grams
<italic>g</italic><sub>1</sub> and <italic>g</italic><sub>2</sub>, which is depicted in Figure
<xref ref-type="fig" rid="F2">2</xref>(b), we can see that an additional prefix <italic>q</italic>-gram
<italic>g</italic><sub>3</sub> plays a significant role of filtering out false
positives.</p>
        <fig id="F2" position="float">
          <label>Figure 2</label>
          <caption>
            <p><bold>Filtering effect of an additional prefix</bold><bold><italic>q</italic></bold><bold>-gram.</bold>
Gray-scaled areas indicate candidates. <bold>(a)</bold> An additional prefix
<italic>q</italic>-gram <italic>g</italic><sub>3</sub> plays an important role of filtering
out a number of false positives in <italic>E</italic> and <italic>F</italic>. <bold>(b)</bold> If we
use <italic>k</italic>+1=2<italic>q</italic>-grams, <italic>g</italic><sub>1</sub> and
<italic>g</italic><sub>2</sub>, much more candidates are generated.</p>
          </caption>
          <graphic xlink:href="1471-2105-15-42-2"/>
        </fig>
        <p>Given inverted lists of <italic>k</italic>+2 prefix <italic>q</italic>-grams, in general, we can
generate candidates by taking the union of pairwise intersections of the inverted
lists. That is, each inverted list is intersected <italic>k</italic>+1 times. However, we do
not need to scan each inverted list <italic>k</italic>+1 times to generate candidates.
Instead, we can use an algorithm that merges all inverted lists by scanning each of
them once and selects those locations that appears at least 2 times according to
Lemma 1 [see Additional file <xref ref-type="supplementary-material" rid="S1">1</xref> for the candidate generation
algorithm].</p>
      </sec>
    </sec>
    <sec>
      <title>Supporting insertions and deletions</title>
      <p>If we use an edit distance threshold (i.e., we allow not only substitutions but also
insertions and deletions of bases) for mapping a read, indels introduce two potential
problems to the above described technique. In this section, we discuss these two
potential problems and describe how to fix them. The first potential problem is
caused by insertions or deletions occurred between two matched <italic>q</italic>-grams. In
the proposed technique, a candidate genome subsequence <italic>s</italic> needs to contain at
least two <italic>q</italic>-grams in a read <italic>r</italic>, where each of which must appear at
the same location in both <italic>r</italic> and <italic>s</italic>. In case of edit distance
constraints, however, the proposed technique could filter out a valid candidate
<italic>s</italic>, since indels between two matched <italic>q</italic>-grams make the locations
of the <italic>q</italic>-grams in <italic>r</italic> different from those in <italic>s</italic>.</p>
      <p>For example, consider a genome sequence
<italic>S</italic><sub><italic>g</italic></sub>=CCAGTAATGCTGTTG… and a read
<italic>r</italic>=AGTAATCTGTTG. Given an edit threshold <italic>k</italic>=1, assume that we select
<italic>k</italic>+2=3 non-overlapping tri-grams of <italic>g</italic><sub>1</sub>=AGT,
<italic>g</italic><sub>2</sub>=ATC, and <italic>g</italic><sub>3</sub>=TTG in
<italic>G</italic>(<italic>r</italic>) (underlined in the read) as the prefix <italic>q</italic>-grams.
For <italic>g</italic><sub>1</sub>, we obtain location 2 of <italic>S</italic><sub><italic>g</italic></sub>
since <italic>g</italic><sub>1</sub> appears at location 0 in <italic>r</italic> and at location 2 in
<italic>S</italic><sub><italic>g</italic></sub>. For <italic>g</italic><sub>2</sub>, we cannot find a
matched <italic>q</italic>-gram in <italic>S</italic><sub><italic>g</italic></sub>. Finally, for
<italic>g</italic><sub>3</sub>, we get location 3 of <italic>S</italic><sub><italic>g</italic></sub> since
<italic>g</italic><sub>3</sub> appears at location 10 in <italic>r</italic> and at location 13 in
<italic>S</italic><sub><italic>g</italic></sub>. Because there is no location that appears at
least twice, we filter out both locations of 2 and 3. However, the edit distance
between the read and the subsequence of <italic>S</italic><sub><italic>g</italic></sub> starting at
location 2 is 1 and we should be able to return location 2 of
<italic>S</italic><sub><italic>g</italic></sub> as a mapping location. The problem is caused by
the underlined base <monospace>G</monospace> in <italic>S</italic><sub><italic>g</italic></sub>,
which is located between two matched grams <monospace>AGT</monospace> and
<monospace>TTG</monospace> as depicted in Figure <xref ref-type="fig" rid="F3">3</xref>(a).</p>
      <fig id="F3" position="float">
        <label>Figure 3</label>
        <caption>
          <p><bold>Problems caused by indels.</bold><bold>(a)</bold> Indels occurring between two
matched <italic>q</italic>-grams <bold>(b)</bold> Deletions occurring before any matched
<italic>q</italic>-grams. <bold>(c)</bold> Insertions occurring before any matched
<italic>q</italic>-grams. <bold>(d)</bold> Verification windows of a semi-global alignment
algorithm.</p>
        </caption>
        <graphic xlink:href="1471-2105-15-42-3"/>
      </fig>
      <p>To fix this problem, we need to allow gaps between two matched <italic>q</italic>-grams up to
the edit distance threshold. That is, we treat two locations appearing only once as
candidate locations if their difference is within the edit distance threshold. In our
example, since the difference between the locations 2 and 3 is within the edit
distance threshold 1, we generate both of the locations 2 and 3 as candidates.</p>
      <p>The second problem is caused by indels occurring before any locations of matched
prefix <italic>q</italic>-grams. If there are <italic>d</italic> deletions of bases in a reference
sequence before the matched <italic>q</italic>-grams, we need to consider a subsequence
starting at <italic>l</italic>−<italic>d</italic>, where <italic>l</italic> is a candidate location
calculated from the matched <italic>q</italic>-grams. For example, consider a genome sequence
<italic>S</italic><sub><italic>g</italic></sub>=GAGAGATCTGCATAA… and a read
<italic>r</italic>=GAAGATCTGCATAA, where three underlined tri-grams
<monospace>GAT</monospace>, <monospace>TGC</monospace>, and
<monospace>TAA</monospace> in <italic>G</italic>(<italic>r</italic>) are selected as the prefix
grams for an edit distance 1. As our technique returns location 1 in
<italic>S</italic><sub><italic>g</italic></sub> for all the three <italic>q</italic>-grams, we use the
location as a candidate and verify the genome subsequence <italic>s</italic> starting at the
location. Because the edit distance between <italic>r</italic> and <italic>s</italic> is 2, we do not
have a mapping of the read <italic>r</italic>. However, if we consider the subsequence
starting from location 0 of <italic>S</italic><sub><italic>g</italic></sub>, we should be able to
return the location 0 as a mapping location because the edit distance is 1 as
depicted in Figure <xref ref-type="fig" rid="F3">3</xref>(b). This problem is caused by the deletion
of the underlined base <monospace>G</monospace> from <italic>S</italic><sub><italic>g</italic></sub>,
which is located before the three matched grams <monospace>GAT</monospace>,
<monospace>TGC</monospace>, and <monospace>TTA</monospace>.</p>
      <p>By contrast, if there are <italic>i</italic> insertions of bases in a reference sequence
before any locations of matched prefix <italic>q</italic>-grams, we need to consider a
subsequence starting at location <italic>l</italic>+<italic>i</italic>, where <italic>l</italic> is a
candidate location. For example, consider a genome sequence
<italic>S</italic><sub><italic>g</italic></sub>=AGAAGATCTGCATAA… and a read
<italic>r</italic>=GAGAGATCTGCATAA, where three underlined tri-grams are matched for an edit
distance 1. Although location 0, which is calculated from the matched tri-grams, does
not satisfy the edit distance threshold, we should be able to return location 1 as a
mapping location as depicted in Figure <xref ref-type="fig" rid="F3">3</xref>(c). The underlined
base <monospace>G</monospace> in <italic>r</italic> (or the insertion of the
<monospace>G</monospace> into <italic>S</italic><sub><italic>g</italic></sub>) causes this
problem.</p>
      <p>Therefore, given an edit distance threshold <italic>k</italic> and a candidate starting
location <italic>l</italic>, a potential match can start at any location between
<italic>l</italic>−<italic>k</italic> and <italic>l</italic>+<italic>k</italic>. Similarly, indels can also
occur after matched prefix <italic>q</italic>-grams. Given a candidate ending location
<italic>c</italic>, a potential match can end at any location between
<italic>c</italic>−<italic>k</italic> and <italic>c</italic>+<italic>k</italic>. So altogether, we need to
consider a verification window from <italic>l</italic>−<italic>k</italic> to
<italic>c</italic>+<italic>k</italic> to find all potential matches (Figure <xref ref-type="fig" rid="F3">3</xref>(d)). However, because the verification time based on sequence alignment
is proportional to the size of the verification window, enlarging the window at both
ends by <italic>k</italic> is computationally expensive. In Hobbes2, we adopt the following
heuristic to improve the mapping speed: We first use the verification window [
<italic>l</italic>,<italic>c</italic>+<italic>k</italic>] (Figure <xref ref-type="fig" rid="F3">3</xref>(d)), and run a
semi-global banded alignment algorithm to identify all potential matches located
within this window. If this verification window yields no matches, we then consider
the verification window [ <italic>l</italic>−<italic>k</italic>,<italic>c</italic>]. This approach
could potentially miss some true mappings that start before <italic>l</italic> and at the
same time end after <italic>c</italic>. However, empirically we found that those mappings are
relatively rare and do not significantly impact the accuracy of our algorithm.</p>
    </sec>
    <sec>
      <title>Implementation details</title>
      <p>As Hobbes2 uses an additional prefix <italic>q</italic>-gram instead of bit vectors, it can
significantly improve the performance and substantially reduce memory consumption. In
this section, we describe how Hobbes2 was implemented on top of Hobbes. Other details
and optimization techniques for implementation that are not presented here are the
same as those in Hobbes.</p>
      <p>Hobbes2 builds an inverted index in the same way that Hobbes does. That is, each
element in an inverted list contains a bit vector. However, Hobbes2 loads inverted
lists without bit vectors into the memory if it determines that a read has at least
<italic>k</italic>+2 non-overlapping <italic>q</italic>-grams, where <italic>k</italic> is a distance
threshold. In this case, Hobbes2 filters out false positives using an additional
<italic>q</italic>-gram while it generates candidates. If the number of <italic>q</italic>-grams
contained in a read is less than <italic>k</italic>+2, Hobbes2 loads both inverted lists and
bit vectors into memory. Hobbes2 assumes fixed length input reads and calculate the
number of non-overlapping <italic>q</italic>-grams using the length of the first input read.
For variable length reads, it also safely maps each read but it does not filter out
false positives for those reads that have not enough <italic>q</italic>-grams.</p>
      <p>Obviously, the predefined gram length is important for the usability of the proposed
filtering technique since it determines the number of <italic>q</italic>-grams in a read. If
we increase the gram length, there could be fewer locations in a genome sequence
containing the gram, causing the inverted lists to be shorter. Thus, it may decrease
the time for scanning inverted lists and produce fewer candidate locations. On the
other hand, the size of a hash table for grams in an inverted index becomes very
large. If we increase the gram length by 1, the size of the hash table increases by
up to 4 times since we have four distinct bases of <monospace>A</monospace>,
<monospace>C</monospace>, <monospace>G</monospace>, and
<monospace>T</monospace>.</p>
      <p>Thus, index lookup time for a gram may be the bottleneck of read mapping as the size
of the hash table becomes larger. We found that the mapping speed with an 11-gram
inverted index was the best when we mapped 100bp reads on HG18 genome sequence [see
Additional file <xref ref-type="supplementary-material" rid="S1">1</xref>: Figure S1 for experimental results on
gram length]. Based on the experiments, Hobbes2 uses 11-grams and thus it can always
find enough grams for a 100bp read with up to 7 errors.</p>
    </sec>
  </sec>
  <sec>
    <title>Results and discussion</title>
    <sec>
      <title>Experimental setup</title>
      <p>We implemented Hobbes2 in C++, and compiled it with GCC 4.4.3. All experiments were
run on a machine with 94 GB of RAM, and dual Intel Xeons X5670 (12 cores and 24
threads total) at 2.93 GHz, running a 64-bit Ubuntu OS. We performed experiments to
examine all mapping capabilities of Hobbes2. We focused on edit distance constraints,
and all experiments were performed with the edit distance threshold set to be 5 [see
Additional file <xref ref-type="supplementary-material" rid="S1">1</xref>: Table S1 for the experimental results
with Hamming distance constraints]. Hobbes2 also has an optional <italic>m</italic>-mapping
mode, which returns the results of only those reads whose maximum number of distinct
mapping locations is less than or equal to a given threshold <italic>m</italic>. We reported
the experimental results on the <italic>m</italic>-mapping mode in Additional file <xref ref-type="supplementary-material" rid="S1">1</xref>: Table S2.</p>
      <p>We thoroughly compared Hobbes2 with three state-of-the-art all mappers - Hobbes,
RazerS3, and Masai, and three other popular read mappers - GEM [<xref ref-type="bibr" rid="B15">15</xref>], BWA and Bowtie2. We did not include other all mappers (such as SOAP2 [<xref ref-type="bibr" rid="B16">16</xref>], SHRiMP2 [<xref ref-type="bibr" rid="B17">17</xref>], mrsFAST [<xref ref-type="bibr" rid="B18">18</xref>], and mrFAST-CO [<xref ref-type="bibr" rid="B19">19</xref>]) in our comparison as it has been shown previously that these all mappers
do not perform as well as RazerS3, Masai, and/or Hobbes. We configured read mappers
to output results in the SAM format with cigar strings [see Section S3 in Additional
file <xref ref-type="supplementary-material" rid="S1">1</xref> for the details of the configuration of each read
mapper].</p>
    </sec>
    <sec>
      <title>Index construction and memory footprint</title>
      <p>For each reference genome, we built an inverted index of overlapping <italic>q</italic>-grams
on the reference genome. By default, Hobbes2 uses 16-bit vectors, resulting in a
total index size of 16 GB for the whole human genome NCBI HG18. Hobbes2 loads only
the index into memory and the memory footprint of the index for HG18 is about 11 GB.
Because Hobbes2 has a tight-knit multi-threaded framework that parallelizes both
indexing and mapping, it took only a few minutes to build an index for HG18.</p>
    </sec>
    <sec>
      <title>Single end alignment on simulated data</title>
      <p>We generated 100k simulated reads of length 100bp from HG18 using a read simulator,
Mason [<xref ref-type="bibr" rid="B20">20</xref>]. We used the default profile setting of Mason with the
<monospace>illumina</monospace> option. We used Rabema [<xref ref-type="bibr" rid="B21">21</xref>] benchmark to compare accuracies of read mappers. The benchmark was
performed for an error rate 5%, or edit distance 5. To build a gold standard of
simulated reads, we used RazerS3 in full-sensitive mode (we ran RazerS3 with its
default setting for the performance comparison).</p>
      <p>The benchmark found all, all of the best, and any of the best edit distance locations
from the mapping results of each mapper. As the simulator generated original
locations of simulated reads, we also measured the recall of each mapper, which is
the fraction of reads whose original locations correctly reported.</p>
      <p>Table <xref ref-type="table" rid="T1">1</xref> shows rabema scores in percentage, each of which is the
average fraction of edit distance locations returned by a read mapper per read. Large
numbers are total scores and small numbers are scores for reads with
<inline-formula><mml:math id="M7" name="1471-2105-15-42-i17" overflow="scroll"><mml:mtable class="array" columnalign="left"><mml:mtr><mml:mtd><mml:mn>0</mml:mn><mml:mspace width="1em"/><mml:mn>1</mml:mn><mml:mspace width="1em"/><mml:mn>2</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>3</mml:mn><mml:mspace width="1em"/><mml:mn>4</mml:mn><mml:mspace width="1em"/><mml:mn>5</mml:mn></mml:mtd></mml:mtr></mml:mtable></mml:math></inline-formula>errors. We could not measure the mapping time of Masai
with 16 threads since it does not support multi-threading. We omitted the mapping
time of Bowtie2 with a single thread since it could finish only about 10% of 100k
reads in 6 hours.</p>
      <table-wrap position="float" id="T1">
        <label>Table 1</label>
        <caption>
          <p>Rabema benchmark results of mapping simulated 100k reads of length 100bp
against HG18</p>
        </caption>
        <table frame="hsides" rules="groups" border="1">
          <colgroup>
            <col/>
            <col/>
            <col/>
            <col/>
            <col/>
            <col/>
            <col/>
            <col/>
            <col/>
            <col/>
            <col/>
            <col/>
            <col/>
            <col/>
            <col/>
            <col/>
            <col/>
            <col/>
            <col/>
            <col/>
            <col/>
          </colgroup>
          <thead valign="top">
            <tr>
              <th align="left" valign="bottom"> <hr/></th>
              <th colspan="2" align="center" valign="bottom">
                <bold>Time (min:sec)</bold>
                <hr/>
              </th>
              <th align="left" valign="bottom"> <hr/></th>
              <th colspan="16" align="center" valign="bottom">
                <bold>Benchmark category</bold>
                <hr/>
              </th>
              <th align="center" valign="bottom">
                <bold>Peak</bold>
                <hr/>
              </th>
            </tr>
            <tr>
              <th align="left">
                <bold>Mapper</bold>
              </th>
              <th align="center">
                <bold>1 thr</bold>
              </th>
              <th align="center">
                <bold>16 thrs</bold>
              </th>
              <th align="left"> </th>
              <th colspan="4" align="center">
                <bold>All</bold>
              </th>
              <th colspan="4" align="center">
                <bold>All-best</bold>
              </th>
              <th colspan="4" align="center">
                <bold>Any-best</bold>
              </th>
              <th colspan="4" align="center">
                <bold>Recall</bold>
              </th>
              <th align="center">
                <bold>memory</bold>
              </th>
            </tr>
          </thead>
          <tbody valign="top">
            <tr>
              <td align="left" valign="bottom">Hobbes2<hr/></td>
              <td align="center" valign="bottom">9:43<hr/></td>
              <td align="center" valign="bottom">1:33<hr/></td>
              <td align="center" valign="bottom"> <hr/></td>
              <td align="center" valign="bottom">99.85<hr/></td>
              <td align="center" valign="bottom">100.0<hr/></td>
              <td align="center" valign="bottom">100.0<hr/></td>
              <td align="center" valign="bottom">100.0<hr/></td>
              <td align="center" valign="bottom">99.99<hr/></td>
              <td align="center" valign="bottom">100.0<hr/></td>
              <td align="center" valign="bottom">100.0<hr/></td>
              <td align="center" valign="bottom">100.0<hr/></td>
              <td align="center" valign="bottom">99.99<hr/></td>
              <td align="center" valign="bottom">100.0<hr/></td>
              <td align="center" valign="bottom">100.0<hr/></td>
              <td align="center" valign="bottom">100.0<hr/></td>
              <td align="center" valign="bottom">98.97<hr/></td>
              <td align="center" valign="bottom">100.0<hr/></td>
              <td align="center" valign="bottom">99.90<hr/></td>
              <td align="center" valign="bottom">99.68<hr/></td>
              <td align="center" valign="bottom">14.6 GB<hr/></td>
            </tr>
            <tr>
              <td align="left" valign="bottom"> <hr/></td>
              <td align="center" valign="bottom"> <hr/></td>
              <td align="center" valign="bottom"> <hr/></td>
              <td align="center" valign="bottom"> <hr/></td>
              <td align="center" valign="bottom"> <hr/></td>
              <td align="center" valign="bottom">99.99<hr/></td>
              <td align="center" valign="bottom">99.94<hr/></td>
              <td align="center" valign="bottom">97.48<hr/></td>
              <td align="center" valign="bottom"> <hr/></td>
              <td align="center" valign="bottom">100.0<hr/></td>
              <td align="center" valign="bottom">100.0<hr/></td>
              <td align="center" valign="bottom">99.84<hr/></td>
              <td align="center" valign="bottom"> <hr/></td>
              <td align="center" valign="bottom">100.0<hr/></td>
              <td align="center" valign="bottom">100.0<hr/></td>
              <td align="center" valign="bottom">99.84<hr/></td>
              <td align="center" valign="bottom"> <hr/></td>
              <td align="center" valign="bottom">99.34<hr/></td>
              <td align="center" valign="bottom">99.04<hr/></td>
              <td align="center" valign="bottom">99.77<hr/></td>
              <td align="center" valign="bottom"> <hr/></td>
            </tr>
            <tr>
              <td align="left" valign="bottom">Hobbes<hr/></td>
              <td align="center" valign="bottom">19:36<hr/></td>
              <td align="center" valign="bottom">3:35<hr/></td>
              <td align="center" valign="bottom"> <hr/></td>
              <td align="center" valign="bottom">98.34<hr/></td>
              <td align="center" valign="bottom">99.29<hr/></td>
              <td align="center" valign="bottom">99.28<hr/></td>
              <td align="center" valign="bottom">98.93<hr/></td>
              <td align="center" valign="bottom">98.67<hr/></td>
              <td align="center" valign="bottom">98.86<hr/></td>
              <td align="center" valign="bottom">99.02<hr/></td>
              <td align="center" valign="bottom">99.00<hr/></td>
              <td align="center" valign="bottom">98.99<hr/></td>
              <td align="center" valign="bottom">99.19<hr/></td>
              <td align="center" valign="bottom">99.31<hr/></td>
              <td align="center" valign="bottom">99.34<hr/></td>
              <td align="center" valign="bottom">96.91<hr/></td>
              <td align="center" valign="bottom">98.66<hr/></td>
              <td align="center" valign="bottom">97.99<hr/></td>
              <td align="center" valign="bottom">96.68<hr/></td>
              <td align="center" valign="bottom">20.7 GB<hr/></td>
            </tr>
            <tr>
              <td align="left" valign="bottom"> <hr/></td>
              <td align="center" valign="bottom"> <hr/></td>
              <td align="center" valign="bottom"> <hr/></td>
              <td align="center" valign="bottom"> <hr/></td>
              <td align="center" valign="bottom"> <hr/></td>
              <td align="center" valign="bottom">97.40<hr/></td>
              <td align="center" valign="bottom">93.78<hr/></td>
              <td align="center" valign="bottom">87.84<hr/></td>
              <td align="center" valign="bottom"> <hr/></td>
              <td align="center" valign="bottom">98.19<hr/></td>
              <td align="center" valign="bottom">92.85<hr/></td>
              <td align="center" valign="bottom">89.21<hr/></td>
              <td align="center" valign="bottom"> <hr/></td>
              <td align="center" valign="bottom">98.55<hr/></td>
              <td align="center" valign="bottom">93.25<hr/></td>
              <td align="center" valign="bottom">90.14<hr/></td>
              <td align="center" valign="bottom"> <hr/></td>
              <td align="center" valign="bottom">95.33<hr/></td>
              <td align="center" valign="bottom">91.68<hr/></td>
              <td align="center" valign="bottom">90.17<hr/></td>
              <td align="center" valign="bottom"> <hr/></td>
            </tr>
            <tr>
              <td align="left" valign="bottom">Masai<hr/></td>
              <td align="center" valign="bottom">18:11<hr/></td>
              <td align="center" valign="bottom">−<hr/></td>
              <td align="center" valign="bottom"> <hr/></td>
              <td align="center" valign="bottom">99.83<hr/></td>
              <td align="center" valign="bottom">100.0<hr/></td>
              <td align="center" valign="bottom">100.0<hr/></td>
              <td align="center" valign="bottom">100.0<hr/></td>
              <td align="center" valign="bottom">99.94<hr/></td>
              <td align="center" valign="bottom">100.0<hr/></td>
              <td align="center" valign="bottom">100.0<hr/></td>
              <td align="center" valign="bottom">100.0<hr/></td>
              <td align="center" valign="bottom">99.94<hr/></td>
              <td align="center" valign="bottom">100.0<hr/></td>
              <td align="center" valign="bottom">100.0<hr/></td>
              <td align="center" valign="bottom">100.0<hr/></td>
              <td align="center" valign="bottom">99.03<hr/></td>
              <td align="center" valign="bottom">100.0<hr/></td>
              <td align="center" valign="bottom">100.0<hr/></td>
              <td align="center" valign="bottom">100.0<hr/></td>
              <td align="center" valign="bottom">16.9 GB<hr/></td>
            </tr>
            <tr>
              <td align="left" valign="bottom"> <hr/></td>
              <td align="center" valign="bottom"> <hr/></td>
              <td align="center" valign="bottom"> <hr/></td>
              <td align="center" valign="bottom"> <hr/></td>
              <td align="center" valign="bottom"> <hr/></td>
              <td align="center" valign="bottom">99.73<hr/></td>
              <td align="center" valign="bottom">99.18<hr/></td>
              <td align="center" valign="bottom">97.69<hr/></td>
              <td align="center" valign="bottom"> <hr/></td>
              <td align="center" valign="bottom">99.69<hr/></td>
              <td align="center" valign="bottom">98.73<hr/></td>
              <td align="center" valign="bottom">98.52<hr/></td>
              <td align="center" valign="bottom"> <hr/></td>
              <td align="center" valign="bottom">99.69<hr/></td>
              <td align="center" valign="bottom">98.73<hr/></td>
              <td align="center" valign="bottom">98.52<hr/></td>
              <td align="center" valign="bottom"> <hr/></td>
              <td align="center" valign="bottom">99.71<hr/></td>
              <td align="center" valign="bottom">98.77<hr/></td>
              <td align="center" valign="bottom">98.56<hr/></td>
              <td align="center" valign="bottom"> <hr/></td>
            </tr>
            <tr>
              <td align="left" valign="bottom">RazerS3<hr/></td>
              <td align="center" valign="bottom">60:06<hr/></td>
              <td align="center" valign="bottom">42:07<hr/></td>
              <td align="center" valign="bottom"> <hr/></td>
              <td align="center" valign="bottom">99.90<hr/></td>
              <td align="center" valign="bottom">100.0<hr/></td>
              <td align="center" valign="bottom">100.0<hr/></td>
              <td align="center" valign="bottom">100.0<hr/></td>
              <td align="center" valign="bottom">99.99<hr/></td>
              <td align="center" valign="bottom">100.0<hr/></td>
              <td align="center" valign="bottom">100.0<hr/></td>
              <td align="center" valign="bottom">100.0<hr/></td>
              <td align="center" valign="bottom">99.99<hr/></td>
              <td align="center" valign="bottom">100.0<hr/></td>
              <td align="center" valign="bottom">100.0<hr/></td>
              <td align="center" valign="bottom">100.0<hr/></td>
              <td align="center" valign="bottom">99.09<hr/></td>
              <td align="center" valign="bottom">100.0<hr/></td>
              <td align="center" valign="bottom">100.0<hr/></td>
              <td align="center" valign="bottom">100.0<hr/></td>
              <td align="center" valign="bottom">4.5 GB<hr/></td>
            </tr>
            <tr>
              <td align="left" valign="bottom"> <hr/></td>
              <td align="center" valign="bottom"> <hr/></td>
              <td align="center" valign="bottom"> <hr/></td>
              <td align="center" valign="bottom"> <hr/></td>
              <td align="center" valign="bottom"> <hr/></td>
              <td align="center" valign="bottom">100.0<hr/></td>
              <td align="center" valign="bottom">99.86<hr/></td>
              <td align="center" valign="bottom">98.44<hr/></td>
              <td align="center" valign="bottom"> <hr/></td>
              <td align="center" valign="bottom">100.0<hr/></td>
              <td align="center" valign="bottom">100.0<hr/></td>
              <td align="center" valign="bottom">99.92<hr/></td>
              <td align="center" valign="bottom"> <hr/></td>
              <td align="center" valign="bottom">100.0<hr/></td>
              <td align="center" valign="bottom">100.0<hr/></td>
              <td align="center" valign="bottom">99.92<hr/></td>
              <td align="center" valign="bottom"> <hr/></td>
              <td align="center" valign="bottom">100.0<hr/></td>
              <td align="center" valign="bottom">100.0<hr/></td>
              <td align="center" valign="bottom">99.92<hr/></td>
              <td align="center" valign="bottom"> <hr/></td>
            </tr>
            <tr>
              <td align="left" valign="bottom">Bowtie2<hr/></td>
              <td align="center" valign="bottom">−<hr/></td>
              <td align="center" valign="bottom">266:21<hr/></td>
              <td align="center" valign="bottom"> <hr/></td>
              <td align="center" valign="bottom">99.74<hr/></td>
              <td align="center" valign="bottom">100.0<hr/></td>
              <td align="center" valign="bottom">100.0<hr/></td>
              <td align="center" valign="bottom">100.0<hr/></td>
              <td align="center" valign="bottom">99.97<hr/></td>
              <td align="center" valign="bottom">100.0<hr/></td>
              <td align="center" valign="bottom">100.0<hr/></td>
              <td align="center" valign="bottom">100.0<hr/></td>
              <td align="center" valign="bottom">99.97<hr/></td>
              <td align="center" valign="bottom">100.0<hr/></td>
              <td align="center" valign="bottom">100.0<hr/></td>
              <td align="center" valign="bottom">100.0<hr/></td>
              <td align="center" valign="bottom">98.80<hr/></td>
              <td align="center" valign="bottom">100.0<hr/></td>
              <td align="center" valign="bottom">99.70<hr/></td>
              <td align="center" valign="bottom">99.40<hr/></td>
              <td align="center" valign="bottom">37.7 GB<hr/></td>
            </tr>
            <tr>
              <td align="left" valign="bottom"> <hr/></td>
              <td align="center" valign="bottom"> <hr/></td>
              <td align="center" valign="bottom"> <hr/></td>
              <td align="center" valign="bottom"> <hr/></td>
              <td align="center" valign="bottom"> <hr/></td>
              <td align="center" valign="bottom">100.0<hr/></td>
              <td align="center" valign="bottom">99.55<hr/></td>
              <td align="center" valign="bottom">95.75<hr/></td>
              <td align="center" valign="bottom"> <hr/></td>
              <td align="center" valign="bottom">100.0<hr/></td>
              <td align="center" valign="bottom">99.70<hr/></td>
              <td align="center" valign="bottom">98.35<hr/></td>
              <td align="center" valign="bottom"> <hr/></td>
              <td align="center" valign="bottom">100.0<hr/></td>
              <td align="center" valign="bottom">99.72<hr/></td>
              <td align="center" valign="bottom">98.45<hr/></td>
              <td align="center" valign="bottom"> <hr/></td>
              <td align="center" valign="bottom">99.10<hr/></td>
              <td align="center" valign="bottom">98.70<hr/></td>
              <td align="center" valign="bottom">98.50<hr/></td>
              <td align="center" valign="bottom"> <hr/></td>
            </tr>
            <tr>
              <td align="left" valign="bottom">BWA<hr/></td>
              <td align="center" valign="bottom">75:04<hr/></td>
              <td align="center" valign="bottom">12:20<hr/></td>
              <td align="center" valign="bottom"> <hr/></td>
              <td align="center" valign="bottom">97.73<hr/></td>
              <td align="center" valign="bottom">100.0<hr/></td>
              <td align="center" valign="bottom">99.98<hr/></td>
              <td align="center" valign="bottom">99.64<hr/></td>
              <td align="center" valign="bottom">98.89<hr/></td>
              <td align="center" valign="bottom">100.0<hr/></td>
              <td align="center" valign="bottom">99.98<hr/></td>
              <td align="center" valign="bottom">99.61<hr/></td>
              <td align="center" valign="bottom">98.90<hr/></td>
              <td align="center" valign="bottom">100.0<hr/></td>
              <td align="center" valign="bottom">99.98<hr/></td>
              <td align="center" valign="bottom">99.61<hr/></td>
              <td align="center" valign="bottom">97.91<hr/></td>
              <td align="center" valign="bottom">100.0<hr/></td>
              <td align="center" valign="bottom">99.98<hr/></td>
              <td align="center" valign="bottom">99.45<hr/></td>
              <td align="center" valign="bottom">4.8 GB<hr/></td>
            </tr>
            <tr>
              <td align="left" valign="bottom"> <hr/></td>
              <td align="center" valign="bottom"> <hr/></td>
              <td align="center" valign="bottom"> <hr/></td>
              <td align="center" valign="bottom"> <hr/></td>
              <td align="center" valign="bottom"> <hr/></td>
              <td align="center" valign="bottom">93.47<hr/></td>
              <td align="center" valign="bottom">82.91<hr/></td>
              <td align="center" valign="bottom">75.15<hr/></td>
              <td align="center" valign="bottom"> <hr/></td>
              <td align="center" valign="bottom">93.03<hr/></td>
              <td align="center" valign="bottom">78.87<hr/></td>
              <td align="center" valign="bottom">70.57<hr/></td>
              <td align="center" valign="bottom"> <hr/></td>
              <td align="center" valign="bottom">93.03<hr/></td>
              <td align="center" valign="bottom">78.98<hr/></td>
              <td align="center" valign="bottom">70.73<hr/></td>
              <td align="center" valign="bottom"> <hr/></td>
              <td align="center" valign="bottom">92.47<hr/></td>
              <td align="center" valign="bottom">78.55<hr/></td>
              <td align="center" valign="bottom">71.18<hr/></td>
              <td align="center" valign="bottom"> <hr/></td>
            </tr>
            <tr>
              <td align="left" valign="bottom">GEM<hr/></td>
              <td align="center" valign="bottom">5:19<hr/></td>
              <td align="center" valign="bottom">2:56<hr/></td>
              <td align="center" valign="bottom"> <hr/></td>
              <td align="center" valign="bottom">97.74<hr/></td>
              <td align="center" valign="bottom">100.0<hr/></td>
              <td align="center" valign="bottom">99.99<hr/></td>
              <td align="center" valign="bottom">99.84<hr/></td>
              <td align="center" valign="bottom">99.86<hr/></td>
              <td align="center" valign="bottom">100.0<hr/></td>
              <td align="center" valign="bottom">99.88<hr/></td>
              <td align="center" valign="bottom">99.81<hr/></td>
              <td align="center" valign="bottom">99.92<hr/></td>
              <td align="center" valign="bottom">100.0<hr/></td>
              <td align="center" valign="bottom">99.96<hr/></td>
              <td align="center" valign="bottom">99.93<hr/></td>
              <td align="center" valign="bottom">98.66<hr/></td>
              <td align="center" valign="bottom">100.0<hr/></td>
              <td align="center" valign="bottom">99.42<hr/></td>
              <td align="center" valign="bottom">99.12<hr/></td>
              <td align="center" valign="bottom">4.3 GB<hr/></td>
            </tr>
            <tr>
              <td align="left" valign="bottom"> <hr/></td>
              <td align="center" valign="bottom"> <hr/></td>
              <td align="center" valign="bottom"> <hr/></td>
              <td align="center" valign="bottom"> <hr/></td>
              <td align="center" valign="bottom"> <hr/></td>
              <td align="center" valign="bottom">97.36<hr/></td>
              <td align="center" valign="bottom">88.78<hr/></td>
              <td align="center" valign="bottom">68.31<hr/></td>
              <td align="center" valign="bottom"> <hr/></td>
              <td align="center" valign="bottom">99.47<hr/></td>
              <td align="center" valign="bottom">99.28<hr/></td>
              <td align="center" valign="bottom">97.34<hr/></td>
              <td align="center" valign="bottom"> <hr/></td>
              <td align="center" valign="bottom">99.69<hr/></td>
              <td align="center" valign="bottom">99.61<hr/></td>
              <td align="center" valign="bottom">97.67<hr/></td>
              <td align="center" valign="bottom"> <hr/></td>
              <td align="center" valign="bottom">98.17<hr/></td>
              <td align="center" valign="bottom">98.29<hr/></td>
              <td align="center" valign="bottom">98.64<hr/></td>
              <td align="center" valign="bottom"> <hr/></td>
            </tr>
            <tr>
              <td align="left" valign="bottom">Bowtie2*<hr/></td>
              <td align="center" valign="bottom">0:31<hr/></td>
              <td align="center" valign="bottom">0:32<hr/></td>
              <td align="center" valign="bottom"> <hr/></td>
              <td align="center" valign="bottom">91.34<hr/></td>
              <td align="center" valign="bottom">98.87<hr/></td>
              <td align="center" valign="bottom">97.75<hr/></td>
              <td align="center" valign="bottom">93.55<hr/></td>
              <td align="center" valign="bottom">97.08<hr/></td>
              <td align="center" valign="bottom">97.65<hr/></td>
              <td align="center" valign="bottom">97.33<hr/></td>
              <td align="center" valign="bottom">95.69<hr/></td>
              <td align="center" valign="bottom">99.29<hr/></td>
              <td align="center" valign="bottom">100.0<hr/></td>
              <td align="center" valign="bottom">99.45<hr/></td>
              <td align="center" valign="bottom">97.65<hr/></td>
              <td align="center" valign="bottom">95.96<hr/></td>
              <td align="center" valign="bottom">97.75<hr/></td>
              <td align="center" valign="bottom">96.88<hr/></td>
              <td align="center" valign="bottom">95.00<hr/></td>
              <td align="center" valign="bottom">3.2 GB<hr/></td>
            </tr>
            <tr>
              <td align="left" valign="bottom"> <hr/></td>
              <td align="center" valign="bottom"> <hr/></td>
              <td align="center" valign="bottom"> <hr/></td>
              <td align="center" valign="bottom"> <hr/></td>
              <td align="center" valign="bottom"> <hr/></td>
              <td align="center" valign="bottom">81.07<hr/></td>
              <td align="center" valign="bottom">53.90<hr/></td>
              <td align="center" valign="bottom">21.95<hr/></td>
              <td align="center" valign="bottom"> <hr/></td>
              <td align="center" valign="bottom">95.38<hr/></td>
              <td align="center" valign="bottom">93.98<hr/></td>
              <td align="center" valign="bottom">93.74<hr/></td>
              <td align="center" valign="bottom"> <hr/></td>
              <td align="center" valign="bottom">97.41<hr/></td>
              <td align="center" valign="bottom">96.24<hr/></td>
              <td align="center" valign="bottom">95.89<hr/></td>
              <td align="center" valign="bottom"> <hr/></td>
              <td align="center" valign="bottom">94.60<hr/></td>
              <td align="center" valign="bottom">93.33<hr/></td>
              <td align="center" valign="bottom">93.95<hr/></td>
              <td align="center" valign="bottom"> <hr/></td>
            </tr>
            <tr>
              <td align="left" valign="bottom">BWA*<hr/></td>
              <td align="center" valign="bottom">2:08<hr/></td>
              <td align="center" valign="bottom">0:25<hr/></td>
              <td align="center" valign="bottom"> <hr/></td>
              <td align="center" valign="bottom">92.27<hr/></td>
              <td align="center" valign="bottom">100.0<hr/></td>
              <td align="center" valign="bottom">99.82<hr/></td>
              <td align="center" valign="bottom">96.90<hr/></td>
              <td align="center" valign="bottom">98.79<hr/></td>
              <td align="center" valign="bottom">100.0<hr/></td>
              <td align="center" valign="bottom">99.83<hr/></td>
              <td align="center" valign="bottom">99.41<hr/></td>
              <td align="center" valign="bottom">98.83<hr/></td>
              <td align="center" valign="bottom">100.0<hr/></td>
              <td align="center" valign="bottom">99.89<hr/></td>
              <td align="center" valign="bottom">99.49<hr/></td>
              <td align="center" valign="bottom">97.31<hr/></td>
              <td align="center" valign="bottom">100.0<hr/></td>
              <td align="center" valign="bottom">99.17<hr/></td>
              <td align="center" valign="bottom">97.76<hr/></td>
              <td align="center" valign="bottom">4.5 GB<hr/></td>
            </tr>
            <tr>
              <td align="left" valign="bottom"> <hr/></td>
              <td align="center" valign="bottom"> <hr/></td>
              <td align="center" valign="bottom"> <hr/></td>
              <td align="center" valign="bottom"> <hr/></td>
              <td align="center" valign="bottom"> <hr/></td>
              <td align="center" valign="bottom">79.11<hr/></td>
              <td align="center" valign="bottom">45.49<hr/></td>
              <td align="center" valign="bottom">16.99<hr/></td>
              <td align="center" valign="bottom"> <hr/></td>
              <td align="center" valign="bottom">92.57<hr/></td>
              <td align="center" valign="bottom">78.26<hr/></td>
              <td align="center" valign="bottom">70.34<hr/></td>
              <td align="center" valign="bottom"> <hr/></td>
              <td align="center" valign="bottom">92.70<hr/></td>
              <td align="center" valign="bottom">78.60<hr/></td>
              <td align="center" valign="bottom">70.73<hr/></td>
              <td align="center" valign="bottom"> <hr/></td>
              <td align="center" valign="bottom">90.39<hr/></td>
              <td align="center" valign="bottom">77.11<hr/></td>
              <td align="center" valign="bottom">70.35<hr/></td>
              <td align="center" valign="bottom"> <hr/></td>
            </tr>
            <tr>
              <td align="left" valign="bottom">GEM*<hr/></td>
              <td align="center" valign="bottom">0:31<hr/></td>
              <td align="center" valign="bottom">0:13<hr/></td>
              <td align="center" valign="bottom"> <hr/></td>
              <td align="center" valign="bottom">94.48<hr/></td>
              <td align="center" valign="bottom">100.0<hr/></td>
              <td align="center" valign="bottom">99.38<hr/></td>
              <td align="center" valign="bottom">97.61<hr/></td>
              <td align="center" valign="bottom">99.86<hr/></td>
              <td align="center" valign="bottom">100.0<hr/></td>
              <td align="center" valign="bottom">99.88<hr/></td>
              <td align="center" valign="bottom">99.81<hr/></td>
              <td align="center" valign="bottom">99.92<hr/></td>
              <td align="center" valign="bottom">100.0<hr/></td>
              <td align="center" valign="bottom">99.95<hr/></td>
              <td align="center" valign="bottom">99.92<hr/></td>
              <td align="center" valign="bottom">98.62<hr/></td>
              <td align="center" valign="bottom">100.0<hr/></td>
              <td align="center" valign="bottom">99.28<hr/></td>
              <td align="center" valign="bottom">99.06<hr/></td>
              <td align="center" valign="bottom">4.3 GB<hr/></td>
            </tr>
            <tr>
              <td align="left"> </td>
              <td align="center"> </td>
              <td align="center"> </td>
              <td align="center"> </td>
              <td align="center"> </td>
              <td align="center">90.10</td>
              <td align="center">69.11</td>
              <td align="center">35.34</td>
              <td align="center"> </td>
              <td align="center">99.41</td>
              <td align="center">99.17</td>
              <td align="center">97.37</td>
              <td align="center"> </td>
              <td align="center">99.72</td>
              <td align="center">99.61</td>
              <td align="center">97.75</td>
              <td align="center"> </td>
              <td align="center">98.24</td>
              <td align="center">98.35</td>
              <td align="center">98.94</td>
              <td align="center"> </td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <p>all: all mappings within the given edit distance threshold; all-best: all
best mappings (i.e., all mappings with lowest edit distances); any-best: any
best mappings (i.e., any mapping with lowest edit distances).</p>
        </table-wrap-foot>
      </table-wrap>
      <p>In terms of the accuracy of all mapping, the top three performers were RaserS3,
Hobbes2 and Masai, with an accuracy score of 99.90, 99.85 and 99.83, respectively.
Hobbes2 was slightly worse than RaserS3 on reads with high error rates. However, in
terms of mapping time, Hobbes2 was much faster than both RaserS3 and Masai - six
times faster than RaserS3 and twice as faster than Masai on a single thread, and 20
times faster than RaserS3 on 16 threads (there is no implementation of
multi-threading on Masai.) BWA and Bowtie2, two most popular read mappers, trailed
behind Hobbes2 in both accuracy and mapping time. GEM was faster than Hobbes2 on a
single thread but slower than Hobbes2 on 16 threads. Although GEM mapped reads fast
but it lost a lot of mapping locations of edit distance 4 and 5 and exhibited poor
accuracy.</p>
      <p>We also ran BWA, Bowtie2, and GEM in their default mode (or best mapping mode) to
compare the performance. The results are reported at the end of Table <xref ref-type="table" rid="T1">1</xref> with mapper names, Bowtie2*, BWA*, and GEM*, respectively. Although they
could produce results quickly, they exhibited poor mapping results. In particular,
they lost most of locations of edit distance 5 and about a half of locations of edit
distance 4.</p>
    </sec>
    <sec>
      <title>Single end alignment on real data</title>
      <p>We used the human genome with HG18, caenorhabditis elegans (WormBase WS201), and
drosophila melanogaster (FlyBase release 5.42) as reference sequences. For the human
genome, we used the 100bp reads from specimen HG00096 of the 1000 genome project [<xref ref-type="bibr" rid="B22">22</xref>]. We also used 100bp reads taken from the DNA Data Bank of Japan (DDBJ)
repository [<xref ref-type="bibr" rid="B23">23</xref>] with entry SRX026594 for the worm genome and SRX148416 for the fly
genome.</p>
      <p>Table <xref ref-type="table" rid="T2">2</xref> lists the experimental results of mapping 1 million
reads of length 100bp against the human genome. We excluded Bowtie2 and BWA in the
experiment since they are not designed as all mappers and exhibited poor mapping
speed when aligning long, repetitive genomes. Hobbes2 mapped more reads than other
read mappers while running significantly faster. Hobbes2 with 16 threads was about 3
times faster than Hobbes, 9 times faster than Masai and 42 times faster than RazerS3.
By comparing the results of 500k reads and 1 million reads, we observed that the
mapping time of each read mapper was approximately proportional to the number of
input reads.</p>
      <table-wrap position="float" id="T2">
        <label>Table 2</label>
        <caption>
          <p>Results of mapping 500k and 1 million single end reads of length 100bp
against HG18</p>
        </caption>
        <table frame="hsides" rules="groups" border="1">
          <colgroup>
            <col/>
            <col/>
            <col/>
            <col/>
            <col/>
            <col/>
            <col/>
            <col/>
            <col/>
            <col/>
            <col/>
            <col/>
          </colgroup>
          <thead valign="top">
            <tr>
              <th align="left" valign="bottom"> <hr/></th>
              <th colspan="5" align="center" valign="bottom">
                <bold>500,000 reads</bold>
                <hr/>
              </th>
              <th align="left" valign="bottom"> <hr/></th>
              <th colspan="5" align="center" valign="bottom">
                <bold>1,000,000 reads</bold>
                <hr/>
              </th>
            </tr>
            <tr>
              <th align="left" valign="bottom"> <hr/></th>
              <th align="center" valign="bottom">
                <bold>Read</bold>
                <hr/>
              </th>
              <th align="center" valign="bottom">
                <bold># mappings</bold>
                <hr/>
              </th>
              <th colspan="2" align="center" valign="bottom">
                <bold>Time (min:sec)</bold>
                <hr/>
              </th>
              <th align="center" valign="bottom">
                <bold>Peak</bold>
                <hr/>
              </th>
              <th align="left" valign="bottom"> <hr/></th>
              <th align="center" valign="bottom">
                <bold>Read</bold>
                <hr/>
              </th>
              <th align="center" valign="bottom">
                <bold># mappings</bold>
                <hr/>
              </th>
              <th colspan="2" align="center" valign="bottom">
                <bold>Time (min:sec)</bold>
                <hr/>
              </th>
              <th align="center" valign="bottom">
                <bold>Peak</bold>
                <hr/>
              </th>
            </tr>
            <tr>
              <th align="left">
                <bold>Mapper</bold>
              </th>
              <th align="center">
                <bold>mapped</bold>
              </th>
              <th align="center">
                <bold>(million)</bold>
              </th>
              <th align="right">
                <bold>1 thr</bold>
              </th>
              <th align="right">
                <bold>16 thrs</bold>
              </th>
              <th align="center">
                <bold>memory</bold>
              </th>
              <th align="left"> </th>
              <th align="center">
                <bold>mapped</bold>
              </th>
              <th align="center">
                <bold>(million)</bold>
              </th>
              <th align="right">
                <bold>1 thr</bold>
              </th>
              <th align="right">
                <bold>16 thrs</bold>
              </th>
              <th align="center">
                <bold>memory</bold>
              </th>
            </tr>
          </thead>
          <tbody valign="top">
            <tr>
              <td align="left" valign="bottom">Hobbes2<hr/></td>
              <td align="center" valign="bottom">91.476%<hr/></td>
              <td align="center" valign="bottom">66.34<hr/></td>
              <td align="right" valign="bottom">44:54<hr/></td>
              <td align="right" valign="bottom">05:17<hr/></td>
              <td align="center" valign="bottom">14.7 GB<hr/></td>
              <td align="center" valign="bottom"> <hr/></td>
              <td align="center" valign="bottom">91.558%<hr/></td>
              <td align="center" valign="bottom">132.87<hr/></td>
              <td align="right" valign="bottom">87:27<hr/></td>
              <td align="right" valign="bottom">09:04<hr/></td>
              <td align="center" valign="bottom">14.7 GB<hr/></td>
            </tr>
            <tr>
              <td align="left" valign="bottom">Hobbes<hr/></td>
              <td align="center" valign="bottom">91.449%<hr/></td>
              <td align="center" valign="bottom">66.93<hr/></td>
              <td align="right" valign="bottom">84:38<hr/></td>
              <td align="right" valign="bottom">13:10<hr/></td>
              <td align="center" valign="bottom">21.5 GB<hr/></td>
              <td align="center" valign="bottom"> <hr/></td>
              <td align="center" valign="bottom">91.533%<hr/></td>
              <td align="center" valign="bottom">134.14<hr/></td>
              <td align="right" valign="bottom">169:50<hr/></td>
              <td align="right" valign="bottom">26:33<hr/></td>
              <td align="center" valign="bottom">22.8 GB<hr/></td>
            </tr>
            <tr>
              <td align="left" valign="bottom">Masai<hr/></td>
              <td align="center" valign="bottom">91.473%<hr/></td>
              <td align="center" valign="bottom">66.44<hr/></td>
              <td align="right" valign="bottom">47:38<hr/></td>
              <td align="right" valign="bottom">−<hr/></td>
              <td align="center" valign="bottom">17.1 GB<hr/></td>
              <td align="center" valign="bottom"> <hr/></td>
              <td align="center" valign="bottom">91.555%<hr/></td>
              <td align="center" valign="bottom">133.09<hr/></td>
              <td align="right" valign="bottom">82:46<hr/></td>
              <td align="right" valign="bottom">−<hr/></td>
              <td align="center" valign="bottom">17.3 GB<hr/></td>
            </tr>
            <tr>
              <td align="left">RazerS3</td>
              <td align="center">91.472%</td>
              <td align="center">66.10</td>
              <td align="right">276:00</td>
              <td align="right">193:19</td>
              <td align="center">10.8 GB</td>
              <td align="center"> </td>
              <td align="center">91.554%</td>
              <td align="center">132.45</td>
              <td align="right">540:35</td>
              <td align="right">378:18</td>
              <td align="center">18.8 GB</td>
            </tr>
          </tbody>
        </table>
      </table-wrap>
      <p>The memory footprint of Hobbes2 was the smallest among the four mappers being
compared on the dataset with 1 million reads. The memory requirement of Hobbes2 was
independent of the number of input reads because it did alignment read by read. Masai
used slightly more memory as the number of reads increased. The memory consumption of
RazerS3 was greatly affected by the number of reads and the total number of
mappings.</p>
      <p>Table <xref ref-type="table" rid="T3">3</xref> shows the results of mapping 1 million reads of length
100bp against the C. elegans and D. melanogaster data sets. Hobbes had much higher
memory footprint than Hobbes2 on the D. melanogaster data set. RazerS3 was unable to
map reads on the D. melanogaster data set because it used too much memory space and
was killed before the job was finished.</p>
      <table-wrap position="float" id="T3">
        <label>Table 3</label>
        <caption>
          <p>Results of mapping 1 million single end reads of length 100bp against C.
elegans and D. melanogaster</p>
        </caption>
        <table frame="hsides" rules="groups" border="1">
          <colgroup>
            <col/>
            <col/>
            <col/>
            <col/>
            <col/>
            <col/>
            <col/>
            <col/>
            <col/>
            <col/>
            <col/>
            <col/>
          </colgroup>
          <thead valign="top">
            <tr>
              <th align="left" valign="bottom"> <hr/></th>
              <th colspan="5" align="center" valign="bottom">
                <bold>C. elegans</bold>
                <hr/>
              </th>
              <th align="left" valign="bottom"> <hr/></th>
              <th colspan="5" align="center" valign="bottom">
                <bold>D. melanogaster</bold>
                <hr/>
              </th>
            </tr>
            <tr>
              <th align="left" valign="bottom"> <hr/></th>
              <th align="center" valign="bottom">
                <bold>Read</bold>
                <hr/>
              </th>
              <th align="center" valign="bottom">
                <bold># mappings</bold>
                <hr/>
              </th>
              <th colspan="2" align="center" valign="bottom">
                <bold>Time (min:sec)</bold>
                <hr/>
              </th>
              <th align="center" valign="bottom">
                <bold>Peak</bold>
                <hr/>
              </th>
              <th align="left" valign="bottom"> <hr/></th>
              <th align="center" valign="bottom">
                <bold>Read</bold>
                <hr/>
              </th>
              <th align="center" valign="bottom">
                <bold># mappings</bold>
                <hr/>
              </th>
              <th colspan="2" align="center" valign="bottom">
                <bold>Time (min:sec)</bold>
                <hr/>
              </th>
              <th align="center" valign="bottom">
                <bold>Peak</bold>
                <hr/>
              </th>
            </tr>
            <tr>
              <th align="center">
                <bold>Mapper</bold>
              </th>
              <th align="center">
                <bold>mapped</bold>
              </th>
              <th align="center">
                <bold>(million)</bold>
              </th>
              <th align="right">
                <bold>1 thr</bold>
              </th>
              <th align="right">
                <bold>16 thrs</bold>
              </th>
              <th align="center">
                <bold>memory</bold>
              </th>
              <th align="left"> </th>
              <th align="center">
                <bold>mapped</bold>
              </th>
              <th align="center">
                <bold>(million)</bold>
              </th>
              <th align="right">
                <bold>1 thr</bold>
              </th>
              <th align="right">
                <bold>16 thrs</bold>
              </th>
              <th align="center">
                <bold>memory</bold>
              </th>
            </tr>
          </thead>
          <tbody valign="top">
            <tr>
              <td align="left" valign="bottom">Hobbes2<hr/></td>
              <td align="center" valign="bottom">91.003%<hr/></td>
              <td align="center" valign="bottom">5.71<hr/></td>
              <td align="right" valign="bottom">03:09<hr/></td>
              <td align="right" valign="bottom">00:41<hr/></td>
              <td align="center" valign="bottom">0.8 GB<hr/></td>
              <td align="center" valign="bottom"> <hr/></td>
              <td align="center" valign="bottom">95.470%<hr/></td>
              <td align="center" valign="bottom">438.33<hr/></td>
              <td align="right" valign="bottom">79:35<hr/></td>
              <td align="right" valign="bottom">28:46<hr/></td>
              <td align="right" valign="bottom">1.2 GB<hr/></td>
            </tr>
            <tr>
              <td align="left" valign="bottom">Hobbes<hr/></td>
              <td align="center" valign="bottom">90.994%<hr/></td>
              <td align="center" valign="bottom">5.84<hr/></td>
              <td align="right" valign="bottom">04:26<hr/></td>
              <td align="right" valign="bottom">01:06<hr/></td>
              <td align="center" valign="bottom">1.4 GB<hr/></td>
              <td align="center" valign="bottom"> <hr/></td>
              <td align="center" valign="bottom">95.436%<hr/></td>
              <td align="center" valign="bottom">453.43<hr/></td>
              <td align="right" valign="bottom">90:11<hr/></td>
              <td align="right" valign="bottom">57:01<hr/></td>
              <td align="right" valign="bottom">29.1 GB<hr/></td>
            </tr>
            <tr>
              <td align="left" valign="bottom">Masai<hr/></td>
              <td align="center" valign="bottom">91.002%<hr/></td>
              <td align="center" valign="bottom">5.68<hr/></td>
              <td align="right" valign="bottom">05:19<hr/></td>
              <td align="right" valign="bottom">−<hr/></td>
              <td align="center" valign="bottom">0.9 GB<hr/></td>
              <td align="center" valign="bottom"> <hr/></td>
              <td align="center" valign="bottom">95.466%<hr/></td>
              <td align="center" valign="bottom">446.98<hr/></td>
              <td align="right" valign="bottom">131:11<hr/></td>
              <td align="right" valign="bottom">−<hr/></td>
              <td align="right" valign="bottom">1.3 GB<hr/></td>
            </tr>
            <tr>
              <td align="left">RazerS3</td>
              <td align="center">91.002%</td>
              <td align="center">5.69</td>
              <td align="right">13:28</td>
              <td align="right">12:35</td>
              <td align="center">1.4 GB</td>
              <td align="center"> </td>
              <td align="center">−</td>
              <td align="center">−</td>
              <td align="right">−</td>
              <td align="right">−</td>
              <td align="right">96.5 GB</td>
            </tr>
          </tbody>
        </table>
      </table-wrap>
      <p>Again, Hobbes2 mapped more reads than other mappers for both data sets. For the C.
elegans data set, Hobbes2 with 16 threads was about twice as faster as Hobbes, 7
times faster than Masai and 18 times faster than RazerS3. For the D. melanogaster
data set, Hobbes2 also exhibited the best mapping speed in both single threaded and
multi-threaded cases. Hobbes2 used the least amount of memory in both data sets.</p>
      <p>The significant improvement of Hobbes2 is mainly due to our improved method of
generating initial candidates. It is very important to quickly generate a small
number of candidates in edit distance case since most of the mapping time is spent in
the verification process, which requires a more expensive dynamic programming
procedure. Table <xref ref-type="table" rid="T4">4</xref> shows the number of candidates initially
generated by the read mappers and the time for generating candidates. Hobbes2
generated the least number of candidates among the read mappers. Hobbes generated
candidates very fast with the help of bit vectors, but Hobbes2 and Masai generated
about four times fewer candidates than Hobbes. Hobbes2 produced candidates more than
two times faster than Masai while generating fewer candidates.</p>
      <table-wrap position="float" id="T4">
        <label>Table 4</label>
        <caption>
          <p>Filtration of 500k reads of length 100bp on HG18</p>
        </caption>
        <table frame="hsides" rules="groups" border="1">
          <colgroup>
            <col align="left"/>
            <col align="center"/>
            <col align="center"/>
          </colgroup>
          <thead valign="top">
            <tr>
              <th align="left">
                <bold>Mapper</bold>
              </th>
              <th align="center">
                <bold>Filtration time (min:sec)</bold>
              </th>
              <th align="center">
                <bold>Number of candidates</bold>
              </th>
            </tr>
          </thead>
          <tbody valign="top">
            <tr>
              <td align="left" valign="bottom">Hobbes2<hr/></td>
              <td align="center" valign="bottom">04:14<hr/></td>
              <td align="center" valign="bottom">1,161,828,591<hr/></td>
            </tr>
            <tr>
              <td align="left" valign="bottom">Hobbes<hr/></td>
              <td align="center" valign="bottom">01:45<hr/></td>
              <td align="center" valign="bottom">3,833,554,010<hr/></td>
            </tr>
            <tr>
              <td align="left" valign="bottom">Masai<hr/></td>
              <td align="center" valign="bottom">09:48<hr/></td>
              <td align="center" valign="bottom">1,190,600,997<hr/></td>
            </tr>
            <tr>
              <td align="left">RazerS3</td>
              <td align="center">15:01</td>
              <td align="center">7,007,527,711</td>
            </tr>
          </tbody>
        </table>
      </table-wrap>
    </sec>
    <sec>
      <title>Paired end alignment</title>
      <p>For paired end read alignment, we used the human genome HG18 as the reference
sequence. We ran experiments using 100bp read pairs from specimen HG00096.</p>
      <p>Our performance results for the paired end alignment are summarized in Table <xref ref-type="table" rid="T5">5</xref>. We excluded BWA in the experiment since it does not support the
minimum insert size. Bowtie2 in all mapping mode could not finish the mapping in 24
hours. We used Bowtie2 in the default mode, which is listed as Bowtie2* in Table
<xref ref-type="table" rid="T5">5</xref>. Since Masai does not directly support mapping paired end
reads, we separately ran <monospace>masai_mapper</monospace> for each read file to
output results in Masai’s raw format, and merged the results using
<monospace>masai_output_pe</monospace> to produce mappings in the SAM format.</p>
      <table-wrap position="float" id="T5">
        <label>Table 5</label>
        <caption>
          <p>Results of mapping 1 million × 2 paired end reads of length 100bp
against HG18</p>
        </caption>
        <table frame="hsides" rules="groups" border="1">
          <colgroup>
            <col align="left"/>
            <col align="center"/>
            <col align="center"/>
            <col align="center"/>
            <col align="center"/>
          </colgroup>
          <thead valign="top">
            <tr>
              <th align="left" valign="bottom"> <hr/></th>
              <th align="center" valign="bottom">
                <bold>Read</bold>
                <hr/>
              </th>
              <th colspan="2" align="center" valign="bottom">
                <bold>Mapping time (min:sec)</bold>
                <hr/>
              </th>
              <th align="right" valign="bottom">
                <bold>Peak</bold>
                <hr/>
              </th>
            </tr>
            <tr>
              <th align="left">
                <bold>Mapper</bold>
              </th>
              <th align="center">
                <bold>mapped</bold>
              </th>
              <th align="right">
                <bold>1 thr</bold>
              </th>
              <th align="right">
                <bold>16 thrs</bold>
              </th>
              <th align="right">
                <bold>memory</bold>
              </th>
            </tr>
          </thead>
          <tbody valign="top">
            <tr>
              <td align="left" valign="bottom">Hobbes2<hr/></td>
              <td align="center" valign="bottom">86.66%<hr/></td>
              <td align="right" valign="bottom">59:40<hr/></td>
              <td align="right" valign="bottom">11:12<hr/></td>
              <td align="right" valign="bottom">14.9 GB<hr/></td>
            </tr>
            <tr>
              <td align="left" valign="bottom">Hobbes<hr/></td>
              <td align="center" valign="bottom">86.52%<hr/></td>
              <td align="right" valign="bottom">61:54<hr/></td>
              <td align="right" valign="bottom">24:43<hr/></td>
              <td align="right" valign="bottom">20.4 GB<hr/></td>
            </tr>
            <tr>
              <td align="left" valign="bottom">Masai<hr/></td>
              <td align="center" valign="bottom">84.07%<hr/></td>
              <td align="right" valign="bottom">68:46<hr/></td>
              <td align="right" valign="bottom">−<hr/></td>
              <td align="right" valign="bottom">17.3 GB<hr/></td>
            </tr>
            <tr>
              <td align="left" valign="bottom">RazerS3<hr/></td>
              <td align="center" valign="bottom">86.68%<hr/></td>
              <td align="right" valign="bottom">420:07<hr/></td>
              <td align="right" valign="bottom">342:14<hr/></td>
              <td align="right" valign="bottom">17.5 GB<hr/></td>
            </tr>
            <tr>
              <td align="left">Bowtie2*</td>
              <td align="center">82.12%</td>
              <td align="right">8:40</td>
              <td align="right">0:52</td>
              <td align="right">3.6 GB</td>
            </tr>
          </tbody>
        </table>
      </table-wrap>
      <p>We observed that Hobbes2 was the fastest among all mappers in both single threaded
and multi-threaded cases. With 16 threads, Hobbes2 was about twice as faster as
Hobbes, and 31 times faster than RazerS3. In terms of mapped pairs, Hobbes2 was
similar to Hobbes and RazerS3, but was better than Masai. Hobbes used the least
amount of memory for the paired end mapping. Although Bowtie2* ran very fast, it lost
many mapping pairs, and thus exhibited poor mapping quality compared with other all
mappers.</p>
    </sec>
  </sec>
  <sec sec-type="conclusions">
    <title>Conclusion</title>
    <p>Hobbes2 efficiently finds all mapping locations of a read in a reference genome. We have
shown that Hobbes2 is substantially faster than state-of-the-art all mappers while
maintaining similar accuracy. In addition, Hobbes2 consumes less memory space than other
read mappers for long reads since it does not rely on additional data structures other
than inverted lists of <italic>q</italic>-gram signatures.</p>
    <p>Our experiments have also shown that Hobbes2 scales very well in multi-threaded
environment, and exhibits the best performance among the competitors. Given
today’s trend toward massively multi-core CPUs, read mappers with good
multi-thread support will likely become more necessary in the future.</p>
    <p>Because of its simplicity, we believe the candidate generation method implemented in
Hobbes2 can also be adapted for other read mapping programs for improving their
performance.</p>
  </sec>
  <sec>
    <title>Competing interests</title>
    <p>The authors declare that they have no competing interests.</p>
  </sec>
  <sec>
    <title>Authors’ contributions</title>
    <p>JK developed the filtering technique using additional prefix grams and CL applied the
technique to the read alignment problem. JK implemented the read mapping algorithm using
the technique and ran the experiments. XX designed experiments and analyzed the results.
JK wrote the manuscript, and CL and XX read and edited the manuscript. All authors read
and approved the final manuscript.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material content-type="local-data" id="S1">
      <caption>
        <title>Additional file 1</title>
        <p><bold>Supplementary material.</bold> This file contains supplementary text,
algorithm, figures, and tables.</p>
      </caption>
      <media xlink:href="1471-2105-15-42-S1.pdf">
        <caption>
          <p>Click here for file</p>
        </caption>
      </media>
    </supplementary-material>
  </sec>
</body>
<back>
  <sec>
    <title>Acknowledgements</title>
    <p>We thank Lingjie Weng for helpful discussions on implementation of Hobbes and
Hobbes2. We also thank Jacob Biesinger for testing Hobbes2 and providing valuable
feedback.</p>
    <p>This work was partially supported by Chonbuk National University [Research Funds in
2012 to JK]; the National Institutes of Health R01HG006870.</p>
  </sec>
  <ref-list>
    <ref id="B1">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Langmead</surname>
          <given-names>B</given-names>
        </name>
        <name>
          <surname>Trapnell</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Pop</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Salzberg</surname>
          <given-names>SL</given-names>
        </name>
        <article-title>
          <bold>Ultrafast and memory-efficient alignment of short dna sequences to the human
genome</bold>
        </article-title>
        <source>Genome Biol</source>
        <year>2009</year>
        <volume>10</volume>
        <fpage>25</fpage>
        <pub-id pub-id-type="doi">10.1186/gb-2009-10-3-r25</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B2">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Langmead</surname>
          <given-names>B</given-names>
        </name>
        <name>
          <surname>Salzberg</surname>
          <given-names>SL</given-names>
        </name>
        <article-title>
          <bold>Fast gapped-read alignment with bowtie 2</bold>
        </article-title>
        <source>Nat Methods</source>
        <year>2012</year>
        <volume>9</volume>
        <fpage>357</fpage>
        <lpage>359</lpage>
        <pub-id pub-id-type="doi">10.1038/nmeth.1923</pub-id>
        <?supplied-pmid 22388286?>
        <pub-id pub-id-type="pmid">22388286</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B3">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Li</surname>
          <given-names>H</given-names>
        </name>
        <name>
          <surname>Durbin</surname>
          <given-names>R</given-names>
        </name>
        <article-title>
          <bold>Fast and accurate short read alignment with burrows-wheeler transform</bold>
        </article-title>
        <source>Bioinformatics</source>
        <year>2009</year>
        <volume>25</volume>
        <fpage>1754</fpage>
        <lpage>1760</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btp324</pub-id>
        <?supplied-pmid 19451168?>
        <pub-id pub-id-type="pmid">19451168</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B4">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Newkirk</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Biesinger</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Chon</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Yokomori</surname>
          <given-names>K</given-names>
        </name>
        <name>
          <surname>Xie</surname>
          <given-names>X</given-names>
        </name>
        <article-title>
          <bold>Arem: aligning short reads from chip-sequencing by expectation maximization</bold>
        </article-title>
        <source>J Comput Biol</source>
        <year>2011</year>
        <volume>18</volume>
        <fpage>1495</fpage>
        <lpage>1505</lpage>
        <pub-id pub-id-type="doi">10.1089/cmb.2011.0185</pub-id>
        <?supplied-pmid 22035330?>
        <pub-id pub-id-type="pmid">22035330</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B5">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Roberts</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Pachter</surname>
          <given-names>L</given-names>
        </name>
        <article-title>
          <bold>Streaming fragment assignment for real-time analysis of sequencing
experiments</bold>
        </article-title>
        <source>Nat Methods</source>
        <year>2013</year>
        <volume>10</volume>
        <fpage>71</fpage>
        <lpage>73</lpage>
        <?supplied-pmid 23160280?>
        <pub-id pub-id-type="pmid">23160280</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B6">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Lil</surname>
          <given-names>Y</given-names>
        </name>
        <name>
          <surname>Xie</surname>
          <given-names>X</given-names>
        </name>
        <article-title>
          <bold>A mixture model for expression deconvolution from rna-seq in heterogeneous
tissues</bold>
        </article-title>
        <source>BMC Bioinformatics</source>
        <year>2013</year>
        <volume>14</volume>
        <issue>Suppl 5</issue>
        <fpage>S11</fpage>
      </mixed-citation>
    </ref>
    <ref id="B7">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Ahmadi</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Behm</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Honnalli</surname>
          <given-names>N</given-names>
        </name>
        <name>
          <surname>Li</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Xie</surname>
          <given-names>X</given-names>
        </name>
        <article-title>
          <bold>Hobbes: optimized gram-based methods for efficient read alignment</bold>
        </article-title>
        <source>Nucleic Acids Res</source>
        <year>2012</year>
        <volume>40</volume>
        <fpage>41</fpage>
        <pub-id pub-id-type="doi">10.1093/nar/gkr1246</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B8">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Weese</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Holtgrewe</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Reinert</surname>
          <given-names>K</given-names>
        </name>
        <article-title>
          <bold>Razers3: faster, fully sensitive read mapping</bold>
        </article-title>
        <source>Bioinformatics</source>
        <year>2012</year>
        <volume>28</volume>
        <fpage>2592</fpage>
        <lpage>2599</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/bts505</pub-id>
        <?supplied-pmid 22923295?>
        <pub-id pub-id-type="pmid">22923295</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B9">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Siragusa</surname>
          <given-names>E</given-names>
        </name>
        <name>
          <surname>Weese</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Reinert</surname>
          <given-names>K</given-names>
        </name>
        <article-title>
          <bold>Fast and accurate read mapping with approximate seeds and multiple
backtracking</bold>
        </article-title>
        <source>Nucleic Acids Res</source>
        <year>2013</year>
        <volume>41</volume>
        <fpage>78</fpage>
        <pub-id pub-id-type="doi">10.1093/nar/gkt005</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B10">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Ukkonen</surname>
          <given-names>E</given-names>
        </name>
        <article-title>
          <bold>Approximae string matching with q-grams and maximal matching</bold>
        </article-title>
        <source>Theor Comput Sci</source>
        <year>1992</year>
        <volume>1</volume>
        <fpage>191</fpage>
        <lpage>211</lpage>
      </mixed-citation>
    </ref>
    <ref id="B11">
      <mixed-citation publication-type="book">
        <name>
          <surname>Chaudhuri</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Ganti</surname>
          <given-names>V</given-names>
        </name>
        <name>
          <surname>Kaushik</surname>
          <given-names>R</given-names>
        </name>
        <person-group person-group-type="editor">Liu L, Reuter A, Whang KY, Zhang J</person-group>
        <article-title>
          <bold>A primitive operator for similarity joins in data cleaning</bold>
        </article-title>
        <source>Proceedings of the 22nd International Conference on Data Engineering: 3-7 April
2006</source>
        <year>2006</year>
        <publisher-name>Atlanta: IEEE</publisher-name>
        <fpage>5</fpage>
        <lpage>15</lpage>
      </mixed-citation>
    </ref>
    <ref id="B12">
      <mixed-citation publication-type="book">
        <name>
          <surname>Xiao</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Wang</surname>
          <given-names>W</given-names>
        </name>
        <name>
          <surname>Lin</surname>
          <given-names>X</given-names>
        </name>
        <person-group person-group-type="editor">Buneman P, Kersten M, Ozsoyuglu Z</person-group>
        <article-title>
          <bold>Ed-join: an efficient algorithm for similarity joins with edit distance
constraints</bold>
        </article-title>
        <source>Proceedings of the 34th International Conference on Very Large Databases: 23-28
August 2008</source>
        <year>2008</year>
        <publisher-name>Aukland: VLDB Endowment</publisher-name>
        <fpage>933</fpage>
        <lpage>944</lpage>
      </mixed-citation>
    </ref>
    <ref id="B13">
      <mixed-citation publication-type="book">
        <name>
          <surname>Qin</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Wang</surname>
          <given-names>W</given-names>
        </name>
        <name>
          <surname>Lu</surname>
          <given-names>Y</given-names>
        </name>
        <name>
          <surname>Xiao</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Lin</surname>
          <given-names>X</given-names>
        </name>
        <person-group person-group-type="editor">Kementsietsidis A, Velegrakis Y</person-group>
        <article-title>
          <bold>Efficient exact edit similarity query processing with the asymmetric signature
scheme</bold>
        </article-title>
        <source>Proceedings of ACM SIGMOD International Conference on Management of Data: 12-16
June 2011</source>
        <year>2011</year>
        <publisher-name>Athens: ACM</publisher-name>
        <fpage>1033</fpage>
        <lpage>1044</lpage>
      </mixed-citation>
    </ref>
    <ref id="B14">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Ning</surname>
          <given-names>Z</given-names>
        </name>
        <name>
          <surname>Cox</surname>
          <given-names>AJ</given-names>
        </name>
        <name>
          <surname>Mullikin</surname>
          <given-names>JC</given-names>
        </name>
        <article-title>
          <bold>Ssaha: a fast search method for large dna databases</bold>
        </article-title>
        <source>Genome Res</source>
        <year>2001</year>
        <volume>11</volume>
        <fpage>1725</fpage>
        <lpage>1729</lpage>
        <pub-id pub-id-type="doi">10.1101/gr.194201</pub-id>
        <?supplied-pmid 11591649?>
        <pub-id pub-id-type="pmid">11591649</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B15">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Marco-Sola</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Sammeth</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Guigó</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Ribeca</surname>
          <given-names>P</given-names>
        </name>
        <article-title>
          <bold>The gem mapper: fast, accurate and versatile alignment by filtration</bold>
        </article-title>
        <source>Nat Methods</source>
        <year>2012</year>
        <volume>9</volume>
        <fpage>1185</fpage>
        <lpage>1188</lpage>
        <pub-id pub-id-type="doi">10.1038/nmeth.2221</pub-id>
        <?supplied-pmid 23103880?>
        <pub-id pub-id-type="pmid">23103880</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B16">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Li</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Yu</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Li</surname>
          <given-names>Y</given-names>
        </name>
        <name>
          <surname>Lam</surname>
          <given-names>T-W</given-names>
        </name>
        <name>
          <surname>S-M Yiu</surname>
          <given-names>KK</given-names>
        </name>
        <name>
          <surname>Wang</surname>
          <given-names>J</given-names>
        </name>
        <article-title>
          <bold>Soap2: an improved ultrafast tool for short read alignment</bold>
        </article-title>
        <source>Bioinformatics</source>
        <year>2009</year>
        <volume>25</volume>
        <fpage>1966</fpage>
        <lpage>1967</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btp336</pub-id>
        <?supplied-pmid 19497933?>
        <pub-id pub-id-type="pmid">19497933</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B17">
      <mixed-citation publication-type="journal">
        <name>
          <surname>David</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Dzamba</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Lister</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Ilie</surname>
          <given-names>L</given-names>
        </name>
        <name>
          <surname>Brudno</surname>
          <given-names>M</given-names>
        </name>
        <article-title>
          <bold>Shrimp2: sensitive yet practical short read mapping</bold>
        </article-title>
        <source>Bioinformatics</source>
        <year>2011</year>
        <volume>27</volume>
        <fpage>1011</fpage>
        <lpage>1012</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btr046</pub-id>
        <?supplied-pmid 21278192?>
        <pub-id pub-id-type="pmid">21278192</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B18">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Hach</surname>
          <given-names>F</given-names>
        </name>
        <name>
          <surname>Hormozdiari</surname>
          <given-names>F</given-names>
        </name>
        <name>
          <surname>Alkan</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Hormozdiari</surname>
          <given-names>F</given-names>
        </name>
        <name>
          <surname>Birol</surname>
          <given-names>I</given-names>
        </name>
        <name>
          <surname>Eichler</surname>
          <given-names>EE</given-names>
        </name>
        <name>
          <surname>Sahinalp</surname>
          <given-names>SC</given-names>
        </name>
        <article-title>
          <bold>mrsFAST: a cache-oblivious algorithm for short-read mapping</bold>
        </article-title>
        <source>Nat Methods</source>
        <year>2010</year>
        <volume>7</volume>
        <fpage>576</fpage>
        <lpage>577</lpage>
        <pub-id pub-id-type="doi">10.1038/nmeth0810-576</pub-id>
        <?supplied-pmid 20676076?>
        <pub-id pub-id-type="pmid">20676076</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B19">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Alkan</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Kidd</surname>
          <given-names>JM</given-names>
        </name>
        <name>
          <surname>Marques-Bonet</surname>
          <given-names>T</given-names>
        </name>
        <name>
          <surname>Aksay</surname>
          <given-names>G</given-names>
        </name>
        <name>
          <surname>Antonacci</surname>
          <given-names>F</given-names>
        </name>
        <name>
          <surname>Hormozdiari</surname>
          <given-names>F</given-names>
        </name>
        <name>
          <surname>Kitzman</surname>
          <given-names>JO</given-names>
        </name>
        <name>
          <surname>Baker</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Malig</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Mutlu</surname>
          <given-names>O</given-names>
        </name>
        <etal/>
        <article-title>
          <bold>Personalized copy-number and segmental duplication maps using next-generation
sequencing</bold>
        </article-title>
        <source>Nat Genet</source>
        <year>2009</year>
        <volume>41</volume>
        <fpage>1061</fpage>
        <lpage>1067</lpage>
        <pub-id pub-id-type="doi">10.1038/ng.437</pub-id>
        <?supplied-pmid 19718026?>
        <pub-id pub-id-type="pmid">19718026</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B20">
      <mixed-citation publication-type="book">
        <name>
          <surname>Holtgrewe</surname>
          <given-names>M</given-names>
        </name>
        <source>Mason - a Read Simulator for Second Generation Sequencing Data. Technical
report,</source>
        <year>2010</year>
        <publisher-name>Berlin: Freie Universität</publisher-name>
      </mixed-citation>
    </ref>
    <ref id="B21">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Holtgrewe</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Emde</surname>
          <given-names>A-K</given-names>
        </name>
        <name>
          <surname>Weese</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Reinert</surname>
          <given-names>K</given-names>
        </name>
        <article-title>
          <bold>A novel and well-defined benchmarking method for second generation read
mapping</bold>
        </article-title>
        <source>BMC Bioinformatics</source>
        <year>2011</year>
        <volume>12</volume>
        <fpage>210</fpage>
        <pub-id pub-id-type="doi">10.1186/1471-2105-12-210</pub-id>
        <?supplied-pmid 21615913?>
        <pub-id pub-id-type="pmid">21615913</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B22">
      <mixed-citation publication-type="other">
        <article-title>
          <bold>1000 Genomes: a deep catalog of human genetic variation</bold>
        </article-title>
        <comment>[<ext-link ext-link-type="uri" xlink:href="http://www.1000genomes.org/data">http://www.1000genomes.org/data</ext-link>]</comment>
      </mixed-citation>
    </ref>
    <ref id="B23">
      <mixed-citation publication-type="other">
        <article-title>
          <bold>DNA data bank of Japan</bold>
        </article-title>
        <comment>[<ext-link ext-link-type="ftp" xlink:href="ftp://ftp.ddbj.nig.ac.jp">ftp://ftp.ddbj.nig.ac.jp</ext-link>]</comment>
      </mixed-citation>
    </ref>
  </ref-list>
</back>
