<?DTDIdentifier.IdentifierValue article.dtd?>
<?DTDIdentifier.IdentifierType system?>
<?SourceDTD.DTDName article.dtd?>
<?SourceDTD.Version 1.0?>
<?ConverterInfo.XSLTName bmc2nlmx2.xsl?>
<?ConverterInfo.Version 2?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">BMC Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">BMC Bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>BMC Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="epub">1471-2105</issn>
    <publisher>
      <publisher-name>BioMed Central</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">4423727</article-id>
    <article-id pub-id-type="publisher-id">1471-2105-16-S7-S5</article-id>
    <article-id pub-id-type="doi">10.1186/1471-2105-16-S7-S5</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Research</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Heterozygous genome assembly via binary classification of homologous sequence</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" corresp="yes" id="A1">
        <name>
          <surname>Bodily</surname>
          <given-names>Paul M</given-names>
        </name>
        <xref ref-type="aff" rid="I1">1</xref>
        <email>paulmbodily@gmail.com</email>
      </contrib>
      <contrib contrib-type="author" id="A2">
        <name>
          <surname>Fujimoto</surname>
          <given-names>M Stanley</given-names>
        </name>
        <xref ref-type="aff" rid="I1">1</xref>
      </contrib>
      <contrib contrib-type="author" id="A3">
        <name>
          <surname>Ortega</surname>
          <given-names>Cameron</given-names>
        </name>
        <xref ref-type="aff" rid="I1">1</xref>
      </contrib>
      <contrib contrib-type="author" id="A4">
        <name>
          <surname>Okuda</surname>
          <given-names>Nozomu</given-names>
        </name>
        <xref ref-type="aff" rid="I1">1</xref>
      </contrib>
      <contrib contrib-type="author" id="A5">
        <name>
          <surname>Price</surname>
          <given-names>Jared C</given-names>
        </name>
        <xref ref-type="aff" rid="I1">1</xref>
      </contrib>
      <contrib contrib-type="author" id="A6">
        <name>
          <surname>Clement</surname>
          <given-names>Mark J</given-names>
        </name>
        <xref ref-type="aff" rid="I1">1</xref>
      </contrib>
      <contrib contrib-type="author" id="A7">
        <name>
          <surname>Snell</surname>
          <given-names>Quinn</given-names>
        </name>
        <xref ref-type="aff" rid="I1">1</xref>
      </contrib>
    </contrib-group>
    <aff id="I1"><label>1</label>Computer Science Department, Brigham Young University, 3361 TMCB PO Box 26576, Provo, UT, 84602-6576, USA</aff>
    <pub-date pub-type="collection">
      <year>2015</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>23</day>
      <month>4</month>
      <year>2015</year>
    </pub-date>
    <volume>16</volume>
    <issue>Suppl 7</issue>
    <supplement>
      <named-content content-type="supplement-title">Selected articles from The 11th Annual Biotechnology and Bioinformatics Symposium (BIOT-2014): Bioinformatics</named-content>
      <named-content content-type="supplement-editor">Perry Ridge, Mark Clement and Quinn Snell</named-content>
      <named-content content-type="supplement-sponsor">Publication of this supplement has not been supported by sponsorship. Information about the sources of funding for publication charges can be found in the individual articles. Articles have undergone the journal's standard peer review process for supplements. The Supplement Editors declare that they have no competing interests.</named-content>
    </supplement>
    <fpage>S5</fpage>
    <lpage>S5</lpage>
    <permissions>
      <copyright-statement>Copyright © 2015 Bodily et al.; licensee BioMed Central Ltd.</copyright-statement>
      <copyright-year>2015</copyright-year>
      <copyright-holder>Bodily et al.; licensee BioMed Central Ltd.</copyright-holder>
      <license license-type="open-access" xlink:href="http://creativecommons.org/licenses/by/4.0">
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0">http://creativecommons.org/licenses/by/4.0</ext-link>), which permits unrestricted use, distribution, and reproduction in any medium, provided the original work is properly cited. The Creative Commons Public Domain Dedication waiver (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/publicdomain/zero/1.0/">http://creativecommons.org/publicdomain/zero/1.0/</ext-link>) applies to the data made available in this article, unless otherwise stated.</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="http://www.biomedcentral.com/1471-2105/16/S7/S5"/>
    <abstract>
      <sec>
        <title>Background</title>
        <p>Genome assemblers to date have predominantly targeted haploid reference reconstruction from homozygous data. When applied to diploid genome assembly, these assemblers perform poorly, owing to the violation of assumptions during both the contigging and scaffolding phases. Effective tools to overcome these problems are in growing demand. Increasing parameter stringency during contigging is an effective solution to obtaining haplotype-specific contigs; however, effective algorithms for scaffolding such contigs are lacking.</p>
      </sec>
      <sec>
        <title>Methods</title>
        <p>We present a stand-alone scaffolding algorithm, ScaffoldScaffolder, designed specifically for scaffolding diploid genomes. The algorithm identifies homologous sequences as found in "bubble" structures in scaffold graphs. Machine learning classification is used to then classify sequences in partial bubbles as homologous or non-homologous sequences prior to reconstructing haplotype-specific scaffolds. We define four new metrics for assessing diploid scaffolding accuracy: contig sequencing depth, contig homogeneity, phase group homogeneity, and heterogeneity between phase groups.</p>
      </sec>
      <sec>
        <title>Results</title>
        <p>We demonstrate the viability of using bubbles to identify heterozygous homologous contigs, which we term homolotigs. We show that machine learning classification trained on these homolotig pairs can be used effectively for identifying homologous sequences elsewhere in the data with high precision (assuming error-free reads).</p>
      </sec>
      <sec>
        <title>Conclusion</title>
        <p>More work is required to comparatively analyze this approach on real data with various parameters and classifiers against other diploid genome assembly methods. However, the initial results of ScaffoldScaffolder supply validity to the idea of employing machine learning in the difficult task of diploid genome assembly. Software is available at <ext-link ext-link-type="uri" xlink:href="http://bioresearch.byu.edu/scaffoldscaffolder">http://bioresearch.byu.edu/scaffoldscaffolder</ext-link>.</p>
      </sec>
    </abstract>
    <kwd-group>
      <kwd>diploid genome assembly</kwd>
      <kwd>machine learning</kwd>
      <kwd>scaffolding</kwd>
    </kwd-group>
    <conference>
      <conf-date>11-12 December 2014</conf-date>
      <conf-name>The 11th Annual Biotechnology and Bioinformatics Symposium (BIOT-2014)</conf-name>
      <conf-loc>Provo, UT USA</conf-loc>
    </conference>
  </article-meta>
</front>
<body>
  <sec>
    <title>Background</title>
    <p>Efficient and accurate genome assemblies facilitate effective data-driven solutions in fields such as personalized medicine, genetic engineering, and even next-generation digital information storage [<xref ref-type="bibr" rid="B1">1</xref>]. A genome contains all of the genetic information needed for an organism to live and represents a trove of data for seeking to understand the complex mechanisms governing all life. Proper analysis of these data presupposes a correctness of the reconstructed genomic sequence, which continues to motivate the need for assembly algorithms which produce assemblies from next-generation sequence data with greater completeness and correctness.</p>
    <p>Genome assemblers have traditionally been designed to assemble haploid genomes [<xref ref-type="bibr" rid="B2">2</xref>-<xref ref-type="bibr" rid="B4">4</xref>]. This was motivated in the first place by the vast array of monoploid bacterial genomes being sequenced and then later on by the ease with which the two haplotypes of many diploid species could be made homogenous or <italic>homozygous </italic>enough (via inbreeding) to nearly approximate a monoploid specimen. Thus initial <italic>de novo </italic>assembly algorithms were designed to essentially ignore any variation that may have existed between haplotypes.</p>
    <p>Several attempts have been made to assemble highly-polymorphic genomes [<xref ref-type="bibr" rid="B5">5</xref>-<xref ref-type="bibr" rid="B9">9</xref>]. Obtaining a homozygous diploid specimen can in some cases make the specimen inviable, not to mention the time, resources, and ethical concerns that are also often inherent in the inbreeding process. In all of these cases, traditional assembly techniques are poorly equipped to handle the challenges posed by heterozygosity [<xref ref-type="bibr" rid="B10">10</xref>]. Of increasing importance are the questions targeting minute genetic variations that are ultimately responsible for a phenotype or disease in populations as well as individuals. These emphases issue a renewed challenge to develop algorithms to produce high-resolution diploid genomes, including <italic>phased </italic>haplotypic variation (<italic>phasing </italic>is the process of ensuring that variants on the same haplotype are assembled together).</p>
    <p>There exist three primary classes of approaches to this problem. The first approach is to solve <italic>haplotype phasing problem</italic>, which takes (unphased) haplotype data (e.g., SNP chip data) and generates phased haplotypes using parsimony or maximum-likelihood estimation methods [<xref ref-type="bibr" rid="B11">11</xref>-<xref ref-type="bibr" rid="B13">13</xref>]. In doing so, population data may be used to estimate haplotype frequencies, as well as to impute ungenotyped loci [<xref ref-type="bibr" rid="B14">14</xref>].</p>
    <p>A second common approach is to address the challenge in terms of the <italic>haplotype assembly problem </italic>[<xref ref-type="bibr" rid="B15">15</xref>] or simply the <italic>individual haplotyping problem </italic>[<xref ref-type="bibr" rid="B16">16</xref>], which takes reads as input in order to first call variants and then phase them. Variants are generally called through <italic>mapping </italic>or aligning reads (based on sequence similarity) to a previously assembled reference sequence for the individual's species [<xref ref-type="bibr" rid="B17">17</xref>-<xref ref-type="bibr" rid="B20">20</xref>]. Most methods generally do not involve assembly (see [<xref ref-type="bibr" rid="B21">21</xref>] for an exception), but rather determine small-scale variation based on loci where the aligned reads suggest a different nucleotide than that present in the reference [<xref ref-type="bibr" rid="B22">22</xref>,<xref ref-type="bibr" rid="B23">23</xref>]. The primary advantage of the haplotype assembly approach is its use of a reference to ensure access to all regions of a complete, highly manicured reference. However, results from even just the mapping phase vary widely both by algorithm and based on parameter settings [<xref ref-type="bibr" rid="B24">24</xref>]. Mappability is also affected by sequencing errors and heterozygosity [<xref ref-type="bibr" rid="B25">25</xref>]. Mapping to a reference also fails to capture large-scale rearrangements.</p>
    <p>Because of the problems inherent in mapping and in using a reference, the problem of true <italic>de novo </italic>diploid genome assembly, meaning the complete assembly of two haplotypes from sequenced reads without the use of a reference, has begun recently to see increased emphasis (e.g., see Discovar [<xref ref-type="bibr" rid="B26">26</xref>] and Hapsembler [<xref ref-type="bibr" rid="B27">27</xref>]). We present ScaffoldScaffolder, a diploid genome assembly approach which includes a newly developed scaffolding module to resolve haplotype-specific scaffolds.</p>
    <sec>
      <title>Genome assembly background</title>
      <p>All DNA sequencing technologies to date have imposed constraints on the length of fragments that can be sequenced. This then requires the genome to be broken into small pieces and then algorithmically reassembled again from the sequenced fragments. There are two broad families of assembly or <italic>contigging </italic>algorithms: those which employ an Overlap Layout Consensus (OLC) and those which employ a de Bruijn Graph [<xref ref-type="bibr" rid="B4">4</xref>]. OLC algorithms, such as Newbler (454 Life Sciences), attempt to reconstruct larger sequences (termed <italic>contigs</italic>) by maximally overlapping reads. This approach generally produces more complete, accurate assemblies, but is <italic>O</italic>(<italic>n</italic><sup>2</sup>), meaning the runtime increases exponentially with the size of the input data. De Bruijn Graph assemblers, such as SOAPdenovo [<xref ref-type="bibr" rid="B28">28</xref>], are <italic>O</italic>(<italic>n</italic>), meaning their run-time increases linearly with the size of the input data, however, the results are often more fragmented than OLC assemblers. This speed-accuracy tradeoff is a non-trivial decision in each <italic>de novo </italic>assembly.</p>
      <p>OLC assemblers have historically been favored as well for their flexibility with handling errors or <italic>heterozygosity </italic>(i.e., variation between haplotypes). Whereas de Bruijn Graph assemblers must sacrifice a great deal in efficiency in order to consider mismatches or insertion/deletions (indels) in an overlapped read, OLC assemblers can be parameterized to efficiently align mismatched regions. Errors and heterozygosity can thus be easily ignored by simply accepting the most <italic>common </italic>nucleotide at a given locus from those present in the pileup (hence <italic>consensus</italic>).</p>
      <p>Neither assembly approach is natively designed to be able to resolve repetitive sequence or to overcome deficiencies in data sampling. Thus, regardless of the method used, the contigging algorithm produces a set of contigs that is considerably larger than the haploid number that would be ideally recovered. To reduce the set of sequences further, contigs can be positioned and oriented relative to one another using long "anchoring" fragments. These <italic>paired-read </italic>fragments, whose length is approximately known, are too long to be sequenced end to end, but short snippets can be sequenced from either end. Inasmuch as these end sequences find matches in the contig set, the paired-read fragment can "anchor" two contigs at an approximate distance and in a specific relative orientation (see Figure <xref ref-type="fig" rid="F1">1</xref>). This process is termed <italic>scaffolding </italic>or <italic>meta-contigging</italic>.</p>
      <fig id="F1" position="float">
        <label>Figure 1</label>
        <caption>
          <p><bold>Paired Read</bold>. Shown is a 400-bp insert whose ends have been sequenced. When aligned to the contig set, the sequenced ends aligned at specific locations in Contigs <italic>A </italic>and <italic>B</italic>, allowing inference about the relative orientation of and distance between the two contigs.</p>
        </caption>
        <graphic xlink:href="1471-2105-16-S7-S5-1"/>
      </fig>
      <p>The set of contigs and their scaffoldings can be modeled as a graph from which must be elucidated the subset of non-conflicting, highly-supported scaffoldings that represent the correct genomic reconstruction. The graph is made complex by an array of confounding effects including: inaccurate contig assembly; erroneous scaffolding evidence deriving from error-prone read sequencing; the collapsing of highly-repetitive DNA elements into single contigs; possible sample contamination; insufficient data sampling; and insufficient paired read evidence.</p>
    </sec>
  </sec>
  <sec sec-type="methods">
    <title>Methods</title>
    <p>Our method involves two steps: 1. assembling reads so as to preserve haplotype-specificity in the assembled contig set and 2. scaffold contigs into linear haploid scaffolds using a modified scaffolding algorithm.</p>
    <sec>
      <title>Assembly</title>
      <p>In cases where the haplotypic variation is significant, heterozygosity can be preserved by requiring very stringent overlaps in the OLC process. As overlap stringency parameters are often relaxed in order to merge haplotypes, requiring near perfect overlaps will disallow the merging of haplotypes in favor of more accurate, complete diploid contig assembly. This is essentially equivalent to assuming that haplotypes represent different--though similar--molecules (which they do), and should therefore assemble separately. In theory this optimization lends itself nicely to using de Bruijn graph assemblers which perform optimally when perfect overlaps are assumed.</p>
      <p>Imposing more strict overlap requirements during assembly produces a contig set which contains a more biologically accurate representation of the genome: a set of contigs which represent sequence that is homozygous between haplotypes (<italic>homotigs</italic>) and a set of contigs which represent sequence unique to one haplotype in regions where the genome is heterozygous (<italic>heterotigs</italic>). Some of the homotigs may represent repetitive sequence. Nonetheless, by ensuring coverage that is sufficiently high, we may assume that by this approach, every sequence in the genome (whether it belongs to a homozygous or heterozygous region) is assembled in tact in our set of contigs.</p>
    </sec>
    <sec>
      <title>Scaffolding</title>
      <p>We need to state a few more assumptions about the dataset at this point. First, to simplify the problem, we will assume that there are no large-scale rearrangements between haplotypes. Although such rearrangements happen and several can be algorithmically identified [<xref ref-type="bibr" rid="B29">29</xref>], our proposed solution assumes that variation between haplotypes is small-scale. Essentially this allows us to assume that heterozygous sequence that is sequentially similar will be reconstructed in the same orientation at the same position on opposite haplotypes.</p>
      <p>This leads to our second assumption, which is that for each heterotig <italic>a </italic>in the contig set (deriving from haplotype <italic>A</italic>), there exists exactly one homologous heterotig <italic>b</italic>, representing the reconstructed sequence on haplotype <italic>B </italic>opposite <italic>a</italic>. We will say that two such heterotigs <italic>a </italic>and <italic>b </italic>represent a <italic>homolotig pair</italic>.</p>
      <p>Third, we will assume that each homolotig pair exists in the larger context of a heterozygous "bubble" [<xref ref-type="bibr" rid="B30">30</xref>,<xref ref-type="bibr" rid="B31">31</xref>], meaning that both heterotigs in the pair are flanked by a common homotig on their 5' end and by a different common homotig on their 3' end (see Figure <xref ref-type="fig" rid="F2">2</xref>). This assumption is based on the general practice of assembly algorithms to discontinue contig elongation when the read pileup is suggestive of two possible reconstructive paths, as would happen at the junction between homozygous and heterozygous sequence. We assume that as long as contiguous sequence is homologous it will be constructed into a single homotig. Where there is heterozygosity, there will be a bifurcation into two homologous heterotigs. Where there is no longer variation between haplotypes, the reconstruction of the two haplotypes will re-merge as a single homotig, thus completing the bubble.</p>
      <fig id="F2" position="float">
        <label>Figure 2</label>
        <caption>
          <p><bold>A Heterozygous Bubble</bold>. <italic>Homotigs </italic>are formed from homozygous sequence, where read pileups from both haplotypes have the same consensus sequence. <italic>Heterotigs </italic>are formed from heterozygous sequences, where read pileups from each haplotype have a unique consensus due to variation. Inasmuch as two heterotigs are homologous, we say that they form a <italic>homolotig pair</italic>.</p>
        </caption>
        <graphic xlink:href="1471-2105-16-S7-S5-2"/>
      </fig>
      <p>The diploid heterozygous genome assembly problem thus takes on the form of elucidating from the noisy, bidirected scaffold graph an interleaving pattern of single homotigs and homolotig pairs. It should be noted that contigs representing repetitive DNA elements pose a particularly difficult challenge and where such contigs are identified (both by contributive read coverage and by abnormally high total vertex degree in the scaffold graph), we do not attempt to include them in the reconstructed genome.</p>
    </sec>
    <sec>
      <title>ScaffoldScaffolder</title>
      <p>ScaffoldScaffolder was originally developed as a greedy, stand-alone scaffolding algorithm [<xref ref-type="bibr" rid="B32">32</xref>]. In expanding its functionality, we have introduced a module capable of scaffolding diploid heterozygous genomes which have been assembled according to the above-mentioned criteria. The algorithm (implemented in Java) consists of 6 principal steps (see Figure <xref ref-type="fig" rid="F3">3</xref>):</p>
      <fig id="F3" position="float">
        <label>Figure 3</label>
        <caption>
          <p><bold>ScaffoldScaffolder Overview</bold>.</p>
        </caption>
        <graphic xlink:href="1471-2105-16-S7-S5-3"/>
      </fig>
      <p>1. <italic>Input</italic>. The algorithm takes as input a contig set in FASTA format and a set of paired read files in FASTA, FASTQ, or several other formats. Alternatively, ScaffoldScaffolder can operate given a FASTA contig file and a set of alignment output files in SAM, Bowtie, or BLAST output formats. If this is the case, the algorithm will skip the Read Alignment step.</p>
      <p>2. <italic>Read alignment</italic>. Paired reads are aligned to the contig set using any read alignment algorithm which outputs in one of the following formats: SAM, Bowtie, or Blast (default aligner is Bowtie).</p>
      <p>3. <italic>Scaffold graph construction</italic>. A scaffold graph, as described in the Background section is created and edges are created and weighted from evidence in the paired read alignment output.</p>
      <p>4. <italic>Binary classification of homologs</italic>. A binary classifier is trained to identify homolotig pairs as found in "perfect" or easily recognizable bubbles. This classifier is then used to identify additional homolotig pairs in "imperfect" bubbles.</p>
      <p>5. <italic>Bubble chain elucidation</italic>. Remaining scaffoldings are considered greedily for linking bubbles together into chains. Paired reads from larger insert libraries are used to phase haplotypes and further conjoin scaffolds.</p>
      <p>6. <italic>Linear haploid scaffold formation</italic>. The algorithm outputs two FASTA files, each containing one of two linear, phased haplotypes from each scaffold. Several other metadata files are optionally printed to provide information used in the scaffolding process.</p>
      <p>We will consider each of these steps in more detail.</p>
      <sec>
        <title>Input</title>
        <p>The minimum input required to run ScaffoldScaffolder is a FASTA file containing stringently assembled contigs and a "reads info file," which is a file formatted identical to the SOAPdenovo configuration file and contains information for each paired read library including the file locations, the average insert size, and an order in which the library is to be used for scaffolding. The paired read files themselves can be in nearly any format because for the read alignment step, ScaffoldScaffolder uses a user-configured third-party read aligner to align the reads. All that matters is that following the read alignment step, ScaffoldScaffolder will look for output alignment files in one of three formats: SAM, Bowtie or Blast. Alternatively, the user can indicate the alignment files already exist and ScaffoldScaffolder will not attempt to reperform the alignment.</p>
      </sec>
      <sec>
        <title>Read alignment</title>
        <p>When aligning the paired reads to the contigs, ScaffoldScaffolder allows the user to specify which alignment algorithm should be used and with which parameters. A "mapper default" configuration file is provided which can be easily edited to create several custom alignment configurations for one or more alignment algorithms. Each configuration is given a user-specified identifier that can then be easily selected at runtime. The default configuration file includes configurations for Bowtie, Bowtie2, GSnap, and BLASTn (one of which must be separately installed prior to use by ScaffoldScaffolder), however any preferred mapper can be configured, provided that it outputs in one of the accepted formats. A flag allows the user to instruct ScaffoldScaffolder to use "existent mappings," which not only allows the scaffolder to run on alignment files, but has the added benefit of allowing users to run ScaffoldScaffolder repeatedly with different parameterizations without ever having to rerun the read alignment step. ScaffoldScaffolder is not enabled to run on multiple processors. However, a 'procs' parameter can be set to allow third-party algorithms that are so enabled to run on the input number of threads.</p>
      </sec>
      <sec>
        <title>Scaffold graph construction</title>
        <p>On conclusion of the read alignment phase, ScaffoldScaffolder initializes an empty graph containing a vertex for each contig. Then for each paired read for which both ends had a reported alignment, a new weighted edge is created or if the corresponding edge already exists, its weight is incremented (each edge is bidirected in that it defines an orientation for both contigs). The final scaffolding distance is the computed average of the distances suggested by the alignment of each supporting paired read. ScaffoldScaffolder allows for ends to be multiply mapped, but it is suggested that multiply-mapped reads be suppressed by the alignment algorithm in order to more effectively manage memory. In creating the scaffold graph, an optional flag allows the user to instruct ScaffoldScaffolder to output a metafile containing the status of how each paired read was used in the scaffold graph. Each paired read status includes information about if and where each end mapped, whether the pair was used to link two contigs, and whether both ends mapped within a contig (and if so, the distance between the ends). This file is formatted similar to the PairStatus file of the 454 Newbler assembler.</p>
      </sec>
      <sec>
        <title>Binary classification of homologs</title>
        <p>Once the graph is constructed, ScaffoldScaffolder seeks to algorithmically select a subset of contig scaffoldings according to one of two algorithms. The first is a simple greedy algorithm which includes edges in the final subset provided they do not conflict with previously included edges. This algorithm proceeds iteratively in that only a single rank of libraries is considered at each iteration of the greedy algorithm. It is also important to note that at each iteration, a contig may be scaffolded only once in the 5' direction and once in the 3' direction. Thus, a conflicting edge from a contig is any edge that would scaffold that contig in a direction in which it has already been scaffolded. For this reason, ScaffoldScaffolder works optimally when at least one of the libraries has small insert size (500 bp or smaller) in order to resolve more local contig scaffoldings prior to attempting larger-scale scaffoldings. The greedy algorithm makes no attempt to reconcile homologous sequence, but rather greedily chooses reconstructions where multiple possibilities exist. For this reason, the greedy algorithm is not designed to be used on heterozygous diploid datasets.</p>
        <p>ScaffoldScaffolder is equipped with a second scaffold graph reduction algorithm, called the "bubble finder solution" (BFS), which is designed specifically to scaffold diploid contig sets. The BFS begins by algorithmically searching the scaffold graph for bubbles. In the context of the scaffold graph, we will differentiate between a "perfect" and an "imperfect" bubble. A perfect bubble is defined as two contigs <italic>a </italic>and <italic>b </italic>(presumably a homolotig pair), each of which have a single candidate scaffolding (i.e. no conflicting edges) to a common contig in both the 5' and 3' directions (see Figure <xref ref-type="fig" rid="F3">3</xref>). That is, contig <italic>a </italic>has a single scaffolding (<italic>a, c</italic><sub>1</sub>) in the 5' direction of <italic>a </italic>and a single scaffolding (<italic>a, c</italic><sub>2</sub>) in the 3' direction; contig <italic>b </italic>has a single scaffolding (<italic>b, c</italic><sub>1</sub>) in either the 5' or 3' direction of <italic>b </italic>and a single scaffolding (<italic>b, c</italic><sub>2</sub>) in the opposite direction. Contigs <italic>c</italic><sub>1 </sub>and <italic>c</italic><sub>2 </sub>(presumably homotigs) must have identical orientations in each of the scaffoldings in which they appear and are additionally required by our definition of a perfect bubble to have no conflicting scaffoldings with these scaffoldings. Note that two perfect bubbles can share a homotig, but cannot otherwise overlap. A perfect bubble is therefore a construct in our scaffold graph model which in all probability represents a true heterozygous bubble, referring again to the sequence of homozygous, heterozygous, homozygous regions. (For both the greedy and BFS algorithms, a minimum support may also be specified for scaffold graph edges, below which an edge will essentially be considered nonexistent. The default is 2.)</p>
        <p>There are several characteristic features which we expect to be consistent for all true bubbles, particularly features of the pair of homozygous heterotigs. These include the ratio of the heterotig lengths, the ratio of heterotig sequence depths, some normalized measurement of their overall sequence similarity, and the ratio of each sequence depth to the average sequence depth for all contigs [<xref ref-type="bibr" rid="B30">30</xref>]. Table <xref ref-type="table" rid="T1">1</xref> gives more precise definitions to each of these features as well as their expected values both for a valid homolotig pair and for a random pair of non-homologous contigs. Note that in order to calculate sequence depth ratios, the user must provide ScaffoldScaffolder with a contig depth file detailing the sequence depth for each contig. In the absence of this information, the algorithm will still proceed, but the power of the classifier will be limited. Sequence similarity for two contigs is computed as a function of the BLASTn results from aligning the two sequences and thus BLASTn must be installed as a prerequisite to using this module. This then represents a feature vector on which we can attempt to classify true versus false homolotig pairs.</p>
        <table-wrap id="T1" position="float">
          <label>Table 1</label>
          <caption>
            <p>Feature values for classification of homologous contig pairs</p>
          </caption>
          <table frame="hsides" rules="groups">
            <thead>
              <tr>
                <th align="left">Feature Description</th>
                <th align="center">Definition</th>
                <th align="center">Expected Value for Homologous Pair</th>
                <th align="center">Expected Range for Non-Homologous Pair</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="left">Length Ratio</td>
                <td align="center">
                  <inline-formula>
                    <mml:math id="M1" name="1471-2105-16-S7-S5-i4" overflow="scroll">
                      <mml:mfrac>
                        <mml:mrow>
                          <mml:mi>m</mml:mi>
                          <mml:mi>i</mml:mi>
                          <mml:mi>n</mml:mi>
                          <mml:mrow>
                            <mml:mo class="MathClass-open">(</mml:mo>
                            <mml:mrow>
                              <mml:mi>s</mml:mi>
                              <mml:mi>e</mml:mi>
                              <mml:mi>q</mml:mi>
                              <mml:mi>A</mml:mi>
                              <mml:mi>L</mml:mi>
                              <mml:mi>e</mml:mi>
                              <mml:mi>n</mml:mi>
                              <mml:mo class="MathClass-punc">,</mml:mo>
                              <mml:mspace class="tmspace" width="2.77695pt"/>
                              <mml:mi>s</mml:mi>
                              <mml:mi>e</mml:mi>
                              <mml:mi>q</mml:mi>
                              <mml:mi>B</mml:mi>
                              <mml:mi>L</mml:mi>
                              <mml:mi>e</mml:mi>
                              <mml:mi>n</mml:mi>
                            </mml:mrow>
                            <mml:mo class="MathClass-close">)</mml:mo>
                          </mml:mrow>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi>m</mml:mi>
                          <mml:mi>a</mml:mi>
                          <mml:mi>x</mml:mi>
                          <mml:mrow>
                            <mml:mo class="MathClass-open">(</mml:mo>
                            <mml:mrow>
                              <mml:mi>s</mml:mi>
                              <mml:mi>e</mml:mi>
                              <mml:mi>q</mml:mi>
                              <mml:mi>A</mml:mi>
                              <mml:mi>L</mml:mi>
                              <mml:mi>e</mml:mi>
                              <mml:mi>n</mml:mi>
                              <mml:mo class="MathClass-punc">,</mml:mo>
                              <mml:mspace class="tmspace" width="2.77695pt"/>
                              <mml:mi>s</mml:mi>
                              <mml:mi>e</mml:mi>
                              <mml:mi>q</mml:mi>
                              <mml:mi>B</mml:mi>
                              <mml:mi>L</mml:mi>
                              <mml:mi>e</mml:mi>
                              <mml:mi>n</mml:mi>
                            </mml:mrow>
                            <mml:mo class="MathClass-close">)</mml:mo>
                          </mml:mrow>
                        </mml:mrow>
                      </mml:mfrac>
                    </mml:math>
                  </inline-formula>
                </td>
                <td align="center">≈1</td>
                <td align="center">0 &lt; × ≤ 1</td>
              </tr>
              <tr>
                <td align="left">Depth Ratio</td>
                <td align="center">
                  <inline-formula>
                    <mml:math id="M2" name="1471-2105-16-S7-S5-i5" overflow="scroll">
                      <mml:mfrac>
                        <mml:mrow>
                          <mml:mi>m</mml:mi>
                          <mml:mi>i</mml:mi>
                          <mml:mi>n</mml:mi>
                          <mml:mrow>
                            <mml:mo class="MathClass-open">(</mml:mo>
                            <mml:mrow>
                              <mml:mi>s</mml:mi>
                              <mml:mi>e</mml:mi>
                              <mml:mi>q</mml:mi>
                              <mml:mi>A</mml:mi>
                              <mml:mi>D</mml:mi>
                              <mml:mi>e</mml:mi>
                              <mml:mi>p</mml:mi>
                              <mml:mo class="MathClass-punc">,</mml:mo>
                              <mml:mspace class="tmspace" width="2.77695pt"/>
                              <mml:mi>s</mml:mi>
                              <mml:mi>e</mml:mi>
                              <mml:mi>q</mml:mi>
                              <mml:mi>B</mml:mi>
                              <mml:mi>D</mml:mi>
                              <mml:mi>e</mml:mi>
                              <mml:mi>p</mml:mi>
                            </mml:mrow>
                            <mml:mo class="MathClass-close">)</mml:mo>
                          </mml:mrow>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi>m</mml:mi>
                          <mml:mi>a</mml:mi>
                          <mml:mi>x</mml:mi>
                          <mml:mrow>
                            <mml:mo class="MathClass-open">(</mml:mo>
                            <mml:mrow>
                              <mml:mi>s</mml:mi>
                              <mml:mi>e</mml:mi>
                              <mml:mi>q</mml:mi>
                              <mml:mi>A</mml:mi>
                              <mml:mi>D</mml:mi>
                              <mml:mi>e</mml:mi>
                              <mml:mi>p</mml:mi>
                              <mml:mo class="MathClass-punc">,</mml:mo>
                              <mml:mspace class="tmspace" width="2.77695pt"/>
                              <mml:mi>s</mml:mi>
                              <mml:mi>e</mml:mi>
                              <mml:mi>q</mml:mi>
                              <mml:mi>B</mml:mi>
                              <mml:mi>D</mml:mi>
                              <mml:mi>e</mml:mi>
                              <mml:mi>p</mml:mi>
                            </mml:mrow>
                            <mml:mo class="MathClass-close">)</mml:mo>
                          </mml:mrow>
                        </mml:mrow>
                      </mml:mfrac>
                    </mml:math>
                  </inline-formula>
                </td>
                <td align="center">≈1</td>
                <td align="center">0 &lt; × ≤ 1</td>
              </tr>
              <tr>
                <td align="left">% Identical Matches</td>
                <td align="center">
                  <italic>pidentFromBLASTnAlignment</italic>
                </td>
                <td align="center">≈100</td>
                <td align="center">0 ≤ × ≪ 100</td>
              </tr>
              <tr>
                <td align="left">% Length Alignment</td>
                <td align="center">
                  <inline-formula>
                    <mml:math id="M3" name="1471-2105-16-S7-S5-i6" overflow="scroll">
                      <mml:mrow>
                        <mml:mfrac>
                          <mml:mrow>
                            <mml:mi>l</mml:mi>
                            <mml:mi>e</mml:mi>
                            <mml:mi>n</mml:mi>
                            <mml:mi>g</mml:mi>
                            <mml:mi>t</mml:mi>
                            <mml:mi>h</mml:mi>
                            <mml:mi>F</mml:mi>
                            <mml:mi>r</mml:mi>
                            <mml:mi>o</mml:mi>
                            <mml:mi>m</mml:mi>
                            <mml:mi>B</mml:mi>
                            <mml:mi>L</mml:mi>
                            <mml:mi>A</mml:mi>
                            <mml:mi>S</mml:mi>
                            <mml:mi>T</mml:mi>
                            <mml:mi>n</mml:mi>
                            <mml:mi>A</mml:mi>
                            <mml:mi>l</mml:mi>
                            <mml:mi>i</mml:mi>
                            <mml:mi>g</mml:mi>
                            <mml:mi>n</mml:mi>
                            <mml:mi>m</mml:mi>
                            <mml:mi>e</mml:mi>
                            <mml:mi>n</mml:mi>
                            <mml:mi>t</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mi>m</mml:mi>
                            <mml:mi>i</mml:mi>
                            <mml:mi>n</mml:mi>
                            <mml:mrow>
                              <mml:mo class="MathClass-open">(</mml:mo>
                              <mml:mrow>
                                <mml:mi>s</mml:mi>
                                <mml:mi>e</mml:mi>
                                <mml:mi>q</mml:mi>
                                <mml:mi>A</mml:mi>
                                <mml:mi>L</mml:mi>
                                <mml:mi>e</mml:mi>
                                <mml:mi>n</mml:mi>
                                <mml:mo class="MathClass-punc">,</mml:mo>
                                <mml:mspace class="tmspace" width="2.77695pt"/>
                                <mml:mi>s</mml:mi>
                                <mml:mi>e</mml:mi>
                                <mml:mi>q</mml:mi>
                                <mml:mi>B</mml:mi>
                                <mml:mi>L</mml:mi>
                                <mml:mi>e</mml:mi>
                                <mml:mi>n</mml:mi>
                              </mml:mrow>
                              <mml:mo class="MathClass-close">)</mml:mo>
                            </mml:mrow>
                          </mml:mrow>
                        </mml:mfrac>
                      </mml:mrow>
                    </mml:math>
                  </inline-formula>
                </td>
                <td align="center">≈100</td>
                <td align="center">0 ≤ × ≪ 100</td>
              </tr>
              <tr>
                <td align="left">Seq A Depth Proportion to Mode</td>
                <td align="center">
                  <inline-formula>
                    <mml:math id="M4" name="1471-2105-16-S7-S5-i7" overflow="scroll">
                      <mml:mfrac>
                        <mml:mrow>
                          <mml:mi>s</mml:mi>
                          <mml:mi>e</mml:mi>
                          <mml:mi>q</mml:mi>
                          <mml:mi>A</mml:mi>
                          <mml:mi>D</mml:mi>
                          <mml:mi>e</mml:mi>
                          <mml:mi>p</mml:mi>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi>M</mml:mi>
                          <mml:mi>o</mml:mi>
                          <mml:mi>d</mml:mi>
                          <mml:mi>e</mml:mi>
                          <mml:mi>O</mml:mi>
                          <mml:mi>f</mml:mi>
                          <mml:mi>A</mml:mi>
                          <mml:mi>l</mml:mi>
                          <mml:mi>l</mml:mi>
                          <mml:mi>S</mml:mi>
                          <mml:mi>e</mml:mi>
                          <mml:mi>q</mml:mi>
                          <mml:mi>u</mml:mi>
                          <mml:mi>e</mml:mi>
                          <mml:mi>n</mml:mi>
                          <mml:mi>c</mml:mi>
                          <mml:mi>e</mml:mi>
                          <mml:mi>s</mml:mi>
                          <mml:mi>D</mml:mi>
                          <mml:mi>e</mml:mi>
                          <mml:mi>p</mml:mi>
                          <mml:mi>t</mml:mi>
                          <mml:mi>h</mml:mi>
                          <mml:mi>s</mml:mi>
                        </mml:mrow>
                      </mml:mfrac>
                    </mml:math>
                  </inline-formula>
                </td>
                <td align="center">
                  <inline-formula>
                    <mml:math id="M5" name="1471-2105-16-S7-S5-i8" overflow="scroll">
                      <mml:mrow>
                        <mml:mo class="MathClass-rel">≈</mml:mo>
                        <mml:mfrac>
                          <mml:mrow>
                            <mml:mi>A</mml:mi>
                            <mml:mi>v</mml:mi>
                            <mml:mi>e</mml:mi>
                            <mml:mi>r</mml:mi>
                            <mml:mi>a</mml:mi>
                            <mml:mi>g</mml:mi>
                            <mml:mi>e</mml:mi>
                            <mml:mi>H</mml:mi>
                            <mml:mi>a</mml:mi>
                            <mml:mi>p</mml:mi>
                            <mml:mi>l</mml:mi>
                            <mml:mi>o</mml:mi>
                            <mml:mi>i</mml:mi>
                            <mml:mi>d</mml:mi>
                            <mml:mi>S</mml:mi>
                            <mml:mi>e</mml:mi>
                            <mml:mi>q</mml:mi>
                            <mml:mi>u</mml:mi>
                            <mml:mi>e</mml:mi>
                            <mml:mi>n</mml:mi>
                            <mml:mi>c</mml:mi>
                            <mml:mi>e</mml:mi>
                            <mml:mi>D</mml:mi>
                            <mml:mi>e</mml:mi>
                            <mml:mi>p</mml:mi>
                            <mml:mi>t</mml:mi>
                            <mml:mi>h</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mi>M</mml:mi>
                            <mml:mi>o</mml:mi>
                            <mml:mi>d</mml:mi>
                            <mml:mi>e</mml:mi>
                            <mml:mi>O</mml:mi>
                            <mml:mi>f</mml:mi>
                            <mml:mi>A</mml:mi>
                            <mml:mi>l</mml:mi>
                            <mml:mi>l</mml:mi>
                            <mml:mi>S</mml:mi>
                            <mml:mi>e</mml:mi>
                            <mml:mi>q</mml:mi>
                            <mml:mi>u</mml:mi>
                            <mml:mi>e</mml:mi>
                            <mml:mi>n</mml:mi>
                            <mml:mi>c</mml:mi>
                            <mml:mi>e</mml:mi>
                            <mml:mi>s</mml:mi>
                            <mml:mi>D</mml:mi>
                            <mml:mi>e</mml:mi>
                            <mml:mi>p</mml:mi>
                            <mml:mi>t</mml:mi>
                            <mml:mi>h</mml:mi>
                            <mml:mi>s</mml:mi>
                          </mml:mrow>
                        </mml:mfrac>
                      </mml:mrow>
                    </mml:math>
                  </inline-formula>
                </td>
                <td align="center">0 &lt; x</td>
              </tr>
              <tr>
                <td align="left">Seq B Depth Proportion to Mode</td>
                <td align="center">
                  <inline-formula>
                    <mml:math id="M6" name="1471-2105-16-S7-S5-i9" overflow="scroll">
                      <mml:mfrac>
                        <mml:mrow>
                          <mml:mi>s</mml:mi>
                          <mml:mi>e</mml:mi>
                          <mml:mi>q</mml:mi>
                          <mml:mi>B</mml:mi>
                          <mml:mi>D</mml:mi>
                          <mml:mi>e</mml:mi>
                          <mml:mi>p</mml:mi>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi>M</mml:mi>
                          <mml:mi>o</mml:mi>
                          <mml:mi>d</mml:mi>
                          <mml:mi>e</mml:mi>
                          <mml:mi>O</mml:mi>
                          <mml:mi>f</mml:mi>
                          <mml:mi>A</mml:mi>
                          <mml:mi>l</mml:mi>
                          <mml:mi>l</mml:mi>
                          <mml:mi>S</mml:mi>
                          <mml:mi>e</mml:mi>
                          <mml:mi>q</mml:mi>
                          <mml:mi>u</mml:mi>
                          <mml:mi>e</mml:mi>
                          <mml:mi>n</mml:mi>
                          <mml:mi>c</mml:mi>
                          <mml:mi>e</mml:mi>
                          <mml:mi>s</mml:mi>
                          <mml:mi>D</mml:mi>
                          <mml:mi>e</mml:mi>
                          <mml:mi>p</mml:mi>
                          <mml:mi>t</mml:mi>
                          <mml:mi>h</mml:mi>
                          <mml:mi>s</mml:mi>
                        </mml:mrow>
                      </mml:mfrac>
                    </mml:math>
                  </inline-formula>
                </td>
                <td align="center">
                  <inline-formula>
                    <mml:math id="M7" name="1471-2105-16-S7-S5-i10" overflow="scroll">
                      <mml:mrow>
                        <mml:mo class="MathClass-rel">≈</mml:mo>
                        <mml:mfrac>
                          <mml:mrow>
                            <mml:mi>A</mml:mi>
                            <mml:mi>v</mml:mi>
                            <mml:mi>e</mml:mi>
                            <mml:mi>r</mml:mi>
                            <mml:mi>a</mml:mi>
                            <mml:mi>g</mml:mi>
                            <mml:mi>e</mml:mi>
                            <mml:mi>H</mml:mi>
                            <mml:mi>a</mml:mi>
                            <mml:mi>p</mml:mi>
                            <mml:mi>l</mml:mi>
                            <mml:mi>o</mml:mi>
                            <mml:mi>i</mml:mi>
                            <mml:mi>d</mml:mi>
                            <mml:mi>S</mml:mi>
                            <mml:mi>e</mml:mi>
                            <mml:mi>q</mml:mi>
                            <mml:mi>u</mml:mi>
                            <mml:mi>e</mml:mi>
                            <mml:mi>n</mml:mi>
                            <mml:mi>c</mml:mi>
                            <mml:mi>e</mml:mi>
                            <mml:mi>D</mml:mi>
                            <mml:mi>e</mml:mi>
                            <mml:mi>p</mml:mi>
                            <mml:mi>t</mml:mi>
                            <mml:mi>h</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mi>M</mml:mi>
                            <mml:mi>o</mml:mi>
                            <mml:mi>d</mml:mi>
                            <mml:mi>e</mml:mi>
                            <mml:mi>O</mml:mi>
                            <mml:mi>f</mml:mi>
                            <mml:mi>A</mml:mi>
                            <mml:mi>l</mml:mi>
                            <mml:mi>l</mml:mi>
                            <mml:mi>S</mml:mi>
                            <mml:mi>e</mml:mi>
                            <mml:mi>q</mml:mi>
                            <mml:mi>u</mml:mi>
                            <mml:mi>e</mml:mi>
                            <mml:mi>n</mml:mi>
                            <mml:mi>c</mml:mi>
                            <mml:mi>e</mml:mi>
                            <mml:mi>s</mml:mi>
                            <mml:mi>D</mml:mi>
                            <mml:mi>e</mml:mi>
                            <mml:mi>p</mml:mi>
                            <mml:mi>t</mml:mi>
                            <mml:mi>h</mml:mi>
                            <mml:mi>s</mml:mi>
                          </mml:mrow>
                        </mml:mfrac>
                      </mml:mrow>
                    </mml:math>
                  </inline-formula>
                </td>
                <td align="center">0 &lt; x</td>
              </tr>
            </tbody>
          </table>
        </table-wrap>
        <p>We assume therefore that perfect bubbles accurately predict homolotig pairs. ScaffoldScaffolder then trains a binary classifier on homolotig pairs as found in perfect bubbles using our defined feature vector. The algorithm implements the Weka machine learning framework, allowing the user to specify at runtime any one of the classifiers in the weka.classifiers.functions package, including both a backpropagation multilayer perceptron classifier and a number of support vector machine implementations.</p>
      </sec>
      <sec>
        <title>Bubble chain elucidation</title>
        <p>There are presumably many partial or "imperfect" bubbles in the scaffold graph, which are either missing edges or which have conflicting edges as a result of insufficient data, erroneous alignments, or other biological ambiguities. We can then consider each of these imperfect bubbles in decreasing order of "perfectness" and use our classifier to predict whether or not these latter bubbles represent true heterozygous bubbles as indicated by whether or not the purported homolotig pair is classified as valid. An imperfect bubble, any of whose constituent edges either conflicts with already included edges or <italic>is </italic>an already included edge, is disallowed from being classified a true bubble. This guarantees that the resulting subgraph consists entirely of bubbles and/or chains of bubbles (i.e., bubbles which share common homotigs).</p>
        <p>Remaining scaffoldings are then considered greedily (as defined by the simple greedy algorithm above) for linking bubbles and remaining contigs together into chains. As with the greedy algorithm, this algorithm proceeds iteratively, with bubbles being formed and predicted in the first iteration. All iterations past the first use paired reads to link existing bubble chains and scaffolds into larger chains. At each iteration, paired reads mapping within chains are used to phase homolotig pairs so that the final product is a set of phased bubble-chain scaffolds.</p>
      </sec>
      <sec>
        <title>Linear haploid scaffold formation</title>
        <p>From phased bubble chains, ScaffoldScaffolder outputs two FASTA files, each containing one of two linear, phased haplotypes for each scaffold. A linear, phased haplotype is constructed by considering homotigs together with heterotigs from one of the phased haplotypes. ScaffoldScaffolder can optionally output the bubble chain graph in DOT format (viewable with Graphviz) and an additional parameter will additionally display excluded edges as dashed edges.</p>
      </sec>
    </sec>
    <sec>
      <title>Quantitative analysis</title>
      <p>We developed four methods for internally assessing the performance of our homolotig classifier and subsequent phasing algorithm. In defining these methods, we use the following definitions. Let <italic>x </italic>represent an arbitrary read. Let <italic>c </italic>simultaneously represent an arbitrary contig as well as the set of reads {<italic>x</italic> | × ∈ <italic>c</italic>} that constitute <italic>c</italic>. For synthetic haplotypes A and B, let <italic>A </italic>and <italic>B </italic>be the set of reads belonging to synthetic haplotypes A and B respectively (i.e., <italic>A </italic>= {<italic>x</italic> | × ∈ <italic>A</italic>} and <italic>B </italic>= {<italic>x</italic> | × ∈ <italic>B</italic>}). Let <italic>L</italic>(<italic>A</italic>) represent the length of synthetic genome A (note that in our analyses, <italic>L</italic>(<italic>A</italic>) = <italic>L</italic>(<italic>B</italic>)). Let <italic>g </italic>represent an arbitrary set of contigs that are phased together (i.e., <italic>g </italic>= {<italic>c | c </italic>∈ <italic>g</italic>}). All analyses were performed for contigs of length greater than 100 bases.</p>
    </sec>
    <sec>
      <title>Contig sequencing depth</title>
      <p>The contig sequencing depth refers to the average number of reads that contribute to the consensus at each position in the contig. Reads contributing to homotigs derive from two haplotypes and should therefore reflect a diploid sequencing depth. Reads contributing to heterotigs derive from only one of the two haplotypes and should therefore reflect a haploid sequencing depth. To the extent that predicted heterotigs have a greater-than-haploid sequencing depth, we would suspect a failure of haplotype segregation during assembly. We plot the density of <italic>sequencing depth </italic>values for three classes of contigs: heterotigs used in training, for contigs classified as heterotigs, and for contigs classified as homotigs.</p>
    </sec>
    <sec>
      <title>Contig homogeneity</title>
      <p>Properly assembled heterotigs should also exhibit strong homogeneity in the source of their constituents. Insofar as haplotypes segregate properly during assembly, resulting heterotigs should be composed entirely of reads from one haplotype or entirely of reads from the complementary haplotype. For each contig class, we plot a density of <italic>contig homogeneity </italic>values. We define contig homogeneity for a contig <italic>c </italic>as the ratio of reads deriving from haplotype A, calculated as</p>
      <p>
        <disp-formula>
          <mml:math id="M8" name="1471-2105-16-S7-S5-i1" overflow="scroll">
            <mml:mrow>
              <mml:mi>h</mml:mi>
              <mml:mi>o</mml:mi>
              <mml:msub>
                <mml:mrow>
                  <mml:mi>m</mml:mi>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi>c</mml:mi>
                  <mml:mi>o</mml:mi>
                  <mml:mi>n</mml:mi>
                  <mml:mi>t</mml:mi>
                  <mml:mi>i</mml:mi>
                  <mml:mi>n</mml:mi>
                  <mml:mi>g</mml:mi>
                </mml:mrow>
              </mml:msub>
              <mml:mfenced close=")" open="(">
                <mml:mrow>
                  <mml:mi>c</mml:mi>
                </mml:mrow>
              </mml:mfenced>
              <mml:mo class="MathClass-rel">=</mml:mo>
              <mml:mfrac>
                <mml:mrow>
                  <mml:mo class="MathClass-rel">|</mml:mo>
                  <mml:mfenced close="}" open="{">
                    <mml:mrow>
                      <mml:mi>x</mml:mi>
                      <mml:mo class="MathClass-rel">|</mml:mo>
                      <mml:mi>x</mml:mi>
                      <mml:mo class="MathClass-rel">∈</mml:mo>
                      <mml:mi>c</mml:mi>
                      <mml:mo class="MathClass-bin">∧</mml:mo>
                      <mml:mi>x</mml:mi>
                      <mml:mo class="MathClass-rel">∈</mml:mo>
                      <mml:mi>A</mml:mi>
                    </mml:mrow>
                  </mml:mfenced>
                  <mml:mo class="MathClass-rel">|</mml:mo>
                </mml:mrow>
                <mml:mrow>
                  <mml:mo class="MathClass-rel">|</mml:mo>
                  <mml:mfenced close="}" open="{">
                    <mml:mrow>
                      <mml:mi>x</mml:mi>
                      <mml:mo class="MathClass-rel">|</mml:mo>
                      <mml:mi>x</mml:mi>
                      <mml:mo class="MathClass-rel">∈</mml:mo>
                      <mml:mi>c</mml:mi>
                    </mml:mrow>
                  </mml:mfenced>
                  <mml:mo class="MathClass-rel">|</mml:mo>
                </mml:mrow>
              </mml:mfrac>
            </mml:mrow>
          </mml:math>
        </disp-formula>
      </p>
      <p>For contigs trained or classified as heterotigs, we would expect to see peaks near 0 and 1. Homotigs should peak near 0.5.</p>
    </sec>
    <sec>
      <title>Phase group homogeneity</title>
      <p>To assess the accuracy of phasing, we analyze the ratio of haplotype A reads in each group of phased contigs, <italic>g</italic>:</p>
      <p>
        <disp-formula>
          <mml:math id="M9" name="1471-2105-16-S7-S5-i2" overflow="scroll">
            <mml:mrow>
              <mml:mi>h</mml:mi>
              <mml:mi>o</mml:mi>
              <mml:msub>
                <mml:mrow>
                  <mml:mi>m</mml:mi>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi>p</mml:mi>
                  <mml:mi>h</mml:mi>
                  <mml:mi>a</mml:mi>
                  <mml:mi>s</mml:mi>
                  <mml:mi>e</mml:mi>
                </mml:mrow>
              </mml:msub>
              <mml:mfenced close=")" open="(">
                <mml:mrow>
                  <mml:mi>g</mml:mi>
                </mml:mrow>
              </mml:mfenced>
              <mml:mo class="MathClass-rel">=</mml:mo>
              <mml:mfrac>
                <mml:mrow>
                  <mml:msub>
                    <mml:mrow>
                      <mml:mo>∑</mml:mo>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi>c</mml:mi>
                      <mml:mo class="MathClass-rel">∈</mml:mo>
                      <mml:mi>g</mml:mi>
                    </mml:mrow>
                  </mml:msub>
                  <mml:mo class="MathClass-rel">|</mml:mo>
                  <mml:mfenced close="}" open="{">
                    <mml:mrow>
                      <mml:mi>x</mml:mi>
                      <mml:mo class="MathClass-rel">|</mml:mo>
                      <mml:mi>x</mml:mi>
                      <mml:mo class="MathClass-rel">∈</mml:mo>
                      <mml:mi>c</mml:mi>
                      <mml:mo class="MathClass-bin">∧</mml:mo>
                      <mml:mi>x</mml:mi>
                      <mml:mo class="MathClass-rel">∈</mml:mo>
                      <mml:mi>A</mml:mi>
                    </mml:mrow>
                  </mml:mfenced>
                  <mml:mo class="MathClass-rel">|</mml:mo>
                </mml:mrow>
                <mml:mrow>
                  <mml:msub>
                    <mml:mrow>
                      <mml:mo>∑</mml:mo>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi>c</mml:mi>
                      <mml:mo class="MathClass-rel">∈</mml:mo>
                      <mml:mi>g</mml:mi>
                    </mml:mrow>
                  </mml:msub>
                  <mml:mo class="MathClass-rel">|</mml:mo>
                  <mml:mfenced close="}" open="{">
                    <mml:mrow>
                      <mml:mi>x</mml:mi>
                      <mml:mo class="MathClass-rel">|</mml:mo>
                      <mml:mi>x</mml:mi>
                      <mml:mo class="MathClass-rel">∈</mml:mo>
                      <mml:mi>c</mml:mi>
                    </mml:mrow>
                  </mml:mfenced>
                  <mml:mo class="MathClass-rel">|</mml:mo>
                </mml:mrow>
              </mml:mfrac>
            </mml:mrow>
          </mml:math>
        </disp-formula>
      </p>
      <p>Accurate phase groups will have homogeneity values clustering around 0 and 1.</p>
    </sec>
    <sec>
      <title>Heterogeneity between phase groups</title>
      <p>In addition to having a consistent haplotype source within phase groups, accurate phasing is reflected by proper segregation of haplotypes between complementary phase groups, <italic>g<sub>m </sub></italic>and <italic>g<sub>n</sub></italic>. To assess this metric, we compute the difference in the ratio of haplotype A reads between complementary phase groups as</p>
      <p>
        <disp-formula>
          <mml:math id="M10" name="1471-2105-16-S7-S5-i3" overflow="scroll">
            <mml:mrow>
              <mml:mi>h</mml:mi>
              <mml:mi>e</mml:mi>
              <mml:mi>t</mml:mi>
              <mml:mfenced close=")" open="(">
                <mml:mrow>
                  <mml:msub>
                    <mml:mrow>
                      <mml:mi>g</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi>m</mml:mi>
                    </mml:mrow>
                  </mml:msub>
                  <mml:mo class="MathClass-punc">,</mml:mo>
                  <mml:msub>
                    <mml:mrow>
                      <mml:mi>g</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi>n</mml:mi>
                    </mml:mrow>
                  </mml:msub>
                </mml:mrow>
              </mml:mfenced>
              <mml:mo class="MathClass-rel">=</mml:mo>
              <mml:mfenced close="|" open="|">
                <mml:mrow>
                  <mml:mfrac>
                    <mml:mrow>
                      <mml:msub>
                        <mml:mrow>
                          <mml:mo>∑</mml:mo>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi>c</mml:mi>
                          <mml:mo class="MathClass-rel">∈</mml:mo>
                          <mml:msub>
                            <mml:mrow>
                              <mml:mi>g</mml:mi>
                            </mml:mrow>
                            <mml:mrow>
                              <mml:mi>m</mml:mi>
                            </mml:mrow>
                          </mml:msub>
                        </mml:mrow>
                      </mml:msub>
                      <mml:mo class="MathClass-rel">|</mml:mo>
                      <mml:mfenced close="}" open="{">
                        <mml:mrow>
                          <mml:mi>x</mml:mi>
                          <mml:mo class="MathClass-rel">|</mml:mo>
                          <mml:mi>x</mml:mi>
                          <mml:mo class="MathClass-rel">∈</mml:mo>
                          <mml:mi>c</mml:mi>
                          <mml:mo class="MathClass-bin">∧</mml:mo>
                          <mml:mi>x</mml:mi>
                          <mml:mo class="MathClass-rel">∈</mml:mo>
                          <mml:mi>A</mml:mi>
                        </mml:mrow>
                      </mml:mfenced>
                      <mml:mo class="MathClass-rel">|</mml:mo>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:msub>
                        <mml:mrow>
                          <mml:mo>∑</mml:mo>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi>c</mml:mi>
                          <mml:mo class="MathClass-rel">∈</mml:mo>
                          <mml:msub>
                            <mml:mrow>
                              <mml:mi>g</mml:mi>
                            </mml:mrow>
                            <mml:mrow>
                              <mml:mi>m</mml:mi>
                            </mml:mrow>
                          </mml:msub>
                        </mml:mrow>
                      </mml:msub>
                      <mml:mo class="MathClass-rel">|</mml:mo>
                      <mml:mfenced close="}" open="{">
                        <mml:mrow>
                          <mml:mi>x</mml:mi>
                          <mml:mo class="MathClass-rel">|</mml:mo>
                          <mml:mi>x</mml:mi>
                          <mml:mo class="MathClass-rel">∈</mml:mo>
                          <mml:mi>c</mml:mi>
                        </mml:mrow>
                      </mml:mfenced>
                      <mml:mo class="MathClass-rel">|</mml:mo>
                    </mml:mrow>
                  </mml:mfrac>
                  <mml:mo class="MathClass-bin">-</mml:mo>
                  <mml:mfrac>
                    <mml:mrow>
                      <mml:msub>
                        <mml:mrow>
                          <mml:mo>∑</mml:mo>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi>c</mml:mi>
                          <mml:mo class="MathClass-rel">∈</mml:mo>
                          <mml:msub>
                            <mml:mrow>
                              <mml:mi>g</mml:mi>
                            </mml:mrow>
                            <mml:mrow>
                              <mml:mi>n</mml:mi>
                            </mml:mrow>
                          </mml:msub>
                        </mml:mrow>
                      </mml:msub>
                      <mml:mo class="MathClass-rel">|</mml:mo>
                      <mml:mfenced close="}" open="{">
                        <mml:mrow>
                          <mml:mi>x</mml:mi>
                          <mml:mo class="MathClass-rel">|</mml:mo>
                          <mml:mi>x</mml:mi>
                          <mml:mo class="MathClass-rel">∈</mml:mo>
                          <mml:mi>c</mml:mi>
                          <mml:mo class="MathClass-bin">∧</mml:mo>
                          <mml:mi>x</mml:mi>
                          <mml:mo class="MathClass-rel">∈</mml:mo>
                          <mml:mi>A</mml:mi>
                        </mml:mrow>
                      </mml:mfenced>
                      <mml:mo class="MathClass-rel">|</mml:mo>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:msub>
                        <mml:mrow>
                          <mml:mo>∑</mml:mo>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi>c</mml:mi>
                          <mml:mo class="MathClass-rel">∈</mml:mo>
                          <mml:msub>
                            <mml:mrow>
                              <mml:mi>g</mml:mi>
                            </mml:mrow>
                            <mml:mrow>
                              <mml:mi>n</mml:mi>
                            </mml:mrow>
                          </mml:msub>
                        </mml:mrow>
                      </mml:msub>
                      <mml:mo class="MathClass-rel">|</mml:mo>
                      <mml:mfenced close="}" open="{">
                        <mml:mrow>
                          <mml:mi>x</mml:mi>
                          <mml:mo class="MathClass-rel">|</mml:mo>
                          <mml:mi>x</mml:mi>
                          <mml:mo class="MathClass-rel">∈</mml:mo>
                          <mml:mi>c</mml:mi>
                        </mml:mrow>
                      </mml:mfenced>
                      <mml:mo class="MathClass-rel">|</mml:mo>
                    </mml:mrow>
                  </mml:mfrac>
                </mml:mrow>
              </mml:mfenced>
            </mml:mrow>
          </mml:math>
        </disp-formula>
      </p>
      <p>Accurate phase groups result in heterogeneity values clustering around 1.</p>
    </sec>
  </sec>
  <sec sec-type="results">
    <title>Results</title>
    <p>We validated our algorithm on a synthetic example in order to assess the accuracy of haplotype-specificity in assembly and scaffold phasing. We synthetically generated a 4.94-Mb diploid genome with a 0.04 heterozygosity rate. Haplotype A was the first 4.94 Mb of <italic>Homo sapiens </italic>chromosome 20 (gi 27501067). We derived haplotype B from this sequence using HapMaker [<xref ref-type="bibr" rid="B33">33</xref>]. We used ART v 1.3.1 [<xref ref-type="bibr" rid="B34">34</xref>] to generate synthetic error-free 75-bp paired reads from 400-bp inserts and from 1000-bp inserts at 40x coverage each (ART cannot simulate reads longer than 75 bp). We assembled reads using an overlap-layout consensus assembler Newbler 2.6 (-mi 100, -nohet). Only reads from 400-bp fragments were used for scaffolding. Bowtie 0.12.7 [<xref ref-type="bibr" rid="B35">35</xref>] was used for aligning reads to contigs (-v 3 -a -m 1 -f).</p>
    <p>In all 21,358 contigs were combined into 1,252 scaffolds. There were 1,079 perfect bubbles (i.e., homolotig pairs) identified for training and another 3,651 contig pairs classified as homolotigs. Of these 4,187 homolotig pairs (88.5%) were phased into a total of 675 phase groups. In total, 3,275,028 non-N bases (91.0% percent of heterotig-classified bases) were phased.</p>
    <p>The results of diploid scaffolding using ScaffoldScaffolder are seen in Figures <xref ref-type="fig" rid="F4">4</xref> through <xref ref-type="fig" rid="F7">7</xref>. Figures <xref ref-type="fig" rid="F4">4</xref> and <xref ref-type="fig" rid="F5">5</xref> demonstrate several results. First, looking at all contigs, regardless of their classification, we see two very clear categories: 1) homotigs, whose sequencing depth centers roughly at 80x coverage and whose haplotype A ratio centers at 0.5; and 2) heterotigs, whose sequencing depth centers at about 40x and whose haplotype A ratio centers at 0 and 1. This result suggests that a strict parameterization of the assembler successfully segregates heterozygous reads and combines homozygous reads. Second, we see that the contigs selected as "training" (which we assumed were heterotigs) fall entirely into the heterotig camp, suggesting that our method for selecting training examples is highly effective. Third, we see that we classify other heterotigs with high precision (99.7% of 7,302 classified heterotigs had sequencing depth <italic>&lt;</italic>60), at some cost to recall (61.1% of 11,905 contigs with depth <italic>&lt;</italic>60 were classified). Why we fail to classify all true heterotigs (i.e., those with depth <italic>&lt;</italic>60) requires further investigation.</p>
    <fig id="F4" position="float">
      <label>Figure 4</label>
      <caption>
        <p><bold>Contig Sequencing Depth</bold>. That reads from predicted heterotigs reflect a haploid sequencing depth indicates that haplotypes are segregating during assembly. The algorithm favors high precision (no false heterotigs) at some cost to recall (a few misclassified heterotigs), as evidenced by the blue peak at haploid sequencing depth.</p>
      </caption>
      <graphic xlink:href="1471-2105-16-S7-S5-4"/>
    </fig>
    <fig id="F5" position="float">
      <label>Figure 5</label>
      <caption>
        <p><bold>Contig Homogeneity</bold>. Reads from predicted heterotigs come either entirely from haplotype A or entirely from haplotype B, indicating that haplotypes are assembling correctly. We again see high precision with a few mislabeled homotigs (blue peaks at 0 and 1).</p>
      </caption>
      <graphic xlink:href="1471-2105-16-S7-S5-5"/>
    </fig>
    <p>Figures <xref ref-type="fig" rid="F6">6</xref> and <xref ref-type="fig" rid="F7">7</xref> demonstrate the accuracy of phasing in ScaffoldScaffolder. Figure <xref ref-type="fig" rid="F6">6</xref> demonstrates that <italic>within </italic>phase groups, reads derive either entirely from haplotype A or haplotype B. Figure <xref ref-type="fig" rid="F7">7</xref> shows complete heterogeneity <italic>between </italic>homologous phase groups, meaning there are two haplotypes represented and cleanly segregated.</p>
    <fig id="F6" position="float">
      <label>Figure 6</label>
      <caption>
        <p><bold>Phase Group Homogeneity</bold>. As with contig homogeneity, we observe that reads from commonly-phased contigs derive either entirely from haplotype A or entirely from haplotype B. This indicates accurate phasing.</p>
      </caption>
      <graphic xlink:href="1471-2105-16-S7-S5-6"/>
    </fig>
    <fig id="F7" position="float">
      <label>Figure 7</label>
      <caption>
        <p><bold>Heterogeneity between Phase Groups</bold>. Results indicate a complete and accurate segregation of haplotypes between complementary phase groups.</p>
      </caption>
      <graphic xlink:href="1471-2105-16-S7-S5-7"/>
    </fig>
    <p>Overall these results indicate that at least given a highly conservative input dataset, the intuition and implementation of the algorithm are capable of effectively scaffolding and phasing diploid genomes. In the future we plan to perform more rigorous testing and comparative analysis on real datasets. It should also be noted that the algorithm as it currently stands is not designed not accommodate rearrangements or inversions.</p>
  </sec>
  <sec sec-type="conclusions">
    <title>Conclusions</title>
    <p><italic>De novo </italic>diploid genome assembly is a burgeoning research area with exciting implications. We have presented ScaffoldScaffolder, a haplotype-aware scaffolding algorithm for diploid genomes. We have demonstrated the viability of using bubbles to identify heterozygous homologous contigs, which we term homolotigs. We have also shown that machine learning classification trained on these homolotig pairs can be used effectively for identifying homologous sequences elsewhere in the data with high precision (assuming error-free reads).</p>
    <p>In addition to laying out the algorithm of ScaffoldScaffolder, we have defined four metrics which are indicative of diploid assembly quality when run on synthetic data: contig sequencing depth, contig homogeneity, phase group homogeneity, and heterogeneity between phase groups. More work is required to comparatively analyze this approach on real data with various parameters and classifiers against other diploid genome assembly methods (of which there are currently very few). However, the initial results of ScaffoldScaffolder supply validity to the idea of employing machine learning in the difficult task of diploid genome assembly.</p>
  </sec>
  <sec>
    <title>Competing interests</title>
    <p>The authors declare that they have no competing interests.</p>
  </sec>
  <sec>
    <title>Authors' contributions</title>
    <p>PMB conceived of the study, carried out experiments, and drafted the manuscript. MSF, JCP, MJC, and, QS contributed substantially to conception and design. NO contributed to data acquisition, synthetic data preparation, and manuscript editing. CO aided substantially in analysis, interpretation, and presentation of results.</p>
  </sec>
  <sec>
    <title>Declarations</title>
    <p>Funding used to cover the publishing charge also comes from NIH grant R01 HG005692.</p>
    <p>This article has been published as part of <italic>BMC Bioinformatics </italic>Volume 16 Supplement 7, 2015: Selected articles from The 11th Annual Biotechnology and Bioinformatics Symposium (BIOT-2014): Bioinformatics. The full contents of the supplement are available online at <ext-link ext-link-type="uri" xlink:href="http://www.biomedcentral.com/bmcbioinformatics/supplements/16/S7">http://www.biomedcentral.com/bmcbioinformatics/supplements/16/S7</ext-link>.</p>
  </sec>
</body>
<back>
  <sec>
    <title>Acknowledgements</title>
    <p>This research was made possible thanks to NIH grant R01 HG005692.</p>
  </sec>
  <ref-list>
    <ref id="B1">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Church</surname>
          <given-names>GM</given-names>
        </name>
        <name>
          <surname>Gao</surname>
          <given-names>Y</given-names>
        </name>
        <name>
          <surname>Kosuri</surname>
          <given-names>S</given-names>
        </name>
        <article-title>Next-generation digital information storage in DNA</article-title>
        <source>Science</source>
        <year>2012</year>
        <volume>337</volume>
        <issue>6102</issue>
        <fpage>1628</fpage>
        <lpage>1628</lpage>
        <pub-id pub-id-type="doi">10.1126/science.1226355</pub-id>
        <?supplied-pmid 22903519?>
        <pub-id pub-id-type="pmid">22903519</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B2">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Li</surname>
          <given-names>R.</given-names>
        </name>
        <name>
          <surname>Zhu</surname>
          <given-names>H</given-names>
        </name>
        <name>
          <surname>Ruan</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Qian</surname>
          <given-names>W</given-names>
        </name>
        <name>
          <surname>Fang</surname>
          <given-names>X</given-names>
        </name>
        <name>
          <surname>Shi</surname>
          <given-names>Z</given-names>
        </name>
        <name>
          <surname>Li</surname>
          <given-names>Y</given-names>
        </name>
        <name>
          <surname>Li</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Shan</surname>
          <given-names>G</given-names>
        </name>
        <name>
          <surname>Kristiansen</surname>
          <given-names>K</given-names>
        </name>
        <etal/>
        <article-title>De novo assembly of human genomes with massively parallel short read sequencing</article-title>
        <source>Genome research</source>
        <year>2010</year>
        <volume>20</volume>
        <issue>2</issue>
        <fpage>265</fpage>
        <lpage>272</lpage>
        <pub-id pub-id-type="doi">10.1101/gr.097261.109</pub-id>
        <?supplied-pmid 20019144?>
        <pub-id pub-id-type="pmid">20019144</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B3">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Jaffe</surname>
          <given-names>DB</given-names>
        </name>
        <name>
          <surname>Butler</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Gnerre</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Mauceli</surname>
          <given-names>E</given-names>
        </name>
        <name>
          <surname>Lindblad-Toh</surname>
          <given-names>K</given-names>
        </name>
        <name>
          <surname>Mesirov</surname>
          <given-names>JP</given-names>
        </name>
        <name>
          <surname>Zody</surname>
          <given-names>MC</given-names>
        </name>
        <name>
          <surname>Lander</surname>
          <given-names>ES</given-names>
        </name>
        <article-title>Whole-genome sequence assembly for mammalian genomes: Arachne 2</article-title>
        <source>Genome research</source>
        <year>2003</year>
        <volume>13</volume>
        <issue>1</issue>
        <fpage>91</fpage>
        <lpage>96</lpage>
        <pub-id pub-id-type="doi">10.1101/gr.828403</pub-id>
        <?supplied-pmid 12529310?>
        <pub-id pub-id-type="pmid">12529310</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B4">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Li</surname>
          <given-names>Z</given-names>
        </name>
        <name>
          <surname>Chen</surname>
          <given-names>Y</given-names>
        </name>
        <name>
          <surname>Mu</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Yuan</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Shi</surname>
          <given-names>Y</given-names>
        </name>
        <name>
          <surname>Zhang</surname>
          <given-names>H</given-names>
        </name>
        <name>
          <surname>Gan</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Li</surname>
          <given-names>N</given-names>
        </name>
        <name>
          <surname>Hu</surname>
          <given-names>X</given-names>
        </name>
        <name>
          <surname>Liu</surname>
          <given-names>B</given-names>
        </name>
        <etal/>
        <article-title>Comparison of the two major classes of assembly algorithms: overlap-layout-consensus and de-bruijn-graph</article-title>
        <source>Briefings in functional genomics</source>
        <year>2012</year>
        <volume>11</volume>
        <issue>1</issue>
        <fpage>25</fpage>
        <lpage>37</lpage>
        <pub-id pub-id-type="doi">10.1093/bfgp/elr035</pub-id>
        <?supplied-pmid 22184334?>
        <pub-id pub-id-type="pmid">22184334</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B5">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Holt</surname>
          <given-names>RA</given-names>
        </name>
        <name>
          <surname>Subramanian</surname>
          <given-names>GM</given-names>
        </name>
        <name>
          <surname>Halpern</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Sutton</surname>
          <given-names>GG</given-names>
        </name>
        <name>
          <surname>Charlab</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Nusskern</surname>
          <given-names>DR</given-names>
        </name>
        <name>
          <surname>Wincker</surname>
          <given-names>P</given-names>
        </name>
        <name>
          <surname>Clark</surname>
          <given-names>AG</given-names>
        </name>
        <name>
          <surname>Ribeiro</surname>
          <given-names>JC</given-names>
        </name>
        <name>
          <surname>Wides</surname>
          <given-names>R</given-names>
        </name>
        <etal/>
        <article-title>The genome sequence of the malaria mosquito anopheles gambiae</article-title>
        <source>Science</source>
        <year>2002</year>
        <volume>298</volume>
        <issue>5591</issue>
        <fpage>129</fpage>
        <lpage>149</lpage>
        <pub-id pub-id-type="doi">10.1126/science.1076181</pub-id>
        <?supplied-pmid 12364791?>
        <pub-id pub-id-type="pmid">12364791</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B6">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Jones</surname>
          <given-names>T</given-names>
        </name>
        <name>
          <surname>Federspiel</surname>
          <given-names>NA</given-names>
        </name>
        <name>
          <surname>Chibana</surname>
          <given-names>H</given-names>
        </name>
        <name>
          <surname>Dungan</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Kalman</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Magee</surname>
          <given-names>B</given-names>
        </name>
        <name>
          <surname>Newport</surname>
          <given-names>G</given-names>
        </name>
        <name>
          <surname>Thorstenson</surname>
          <given-names>YR</given-names>
        </name>
        <name>
          <surname>Agabian</surname>
          <given-names>N</given-names>
        </name>
        <name>
          <surname>Magee</surname>
          <given-names>P</given-names>
        </name>
        <etal/>
        <article-title>The diploid genome sequence of candida albicans</article-title>
        <source>Proceedings of the National Academy of Sciences of the United States of America</source>
        <year>2004</year>
        <volume>101</volume>
        <issue>19</issue>
        <fpage>7329</fpage>
        <pub-id pub-id-type="doi">10.1073/pnas.0401648101</pub-id>
        <?supplied-pmid 15123810?>
        <pub-id pub-id-type="pmid">15123810</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B7">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Vinson</surname>
          <given-names>JP</given-names>
        </name>
        <name>
          <surname>Jaffe</surname>
          <given-names>DB</given-names>
        </name>
        <name>
          <surname>O'Neill</surname>
          <given-names>K</given-names>
        </name>
        <name>
          <surname>Karlsson</surname>
          <given-names>EK</given-names>
        </name>
        <name>
          <surname>Stange-Thomann</surname>
          <given-names>N</given-names>
        </name>
        <name>
          <surname>Anderson</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Mesirov</surname>
          <given-names>JP</given-names>
        </name>
        <name>
          <surname>Satoh</surname>
          <given-names>N</given-names>
        </name>
        <name>
          <surname>Satou</surname>
          <given-names>Y</given-names>
        </name>
        <name>
          <surname>Nusbaum</surname>
          <given-names>C</given-names>
        </name>
        <etal/>
        <article-title>Assembly of polymorphic genomes: algorithms and application to ciona savignyi</article-title>
        <source>Genome research</source>
        <year>2005</year>
        <volume>15</volume>
        <issue>8</issue>
        <fpage>1127</fpage>
        <lpage>1135</lpage>
        <pub-id pub-id-type="doi">10.1101/gr.3722605</pub-id>
        <?supplied-pmid 16077012?>
        <pub-id pub-id-type="pmid">16077012</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B8">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Velasco</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Zharkikh</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Troggio</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Cartwright</surname>
          <given-names>DA</given-names>
        </name>
        <name>
          <surname>Cestaro</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Pruss</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Pindo</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>FitzGerald</surname>
          <given-names>LM</given-names>
        </name>
        <name>
          <surname>Vezzulli</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Reid</surname>
          <given-names>J</given-names>
        </name>
        <etal/>
        <article-title>A high quality draft consensus sequence of the genome of a heterozygous grapevine variety</article-title>
        <source>PLoS One</source>
        <year>2007</year>
        <volume>2</volume>
        <issue>12</issue>
        <fpage>1326</fpage>
        <pub-id pub-id-type="doi">10.1371/journal.pone.0001326</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B9">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Takeuchi</surname>
          <given-names>T</given-names>
        </name>
        <name>
          <surname>Kawashima</surname>
          <given-names>T</given-names>
        </name>
        <name>
          <surname>Koyanagi</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Gyoja</surname>
          <given-names>F</given-names>
        </name>
        <name>
          <surname>Tanaka</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Ikuta</surname>
          <given-names>T</given-names>
        </name>
        <name>
          <surname>Shoguchi</surname>
          <given-names>E</given-names>
        </name>
        <name>
          <surname>Fujiwara</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Shinzato</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Hisata</surname>
          <given-names>K</given-names>
        </name>
        <etal/>
        <article-title>Draft genome of the pearl oyster <italic>Pinctada fucata</italic>: a platform for understanding bivalve biology</article-title>
        <source>DNA research</source>
        <year>2012</year>
        <volume>19</volume>
        <issue>2</issue>
        <fpage>117</fpage>
        <lpage>130</lpage>
        <pub-id pub-id-type="doi">10.1093/dnares/dss005</pub-id>
        <?supplied-pmid 22315334?>
        <pub-id pub-id-type="pmid">22315334</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B10">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Zharkikh</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Troggio</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Pruss</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Cestaro</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Eldrdge</surname>
          <given-names>G</given-names>
        </name>
        <name>
          <surname>Pindo</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Mitchell</surname>
          <given-names>JT</given-names>
        </name>
        <name>
          <surname>Vezzulli</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Bhatnagar</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Fontana</surname>
          <given-names>P</given-names>
        </name>
        <etal/>
        <article-title>Sequencing and assembly of highly heterozygous genome of <italic>Vitis vinifera </italic>L. cv Pinot Noir: Problems and solutions</article-title>
        <source>Journal of biotechnology</source>
        <year>2008</year>
        <volume>136</volume>
        <issue>1</issue>
        <fpage>38</fpage>
        <lpage>43</lpage>
        <?supplied-pmid 18538432?>
        <pub-id pub-id-type="pmid">18538432</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B11">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Clark</surname>
          <given-names>AG</given-names>
        </name>
        <article-title>Inference of haplotypes from pcr-amplified samples of diploid populations</article-title>
        <source>Molecular biology and evolution</source>
        <year>1990</year>
        <volume>7</volume>
        <issue>2</issue>
        <fpage>111</fpage>
        <lpage>122</lpage>
        <?supplied-pmid 2108305?>
        <pub-id pub-id-type="pmid">2108305</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B12">
      <mixed-citation publication-type="other">
        <name>
          <surname>Gusfield</surname>
          <given-names>D</given-names>
        </name>
        <article-title>A practical algorithm for optimal inference of haplotypes from diploid populations</article-title>
        <source>ISMB</source>
        <year>2000</year>
        <fpage>183</fpage>
        <lpage>189</lpage>
        <pub-id pub-id-type="pmid">10977079</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B13">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Excoffier</surname>
          <given-names>L</given-names>
        </name>
        <name>
          <surname>Slatkin</surname>
          <given-names>M</given-names>
        </name>
        <article-title>Maximum-likelihood estimation of molecular haplotype frequencies in a diploid population</article-title>
        <source>Molecular biology and evolution</source>
        <year>1995</year>
        <volume>12</volume>
        <issue>5</issue>
        <fpage>921</fpage>
        <lpage>927</lpage>
        <?supplied-pmid 7476138?>
        <pub-id pub-id-type="pmid">7476138</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B14">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Browning</surname>
          <given-names>BL</given-names>
        </name>
        <name>
          <surname>Browning</surname>
          <given-names>SR</given-names>
        </name>
        <article-title>A unified approach to genotype imputation and haplotype-phase inference for large data sets of trios and unrelated individuals</article-title>
        <source>The American Journal of Human Genetics</source>
        <year>2009</year>
        <volume>84</volume>
        <issue>2</issue>
        <fpage>210</fpage>
        <lpage>223</lpage>
        <pub-id pub-id-type="doi">10.1016/j.ajhg.2009.01.005</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B15">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Schwartz</surname>
          <given-names>R</given-names>
        </name>
        <etal/>
        <article-title>Theory and algorithms for the haplotype assembly problem</article-title>
        <source>Communications in Information &amp; Systems</source>
        <year>2010</year>
        <volume>10</volume>
        <issue>1</issue>
        <fpage>23</fpage>
        <lpage>38</lpage>
        <pub-id pub-id-type="doi">10.4310/CIS.2010.v10.n1.a2</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B16">
      <mixed-citation publication-type="book">
        <name>
          <surname>Rizzi</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Bafna</surname>
          <given-names>V</given-names>
        </name>
        <name>
          <surname>Istrail</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Lancia</surname>
          <given-names>G</given-names>
        </name>
        <article-title>Practical algorithms and fixed-parameter tractability for the single individual snp haplotyping problem</article-title>
        <source>Algorithms in Bioinformatics</source>
        <year>2002</year>
        <publisher-name>Springer, Berlin</publisher-name>
        <fpage>29</fpage>
        <lpage>43</lpage>
      </mixed-citation>
    </ref>
    <ref id="B17">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Li</surname>
          <given-names>H</given-names>
        </name>
        <name>
          <surname>Ruan</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Durbin</surname>
          <given-names>R</given-names>
        </name>
        <article-title>Mapping short DNA sequencing reads and calling variants using mapping quality scores</article-title>
        <source>Genome research</source>
        <year>2008</year>
        <volume>18</volume>
        <issue>11</issue>
        <fpage>1851</fpage>
        <lpage>1858</lpage>
        <pub-id pub-id-type="doi">10.1101/gr.078212.108</pub-id>
        <?supplied-pmid 18714091?>
        <pub-id pub-id-type="pmid">18714091</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B18">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Li</surname>
          <given-names>H</given-names>
        </name>
        <name>
          <surname>Durbin</surname>
          <given-names>R</given-names>
        </name>
        <article-title>Fast and accurate short read alignment with burrows-wheeler transform</article-title>
        <source>Bioinformatics</source>
        <year>2009</year>
        <volume>25</volume>
        <issue>14</issue>
        <fpage>1754</fpage>
        <lpage>1760</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btp324</pub-id>
        <?supplied-pmid 19451168?>
        <pub-id pub-id-type="pmid">19451168</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B19">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Li</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Li</surname>
          <given-names>Y</given-names>
        </name>
        <name>
          <surname>Kristiansen</surname>
          <given-names>K</given-names>
        </name>
        <name>
          <surname>Wang</surname>
          <given-names>J</given-names>
        </name>
        <article-title>Soap: short oligonucleotide alignment program</article-title>
        <source>Bioinformatics</source>
        <year>2008</year>
        <volume>24</volume>
        <issue>5</issue>
        <fpage>713</fpage>
        <lpage>714</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btn025</pub-id>
        <?supplied-pmid 18227114?>
        <pub-id pub-id-type="pmid">18227114</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B20">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Clement</surname>
          <given-names>NL</given-names>
        </name>
        <name>
          <surname>Snell</surname>
          <given-names>Q</given-names>
        </name>
        <name>
          <surname>Clement</surname>
          <given-names>MJ</given-names>
        </name>
        <name>
          <surname>Hollenhorst</surname>
          <given-names>PC</given-names>
        </name>
        <name>
          <surname>Purwar</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Graves</surname>
          <given-names>BJ</given-names>
        </name>
        <name>
          <surname>Cairns</surname>
          <given-names>BR</given-names>
        </name>
        <name>
          <surname>Johnson</surname>
          <given-names>WE</given-names>
        </name>
        <article-title>The gnumap algorithm: unbiased probabilistic mapping of oligonucleotides from next-generation sequencing</article-title>
        <source>Bioinformatics</source>
        <year>2010</year>
        <volume>26</volume>
        <issue>1</issue>
        <fpage>38</fpage>
        <lpage>45</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btp614</pub-id>
        <?supplied-pmid 19861355?>
        <pub-id pub-id-type="pmid">19861355</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B21">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Rimmer</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Phan</surname>
          <given-names>H</given-names>
        </name>
        <name>
          <surname>Mathieson</surname>
          <given-names>I</given-names>
        </name>
        <name>
          <surname>Iqbal</surname>
          <given-names>Z</given-names>
        </name>
        <name>
          <surname>Twigg</surname>
          <given-names>SR</given-names>
        </name>
        <name>
          <surname>Wilkie</surname>
          <given-names>AO</given-names>
        </name>
        <name>
          <surname>McVean</surname>
          <given-names>G</given-names>
        </name>
        <name>
          <surname>Lunter</surname>
          <given-names>G</given-names>
        </name>
        <name>
          <surname>Consortium</surname>
          <given-names>W</given-names>
        </name>
        <etal/>
        <article-title>Integrating mapping-, assembly-and haplotype-based approaches for calling variants in clinical sequencing applications</article-title>
        <source>Nature genetics</source>
        <year>2014</year>
        <volume>46</volume>
        <issue>8</issue>
        <fpage>912</fpage>
        <lpage>918</lpage>
        <pub-id pub-id-type="doi">10.1038/ng.3036</pub-id>
        <?supplied-pmid 25017105?>
        <pub-id pub-id-type="pmid">25017105</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B22">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Bansal</surname>
          <given-names>V</given-names>
        </name>
        <name>
          <surname>Bafna</surname>
          <given-names>V</given-names>
        </name>
        <article-title>Hapcut: an efficient and accurate algorithm for the haplotype assembly problem</article-title>
        <source>Bioinformatics</source>
        <year>2008</year>
        <volume>24</volume>
        <issue>16</issue>
        <fpage>153</fpage>
        <lpage>159</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btn298</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B23">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Kim</surname>
          <given-names>JH</given-names>
        </name>
        <name>
          <surname>Waterman</surname>
          <given-names>MS</given-names>
        </name>
        <name>
          <surname>Li</surname>
          <given-names>LM</given-names>
        </name>
        <article-title>Diploid genome reconstruction of ciona intestinalis and comparative analysis with ciona savignyi</article-title>
        <source>Genome research</source>
        <year>2007</year>
        <volume>17</volume>
        <issue>7</issue>
        <fpage>1101</fpage>
        <lpage>1110</lpage>
        <pub-id pub-id-type="doi">10.1101/gr.5894107</pub-id>
        <?supplied-pmid 17567986?>
        <pub-id pub-id-type="pmid">17567986</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B24">
      <mixed-citation publication-type="journal">
        <name>
          <surname>O'Rawe</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Jiang</surname>
          <given-names>T</given-names>
        </name>
        <name>
          <surname>Sun</surname>
          <given-names>G</given-names>
        </name>
        <name>
          <surname>Wu</surname>
          <given-names>Y</given-names>
        </name>
        <name>
          <surname>Wang</surname>
          <given-names>W</given-names>
        </name>
        <name>
          <surname>Hu</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Bodily</surname>
          <given-names>P</given-names>
        </name>
        <name>
          <surname>Tian</surname>
          <given-names>L</given-names>
        </name>
        <name>
          <surname>Hakonarson</surname>
          <given-names>H</given-names>
        </name>
        <name>
          <surname>Johnson</surname>
          <given-names>WE</given-names>
        </name>
        <etal/>
        <article-title>Low concordance of multiple variant-calling pipelines: practical implications for exome and genome sequencing</article-title>
        <source>Genome Med</source>
        <year>2013</year>
        <volume>5</volume>
        <issue>3</issue>
        <fpage>28</fpage>
        <pub-id pub-id-type="doi">10.1186/gm432</pub-id>
        <?supplied-pmid 23537139?>
        <pub-id pub-id-type="pmid">23537139</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B25">
      <mixed-citation publication-type="other">
        <name>
          <surname>Bodily</surname>
          <given-names>PM</given-names>
        </name>
        <name>
          <surname>Clement</surname>
          <given-names>MJ</given-names>
        </name>
        <name>
          <surname>Snell</surname>
          <given-names>Q</given-names>
        </name>
        <name>
          <surname>Fujimoto</surname>
          <given-names>MS</given-names>
        </name>
        <name>
          <surname>Ridge</surname>
          <given-names>PG</given-names>
        </name>
        <article-title>Haplotype-centered mapping for improved alignments and genetic association studies</article-title>
        <source>Proceedings of the 5th ACM Conference on Bioinformatics, Computational Biology, and Health Informatics, ACM</source>
        <year>2014</year>
        <fpage>499</fpage>
        <lpage>505</lpage>
      </mixed-citation>
    </ref>
    <ref id="B26">
      <mixed-citation publication-type="other">
        <name>
          <surname>Weisenfeld</surname>
          <given-names>NI</given-names>
        </name>
        <name>
          <surname>Yin</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Sharpe</surname>
          <given-names>T</given-names>
        </name>
        <name>
          <surname>Lau</surname>
          <given-names>B</given-names>
        </name>
        <name>
          <surname>Hegarty</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Holmes</surname>
          <given-names>L</given-names>
        </name>
        <name>
          <surname>Sogoloff</surname>
          <given-names>B</given-names>
        </name>
        <name>
          <surname>Tabbaa</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Williams</surname>
          <given-names>L</given-names>
        </name>
        <name>
          <surname>Russ</surname>
          <given-names>C</given-names>
        </name>
        <etal/>
        <article-title>Comprehensive variation discovery in single human genomes</article-title>
        <source>Nature genetics</source>
        <year>2014</year>
      </mixed-citation>
    </ref>
    <ref id="B27">
      <mixed-citation publication-type="book">
        <name>
          <surname>Donmez</surname>
          <given-names>N</given-names>
        </name>
        <name>
          <surname>Brudno</surname>
          <given-names>M</given-names>
        </name>
        <article-title>Hapsembler: an assembler for highly polymorphic genomes</article-title>
        <source>Research in Computational Molecular Biology</source>
        <year>2011</year>
        <publisher-name>Springer</publisher-name>
        <fpage>38</fpage>
        <lpage>52</lpage>
      </mixed-citation>
    </ref>
    <ref id="B28">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Li</surname>
          <given-names>Y</given-names>
        </name>
        <name>
          <surname>Hu</surname>
          <given-names>Y</given-names>
        </name>
        <name>
          <surname>Bolund</surname>
          <given-names>L</given-names>
        </name>
        <name>
          <surname>Wang</surname>
          <given-names>J</given-names>
        </name>
        <etal/>
        <article-title>State of the art de novo assembly of human genomes from massively parallel sequencing data</article-title>
        <source>Hum Genomics</source>
        <year>2010</year>
        <volume>4</volume>
        <issue>4</issue>
        <fpage>271</fpage>
        <lpage>277</lpage>
        <pub-id pub-id-type="doi">10.1186/1479-7364-4-4-271</pub-id>
        <?supplied-pmid 20511140?>
        <pub-id pub-id-type="pmid">20511140</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B29">
      <mixed-citation publication-type="other">
        <name>
          <surname>Bodily</surname>
          <given-names>P</given-names>
        </name>
        <name>
          <surname>Clement</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Price</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Okuda</surname>
          <given-names>N</given-names>
        </name>
        <name>
          <surname>Fujimoto</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Snell</surname>
          <given-names>Q</given-names>
        </name>
        <name>
          <surname>Lyman</surname>
          <given-names>C</given-names>
        </name>
        <article-title>Application of a max-cut heuristic to the contig orientation problem in genome assembly</article-title>
        <source>The 2013 ACM Conference on Bioinformatics, Computational Biology and Biomedical Informatics (ACM-BCB 2013); Washington, D.C., USA</source>
        <year>2013</year>
        <fpage>476</fpage>
        <lpage>483</lpage>
      </mixed-citation>
    </ref>
    <ref id="B30">
      <mixed-citation publication-type="other">
        <name>
          <surname>Price</surname>
          <given-names>JC</given-names>
        </name>
        <name>
          <surname>Udall</surname>
          <given-names>JA</given-names>
        </name>
        <name>
          <surname>Bodily</surname>
          <given-names>PM</given-names>
        </name>
        <name>
          <surname>Ward</surname>
          <given-names>JA</given-names>
        </name>
        <name>
          <surname>Schatz</surname>
          <given-names>MC</given-names>
        </name>
        <name>
          <surname>Page</surname>
          <given-names>JT</given-names>
        </name>
        <name>
          <surname>Jensen</surname>
          <given-names>JD</given-names>
        </name>
        <name>
          <surname>Snell</surname>
          <given-names>QO</given-names>
        </name>
        <name>
          <surname>Clement</surname>
          <given-names>MJ</given-names>
        </name>
        <article-title>De novo identification of "heterotigs" towards accurate and in-phase assembly of complex plant genomes</article-title>
        <source>Proceedings of the 2012 International Conference on Bioinformatics &amp; Computational Biology</source>
        <year>2012</year>
        <fpage>144</fpage>
        <lpage>150</lpage>
      </mixed-citation>
    </ref>
    <ref id="B31">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Fasulo</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Halpern</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Dew</surname>
          <given-names>I</given-names>
        </name>
        <name>
          <surname>Mobarry</surname>
          <given-names>C</given-names>
        </name>
        <article-title>Efficiently detecting polymorphisms during the fragment assembly process</article-title>
        <source>Bioinformatics</source>
        <year>2002</year>
        <volume>18</volume>
        <issue>suppl 1</issue>
        <fpage>294</fpage>
        <lpage>302</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/18.suppl_1.S294</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B32">
      <mixed-citation publication-type="other">
        <name>
          <surname>Bodily</surname>
          <given-names>P</given-names>
        </name>
        <name>
          <surname>Price</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Clement</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Snell</surname>
          <given-names>Q</given-names>
        </name>
        <article-title>Scaffoldscaffolder: An aggressive scaffold finishing algorithm</article-title>
        <source>Proceedings of the 2012 International Conference on Bioinformatics &amp; Computational Biology</source>
        <year>2012</year>
        <fpage>385</fpage>
        <lpage>390</lpage>
      </mixed-citation>
    </ref>
    <ref id="B33">
      <mixed-citation publication-type="other">
        <name>
          <surname>Okuda</surname>
          <given-names>N</given-names>
        </name>
        <name>
          <surname>Bodily</surname>
          <given-names>P</given-names>
        </name>
        <name>
          <surname>Price</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Clement</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Snell</surname>
          <given-names>Q</given-names>
        </name>
        <article-title>Hapmaker: Synthetic haplotype generator</article-title>
        <source>Proceedings of the 2013 International Conference on Bioinformatics &amp; Computational Biology</source>
        <year>2013</year>
        <fpage>370</fpage>
        <lpage>374</lpage>
      </mixed-citation>
    </ref>
    <ref id="B34">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Huang</surname>
          <given-names>W</given-names>
        </name>
        <name>
          <surname>Li</surname>
          <given-names>L</given-names>
        </name>
        <name>
          <surname>Myers</surname>
          <given-names>JR</given-names>
        </name>
        <name>
          <surname>Marth</surname>
          <given-names>GT</given-names>
        </name>
        <article-title>Art: a next-generation sequencing read simulator</article-title>
        <source>Bioinformatics</source>
        <year>2012</year>
        <volume>28</volume>
        <issue>4</issue>
        <fpage>593</fpage>
        <lpage>594</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btr708</pub-id>
        <?supplied-pmid 22199392?>
        <pub-id pub-id-type="pmid">22199392</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B35">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Langmead</surname>
          <given-names>B</given-names>
        </name>
        <name>
          <surname>Trapnell</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Pop</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Salzberg</surname>
          <given-names>SL</given-names>
        </name>
        <etal/>
        <article-title>Ultrafast and memory-efficient alignment of short DNA sequences to the human genome</article-title>
        <source>Genome Biol</source>
        <year>2009</year>
        <volume>10</volume>
        <issue>3</issue>
        <fpage>25</fpage>
        <pub-id pub-id-type="doi">10.1186/gb-2009-10-3-r25</pub-id>
      </mixed-citation>
    </ref>
  </ref-list>
</back>
