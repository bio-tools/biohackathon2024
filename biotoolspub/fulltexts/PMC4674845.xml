<?DTDIdentifier.IdentifierValue article.dtd?>
<?DTDIdentifier.IdentifierType system?>
<?SourceDTD.DTDName article.dtd?>
<?SourceDTD.Version 1.0?>
<?ConverterInfo.XSLTName bmc2nlmx2.xsl?>
<?ConverterInfo.Version 2?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">BMC Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">BMC Bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>BMC Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="epub">1471-2105</issn>
    <publisher>
      <publisher-name>BioMed Central</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">4674845</article-id>
    <article-id pub-id-type="publisher-id">1471-2105-16-S17-S10</article-id>
    <article-id pub-id-type="doi">10.1186/1471-2105-16-S17-S10</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Research</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>SpliceJumper: a classification-based approach for calling splicing junctions from RNA-seq data</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" id="A1">
        <name>
          <surname>Chu</surname>
          <given-names>Chong</given-names>
        </name>
        <xref ref-type="aff" rid="I1">1</xref>
      </contrib>
      <contrib contrib-type="author" id="A2">
        <name>
          <surname>Li</surname>
          <given-names>Xin</given-names>
        </name>
        <xref ref-type="aff" rid="I1">1</xref>
      </contrib>
      <contrib contrib-type="author" corresp="yes" id="A3">
        <name>
          <surname>Wu</surname>
          <given-names>Yufeng</given-names>
        </name>
        <xref ref-type="aff" rid="I1">1</xref>
        <email>ywu@engr.uconn.edu</email>
      </contrib>
    </contrib-group>
    <aff id="I1"><label>1</label>Department of Computer Science and Engineering, University of Connecticut, 371 Fairfield Way, Unit 2155, 06269 Storrs, CT, U.S.A</aff>
    <pub-date pub-type="collection">
      <year>2015</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>7</day>
      <month>12</month>
      <year>2015</year>
    </pub-date>
    <volume>16</volume>
    <issue>Suppl 17</issue>
    <supplement>
      <named-content content-type="supplement-title">Selected articles from the Fourth IEEE International Conference on Computational Advances in Bio and medical Sciences (ICCABS 2014): Bioinformatics</named-content>
      <named-content content-type="supplement-editor">Jake Chen, Yury Khudyakov, Vasant Honavar, Ion Mandoiu, Sanguthevar Rajasekaran and Alex Zelikovsky</named-content>
      <named-content content-type="supplement-sponsor">Publication of this supplement has not been supported by sponsorship. Information about the source of funding for publication charges can be found in the individual articles. Articles have undergone the journal's standard peer review process for supplements.</named-content>
    </supplement>
    <fpage>S10</fpage>
    <lpage>S10</lpage>
    <permissions>
      <copyright-statement>Copyright © 2015 Chu et al.</copyright-statement>
      <copyright-year>2015</copyright-year>
      <copyright-holder>Chu et al.</copyright-holder>
      <license license-type="open-access" xlink:href="http://creativecommons.org/licenses/by/4.0">
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0">http://creativecommons.org/licenses/by/4.0</ext-link>), which permits unrestricted use, distribution, and reproduction in any medium, provided the original work is properly cited. The Creative Commons Public Domain Dedication waiver (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/publicdomain/zero/1.0/">http://creativecommons.org/publicdomain/zero/1.0/</ext-link>) applies to the data made available in this article, unless otherwise stated.</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="http://www.biomedcentral.com/1471-21-5/16/S17/S10"/>
    <abstract>
      <sec>
        <title>Background</title>
        <p>Next-generation RNA sequencing technologies have been widely applied in transcriptome profiling. This facilitates further studies of gene structure and expression on the genome wide scale. It is an important step to align reads to the reference genome and call out splicing junctions for the following analysis, such as the analysis of alternative splicing and isoform construction. However, because of the existence of introns, when RNA-seq reads are aligned to the reference genome, reads can not be fully mapped at splicing sites. Thus, it is challenging to align reads and call out splicing junctions accurately.</p>
      </sec>
      <sec>
        <title>Results</title>
        <p>In this paper, we present a classification based approach for calling splicing junctions from RNA-seq data, which is implemented in the program SpliceJumper. SpliceJumper uses a machine learning approach which combines multiple features extracted from RNA-seq data. We compare SpliceJumper with two existing RNA-seq analysis approaches, TopHat2 and MapSplice2, on both simulated and real data. Our results show that SpliceJumper outperforms TopHat2 and MapSplice2 in accuracy. The program SpliceJumper can be downloaded at <ext-link ext-link-type="uri" xlink:href="https://github.com/Reedwarbler/SpliceJumper">https://github.com/Reedwarbler/SpliceJumper</ext-link>.</p>
      </sec>
    </abstract>
    <kwd-group>
      <kwd>splicing junction calling</kwd>
      <kwd>RNA-seq</kwd>
      <kwd>sequence reads alignment</kwd>
      <kwd>support vector machine</kwd>
    </kwd-group>
    <conference>
      <conf-date>2-4 June 2014</conf-date>
      <conf-name>Fourth IEEE International Conference on Computational Advances in Bio and medical Sciences (ICCABS 2014)</conf-name>
      <conf-loc>Miami Beach, FL, USA</conf-loc>
    </conference>
  </article-meta>
</front>
<body>
  <sec>
    <title>Introduction</title>
    <p>With the development of high-throughput sequencing technologies, RNA-seq has been widely applied in transcriptome profiling. This facilitates the further studies of gene structure and expression on the genome wide scale. One of the opportunities provided by RNA-seq is detecting splicing junctions. In eukaryotic genomes, splicing is a process that exons join together and introns are excluded to form the mature mRNA. Recent studies show that variations in splicing patterns are associated with Alzheimer [<xref ref-type="bibr" rid="B1">1</xref>] and other complex diseases [<xref ref-type="bibr" rid="B2">2</xref>]. Thus, detecting splicing junctions not only helps to profile transcriptomes, but also contributes to the understanding of the mechanism of some complex diseases. In this paper, we focus on calling splicing junctions from RNA-seq data of organisms that have released reference genomes.</p>
    <p>Over the past several years, many sophisticated computational approaches for calling splicing junctions from RNA-seq data have been developed [<xref ref-type="bibr" rid="B3">3</xref>-<xref ref-type="bibr" rid="B6">6</xref>]. But it is still challenging to call out splicing junctions accurately. One difficulty is that because of the discrete nature of RNA-seq data, reads spanning splice sites cannot be fully mapped to the reference genome. Situation becomes worse when reads span three or more exons. A common strategy is to map reads that span two or more exons as split-mapped reads. Split-mapped read means that one wants to map segments of the read onto multiple disjoint genomic regions (which correspond to the exons). Most existing RNA-seq reads alignment tools, such as TopHat [<xref ref-type="bibr" rid="B3">3</xref>,<xref ref-type="bibr" rid="B7">7</xref>], MapSplice [<xref ref-type="bibr" rid="B4">4</xref>], STAR [<xref ref-type="bibr" rid="B8">8</xref>], PALMapper [<xref ref-type="bibr" rid="B9">9</xref>], GSNAP [<xref ref-type="bibr" rid="B10">10</xref>], PASS [<xref ref-type="bibr" rid="B11">11</xref>], and GEM [<xref ref-type="bibr" rid="B12">12</xref>], are able to handle split-mapped reads with large or small gaps. But because of the repeats on genome, reads errors, and the short length of unmapped segments, it is still difficult to align the unmapped segments correctly. Another challenge is that the coverage of reads is uneven, and the expression level of many transcripts is low. Thus many exons are covered by only a few or even no reads. This can make it difficult to call out junctions especially for tools relying on coverage to form exon islands. Another issue is that many tools only use part of the information contained in the reads. For example, TopHat [<xref ref-type="bibr" rid="B7">7</xref>] only uses reads coverage to call splicing junctions. In principle, using more information, e.g. number of discordant encompassing pairs and number of split-mapped reads, contained in the reads may make junction calling more accurate. Moreover. the past study of RNA in organisms such as humans has accumulated substantial knowledge about RNA structure. Ideally, calling splice junctions can be assisted by these prior knowledge. Thus, it is useful to develop new tools that use more information contained in RNA-seq data and also the prior knowledge about the RNA structure to achieve higher sensitivity and specificity of the called splicing junctions.</p>
    <p>In this paper, we introduce a new approach, SpliceJumper, which uses a machine learning approach that combines multiple features extracted from RNA-seq paired-end reads. There are three steps for SplicJumper. First, we align the raw reads to genome sequence using BWA [<xref ref-type="bibr" rid="B13">13</xref>] and call out all the candidate splicing sites. Then, we classify the true and false splicing sites using a machine learning approach by combining several features extracted from the reads. Finally, we call out the splicing junctions with the true splicing sites, and paired-end reads are used to filter out the false ones. The main idea behind our approach is that we treat the problem of calling splicing sites as a classification problem. Then, we use the called out splicing sites to guide the re-alignments of reads that are initially not fully mapped. This allows accurate calling of splicing junctions.</p>
    <p>There are three main aspects for SpliceJumper:</p>
    <p>1) SpliceJumper uses a machine learning approach to call out true splicing sites by combining more features. Also, information contained in paired-end reads is used by SpliceJumper. As in many situations, it is not easy to call out splicing junctions using only one or two features. So combining more features helps to improve sensitivity and specificity. Moreover, we use an efficient classification approach to combine all these features.</p>
    <p>2) Similar to many existing approaches, we also re-align the initially unmapped reads. The difference is that we try to re-align the unmapped parts in focal regions with the help of the called out splicing sites. This way, it not only works efficiently, but also helps to filter out ambiguous alignments. We show that SpliceJumper outperforms TopHat2 and MapSplice2 in accuracy on both simulation and real data.</p>
    <p>3) Unlike tools such as TopHat, MapSplice, or other tools that require user-provided threshold parameters to call out splicing junctions, SpliceJumper learns the parameters through the training procedure. Thus there is no need for users to set any thresholds.</p>
  </sec>
  <sec>
    <title>Background</title>
    <sec>
      <title>Signatures of splicing junctions on reads</title>
      <p>Alternative splicing is a regulated process during gene expression that results in a single gene coding for multiple proteins. In this process, some exons of a gene may be included within, or excluded from, the final processed messenger RNA (mRNA) produced from that gene [<xref ref-type="bibr" rid="B14">14</xref>]. Each alternative splicing event happens at a donor site and an acceptor site. And these two splicing sites form a splicing junction. When sequenced reads are taken from a splicing site, various signatures left by the splicing junction may be found from the reads. Figure <xref ref-type="fig" rid="F1">1</xref> illustrates an alternative splicing event. A, B, C, and D are four splicing sites, and three splicing junctions, [A,B], [C,D], and [A,D], are formed.</p>
      <fig id="F1" position="float">
        <label>Figure 1</label>
        <caption>
          <p><bold>Features indicating existence of splicing junctions: discordant encompassing pairs, split-mapped reads, and coverage change at two neighbor regions of a splicing site</bold>. A, B, C, and D are four splicing sites.</p>
        </caption>
        <graphic xlink:href="1471-2105-16-S17-S10-1"/>
      </fig>
      <p>There are mainly three types of signatures that can be extracted from the RNA-seq reads around splicing sites.</p>
      <p>(i) Discordant encompassing pair signature: the number of discordant encompassing pairs. A discordant pair has insert size from the two mapped reads outside the range [m-3v,m+3v], where m is the mean insert size, and v is the standard variation of the insert size. If the length of a splicing junction is large enough, then a pair-end reads encompassing the splicing junction will become discordant after aligned to the reference genome. Figure <xref ref-type="fig" rid="F1">1</xref> shows two discordant pairs that encompass splicing junctions [C,D] and [A,D].</p>
      <p>(ii) Split-mapped reads signature: the number of split-mapped reads. Reads spanning splicing sites may be clip-mapped at the splicing sites. Thus, each read will be split into two or more segments. If all these segments are aligned correctly, the split-mapped read may reveal the positions of the splicing sites. Figure <xref ref-type="fig" rid="F1">1</xref> shows three split-mapped reads that span splicing sites A, B, C, and D. Take the read split-mapped at sites A and B as an example. The partially mapped segment (the left segment) clipped at site A indicates site A is a potential splicing site. And the clipped segment (the right segment) can be mapped at site B that indicates site B is also a potential splicing site.</p>
      <p>(iii) Coverage changing signature: the coverage change between left and right neighboring regions. Coverage change will be apparent from left neighboring region to right neighbor region of a splicing site. This is because no reads will be mapped at the right region of a donnor site, and no reads aligned at the left region of an acceptor site. Figure <xref ref-type="fig" rid="F1">1</xref> shows the coverage changing of the four splicing sites A, B, C, and D.</p>
      <p>More detailed information of parsing features from RNA-seq data are explained in the Method section.</p>
    </sec>
    <sec>
      <title>Existing approaches</title>
      <p>During the past few years, many tools have been developed to call splicing junctions. According to features used and strategies to combine features, there are two main types of approaches. The first is "exon inference" based approach, which uses coverage information to infer exons first, and then align initially unmapped reads and call splicing junctions. One tool is TopHat which first infers exon islands with the initially mapped reads aligned by Bowtie [<xref ref-type="bibr" rid="B15">15</xref>,<xref ref-type="bibr" rid="B16">16</xref>]. Then TopHat concatenates the potential exons using the known splicing motifs, and finally re-aligns the initially unmapped reads to the jointed exons. Another similar tool is PASSION [<xref ref-type="bibr" rid="B6">6</xref>]. PASSION also builds exon islands from initially mapped reads. Then it uses the pattern growth algorithm to split and align unmapped reads. And finally a filtering strategy is used to call out splicing junctions. When coverage is high, this kind of approaches is expected to work well. However, when coverage is low, these approaches may not work well. For example, because of the existence of errors (reads errors or alignment errors), variations, or the uneven coverage, there may be no reads covering some (small or large) regions of an exon. Thus the exon will be partitioned into two or even more "exons" in this step. This not only affects the alignments of reads in the following steps, but also introduces many false positives.</p>
      <p>The second type of approach is "gap alignment" based. There are two main steps for this kind of approaches. The first step is a "seed-extend" process that splits reads into segments (called kmers), which are then aligned to the reference genome independently. If a segment cannot be initially mapped, sometimes its neighboring segments are mapped. If this segment can be reconstructed by extending its neighboring regions, the gap spanned by this segment is considered as a potential splicing junction and is called out. In the second step, true splicing junctions are called out according to some threshold parameters. MapSplice is a tool of this kind. In the second step, each potential splicing junction is scored by MapSplice according to anchor significance and entropy. Another similar approach is TopHat2, which is an improved version of TopHat. One difference between TopHat2 and MapSplice is that TopHat2 first aligns reads to transcriptome that are generated from provided annotations. It is believed that "gap alignment" based approaches perform better than "exon inference" based methods, especially when the expression level or coverage is low [<xref ref-type="bibr" rid="B17">17</xref>]. However, this kind of approaches also has its own limitations. For example, the length of many splicing junctions is several thousands bases or even larger, and many kmers may be ambiguously mapped in such a long region. Thus it can be difficult for those tools to distinguish which is the true alignment, even using some anchor based strategies.</p>
      <p>Besides these two main kinds of approaches, there are other approaches that combine different features, such as TrueSight [<xref ref-type="bibr" rid="B5">5</xref>]. TrueSight combines RNA-seq read mapping quality and coding potential of genomic sequence into a model, which is trained by iterative logistic regression. Then TrueSight uses the model to de novo identify splicing junctions and filter out unreliable ones. One issue is that TrueSight views each candidate junction as a whole and this may introduce false positives. For example, if the donor site is of high confidence (have strong features) while the acceptor site is a false one, then it is quite possible for TrueSight to call this splicing junction as a true one. This can introduce false positives.</p>
      <p>In this paper, we compare the performance of SpliceJumper with two tools. One is TopHat2. TopHat2 is widely used for splicing junction calling and RNA-seq reads alignment. The other is MapSplice. MapSplice performs well for both reads alignments and splicing junction calling according to two assessment papers [<xref ref-type="bibr" rid="B17">17</xref>,<xref ref-type="bibr" rid="B18">18</xref>].</p>
    </sec>
  </sec>
  <sec>
    <title>Methods</title>
    <sec>
      <title>High-level approach</title>
      <p>Our approach, SpliceJumper, aims to call splicing junctions from RNA-seq paired-end reads, and also align the reads. There are mainly three steps to call out the splicing junctions. First, SpliceJumper aligns the raw reads to the reference sequence using BWA, and calls out all the candidate splicing sites. As each candidate splicing site is either a true one or a false one, this problem can be viewed as a classification problem. So it is natural to use machine learning approaches to perform classification. Thus in the second step we use a supervised machine learning approach to call splicing sites. We choose supervised machine learning because for both real and simulation data, we have enough labeled data as training data. To train a model, choosing the appropriate features is important. SpliceJumper uses four features parsed from the three signatures explained in the Background Section. After parsing all the features, SpliceJumper trains a model using the training data. Then with the trained model, SpliceJumper calls out the splicing sites. Finally, in the third step, we call out the splicing junctions with the called out splicing sites. In this step, each called out splicing junction should satisfy three conditions: 1)Both the donor and acceptor sites are the true ones that are called out in the second step. 2) At least one read is split-mapped at the donor and acceptor sides. 3) The distance between the mapped segment and the clipped segment is concordant with the insert size between the split-mapped read and its mapped mate read. And also, the reads alignment is finished during this procedure.</p>
    </sec>
    <sec>
      <title>Details of our approach</title>
      <p>SpliceJumper calls splicing junctions in three steps. In the first step, BWA is used to align the raw reads to the reference genome and from the BAM file we call out all the candidate splicing sites. Then we collect all the features of each candidate splicing site, train a SVM model based on training data, and then call out the true ones using the trained model. Finally, we call out splicing junctions with the true splicing sites.</p>
      <sec>
        <title>Preprocessing and candidate splicing sites calling</title>
        <p>SpliceJumper requires BAM files (sorted and indexed) as input. So before calling candidate splicing sites, BWA (or other alignment tools reporting soft-clipped and hard-clipped alignments) is used to align the raw reads to the reference genome. Then reads are classified to three types according to the alignment type: fully mapped reads, clip-mapped reads including soft-clipped and hard-clipped reads, and other reads. Fully mapped reads refer to the reads that can be fully aligned to the reference. BWA only reports the primary alignment. So if only a part of a read is primarily aligned, the read will be reported as a clip-mapped read. Depending on whether the clipped part is ambiguously mapped or not, clip-mapped reads are classified as hard-clipped reads and soft-clipped reads. Other reads are mainly unmapped reads, which usually refer to those reads that are mapped to the junction of two adjacent reference sequences. In our approach, reads with low mapping quality or unmapped are discarded. During the process of classifying reads, reads coverage is calculated. If a read pair is discordant, we also mark the positions of the read pair.</p>
        <p>To call candidate splicing sites, our approach is based on two observations: 1) For splicing sites with enough reads covered, when aligned to the reference genome, reads will be clip-mapped at the splicing sites. 2) For splicing sites without enough reads covered, there may be no reads clip-mapped at the splicing sites. But the read coverage will change near the splicing sites. For example, maybe there is only one read fully mapped within an exon, and we can call out this type of candidate splicing sites through coverage change. If read coverage at some sites decreases to zero or increases from zero, then this site is also called out as a candidate junction site. Thus, two types of candidate sites are called out at this stage: one is the read clip position, and the other is the coverage change position. Figure <xref ref-type="fig" rid="F2">2</xref> shows an example of the two types of candidate splicing sites. Figure <xref ref-type="fig" rid="F2">2(a)</xref> is a type one candidate splicing site. We can see many reads are clipped at the splicing sites. Figure <xref ref-type="fig" rid="F2">2(b)</xref> is a type two candidate splicing site, which does not have enough reads covered, and no reads clipped at the splicing sites, but there is coverage change. Candidate splicing sites within s bases (by default s = 10) from each other are combined. SpliceJumper provides a "-s" option for users to set s. Each candidate site is given a direction to indicate whether it is an candidate donor site or candidate acceptor site. For the first type of candidate sites, site direction is decided by the reads clip direction. If most of the reads are left-segment clipped, then it is a candidate donor site. Otherwise it is a candidate acceptor site. For the second type of candidate sites, if coverage changes from zero to some value then it is an acceptor site. Otherwise it is a donor site. Note that not all splicing sites will be called out at this step. Some of these missed splicing sites may still be called during the reads re-alignment step.</p>
        <fig id="F2" position="float">
          <label>Figure 2</label>
          <caption>
            <p><bold>Two types of candidate splicing sites: Figure (a) shows candidate splicing sites called out by clipped reads; Figure (b) shows candidate splicing sites called out by coverage changing</bold>.</p>
          </caption>
          <graphic xlink:href="1471-2105-16-S17-S10-2"/>
        </fig>
      </sec>
      <sec>
        <title>Feature parsing</title>
        <p>Once the candidate splicing sites are called out, SpliceJumper collects features for each site. We extract four features from the three signatures mentioned in the Background Section. A clipped read contains two types of segments: partially mapped segments and clipped segments. Different types of segments provide information for different splicing sites. So we collect the two features from the split-mapped reads signature: (i) the number of reads clipped at candidate sites, and (ii) the number of clipped segments mapped at candidate sites. From the other two signatures we collect two features: (iii) the number of discordant encompassing paired-end reads, and (iv) the coverage difference between the left and right neighbor regions. Thus, each candidate site will be represented by four features and be viewed as a point in four dimensional space. In this way, the splicing sites calling problem is converted to a classification problem.</p>
        <p>(i) Reads clipped at candidate sites: the number of reads clipped at candidate sites. Because of the existence of introns, reads spanning the splicing sites cannot be fully mapped and are reported as soft-clipped or hard-clipped alignments. This provides us not only the positions of splicing sites, but also strong evidence that the candidate splicing sites may be the true ones. Figure <xref ref-type="fig" rid="F1">1</xref> shows three reads clipped at splicing sites.</p>
        <p>(ii) Clipped segments mapped at candidate sites: the number of clipped segments, which initially cannot find primary alignments when aligned with BWA, but are mapped at candidate splicing sites in the re-alignment stage.</p>
        <p>To obtain the quantity of this feature, we re-align the clipped segments to the reference genome. For hard-clipped reads, because the clipped segments are not reported in the alignments, we trace the original reads from the raw read files (in fastq format) according to the "qname" field of alignments. Thus all hard-clipped reads are transformed to soft-clipped reads. Then for each soft-clipped read, we do re-alignment based on the observation that if a read is clipped at one side of a junction, then the clipped segment should align at the other side of the junction. So for the suffix soft-clipped reads, we align the clipped segment to candidate acceptor sites following down the reference genome. And for prefix soft-clipped reads, we try to align them to candidate donor sites following up the reference genome. If both the suffix and prefix of a read are clipped, then it is quite likely that the read spans more than two exons. In this case, we align both the suffix and prefix clipped segments separately following the same strategy. Suppose the read is clipped at <italic>b</italic><sub>0</sub>, and we use [<italic>b</italic><sub>1</sub>, <italic>b</italic><sub>2</sub>] to indicate the region where to search the alignment. The insert size of paired-end reads is used to bound the searching. If the suffix (or prefix) segment of a read is clipped, and the mate read is mapped at the right (or left) side of this read, then the mapping position <italic>b<sub>p </sub></italic>of the mate read can be used as the right (or the left) boundary of the searching. Then the searching region becomes [<italic>b</italic><sub>0</sub>, <italic>b<sub>p</sub></italic>] (or [<italic>b<sub>p</sub>, b</italic><sub>0</sub>]). Figure <xref ref-type="fig" rid="F3">3</xref> shows an example of how paired-end reads are used to guide the alignments. 1a and 1b are a pair, and 1a is fully mapped at E (right end of 1a) while 1b is clipped at position D. Thus, [E,D] forms a focal region to align the clipped segment of 1b. Because 1b is clipped at an acceptor site, we try to align the clipped segment at donor sites in region [E,D]. Because the clipped segment is short, we find two alignments at A and C. The insert size between 1a and 1b here is used to call out the correct one. The alignment at C is likey to be false because otherwise 1a and 1b will form a discordant pair. But this is not very likely and so the alignment at position A is chosen.</p>
        <fig id="F3" position="float">
          <label>Figure 3</label>
          <caption>
            <p><bold>Illustration of paired-end reads that are used to guide the alignment and filter out false splicing junctions</bold>. A, B, C and D are four called out splicing sites. 1(1a and 1b), 2(2a and 2b), and 3(3a and 3b) are three pairs. 1a, 2a, and 3b are fully mapped, while 1b, 2b, and 3a are split-mapped. The right end of 1a is aligned at site E, and [E,D] forms a focal region to align the clipped segment of 1b. Insert size between 1a and 1b can be used to guide the alignment of the clipped segment of 1b: the clipped segment is short and can be aligned at both position A and C, but the alignment at C is wrong because otherwise 1a and 1b form a discordant pair which has low probability. Thus alignment at position A is chosen. Paired-end reads can also be used to filter out false splicing junctions. Splicing junction [C,D] is considered as a false one, because although read 2b is split-mapped at position C and D, 2a and 2b will form a discordant pair if the alignment of 2b is correct. Thus a conflict happens, and SpliceJumper will report [C,D] a false positive. In contrast, splicing junction [A,B] is considered as a true splicing junction.</p>
          </caption>
          <graphic xlink:href="1471-2105-16-S17-S10-3"/>
        </fig>
        <p>If no paired-end reads can be used as the boundary, a maximum junction size with default value 1,500,000 bp is used as the boundary. For reads clipped at donor (acceptor) sites, the searching region is [<italic>b</italic><sub>0</sub>,<italic>b</italic><sub>0</sub>+1500000] ([<italic>b</italic><sub>0</sub>-1500000,<italic>b</italic><sub>0</sub>]). We try to find an alignment around related splicing sites in the searching region. Here, "related" means for reads clipped at donor sites, we only check candidate acceptor sites; and conversely for reads clipped at acceptor sites, we only check candidate donor sites. If an alignment can still not be found, then we try to align the segment within the whole region [<italic>b</italic><sub>1</sub>, <italic>b</italic><sub>2</sub>] using local alignment. And if the segment finds an alignment at position <italic>p<sub>new </sub></italic>, then <italic>p<sub>new </sub></italic>will be viewed as a new candidate splicing site and is added into the candidate splicing sites list. If the clipped segment finds an alignment at candidate site <italic>c<sub>j </sub></italic>, then the number of clipped segments mapped at <italic>c<sub>j </sub></italic>is increased by one.</p>
        <p>(i) Discordant encompassing pair: the number of discordant encompassing pairs.</p>
        <p>Recall that a discordant pair has insert size from the two mapped reads outside the range [m-3v,m+3v], where m is the mean insert size, and v is the standard variation of the insert size. See Figure <xref ref-type="fig" rid="F1">1</xref> for an illustration of discordant encompassing pair for splicing junctions. Note that not all the junctions can make encompassing read pairs to be discordant. This is because if the length of a splicing junction is smaller than 3v, then even the read pair encompasses the junction, it still could be concordant. Our approach relies on other features to call out these splicing junctions. According to our experiments, around nine tenths of the junctions can cause encompassing pairs to be discordant. Thus, discordant encompassing pair is still a useful feature for calling splicing junctions.</p>
        <p>(ii) Coverage difference between left and right neighboring regions: for candidate donor (acceptor) sites, it is the average coverage of left (right) region minus the average coverage of right (left) region. The average coverage of a region is calculated by: <inline-formula><mml:math id="M1" name="1471-2105-16-S17-S10-i1" overflow="scroll"><mml:msubsup><mml:mrow><mml:mo class="MathClass-op"> ∑</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo class="MathClass-rel">=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mi>L</mml:mi><mml:mi>d</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:msubsup><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow><mml:mo class="MathClass-bin">/</mml:mo><mml:msub><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula>, where <italic>L<sub>d </sub></italic>is the length of the region and <italic>d<sub>i </sub></italic>is the read depth at position <italic>i </italic>of the region. SpliceJumper provides a "-l" option for users to set the region length (with default value 25 bp). Figure <xref ref-type="fig" rid="F1">1</xref> illustrates the coverage difference at splicing sites A, B, C and D.</p>
      </sec>
      <sec>
        <title>Classification and call out junctions</title>
        <p>After parsing all the features for each candidate splicing site, SpliceJumper uses a machine learning based approach to classify all the candidate splicing sites into the true ones and the false ones. Before training the model, for each candidate site with four features we perform normalization. This is based on the observation that coverage is quite uneven. And for a candidate site from a region with high coverage the quantity of the features will be large, while for a candidate site from a region with low coverage the quantity will be small. However, maybe both of the two sites are the true ones. Thus using the original quantity of the features may mislead the classifier. So normalization before training can improve the accuracy. For candidate donor sites, all the four features are normalized by the average coverage of the left neighboring regions. For candidate acceptor sites, all are normalized by the average coverage of the right neighboring regions.</p>
        <p><italic>Model training and classification </italic>We use support vector machine (SVM) to perform classification. In particular, we use LibSVM [<xref ref-type="bibr" rid="B19">19</xref>] to train a model, and then use the trained model to classify splicing sites. To train a model, training data that contains candidate sites and labeled with true or false should be provided. For simulation data, the true label of each candidate is known. So to prepare the training data we just label the candidate splicing sites that are ture as 1, and the rest are labeled as 0. For real data, users can train the model with released annotations, such as human annotations released by UCSC, Ensembl, Geneid, Genscan, RefSeq, SGP, AceView, Vega, etc. One problem is that not all transcripts will express in every sample. In other words although some splicing sites do exist in annotations, they may not express. So there will be no reads cover those splicing sites. This kind of splicing sites should not be considered as true ones. So before using labeled splicing sites released in annotations, first we check whether the coverage around the sites is zero or not. If larger than zero then the sites are labeled with true. In this way, we get all the positive cases of the training data. Then we randomly choose the same number of negative cases, which are sites that have reads covered but not in annotation. With the positive and negative cases, we have all the training data of real data. To train a model, 10-cross validation and grid search are used to find the optimal parameters. Then with the trained model, we classify the candidate sites in testing data into the true and false ones.</p>
        <p><italic>Junction calling </italic>After finishing classification, SpliceJumper has called out all the true splicing sites. There are two steps to call out the splicing junctions. First, we call out all the candidate splicing junctions. To call a splicing junction, first both the two sites (one is donor and the other is acceptor) of the junction should be true in classification. There should be a connection between the two sites. We say two sites are connected if there at least one read that is clipped at the donor (acceptor) site, and the clipped segment of the read can be aligned at the acceptor (donor) site. In practice, this step is finished in feature parsing step, and a graph with all the candidate sites as nodes and connecting edges is kept. In the second step, we check whether there is a conflict between the insert size and the mapping position of the clipped segment. If the mapped clipped segment leads the read pair to be discordant, then we say it is a conflict. If conflicts happen, it is quite possible that the connection between the two sites is false. This may be caused by wrong alignment of the clipped segment because the segment usually is short and there are repeats in genome. We discard this kind of splicing junctions. Figure <xref ref-type="fig" rid="F3">3</xref> shows an example: A, B, C, and D are called out splicing sites. 1(1a and 1b), 2(2a and 2b), and 3(3a and 3b) are three pairs. 1a, 2a, and 3b are fully mapped, while 1b, 2b, and 3a are split-mapped. Splicing junction [C,D] is considered as a false one, because although read 2b is split-mapped at position C and D, 2a and 2b will form a discordant pair if the alignment of 2b is correct. Thus a conflict happens, and SpliceJumper will report [C,D] as false positive. In contrast, splicing junction [A,B] is considered as a true splicing junction.</p>
      </sec>
    </sec>
  </sec>
  <sec>
    <title>Results</title>
    <p>We run SpliceJumper on both simulation and real data, and compare with TopHat 2.0.10 and MapSplice 2.1.6 on accuracy and efficiency. For simulation data, because we know the true junctions, we can calculate the number of true positive, false positive and false negative of each tool. Three metrics are used: 1) Precision=TP/(TP+FP), 2) Recall=TP/(TP+FN), and 3) F-value = 2*Precision*Recall/(Precission+Recall), where TP represents true positive, FP represents false positive, and FN represents false negative. For real data, because no true junctions are provided, we cannot directly evaluate the accuracy of called junctions of each tool. We rely on another metric: the ratio of mapped bases. RNA-seq reads alignment and splicing junction calling are related to each other. To call splicing junctions accurately the first step is to align reads correctly, and at the same time calling splicing junctions accurately can also help to guide the alignment of the unmapped reads. Thus, the ratio of mapped bases is an approximate estimate of the accuracy of called out splicing junctions. For real data, as the origin of each read is unknown, we give the ratio of mapped bases. For simulation data, because the true alignment position of each read is known, we compare the ratio of correctly mapped bases.</p>
    <sec>
      <title>Calling RNA junctions with simulated data</title>
      <p>We use the same simulated data released in [<xref ref-type="bibr" rid="B17">17</xref>]. Two datasets (Test1 and Test2 of simulation one) are used. All the reads are simulated using a tool BEERS released in the same paper. Both of the datasets are generated from 30,000 mouse build mm9 transcript models. Indel, substitution and error rates for the Test1 dataset are 0.0005, 0.001 and 0.005 respectively, and 0.0025, 0.005 and 0.01 for Test2 dataset. For each dataset, 10 million pairs of reads with read length 100bp are simulated. Wetest the accuracy of the three tools on chromosome 11. It is unfair for all the tools if there are no reads covering the splicing sites. So when calculating the accuracy, only junctions with at least one read covered are counted. Thus there are 14,939 and 15,738 benchmarked junctions on chromosome 11 for Test1 and Test2 dataset respectively. Recall that SpliceJumper requires training data. We use the splicing sites of chomosome 1 as the training data, and test the performance of the trained model on chromosome 11.</p>
      <p>To compare the called out junctions with the benchmark data, a slack value is introduced. If the distance between both the left and right sides of a called out splicing junction and a benchmarked one is smaller or equal to the slack value, then the called out one is considered as a correct one. Table <xref ref-type="table" rid="T1">1</xref> shows the change of F-value of the three tools as slack value increases from 0 to 15 for the Test1 and Test2 dataset. The results show that the F-value improves for all the three tools when the slack value increases. When the slack value is 0, MapSplice2 has the best performance but none of the three tools reaches its best performance. And when the slack value reaches 8, the F-value of all the three tools basically reaches stable values, and SpliceJumper has the best performance. Detailed results for the three tools when the slack value is 8 are shown in Table <xref ref-type="table" rid="T2">2</xref> and Table <xref ref-type="table" rid="T3">3</xref> for Test1 and Test2 dataset respectively.</p>
      <table-wrap id="T1" position="float">
        <label>Table 1</label>
        <caption>
          <p>Comparison of SpliceJumper, TopHat2 and MapSplice2 on simulation data.</p>
        </caption>
        <table frame="hsides" rules="groups">
          <thead>
            <tr>
              <th align="center">Slack value</th>
              <th align="center" colspan="2">Test1 dataset</th>
              <th/>
              <th align="center" colspan="2">Test2 dataset</th>
              <th/>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td/>
              <td align="center">
                <bold>SpliceJumper</bold>
              </td>
              <td align="center">
                <bold>TopHat2</bold>
              </td>
              <td align="center">
                <bold>MapSplice2</bold>
              </td>
              <td align="center">
                <bold>SpliceJumper</bold>
              </td>
              <td align="center">
                <bold>TopHat2</bold>
              </td>
              <td align="center">
                <bold>MapSplice2</bold>
              </td>
            </tr>
            <tr>
              <td colspan="7">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="center">0</td>
              <td align="center">0.8314</td>
              <td align="center">0.0003</td>
              <td align="center">0.8918</td>
              <td align="center">0.7940</td>
              <td align="center">0.0015</td>
              <td align="center">0.8288</td>
            </tr>
            <tr>
              <td align="center">1</td>
              <td align="center">0.8923</td>
              <td align="center">0.0016</td>
              <td align="center">0.9627</td>
              <td align="center">0.8548</td>
              <td align="center">0.0103</td>
              <td align="center">0.9319</td>
            </tr>
            <tr>
              <td align="center">2</td>
              <td align="center">0.9367</td>
              <td align="center">0.9370</td>
              <td align="center">0.9631</td>
              <td align="center">0.9156</td>
              <td align="center">0.8558</td>
              <td align="center">0.9328</td>
            </tr>
            <tr>
              <td align="center">3</td>
              <td align="center">0.9618</td>
              <td align="center">0.9377</td>
              <td align="center">0.9639</td>
              <td align="center">0.9400</td>
              <td align="center">0.9016</td>
              <td align="center">0.9471</td>
            </tr>
            <tr>
              <td align="center">4</td>
              <td align="center">0.9666</td>
              <td align="center">0.9384</td>
              <td align="center">0.9642</td>
              <td align="center">0.9491</td>
              <td align="center">0.9150</td>
              <td align="center">0.9473</td>
            </tr>
            <tr>
              <td align="center">5</td>
              <td align="center">0.9676</td>
              <td align="center">0.9390</td>
              <td align="center">0.9647</td>
              <td align="center">0.9495</td>
              <td align="center">0.9156</td>
              <td align="center">0.9476</td>
            </tr>
            <tr>
              <td align="center">6</td>
              <td align="center">0.9676</td>
              <td align="center">0.9396</td>
              <td align="center">0.9650</td>
              <td align="center">0.9562</td>
              <td align="center">0.9166</td>
              <td align="center">0.9485</td>
            </tr>
            <tr>
              <td align="center">7</td>
              <td align="center">0.9676</td>
              <td align="center">0.9397</td>
              <td align="center">0.9650</td>
              <td align="center">0.9573</td>
              <td align="center">0.9167</td>
              <td align="center">0.9502</td>
            </tr>
            <tr>
              <td align="center">8</td>
              <td align="center">0.9676</td>
              <td align="center">0.9397</td>
              <td align="center">0.9651</td>
              <td align="center">0.9578</td>
              <td align="center">0.9178</td>
              <td align="center">0.9508</td>
            </tr>
            <tr>
              <td align="center">9</td>
              <td align="center">0.9677</td>
              <td align="center">0.9397</td>
              <td align="center">0.9651</td>
              <td align="center">0.9578</td>
              <td align="center">0.9178</td>
              <td align="center">0.9508</td>
            </tr>
            <tr>
              <td align="center">10</td>
              <td align="center">0.9677</td>
              <td align="center">0.9398</td>
              <td align="center">0.9651</td>
              <td align="center">0.9578</td>
              <td align="center">0.9178</td>
              <td align="center">0.9508</td>
            </tr>
            <tr>
              <td align="center">11</td>
              <td align="center">0.9677</td>
              <td align="center">0.9398</td>
              <td align="center">0.9651</td>
              <td align="center">0.9578</td>
              <td align="center">0.9179</td>
              <td align="center">0.9510</td>
            </tr>
            <tr>
              <td align="center">12</td>
              <td align="center">0.9678</td>
              <td align="center">0.9399</td>
              <td align="center">0.9651</td>
              <td align="center">0.9578</td>
              <td align="center">0.9179</td>
              <td align="center">0.9510</td>
            </tr>
            <tr>
              <td align="center">13</td>
              <td align="center">0.9678</td>
              <td align="center">0.9399</td>
              <td align="center">0.9652</td>
              <td align="center">0.9579</td>
              <td align="center">0.9180</td>
              <td align="center">0.9510</td>
            </tr>
            <tr>
              <td align="center">14</td>
              <td align="center">0.9678</td>
              <td align="center">0.9399</td>
              <td align="center">0.9652</td>
              <td align="center">0.9579</td>
              <td align="center">0.9180</td>
              <td align="center">0.9510</td>
            </tr>
            <tr>
              <td align="center">15</td>
              <td align="center">0.9678</td>
              <td align="center">0.9400</td>
              <td align="center">0.9653</td>
              <td align="center">0.9579</td>
              <td align="center">0.9180</td>
              <td align="center">0.9510</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <p>Slack value is introduced when comparing a called out junction with a benchmarked one. And if the distance of both sides between the called out one and the benchmarked one is within the slack value then the called out one is considered as a correct one. We compare the F-value (2*Precision*Recall/(Precision+Recall)) of the three tools for different slack values. The higher the F-value the better the performance.</p>
        </table-wrap-foot>
      </table-wrap>
      <table-wrap id="T2" position="float">
        <label>Table 2</label>
        <caption>
          <p>Comparison of SpliceJumper, TopHat2 and MapSplice2 on simulated Test1 dataset when the slack value is 8.</p>
        </caption>
        <table frame="hsides" rules="groups">
          <thead>
            <tr>
              <th align="center">Tools</th>
              <th align="center">False positive</th>
              <th align="center">False negative</th>
              <th align="center">True positive</th>
              <th align="center">Precision</th>
              <th align="center">Recall</th>
              <th align="center">F-value</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="center">SpliceJumper</td>
              <td align="center">78</td>
              <td align="center">862</td>
              <td align="center">14,077</td>
              <td align="center">0.9945</td>
              <td align="center">0.9423</td>
              <td align="center">0.9677</td>
            </tr>
            <tr>
              <td align="center">TopHat2</td>
              <td align="center">248</td>
              <td align="center">1,475</td>
              <td align="center">13,430</td>
              <td align="center">0.9819</td>
              <td align="center">0.9010</td>
              <td align="center">0.9397</td>
            </tr>
            <tr>
              <td align="center">MapSplice2</td>
              <td align="center">125</td>
              <td align="center">888</td>
              <td align="center">14,006</td>
              <td align="center">0.9912</td>
              <td align="center">0.9404</td>
              <td align="center">0.9651</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <p>False positive: the number of called out junctions that are actually false ones. False negative: the number of not called out junctions that are actually true ones. True positive: the number of called out junctions that are actually true ones.</p>
        </table-wrap-foot>
      </table-wrap>
      <table-wrap id="T3" position="float">
        <label>Table 3</label>
        <caption>
          <p>Comparison of SpliceJumper, TopHat2 and MapSplice2 on simulated Test2 dataset when the slack value is 8.</p>
        </caption>
        <table frame="hsides" rules="groups">
          <thead>
            <tr>
              <th align="center">Tools</th>
              <th align="center">False positive</th>
              <th align="center">False negative</th>
              <th align="center">True positive</th>
              <th align="center">Precision</th>
              <th align="center">Recall</th>
              <th align="center">F-value</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="center">SpliceJumper</td>
              <td align="center">334</td>
              <td align="center">969</td>
              <td align="center">14,769</td>
              <td align="center">0.9779</td>
              <td align="center">0.9384</td>
              <td align="center">0.9578</td>
            </tr>
            <tr>
              <td align="center">TopHat2</td>
              <td align="center">717</td>
              <td align="center">1,784</td>
              <td align="center">13,954</td>
              <td align="center">0.9511</td>
              <td align="center">0.8866</td>
              <td align="center">0.9178</td>
            </tr>
            <tr>
              <td align="center">MapSplice2</td>
              <td align="center">358</td>
              <td align="center">1,151</td>
              <td align="center">14,587</td>
              <td align="center">0.9760</td>
              <td align="center">0.9269</td>
              <td align="center">0.9508</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <p>False positive: the number of called out junctions that are actually false ones. False negative: the number of not called out junctions that are actually true ones. True positive: the number of called out junctions that are actually true ones.</p>
        </table-wrap-foot>
      </table-wrap>
      <p>We also calculate the ratio of correctly mapped bases. For Test1 dataset, Splice-Jumper is 95.10%, while TopHat2 and MapSplice2 are 93.49% and 94.11% respectively. For Test2 dataset, SpliceJumper is 92.09%, while TopHat2 and MapSplice2 are 89.76% and 91.25% respectively.</p>
    </sec>
    <sec>
      <title>Calling RNA junctions with real data</title>
      <p>The real data is released in [<xref ref-type="bibr" rid="B20">20</xref>], which is gathered across a time-course experiment (GEO accession number: GSM818582). There are 65,352,789 pairs of reads with read length 101 bp. We compare the performance of the three tools on chromosome 11. We train the model based on the annotation released by UCSC. 8,000 splicing sites of chromosome 20 in the released annotation data are used as positive cases, and each splicing site has at least one read covered. 8,000 randomly generated sites are used as negative cases, and each site has coverage larger than zero and is not included in released annotation. SpliceJumper calls out 9,902 junctions, while TopHat2 and MapSplice2 calls out 9,836 and 9,878 junctions respectively. Because the true junctions are unknown, we use the ratio of mapped bases to evaluate the performance of the three tools. The ratio of mapped bases of SpliceJumper is 92.69%, while 90.89% and 92.13% for TopHat2 and MapSplice2 respectively. One can see SpliceJumper has the highest ratio of mapped bases.</p>
      <p>We also calculate the number of overlapped junctions of the two tools. Similar to the junction comparison in simulation section, a slack value is also introduced when checking whether one splicing junction of one tool overlaps with a splicing junction of another tool. Detailed results of number of overlapped splicing junctions as slack value increases are shown in Table <xref ref-type="table" rid="T4">4</xref>. From the results, we see that when the slack value is 7, the number of called out junctions of all the three tools converges. Splice-Jumper has 8,205 junctions overlapping with MapSplice2, and has 7,726 junctions overlapping with TopHat2, while TopHat2 has 7,526 junctions overlapping with MapSplice2.</p>
      <table-wrap id="T4" position="float">
        <label>Table 4</label>
        <caption>
          <p>Comparison of SpliceJumper, TopHat2 and MapSplice2 on real data.</p>
        </caption>
        <table frame="hsides" rules="groups">
          <thead>
            <tr>
              <th align="center">Slack value</th>
              <th align="center">SpliceJumper with MapSplice2</th>
              <th align="center">SpliceJumper with TopHat2</th>
              <th align="center">TopHat2 with MapSplice2</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="center">0</td>
              <td align="center">7,346</td>
              <td align="center">4,534</td>
              <td align="center">4,601</td>
            </tr>
            <tr>
              <td align="center">1</td>
              <td align="center">7,491</td>
              <td align="center">5,128</td>
              <td align="center">4,987</td>
            </tr>
            <tr>
              <td align="center">2</td>
              <td align="center">7,769</td>
              <td align="center">6,254</td>
              <td align="center">5,589</td>
            </tr>
            <tr>
              <td align="center">3</td>
              <td align="center">8,201</td>
              <td align="center">6,675</td>
              <td align="center">6,701</td>
            </tr>
            <tr>
              <td align="center">4</td>
              <td align="center">8,204</td>
              <td align="center">7,302</td>
              <td align="center">7,465</td>
            </tr>
            <tr>
              <td align="center">5</td>
              <td align="center">8,204</td>
              <td align="center">7,701</td>
              <td align="center">7,509</td>
            </tr>
            <tr>
              <td align="center">6</td>
              <td align="center">8,205</td>
              <td align="center">7,726</td>
              <td align="center">7,526</td>
            </tr>
            <tr>
              <td align="center">7</td>
              <td align="center">8,205</td>
              <td align="center">7,729</td>
              <td align="center">7,526</td>
            </tr>
            <tr>
              <td align="center">8</td>
              <td align="center">8,205</td>
              <td align="center">7,729</td>
              <td align="center">7,526</td>
            </tr>
            <tr>
              <td align="center">9</td>
              <td align="center">8,205</td>
              <td align="center">7,729</td>
              <td align="center">7,526</td>
            </tr>
            <tr>
              <td align="center">10</td>
              <td align="center">8,205</td>
              <td align="center">7,729</td>
              <td align="center">7,526</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <p>Slack value is introduced when comparing two junctions. If the difference between both the left sides and the right sides of two splicing junctions is smaller or equal to the slack value, then we consider these two splicing junctions overlap with each other. When the slack value reaches 7, all the three tools give stable results.</p>
        </table-wrap-foot>
      </table-wrap>
    </sec>
    <sec>
      <title>Running time and memory usage</title>
      <p>We benchmark the running time and memory usage on simulated Test1 dataset. The server configuration is: eight core CPU (Intel(R) Xeon(R) X5482 @ 3.20 GHz) with 32G memory. SpliceJumper accepts bam files aligned by BWA (or other tools which report soft-clipped and hard-clipped alignments). If only original raw reads are provided, users can run BWA (or other tools) to do alignment first. To make the fair evaluation, besides the running time of SpliceJumper, we also include the running time of BWA, model training time and predicting time. Detailed running time and memory usage are provided in Table <xref ref-type="table" rid="T5">5</xref>. The results show that the running time for the three tools are similar, and MapSplice2 is a little better. For memory usage, SpliceJumper is better.</p>
      <table-wrap id="T5" position="float">
        <label>Table 5</label>
        <caption>
          <p>Comparison of running time and memory usage for SpliceJumper, TopHat2 and MapSplice2 on simulated Test1 dataset.</p>
        </caption>
        <table frame="hsides" rules="groups">
          <thead>
            <tr>
              <th align="center">Tools</th>
              <th align="center">Running time</th>
              <th align="center">Memory</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="center">SpliceJumper</td>
              <td align="center">711 minutes and 28 seconds</td>
              <td align="center">3.14G</td>
            </tr>
            <tr>
              <td align="center">TopHat2</td>
              <td align="center">679 minutes and 18 seconds</td>
              <td align="center">6.53G</td>
            </tr>
            <tr>
              <td align="center">MapSplice2</td>
              <td align="center">548 minutes and 5 seconds</td>
              <td align="center">4.61G</td>
            </tr>
          </tbody>
        </table>
      </table-wrap>
    </sec>
  </sec>
  <sec>
    <title>Discussion</title>
    <p>We show in this paper that SpliceJumper is more accurate than TopHat2 and Map-Splice2 on both the simulated and real datasets for calling splicing junctions. Splice-Jumper achieves higher accuracy due to three improvements. First, SpliceJumper views each splicing site independently, and extracts more features for each splicing site. For example, SpliceJumper uses the discordant encompassing pair feature that is not used by TopHat2 and MapSplice2. This feature is a strong feature to indicate the existence of splicing junctions. Second, SpliceJumper uses a machine learning approach to combine the features, which not only uses the features in a more effective way, but also avoids the threshold parameters setting issue. Finally, with the called out splicing sites, the clipped segments can be aligned in focal regions, which improves the accuracy. For illustration, we show an example from the simulated Test1 dataset analyzed in the Results Section. Figure <xref ref-type="fig" rid="F4">4</xref> shows the IGV [<xref ref-type="bibr" rid="B21">21</xref>] view of a region from 3,032,644 to 3,036,223 of chromosome 11. The splicing sites are labeled from 1 to 9. We can see that all the nine splicing sites have strong features: many reads are clipped at the splicing sites; there is significant coverage change between the two neighbor regions of the splicing sites; and many discordant read pairs encompass the splicing sites. SpliceJumer calls out all the marked nine splicing sites correctly. Reads marked as A, B, C, and D are clipped and also discordant with their mate reads. For example, the "cigar" field for A and B are "14S10M1I75M" and "21S10M1I68M" respectively, and the mate read mapping positions for A and B are 3,032,234 and 3,032,253 respectively. From the benchmark data, we know there is a junction from 3,033,210 to 3,035,657 which indicates an alternative splicing event at site 1 and site 8. SpliceJumper correctly calls out this splicing junction, while neither TopHat2 nor MapSplice2 calls out this junction. One reason is that for the clipped reads such as A or B, the clipped segment is short (14 bp for A and 21 bp for B), and the region between site 1 and site 8 is long (2,447 bp). Also there are three exons between them. So it is quite possible for the clipped segments aligned to ambiguous positions that neither TopHat2 nor MapSplice2 can distinguish. In contrast, SpliceJumper first tries to align the clipped segments to focal regions, not the whole region. Consider the read A in the above example. Because it is clipped at an acceptor site. So to align the clipped segment we only check the focal regions of site 7, 5, 3, and then 1. Even when the clipped segment is short, SpliceJumper is still able to align it to the correct position.</p>
    <fig id="F4" position="float">
      <label>Figure 4</label>
      <caption>
        <p><bold>Sequence reads from 3,032,644 to 3,036,223 on chromosome 11 of simulated Test1 dataset</bold>. A benchmarked splicing junction from 3,033,210 to 3,035,657 (connected by dash lines) is called out by SpliceJumper, but missed by both TopHat2 and MapSplice2. 1-9 are nine splicing sites. A, B, and C are three split-mapped reads (only mapped part shown) that are clipped at splicing site 8, and the clipped segment can be aligned at site 1. D is clipped at splicing site 1. The clipped segment can be mapped at site 8. A, B, C, and D and their mate reads form four discordant pairs encompassing splicing site 1 and site 8.</p>
      </caption>
      <graphic xlink:href="1471-2105-16-S17-S10-4"/>
    </fig>
    <p>One issue of using SpliceJumper is that SpliceJumper needs training data (i.e. data with known splicing sites). For well studied organisms, we can use the released annotation data to generate training data. In the case when no annotation data is available, we believe that simulated data may also be used as training data to train models for real data analysis. In [<xref ref-type="bibr" rid="B22">22</xref>], we show that models on simulated data can give reasonably accurate insertion and deletion genotype calling on real data.</p>
    <p>For future work, we notice that some kinds of structural variations, like long deletions, can introduce false positives to our results. Many of the existing methods such as TopHat2 and MapSplcie2 can call indels while aligning reads. So in the future work, we plan to add the indels calling part, which is not only useful to profile the gene structure, and also to improve the accuracy of splicing junctions calling.</p>
  </sec>
  <sec>
    <title>Competing interests</title>
    <p>The authors declare that they have no competing interests.</p>
  </sec>
  <sec>
    <title>Authors' contributions</title>
    <p>CC designed algorithms, developed software, performed analysis and experiments, wrote the paper. XL performed analysis and experiments. YW designed the algorithms, wrote the paper and supervised the project. All authors have read and approved the final manuscript.</p>
  </sec>
</body>
<back>
  <sec>
    <title>Acknowledgements</title>
    <p>All the authors are partially supported by National Science Foundation grants IIS-0953563 and IIS-1447711.</p>
  </sec>
  <sec>
    <title>Declarations</title>
    <p>Publication of this article was funded by National Science Foundation grant IIS-0953563.</p>
    <p>This article has been published as part of <italic>BMC Bioinformatics </italic>Volume 16 Supplement 17, 2015: Selected articles from the Fourth IEEE International Conference on Computational Advances in Bio and medical Sciences (ICCABS 2014): Bioinformatics. The full contents of the supplement are available online at <ext-link ext-link-type="uri" xlink:href="http://www.biomedcentral.com/bmcbioinformatics/supplements/16/S17">http://www.biomedcentral.com/bmcbioinformatics/supplements/16/S17</ext-link>.</p>
  </sec>
  <ref-list>
    <ref id="B1">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Twine</surname>
          <given-names>NA</given-names>
        </name>
        <name>
          <surname>Janitz</surname>
          <given-names>K</given-names>
        </name>
        <name>
          <surname>Wilkins</surname>
          <given-names>MR</given-names>
        </name>
        <name>
          <surname>Janitz</surname>
          <given-names>M</given-names>
        </name>
        <article-title>Whole transcriptome sequencing reveals gene expression and splicing differences in brain regions affected by alzheimer's disease</article-title>
        <source>PLoS ONE</source>
        <year>2011</year>
        <volume>6</volume>
        <issue>1</issue>
        <fpage>16266</fpage>
      </mixed-citation>
    </ref>
    <ref id="B2">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Wang</surname>
          <given-names>GS</given-names>
        </name>
        <name>
          <surname>Cooper</surname>
          <given-names>TA</given-names>
        </name>
        <article-title>Splicing in disease: disruption of the splicing code and the decoding machinery</article-title>
        <source>Nature Reviews Genetics</source>
        <year>2007</year>
        <volume>8</volume>
        <issue>10</issue>
        <fpage>749</fpage>
        <lpage>761</lpage>
      </mixed-citation>
    </ref>
    <ref id="B3">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Kim</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Pertea</surname>
          <given-names>G</given-names>
        </name>
        <name>
          <surname>Trapnell</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Pimentel</surname>
          <given-names>H</given-names>
        </name>
        <name>
          <surname>Kelley</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Salzberg</surname>
          <given-names>SL</given-names>
        </name>
        <article-title>TopHat2: accurate alignment of transcriptomes in the presence of insertions, deletions and gene fusions</article-title>
        <source>Genome Biol</source>
        <year>2013</year>
        <volume>14</volume>
        <issue>4</issue>
        <fpage>36</fpage>
      </mixed-citation>
    </ref>
    <ref id="B4">
      <mixed-citation publication-type="other">
        <name>
          <surname>Wang</surname>
          <given-names>K</given-names>
        </name>
        <name>
          <surname>Singh</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Zeng</surname>
          <given-names>Z</given-names>
        </name>
        <name>
          <surname>Coleman</surname>
          <given-names>SJ</given-names>
        </name>
        <name>
          <surname>Huang</surname>
          <given-names>Y</given-names>
        </name>
        <name>
          <surname>Savich</surname>
          <given-names>GL</given-names>
        </name>
        <name>
          <surname>He</surname>
          <given-names>X</given-names>
        </name>
        <name>
          <surname>Mieczkowski</surname>
          <given-names>P</given-names>
        </name>
        <name>
          <surname>Grimm</surname>
          <given-names>SA</given-names>
        </name>
        <name>
          <surname>Perou</surname>
          <given-names>CM</given-names>
        </name>
        <etal/>
        <article-title>MapSplice: accurate mapping of RNA-seq reads for splice junction discovery</article-title>
        <source>Nucleic acids research</source>
        <year>2010</year>
        <fpage>622</fpage>
      </mixed-citation>
    </ref>
    <ref id="B5">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Li</surname>
          <given-names>Y</given-names>
        </name>
        <name>
          <surname>Li-Byarlay</surname>
          <given-names>H</given-names>
        </name>
        <name>
          <surname>Burns</surname>
          <given-names>P</given-names>
        </name>
        <name>
          <surname>Borodovsky</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Robinson</surname>
          <given-names>GE</given-names>
        </name>
        <name>
          <surname>Ma</surname>
          <given-names>J</given-names>
        </name>
        <article-title>TrueSight: a new algorithm for splice junction detection using RNA-seq</article-title>
        <source>Nucleic acids research</source>
        <year>2013</year>
        <volume>41</volume>
        <issue>4</issue>
        <fpage>51</fpage>
        <lpage>51</lpage>
      </mixed-citation>
    </ref>
    <ref id="B6">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Zhang</surname>
          <given-names>Y</given-names>
        </name>
        <name>
          <surname>Lameijer</surname>
          <given-names>EW</given-names>
        </name>
        <name>
          <surname>AC't Hoen</surname>
          <given-names>P</given-names>
        </name>
        <name>
          <surname>Ning</surname>
          <given-names>Z</given-names>
        </name>
        <name>
          <surname>Slagboom</surname>
          <given-names>PE</given-names>
        </name>
        <name>
          <surname>Ye</surname>
          <given-names>K</given-names>
        </name>
        <article-title>PASSion: a pattern growth algorithm-based pipeline for splice junction detection in paired-end RNA-seq data</article-title>
        <source>Bioinformatics</source>
        <year>2012</year>
        <volume>28</volume>
        <issue>4</issue>
        <fpage>479</fpage>
        <lpage>486</lpage>
        <pub-id pub-id-type="pmid">22219203</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B7">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Trapnell</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Pachter</surname>
          <given-names>L</given-names>
        </name>
        <name>
          <surname>Salzberg</surname>
          <given-names>SL</given-names>
        </name>
        <article-title>TopHat: discovering splice junctions with RNA-seq</article-title>
        <source>Bioinformatics</source>
        <year>2009</year>
        <volume>25</volume>
        <issue>9</issue>
        <fpage>1105</fpage>
        <lpage>1111</lpage>
        <pub-id pub-id-type="pmid">19289445</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B8">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Dobin</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Davis</surname>
          <given-names>CA</given-names>
        </name>
        <name>
          <surname>Schlesinger</surname>
          <given-names>F</given-names>
        </name>
        <name>
          <surname>Drenkow</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Zaleski</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Jha</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Batut</surname>
          <given-names>P</given-names>
        </name>
        <name>
          <surname>Chaisson</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Gingeras</surname>
          <given-names>TR</given-names>
        </name>
        <article-title>STAR: ultrafast universal RNA-seq aligner</article-title>
        <source>Bioinformatics</source>
        <year>2013</year>
        <volume>29</volume>
        <issue>1</issue>
        <fpage>15</fpage>
        <lpage>21</lpage>
        <pub-id pub-id-type="pmid">23104886</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B9">
      <mixed-citation publication-type="other">
        <name>
          <surname>Jean</surname>
          <given-names>G</given-names>
        </name>
        <name>
          <surname>Kahles</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Sreedharan</surname>
          <given-names>VT</given-names>
        </name>
        <name>
          <surname>Bona</surname>
          <given-names>FD</given-names>
        </name>
        <name>
          <surname>Rätsch</surname>
          <given-names>G</given-names>
        </name>
        <article-title>RNA-Seq Read Alignments with PALMapper</article-title>
        <source>Current protocols in bioinformatics</source>
        <year>2010</year>
        <fpage>11</fpage>
        <lpage>6</lpage>
        <pub-id pub-id-type="pmid">20521243</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B10">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Wu</surname>
          <given-names>TD</given-names>
        </name>
        <name>
          <surname>Nacu</surname>
          <given-names>S</given-names>
        </name>
        <article-title>Fast and SNP-tolerant detection of complex variants and splicing in short reads</article-title>
        <source>Bioinformatics</source>
        <year>2010</year>
        <volume>26</volume>
        <issue>7</issue>
        <fpage>873</fpage>
        <lpage>881</lpage>
        <pub-id pub-id-type="pmid">20147302</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B11">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Campagna</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Albiero</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Bilardi</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Caniato</surname>
          <given-names>E</given-names>
        </name>
        <name>
          <surname>Forcato</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Manavski</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Vitulo</surname>
          <given-names>N</given-names>
        </name>
        <name>
          <surname>Valle</surname>
          <given-names>G</given-names>
        </name>
        <article-title>PASS: a program to align short sequences</article-title>
        <source>Bioinformatics</source>
        <year>2009</year>
        <volume>25</volume>
        <issue>7</issue>
        <fpage>967</fpage>
        <lpage>968</lpage>
        <pub-id pub-id-type="pmid">19218350</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B12">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Marco-Sola</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Sammeth</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Guigó</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Ribeca</surname>
          <given-names>P</given-names>
        </name>
        <article-title>The GEM mapper: fast, accurate and versatile alignment by filtration</article-title>
        <source>Nature methods</source>
        <year>2012</year>
        <volume>9</volume>
        <issue>12</issue>
        <fpage>1185</fpage>
        <lpage>1188</lpage>
        <pub-id pub-id-type="pmid">23103880</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B13">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Li</surname>
          <given-names>H</given-names>
        </name>
        <name>
          <surname>Durbin</surname>
          <given-names>R</given-names>
        </name>
        <article-title>Fast and accurate short read alignment with Burrows-Wheeler transform</article-title>
        <source>Bioinformatics</source>
        <year>2009</year>
        <volume>25</volume>
        <issue>14</issue>
        <fpage>1754</fpage>
        <lpage>1760</lpage>
        <pub-id pub-id-type="pmid">19451168</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B14">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Black</surname>
          <given-names>DL</given-names>
        </name>
        <article-title>Mechanisms of alternative pre-messenger RNA splicing</article-title>
        <source>Annual review of biochemistry</source>
        <year>2003</year>
        <volume>72</volume>
        <issue>1</issue>
        <fpage>291</fpage>
        <lpage>336</lpage>
      </mixed-citation>
    </ref>
    <ref id="B15">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Langmead</surname>
          <given-names>B</given-names>
        </name>
        <name>
          <surname>Trapnell</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Pop</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Salzberg</surname>
          <given-names>SL</given-names>
        </name>
        <etal/>
        <article-title>Ultrafast and memory-efficient alignment of short DNA sequences to the human genome</article-title>
        <source>Genome Biol</source>
        <year>2009</year>
        <volume>10</volume>
        <issue>3</issue>
        <fpage>25</fpage>
      </mixed-citation>
    </ref>
    <ref id="B16">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Langmead</surname>
          <given-names>B</given-names>
        </name>
        <name>
          <surname>Salzberg</surname>
          <given-names>SL</given-names>
        </name>
        <article-title>Fast gapped-read alignment with Bowtie 2</article-title>
        <source>Nature methods</source>
        <year>2012</year>
        <volume>9</volume>
        <issue>4</issue>
        <fpage>357</fpage>
        <lpage>359</lpage>
        <pub-id pub-id-type="pmid">22388286</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B17">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Grant</surname>
          <given-names>GR</given-names>
        </name>
        <name>
          <surname>Farkas</surname>
          <given-names>MH</given-names>
        </name>
        <name>
          <surname>Pizarro</surname>
          <given-names>AD</given-names>
        </name>
        <name>
          <surname>Lahens</surname>
          <given-names>NF</given-names>
        </name>
        <name>
          <surname>Schug</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Brunk</surname>
          <given-names>BP</given-names>
        </name>
        <name>
          <surname>Stoeckert</surname>
          <given-names>CJ</given-names>
        </name>
        <name>
          <surname>Hogenesch</surname>
          <given-names>JB</given-names>
        </name>
        <name>
          <surname>Pierce</surname>
          <given-names>EA</given-names>
        </name>
        <article-title>Comparative analysis of RNA-seq alignment algorithms and the RNA-seq unified mapper (RUM)</article-title>
        <source>Bioinformatics</source>
        <year>2011</year>
        <volume>27</volume>
        <issue>18</issue>
        <fpage>2518</fpage>
        <lpage>2528</lpage>
        <pub-id pub-id-type="pmid">21775302</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B18">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Engström</surname>
          <given-names>PG</given-names>
        </name>
        <name>
          <surname>Steijger</surname>
          <given-names>T</given-names>
        </name>
        <name>
          <surname>Sipos</surname>
          <given-names>B</given-names>
        </name>
        <name>
          <surname>Grant</surname>
          <given-names>GR</given-names>
        </name>
        <name>
          <surname>Kahles</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Rätsch</surname>
          <given-names>G</given-names>
        </name>
        <name>
          <surname>Goldman</surname>
          <given-names>N</given-names>
        </name>
        <name>
          <surname>Hubbard</surname>
          <given-names>TJ</given-names>
        </name>
        <name>
          <surname>Harrow</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Guigó</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>et</surname>
          <given-names>al</given-names>
        </name>
        <article-title>Systematic evaluation of spliced alignment programs for RNA-seq data</article-title>
        <source>Nature methods</source>
        <year>2013</year>
        <volume>10</volume>
        <issue>12</issue>
        <fpage>1185</fpage>
        <lpage>1191</lpage>
        <pub-id pub-id-type="pmid">24185836</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B19">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Chang</surname>
          <given-names>CC</given-names>
        </name>
        <name>
          <surname>Lin</surname>
          <given-names>CJ</given-names>
        </name>
        <article-title>LIBSVM: A library for support vector machines</article-title>
        <source>ACM Transactions on Intelligent Systems and Technology</source>
        <year>2011</year>
        <volume>2</volume>
        <fpage>27</fpage>
        <lpage>12727</lpage>
        <comment>(2011). Software available at <ext-link ext-link-type="uri" xlink:href="http://www.csie.ntu.edu.tw/~cjlin/libsvm">http://www.csie.ntu.edu.tw/~cjlin/libsvm</ext-link></comment>
      </mixed-citation>
    </ref>
    <ref id="B20">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Chen</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Mias</surname>
          <given-names>GI</given-names>
        </name>
        <name>
          <surname>Li-Pook-Than</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Jiang</surname>
          <given-names>L</given-names>
        </name>
        <name>
          <surname>Lam</surname>
          <given-names>HY</given-names>
        </name>
        <name>
          <surname>Chen</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Miriami</surname>
          <given-names>E</given-names>
        </name>
        <name>
          <surname>Karczewski</surname>
          <given-names>KJ</given-names>
        </name>
        <name>
          <surname>Hariharan</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Dewey</surname>
          <given-names>FE</given-names>
        </name>
        <etal/>
        <article-title>Personal omics profiling reveals dynamic molecular and medical phenotypes</article-title>
        <source>Cell</source>
        <year>2012</year>
        <volume>148</volume>
        <issue>6</issue>
        <fpage>1293</fpage>
        <lpage>1307</lpage>
        <pub-id pub-id-type="pmid">22424236</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B21">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Robinson</surname>
          <given-names>JT</given-names>
        </name>
        <name>
          <surname>Thorvaldsdóttir</surname>
          <given-names>H</given-names>
        </name>
        <name>
          <surname>Winckler</surname>
          <given-names>W</given-names>
        </name>
        <name>
          <surname>Guttman</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Lander</surname>
          <given-names>ES</given-names>
        </name>
        <name>
          <surname>Getz</surname>
          <given-names>G</given-names>
        </name>
        <name>
          <surname>Mesirov</surname>
          <given-names>JP</given-names>
        </name>
        <article-title>Integrative genomics viewer</article-title>
        <source>Nature biotechnology</source>
        <year>2011</year>
        <volume>29</volume>
        <issue>1</issue>
        <fpage>24</fpage>
        <lpage>26</lpage>
      </mixed-citation>
    </ref>
    <ref id="B22">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Chu</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Zhang</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Wu</surname>
          <given-names>Y</given-names>
        </name>
        <article-title>GINDEL: accurate genotype calling of insertions and deletions from low coverage population sequence reads</article-title>
        <source>PLoS ONE</source>
        <year>2014</year>
        <volume>9</volume>
        <fpage>113324</fpage>
      </mixed-citation>
    </ref>
  </ref-list>
</back>
