<?DTDIdentifier.IdentifierValue -//ES//DTD journal article DTD version 5.6.0//EN//XML?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName art560.dtd?>
<?SourceDTD.Version 5.6.0?>
<?ConverterInfo.XSLTName elsevier2nlmx2.xsl?>
<?ConverterInfo.Version 1?>
<?origin publisher?>
<?FILEmeta_CSBJ1101 xml ?>
<?FILEmain xml ?>
<?FILEmain pdf ?>
<?FILEgr1 jpg ?>
<?FILEgr2 jpg ?>
<?FILEgr3 jpg ?>
<?FILEgr4 jpg ?>
<?FILEgr5 jpg ?>
<?FILEgr6 jpg ?>
<?FILEga1 jpg ?>
<?FILEsi1 svg ?>
<?FILEsi2 svg ?>
<?FILEsi3 svg ?>
<?FILEsi4 svg ?>
<?FILEsi5 svg ?>
<?FILEsi6 svg ?>
<?FILEsi7 svg ?>
<?FILEsi8 svg ?>
<?FILEsi9 svg ?>
<?FILEsi10 svg ?>
<?FILEsi11 svg ?>
<?FILEsi12 svg ?>
<?FILEsi13 svg ?>
<?FILEsi14 svg ?>
<?FILEsi15 svg ?>
<?FILEsi16 svg ?>
<?FILEsi17 svg ?>
<?FILEsi18 svg ?>
<?FILEsi19 svg ?>
<?FILEsi20 svg ?>
<?FILEsi21 svg ?>
<?FILEsi22 svg ?>
<?FILEsi23 svg ?>
<?FILEsi24 svg ?>
<?FILEsi25 svg ?>
<?FILEsi26 svg ?>
<?FILEsi27 svg ?>
<?FILEsi28 svg ?>
<?FILEsi29 svg ?>
<?FILEsi30 svg ?>
<?FILEsi31 svg ?>
<?FILEsi32 svg ?>
<?FILEsi33 svg ?>
<?FILEsi34 svg ?>
<?FILEsi35 svg ?>
<?FILEsi36 svg ?>
<?FILEsi37 svg ?>
<?FILEsi38 svg ?>
<?FILEsi39 svg ?>
<?FILEsi40 svg ?>
<?FILEsi41 svg ?>
<?FILEsi42 svg ?>
<?FILEsi43 svg ?>
<?FILEsi44 svg ?>
<?FILEsi45 svg ?>
<?FILEsi46 svg ?>
<?FILEsi47 svg ?>
<?FILEsi48 svg ?>
<?FILEsi49 svg ?>
<?FILEsi50 svg ?>
<?FILEsi51 svg ?>
<?FILEsi52 svg ?>
<?FILEsi53 svg ?>
<?FILEsi54 svg ?>
<?FILEsi55 svg ?>
<?FILEsi56 svg ?>
<?FILEsi57 svg ?>
<?FILEsi58 svg ?>
<?FILEsi59 svg ?>
<?FILEsi60 svg ?>
<?FILEsi61 svg ?>
<?FILEsi62 svg ?>
<?FILEsi63 svg ?>
<?FILEsi64 svg ?>
<?FILEsi65 svg ?>
<?FILEsi66 svg ?>
<?FILEsi67 svg ?>
<?FILEsi68 svg ?>
<?FILEsi69 svg ?>
<?FILEsi70 svg ?>
<?FILEsi71 svg ?>
<?FILEsi72 svg ?>
<?FILEsi73 svg ?>
<?FILEsi74 svg ?>
<?FILEsi75 svg ?>
<?FILEsi76 svg ?>
<?FILEsi77 svg ?>
<?FILEsi78 svg ?>
<?FILEsi79 svg ?>
<?FILEsi80 svg ?>
<?FILEsi81 svg ?>
<?FILEsi82 svg ?>
<?FILEsi83 svg ?>
<?FILEsi84 svg ?>
<?FILEsi85 svg ?>
<?FILEsi86 svg ?>
<?FILEsi87 svg ?>
<?FILEsi88 svg ?>
<?FILEsi89 svg ?>
<?FILEsi90 svg ?>
<?FILEsi91 svg ?>
<?FILEsi92 svg ?>
<?FILEsi93 svg ?>
<?FILEsi94 svg ?>
<?FILEsi95 svg ?>
<?FILEsi96 svg ?>
<?FILEsi97 svg ?>
<?FILEsi98 svg ?>
<?FILEsi99 svg ?>
<?FILEsi100 svg ?>
<?FILEsi101 svg ?>
<?FILEsi102 svg ?>
<?FILEsi103 svg ?>
<?FILEsi104 svg ?>
<?FILEsi105 svg ?>
<?FILEsi106 svg ?>
<?FILEsi107 svg ?>
<?FILEsi108 svg ?>
<?FILEsi109 svg ?>
<?FILEsi110 svg ?>
<?FILEsi111 svg ?>
<?FILEsi112 svg ?>
<?FILEsi113 svg ?>
<?FILEsi114 svg ?>
<?FILEsi115 svg ?>
<?FILEsi116 svg ?>
<?FILEsi117 svg ?>
<?FILEsi118 svg ?>
<?FILEsi119 svg ?>
<?FILEsi120 svg ?>
<?FILEsi121 svg ?>
<?FILEsi122 svg ?>
<?FILEsi123 svg ?>
<?FILEsi124 svg ?>
<?FILEsi125 svg ?>
<?FILEsi126 svg ?>
<?FILEsi127 svg ?>
<?FILEsi128 svg ?>
<?FILEsi129 svg ?>
<?FILEsi130 svg ?>
<?FILEsi131 svg ?>
<?FILEsi132 svg ?>
<?FILEsi133 svg ?>
<?FILEsi134 svg ?>
<?FILEsi135 svg ?>
<?FILEsi136 svg ?>
<?FILEsi137 svg ?>
<?FILEsi138 svg ?>
<?FILEsi139 svg ?>
<?FILEsi140 svg ?>
<?FILEsi141 svg ?>
<?FILEsi142 svg ?>
<?FILEsi143 svg ?>
<?FILEsi144 svg ?>
<?FILEsi145 svg ?>
<?FILEsi146 svg ?>
<?FILEsi147 svg ?>
<?FILEsi148 svg ?>
<?FILEsi149 svg ?>
<?FILEsi150 svg ?>
<?FILEsi151 svg ?>
<?FILEsi152 svg ?>
<?FILEsi153 svg ?>
<?FILEsi154 svg ?>
<?FILEsi155 svg ?>
<?FILEsi156 svg ?>
<?FILEsi157 svg ?>
<?FILEsi158 svg ?>
<?FILEsi159 svg ?>
<?FILEsi160 svg ?>
<?FILEsi161 svg ?>
<?FILEsi162 svg ?>
<?FILEsi163 svg ?>
<?FILEsi164 svg ?>
<?FILEsi165 svg ?>
<?FILEsi166 svg ?>
<?FILEsi167 svg ?>
<?FILEsi168 svg ?>
<?FILEsi169 svg ?>
<?FILEsi170 svg ?>
<?FILEsi171 svg ?>
<?FILEsi172 svg ?>
<?FILEsi173 svg ?>
<?FILEsi174 svg ?>
<?FILEsi175 svg ?>
<?FILEsi176 svg ?>
<?FILEsi177 svg ?>
<?FILEsi178 svg ?>
<?FILEsi179 svg ?>
<?FILEsi180 svg ?>
<?FILEsi181 svg ?>
<?FILEsi182 svg ?>
<?FILEsi183 svg ?>
<?FILEsi184 svg ?>
<?FILEsi185 svg ?>
<?FILEsi186 svg ?>
<?FILEsi187 svg ?>
<?FILEsi188 svg ?>
<?FILEsi189 svg ?>
<?FILEsi190 svg ?>
<?FILEsi191 svg ?>
<?FILEsi192 svg ?>
<?FILEsi193 svg ?>
<?FILEsi194 svg ?>
<?FILEsi195 svg ?>
<?FILEsi196 svg ?>
<?FILEsi197 svg ?>
<?FILEsi198 svg ?>
<?FILEsi199 svg ?>
<?FILEsi200 svg ?>
<?FILEsi201 svg ?>
<?FILEsi202 svg ?>
<?FILEsi203 svg ?>
<?FILEsi204 svg ?>
<?FILEsi205 svg ?>
<?FILEsi206 svg ?>
<?FILEsi207 svg ?>
<?FILEsi208 svg ?>
<?FILEsi209 svg ?>
<?FILEsi210 svg ?>
<?FILEsi211 svg ?>
<?FILEsi212 svg ?>
<?FILEsi213 svg ?>
<?FILEsi214 svg ?>
<?FILEsi215 svg ?>
<?FILEsi216 svg ?>
<?FILEsi217 svg ?>
<?FILEsi218 svg ?>
<?FILEsi219 svg ?>
<?FILEsi220 svg ?>
<?FILEsi221 svg ?>
<?FILEsi222 svg ?>
<?FILEsi223 svg ?>
<?FILEsi224 svg ?>
<?FILEsi225 svg ?>
<?FILEsi226 svg ?>
<?FILEsi227 svg ?>
<?FILEsi228 svg ?>
<?FILEsi229 svg ?>
<?FILEsi230 svg ?>
<?FILEsi231 svg ?>
<?FILEsi232 svg ?>
<?FILEsi233 svg ?>
<?FILEsi234 svg ?>
<?FILEsi235 svg ?>
<?FILEsi236 svg ?>
<?FILEsi237 svg ?>
<?FILEsi238 svg ?>
<?FILEsi239 svg ?>
<?FILEsi240 svg ?>
<?FILEsi241 svg ?>
<?FILEsi242 svg ?>
<?FILEsi243 svg ?>
<?FILEsi244 svg ?>
<?FILEsi245 svg ?>
<?FILEsi246 svg ?>
<?FILEsi247 svg ?>
<?FILEsi248 svg ?>
<?FILEsi249 svg ?>
<?FILEsi250 svg ?>
<?FILEsi251 svg ?>
<?FILEsi252 svg ?>
<?FILEsi253 svg ?>
<?FILEsi254 svg ?>
<?FILEsi255 svg ?>
<?FILEsi256 svg ?>
<?FILEsi257 svg ?>
<?FILEsi258 svg ?>
<?FILEsi259 svg ?>
<?FILEsi260 svg ?>
<?FILEsi261 svg ?>
<?FILEsi262 svg ?>
<?FILEsi263 svg ?>
<?FILEsi264 svg ?>
<?FILEsi265 svg ?>
<?FILEsi266 svg ?>
<?FILEsi267 svg ?>
<?FILEsi268 svg ?>
<?FILEsi269 svg ?>
<?FILEsi270 svg ?>
<?FILEsi271 svg ?>
<?FILEsi272 svg ?>
<?FILEsi273 svg ?>
<?FILEsi274 svg ?>
<?FILEsi275 svg ?>
<?FILEsi276 svg ?>
<?FILEsi277 svg ?>
<?FILEsi278 svg ?>
<?FILEsi279 svg ?>
<?FILEsi280 svg ?>
<?FILEsi281 svg ?>
<?FILEsi282 svg ?>
<?FILEsi283 svg ?>
<?FILEsi284 svg ?>
<?FILEsi285 svg ?>
<?FILEsi286 svg ?>
<?FILEsi287 svg ?>
<?FILEsi288 svg ?>
<?FILEsi289 svg ?>
<?FILEsi290 svg ?>
<?FILEsi291 svg ?>
<?FILEsi292 svg ?>
<?FILEsi293 svg ?>
<?FILEsi294 svg ?>
<?FILEsi295 svg ?>
<?FILEsi296 svg ?>
<?FILEsi297 svg ?>
<?FILEsi298 svg ?>
<?FILEsi299 svg ?>
<?FILEsi300 svg ?>
<?FILEsi301 svg ?>
<?FILEsi302 svg ?>
<?FILEsi303 svg ?>
<?FILEsi304 svg ?>
<?FILEsi305 svg ?>
<?FILEsi306 svg ?>
<?FILEsi307 svg ?>
<?FILEsi308 svg ?>
<?FILEsi309 svg ?>
<?FILEsi310 svg ?>
<?FILEsi311 svg ?>
<?FILEsi312 svg ?>
<?FILEsi313 svg ?>
<?FILEsi314 svg ?>
<?FILEsi315 svg ?>
<?FILEsi316 svg ?>
<?FILEsi317 svg ?>
<?FILEsi318 svg ?>
<?FILEsi319 svg ?>
<?FILEsi320 svg ?>
<?FILEsi321 svg ?>
<?FILEsi322 svg ?>
<?FILEsi323 svg ?>
<?FILEsi324 svg ?>
<?FILEsi325 svg ?>
<?FILEsi326 svg ?>
<?FILEsi327 svg ?>
<?FILEsi328 svg ?>
<?FILEsi329 svg ?>
<?FILEsi330 svg ?>
<?FILEsi331 svg ?>
<?FILEsi332 svg ?>
<?FILEsi333 svg ?>
<?FILEsi334 svg ?>
<?FILEsi335 svg ?>
<?FILEsi336 svg ?>
<?FILEsi337 svg ?>
<?FILEsi338 svg ?>
<?FILEsi339 svg ?>
<?FILEsi340 svg ?>
<?FILEsi341 svg ?>
<?FILEsi342 svg ?>
<?FILEsi343 svg ?>
<?FILEsi344 svg ?>
<?FILEsi345 svg ?>
<?FILEsi346 svg ?>
<?FILEsi347 svg ?>
<?FILEsi348 svg ?>
<?FILEsi349 svg ?>
<?FILEsi350 svg ?>
<?FILEsi351 svg ?>
<?FILEsi352 svg ?>
<?FILEsi353 svg ?>
<?FILEsi354 svg ?>
<?FILEsi355 svg ?>
<?FILEsi356 svg ?>
<?FILEsi357 svg ?>
<?FILEsi358 svg ?>
<?FILEsi359 svg ?>
<?FILEsi360 svg ?>
<?FILEsi361 svg ?>
<?FILEsi362 svg ?>
<?FILEsi363 svg ?>
<?FILEsi364 svg ?>
<?FILEsi365 svg ?>
<?FILEsi366 svg ?>
<?FILEsi367 svg ?>
<?FILEsi368 svg ?>
<?FILEsi369 svg ?>
<?FILEsi370 svg ?>
<?FILEsi371 svg ?>
<?FILEsi372 svg ?>
<?properties open_access?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Comput Struct Biotechnol J</journal-id>
    <journal-id journal-id-type="iso-abbrev">Comput Struct Biotechnol J</journal-id>
    <journal-title-group>
      <journal-title>Computational and Structural Biotechnology Journal</journal-title>
    </journal-title-group>
    <issn pub-type="epub">2001-0370</issn>
    <publisher>
      <publisher-name>Research Network of Computational and Structural Biotechnology</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">8326735</article-id>
    <article-id pub-id-type="pii">S2001-0370(21)00285-3</article-id>
    <article-id pub-id-type="doi">10.1016/j.csbj.2021.06.047</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Research Article</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Buffering updates enables efficient dynamic de Bruijn graphs</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" id="au005">
        <name>
          <surname>Alanko</surname>
          <given-names>Jarno</given-names>
        </name>
        <email>alanko.jarno@gmail.com</email>
        <xref rid="af005" ref-type="aff">a</xref>
        <xref rid="af010" ref-type="aff">b</xref>
        <xref rid="cor1" ref-type="corresp">⁎</xref>
      </contrib>
      <contrib contrib-type="author" id="au010">
        <name>
          <surname>Alipanahi</surname>
          <given-names>Bahar</given-names>
        </name>
        <xref rid="af015" ref-type="aff">c</xref>
      </contrib>
      <contrib contrib-type="author" id="au015">
        <name>
          <surname>Settle</surname>
          <given-names>Jonathen</given-names>
        </name>
        <xref rid="af015" ref-type="aff">c</xref>
      </contrib>
      <contrib contrib-type="author" id="au020">
        <name>
          <surname>Boucher</surname>
          <given-names>Christina</given-names>
        </name>
        <xref rid="af015" ref-type="aff">c</xref>
        <xref rid="fn1" ref-type="fn">1</xref>
      </contrib>
      <contrib contrib-type="author" id="au025">
        <name>
          <surname>Gagie</surname>
          <given-names>Travis</given-names>
        </name>
        <xref rid="af005" ref-type="aff">a</xref>
        <xref rid="fn1" ref-type="fn">1</xref>
      </contrib>
      <aff id="af005"><label>a</label>Department of Computer Science, University of Helsinki, Helsinki, Finland</aff>
      <aff id="af010"><label>b</label>Faculty of Computer Science, Dalhousie University, Halifax, Canada</aff>
      <aff id="af015"><label>c</label>Department of Computer and Information Science and Engineering, University of Florida, Gainesville, FL, USA</aff>
    </contrib-group>
    <author-notes>
      <corresp id="cor1"><label>⁎</label>Corresponding author. <email>alanko.jarno@gmail.com</email></corresp>
      <fn id="fn1">
        <label>1</label>
        <p id="np005">These authors contributed equally.</p>
      </fn>
    </author-notes>
    <pub-date pub-type="pmc-release">
      <day>06</day>
      <month>7</month>
      <year>2021</year>
    </pub-date>
    <!-- PMC Release delay is 0 months and 0 days and was based on <pub-date
						pub-type="epub">.-->
    <pub-date pub-type="collection">
      <year>2021</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>06</day>
      <month>7</month>
      <year>2021</year>
    </pub-date>
    <volume>19</volume>
    <fpage>4067</fpage>
    <lpage>4078</lpage>
    <history>
      <date date-type="received">
        <day>15</day>
        <month>3</month>
        <year>2021</year>
      </date>
      <date date-type="rev-recd">
        <day>29</day>
        <month>6</month>
        <year>2021</year>
      </date>
      <date date-type="accepted">
        <day>29</day>
        <month>6</month>
        <year>2021</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© 2021 The Authors</copyright-statement>
      <copyright-year>2021</copyright-year>
      <license>
        <ali:license_ref xmlns:ali="http://www.niso.org/schemas/ali/1.0/" specific-use="textmining" content-type="ccbylicense">https://creativecommons.org/licenses/by/4.0/</ali:license_ref>
        <license-p>This is an open access article under the CC BY license (http://creativecommons.org/licenses/by/4.0/).</license-p>
      </license>
    </permissions>
    <abstract abstract-type="graphical" id="ab005">
      <title>Graphical abstract</title>
      <fig id="f0035" position="anchor">
        <graphic xlink:href="ga1"/>
      </fig>
    </abstract>
    <abstract id="ab010">
      <sec>
        <title>Motivation</title>
        <p>The de Bruijn graph has become a ubiquitous graph model for biological data ever since its initial introduction in the late 1990s. It has been used for a variety of purposes including genome assembly (Zerbino and Birney, 2008; Bankevich et al., 2012; Peng et al., 2012), variant detection (Alipanahi et al., 2020b; Iqbal et al., 2012), and storage of assembled genomes (Chikhi et al., 2016). For this reason, there have been over a dozen methods for building and representing the de Bruijn graph and its variants in a space and time efficient manner.</p>
      </sec>
      <sec>
        <title>Results</title>
        <p>With the exception of a few data structures (Muggli et al., 2019; Holley and Melsted, 2020; Crawford et al.,2018), compressed and compact de Bruijn graphs do not allow for the graph to be efficiently updated, meaning that data can be added or deleted. The most recent compressed dynamic de Bruijn graph (Alipanahi et al., 2020a), relies on dynamic bit vectors which are slow in theory and practice. To address this shortcoming, we present a compressed dynamic de Bruijn graph that removes the necessity of dynamic bit vectors by buffering data that should be added or removed from the graph. We implement our method, which we refer to as BufBOSS, and compare its performance to Bifrost, DynamicBOSS, and FDBG. Our experiments demonstrate that BufBOSS achieves attractive trade-offs compared to other tools in terms of time, memory and disk, and has the best deletion performance by an order of magnitude.</p>
      </sec>
    </abstract>
    <kwd-group id="kg005">
      <title>Keywords</title>
      <kwd>de Bruijn graph</kwd>
      <kwd>Dynamic data structures</kwd>
      <kwd>Succinct data structures</kwd>
      <kwd>Burrows-Wheeler transform</kwd>
    </kwd-group>
  </article-meta>
</front>
<body>
  <sec id="s0005">
    <label>1</label>
    <title>Introduction</title>
    <p id="p0005">Analyzing population level data has posed significant algorithmic challenges as the amount of the data has risen steadily in the past decade or more. For example, the 1,000 Genomes Project was concluded in 2012 <xref rid="b0180" ref-type="bibr">[36]</xref>, and more recently, the 100 K Project concluded in 2018 <xref rid="b0250" ref-type="bibr">[50]</xref>. The MetaSub project <xref rid="b0095" ref-type="bibr">[19]</xref>, which collects metagenomic samples from subway systems across the world began in 2016, is now in its fifth year. One of the main goals of these projects is to identify rare variants – including but not limited to single nucleotide polymorphisms (SNPs), insertions, and deletions – within the population, and to attribute them to physiological or disease outcomes. One method of identifying these variants that receives a significant amount of attention is the construction and analysis of the <italic>colored de Bruijn graph</italic>.</p>
    <p id="p0010">To define the colored de Bruijn graph correctly it is useful to first define the de Bruijn graph in a constructive manner as follows. Given a set of sequence reads <italic>R</italic> and integer <italic>k</italic>, the first step is to identify all unique <italic>k</italic>-length substrings (<italic>k</italic>-mers) occurring in <italic>R</italic>, then create a directed edge for each unique <italic>k</italic>-mer with node labels being the <inline-formula><mml:math id="M1" altimg="si9.svg"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo linebreak="badbreak">-</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>-length prefix and the <inline-formula><mml:math id="M2" altimg="si10.svg"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo linebreak="badbreak">-</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>-length suffix of the <italic>k</italic>-mer, and lastly, after all directed edges have been created, glue all nodes that have the same label. The original purpose of the de Bruijn graph was to assemble single genomes <xref rid="b0230" ref-type="bibr">[46]</xref>, however, the definition and purpose has expanded to the linked de Bruijn graph <xref rid="b0255" ref-type="bibr">[51]</xref>, positional de Bruijn graph <xref rid="b0070" ref-type="bibr">[14]</xref>, <xref rid="b0240" ref-type="bibr">[48]</xref>, <xref rid="b0015" ref-type="bibr">[3]</xref> and paired de Bruijn graph <xref rid="b0185" ref-type="bibr">[37]</xref> to name a few. Approaches based on de Bruijn graphs have been successful in genome assembly <xref rid="b0035" ref-type="bibr">[7]</xref>, <xref rid="b0225" ref-type="bibr">[45]</xref>, <xref rid="b0260" ref-type="bibr">[52]</xref>, variant detection <xref rid="b0010" ref-type="bibr">[2]</xref>, <xref rid="b0155" ref-type="bibr">[31]</xref>, and storage of assembled genomes <xref rid="b0075" ref-type="bibr">[15]</xref>. The colored variant of the de Bruijn graph is arguably the most well-studied. It is constructed using the sequence data of a population of genomes, rather than a single genome. Here, we assume we have <italic>d</italic> sets of sequence reads that are denoted as <inline-formula><mml:math id="M3" altimg="si11.svg"><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>.</mml:mo><mml:mo>.</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, and we assign a unique color for each these <italic>d</italic> sets. Using this assignment of colors, each edge (and node) is colored with color <inline-formula><mml:math id="M4" altimg="si12.svg"><mml:mrow><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> if and only if the associated <italic>k</italic>-mer (<inline-formula><mml:math id="M5" altimg="si13.svg"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo linebreak="badbreak">-</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>-mer) is contained in <inline-formula><mml:math id="M6" altimg="si14.svg"><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>. In this way, each edge (or node) is assigned one or more colors which signify the sets of sequence reads which contain the corresponding <italic>k</italic>-mer (<inline-formula><mml:math id="M7" altimg="si15.svg"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo linebreak="badbreak">-</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>-mer). The colored de Bruijn graph can then be seen as a de Bruijn graph constructed from the union of the <italic>k</italic>-mers from <inline-formula><mml:math id="M8" altimg="si16.svg"><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>.</mml:mo><mml:mo>.</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, and a binary matrix <italic>C</italic> that stores the colors of each <italic>k</italic>-mers, i.e., <inline-formula><mml:math id="M9" altimg="si17.svg"><mml:mrow><mml:mi>C</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> if the <italic>i</italic>-th <italic>k</italic>-mer is contained in <inline-formula><mml:math id="M10" altimg="si18.svg"><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>. Thus, by traversing the graph and finding shared and divergent paths, rare genetic variants occurring in the population can be identified.</p>
    <p id="p0015">Iqbal et al. <xref rid="b0155" ref-type="bibr">[31]</xref> introduced the colored de Bruijn graph and gave the first implementation, which was in turn used to analyze the 1,000 Genomes Project data. This initial implementation was not space efficient but it motivated the need for implementations that could handle population-level datasets. Hence, in the past couple years there has been an explosion in the interest in space-efficient colored de Bruijn graphs. <inline-formula><mml:math id="M11" altimg="si19.svg"><mml:mrow><mml:mi mathvariant="italic">Vari</mml:mi></mml:mrow></mml:math></inline-formula>
<xref rid="b0195" ref-type="bibr">[39]</xref> and Rainbowfish <xref rid="b0025" ref-type="bibr">[5]</xref>, were the first space-efficient colored de Bruijn graphs methods. Both recognize that the colored de Bruijn graph can be made space-efficient by storing a succinct de Bruijn graph built from the union of all sets of sequence reads (i.e., <inline-formula><mml:math id="M12" altimg="si20.svg"><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>∪</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>∪</mml:mo><mml:mo>…</mml:mo><mml:mo>∪</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>), and a compressed color matrix. Bloom Filter Trie (BFT) <xref rid="b0150" ref-type="bibr">[30]</xref> was another early method for compactly storing the colored de Bruijn graph that uses Bloom filters to store the de Bruijn graph. These initial developments were followed by many other methods, including Mantis <xref rid="b0215" ref-type="bibr">[43]</xref>, and Bifrost <xref rid="b0145" ref-type="bibr">[29]</xref>.</p>
    <p id="p0020">Yet, several public consortium projects are not only significantly large but are also continually evolving, including GenomeTrakr <xref rid="b0020" ref-type="bibr">[4]</xref> and MetaSub <xref rid="b0095" ref-type="bibr">[19]</xref>. For this reason, there is growing interest in dynamic, space-efficient colored de Bruijn graphs that can also evolve with the data – meaning that they allow addition and deletion of data. Given that there are methods for efficiently storing the color matrix in manner that is dynamic, one of the remaining challenges is how to store the de Bruijn graph in a manner that is mutable but also space and time efficient. This is challenging since mutability and compressibility are contradictory in nature. Even allowing for the addition of data into a compressed version of the de Bruijn graph requires some algorithmic cleverness. For example, VariMerge <xref rid="b0190" ref-type="bibr">[38]</xref> and Bifrost <xref rid="b0145" ref-type="bibr">[29]</xref> allow addition of new data but cannot perform deletion. VariMerge enables addition into a colored de Bruijn graph that is stored using <inline-formula><mml:math id="M13" altimg="si21.svg"><mml:mrow><mml:mi mathvariant="italic">Vari</mml:mi></mml:mrow></mml:math></inline-formula> by implementing an algorithm that merges it with another colored de Bruijn graph that is also stored using <inline-formula><mml:math id="M14" altimg="si22.svg"><mml:mrow><mml:mi mathvariant="italic">Vari</mml:mi></mml:mrow></mml:math></inline-formula>. The merge is done without any decompression for space-efficiency. Bifrost first constructs the de Bruijn graph using Bloom filters, then extracts all non-overlapping and non-branching paths in the graph (unitigs) and indexes all the unitigs using minimizers. It performs addition by rebuilding the de Bruijn graph from the minimizer representation, building a new graph for the additions, and then – similar to VariMerge – merging these two graphs succinctly. We refer the reader to Marchet et al. <xref rid="b0175" ref-type="bibr">[35]</xref> for a more thorough explanation of some of these key concepts, including minimizers and Bloom filters.</p>
    <p id="p0025">Similarly, there are only two compressed data structures for storing the de Bruijn graph that allows for both addition and deletion of data; these are FDBG <xref rid="b0090" ref-type="bibr">[18]</xref> and DynamicBOSS <xref rid="b0005" ref-type="bibr">[1]</xref>. FDBG is an implementation of the hash-based data structure of Belazzougui et al. <xref rid="b0040" ref-type="bibr">[8]</xref>. DynamicBOSS is more closely related to the work in this paper. It adapts the de Bruijn graph representation of Bowe et al. <xref rid="b0065" ref-type="bibr">[13]</xref>, which represents a de Bruijn graph using Burrows Wheeler Transform (BWT). Although DynamicBOSS is capable of handling large datasets and is fully dynamic, it is slow due to the reliance on dynamic bit vector libraries, i.e., the library of Prezza <xref rid="b0235" ref-type="bibr">[47]</xref>. Although dynamic bit vectors are being improved, we think it would be better to avoid their use and implement dynamism using static data structures instead. In <xref rid="t0005" ref-type="table">Table 1</xref>, we give an overview of the basic de Bruijn graph data structures and the operations that they support.<table-wrap position="float" id="t0005"><label>Table 1</label><caption><p>An overview of recent de Bruijn graph implementations and their attributes. In theory, BFT is capable of addition of data but it is no longer supported or functional <xref rid="b0140" ref-type="bibr">[28]</xref>.</p></caption><table frame="hsides" rules="groups"><thead><tr><th/><th>BufBOSS</th><th>DynamicBOSS</th><th>FDBG</th><th>Bifrost</th><th>Pufferfish</th><th>BFT</th><th>Mantis</th></tr></thead><tbody><tr><td>Addition</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td><td>No</td><td>No</td><td>No</td></tr><tr><td>Deletion</td><td>Yes</td><td>Yes</td><td>Yes</td><td>No</td><td>No</td><td>No</td><td>No</td></tr></tbody></table></table-wrap></p>
    <p id="p0030">Our contribution is a dynamic, space-efficient de Bruijn graph representation that eliminates the need for dynamic bit vectors. We implement dynamism using the combination of a static, space-efficient representation of the de Bruijn graph, and two auxiliary data structures, which buffer data that is to be added and deleted. As requests for additions or deletions are made, the corresponding buffers are updated, and after a prescribed number of additions or deletions, the static de Bruijn graph is rebuilt. This amortizes the cost of dynamic operations over the cost of rebuilding from time to time. Traversal or use of the graph takes into account the static de Bruijn graph as well as the addition and deletion buffer, which thus makes the static nature of the underlying data structure opaque. We describe how to: (a) buffer the data that is to be added or deleted, (b) support graph traversal taking into account the updates in the buffer (c) merge the updates to the graph efficiently.</p>
    <p id="p0035">We compare our method to existing dynamic de Bruijn graphs – namely Bifrost <xref rid="b0145" ref-type="bibr">[29]</xref>, FDBG <xref rid="b0090" ref-type="bibr">[18]</xref>, and DynamicBOSS <xref rid="b0005" ref-type="bibr">[1]</xref>. The evaluation criteria are the memory and time needed to construct the data structure, the size of the data structure on disk, the time required to add and delete data from the graph, and the time required to perform look-up queries of <italic>k</italic>-mers. In addition to these existing methods, we also implement and compare against a modified version of FDBG that we refer to as FDBG-RecSplit, where RecSplit <xref rid="b0120" ref-type="bibr">[24]</xref> is used for minimal perfect hashing. RecSplit is the most recent minimal perfect hash implementation and thus, shows to have superior computational performance against competing methods.</p>
    <p id="p0040"><inline-formula><mml:math id="M15" altimg="si23.svg"><mml:mrow><mml:mi mathvariant="italic">BufBOSS</mml:mi></mml:mrow></mml:math></inline-formula> was clearly superior to all methods that support addition and deletion (i.e., DynamicBOSS and FDBG) in both memory and time on all large datasets. Bifrost was the closest competitor but does not support deletion and our method was more performant than Bifrost in construction on large metagenomic datasets. In particular, our results show that <inline-formula><mml:math id="M16" altimg="si24.svg"><mml:mrow><mml:mi mathvariant="italic">BufBOSS</mml:mi></mml:mrow></mml:math></inline-formula> was up to five times faster and used up to 30% less memory to construct than the closest competitor (Bifrost). The time required to add new sequences to <inline-formula><mml:math id="M17" altimg="si25.svg"><mml:mrow><mml:mi mathvariant="italic">BufBOSS</mml:mi></mml:mrow></mml:math></inline-formula> was the second fastest in the competition, losing only to Bifrost by a factor of two, but beating the other tools by more than a factor of ten. The peak space during additions was two times larger than Bifrost, but we can vary a time–space trade-off parameter to push our space to slightly below Bifrost with a cost of slowing down the additions by a factor of five. With this setting, we are still faster than the rest of the tools, with a space that is smaller by a factor of eight or more. Lastly, we note the performance of deletion was the best out of all methods that support deletion, i.e., by a factor of 26 in time, and 13 in memory.</p>
  </sec>
  <sec id="s0010">
    <label>2</label>
    <title>Preliminaries</title>
    <p id="p0045">In this section, we briefly go over some of the basic terminology and definitions that will be used throughout this paper.</p>
    <sec id="s0015">
      <label>2.1</label>
      <title>Basic definitions</title>
      <p id="p0050">A string <italic>X</italic>, is represented as a sequence of characters: <inline-formula><mml:math id="M18" altimg="si26.svg"><mml:mrow><mml:mi>X</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mn>1</mml:mn><mml:mo>.</mml:mo><mml:mo>.</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mn>2</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>…</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>, where <italic>n</italic> is the length of the string. Each character will be drawn from an ordered alphabet <inline-formula><mml:math id="M19" altimg="si27.svg"><mml:mrow><mml:mi mathvariant="normal">Σ</mml:mi></mml:mrow></mml:math></inline-formula> of size <inline-formula><mml:math id="M20" altimg="si28.svg"><mml:mrow><mml:mi>σ</mml:mi></mml:mrow></mml:math></inline-formula>. <inline-formula><mml:math id="M21" altimg="si29.svg"><mml:mrow><mml:mi>X</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>.</mml:mo><mml:mo>.</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> refers to the substring of <italic>X</italic> given by <inline-formula><mml:math id="M22" altimg="si30.svg"><mml:mrow><mml:mi>X</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo linebreak="badbreak">+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>…</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>, where <inline-formula><mml:math id="M23" altimg="si31.svg"><mml:mrow><mml:mn>1</mml:mn><mml:mo>⩽</mml:mo><mml:mi>i</mml:mi><mml:mo>⩽</mml:mo><mml:mi>j</mml:mi><mml:mo>⩽</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:math></inline-formula>. Using this notation, a suffix is a substring with <inline-formula><mml:math id="M24" altimg="si32.svg"><mml:mrow><mml:mi>j</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:math></inline-formula>, while a prefix is a substring with <inline-formula><mml:math id="M25" altimg="si33.svg"><mml:mrow><mml:mi>i</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>. An empty string is denoted with <inline-formula><mml:math id="M26" altimg="si34.svg"><mml:mrow><mml:mi>ε</mml:mi></mml:mrow></mml:math></inline-formula>, and it is considered to be a prefix and a suffix of any string. A string of length <italic>k</italic> is called a <italic>k</italic>-mer. The lexicographic order of two strings <italic>X</italic> and <italic>Y</italic> is defined by the order of the characters at the first mismatching position from the left. If no mismatch exists – i.e., one string is a prefix of the other – the prefix is defined to be smaller. The <italic>colexicographic</italic> order of strings is the same but characters are compared from right to left, and in case of no mismatch, <italic>X</italic> is smaller than <italic>Y</italic> iff <italic>X</italic> is a suffix of <italic>Y</italic>.</p>
      <p id="p0055">In this paper, we use the <italic>edge-centric</italic> definition of de Bruijn graphs. In this definition, the graph is such that the nodes are all the distinct <inline-formula><mml:math id="M27" altimg="si35.svg"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo linebreak="badbreak">-</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>-mers of the input strings. There is an edge from <italic>u</italic> (<inline-formula><mml:math id="M28" altimg="si36.svg"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo linebreak="badbreak">-</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>-mer) to <italic>v</italic> (<inline-formula><mml:math id="M29" altimg="si37.svg"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo linebreak="badbreak">-</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>-mer) iff there exists a <italic>k</italic>-mer in some input string that is prefixed by <italic>v</italic> and suffixed by <italic>u</italic>.</p>
      <p id="p0060">To mitigate confusion on whether <italic>k</italic> refers to the length of edges or nodes, we call the <inline-formula><mml:math id="M30" altimg="si38.svg"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo linebreak="badbreak">-</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>-mers represented by the nodes <italic>nodemers</italic> and the <italic>k</italic>-mers represented by the edges <italic>edgemers</italic>. We denote the <inline-formula><mml:math id="M31" altimg="si39.svg"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo linebreak="badbreak">-</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>-mer represented by a node <italic>v</italic> with <inline-formula><mml:math id="M32" altimg="si40.svg"><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and the <italic>k</italic>-mer represented by an edge <italic>e</italic> with <inline-formula><mml:math id="M33" altimg="si41.svg"><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>e</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. A nodemer or an edgemer from the DNA alphabet ACGT is said to be <italic>canonical</italic> if it is equal to its reverse complement.</p>
    </sec>
    <sec id="s0020">
      <label>2.2</label>
      <title>Overview of BOSS</title>
      <p id="p0065">The BOSS data structure <xref rid="b0065" ref-type="bibr">[13]</xref> is a generalization of the classic FM-index <xref rid="b0125" ref-type="bibr">[25]</xref> to de Bruijn graphs. It is a special case of the more general <italic>Wheeler graph index</italic>
<xref rid="b0135" ref-type="bibr">[27]</xref>. Here, we will describe the BOSS data structure in terms of the more general Wheeler graph index, as our implementation is based on that representation.</p>
      <p id="p0070">The Wheeler graph index for a de Bruijn graph <italic>G</italic> is based on a larger graph <italic>W</italic> that contains <italic>G</italic> as a subgraph. The edges of <italic>W</italic> are labeled by single characters, and the nodes are unlabeled. Edges are labeled by the last characters of the corresponding edgemers in <italic>G</italic>. We denote the single-character label of an edge <italic>e</italic> in <italic>W</italic> with <inline-formula><mml:math id="M34" altimg="si42.svg"><mml:mrow><mml:mi>L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>e</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> to distinguish from the notation <inline-formula><mml:math id="M35" altimg="si43.svg"><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>e</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> that refers to the <italic>k</italic>-mer corresponding to <italic>e</italic>.</p>
      <p id="p0075">This construction guarantees that all incoming paths of length <inline-formula><mml:math id="M36" altimg="si44.svg"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo linebreak="badbreak">-</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> to a node <italic>v</italic> spell the same string. Thus, one can walk back <inline-formula><mml:math id="M37" altimg="si45.svg"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo linebreak="badbreak">-</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> nodes in the graph to extract the <inline-formula><mml:math id="M38" altimg="si46.svg"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo linebreak="badbreak">-</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>-mer represented by a node. However, in subgraph <italic>G</italic> alone, some nodes might not have an incoming path of length <inline-formula><mml:math id="M39" altimg="si47.svg"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo linebreak="badbreak">-</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. To amend this, we add for every node <italic>v</italic> with indegree 0 a new path of <italic>k</italic> nodes, each representing a proper prefix of the <inline-formula><mml:math id="M40" altimg="si48.svg"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo linebreak="badbreak">-</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>-mer represented by <italic>v</italic>, all the way to the empty prefix <inline-formula><mml:math id="M41" altimg="si49.svg"><mml:mrow><mml:mi>ε</mml:mi></mml:mrow></mml:math></inline-formula>. The added edges are labeled by the last character of the corresponding prefix of the destination node. If the same prefix is added for two different nodes, the nodes representing those prefixes are glued together. These added nodes and edges are called <italic>dummy nodes</italic> and <italic>dummy edges</italic>. The dummy nodes and edges form a tree starting from the node of the empty string, such that the leaves of the tree have outgoing edges to nodes of subgraph <italic>G</italic>. The notations <inline-formula><mml:math id="M42" altimg="si50.svg"><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="M43" altimg="si51.svg"><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>e</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> are extended for dummy nodes <italic>v</italic> and dummy edges <italic>e</italic> to denote the prefix represented by the node or the edge. The notation <inline-formula><mml:math id="M44" altimg="si52.svg"><mml:mrow><mml:mi>L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>e</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> again denotes the last character of <inline-formula><mml:math id="M45" altimg="si53.svg"><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>e</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
      <p id="p0080">The Wheeler index on <italic>W</italic> is based on the colexicographical order <inline-formula><mml:math id="M46" altimg="si54.svg"><mml:mrow><mml:mi>≺</mml:mi></mml:mrow></mml:math></inline-formula> on the nodes and edges of <italic>W</italic>. For nodes <italic>u</italic> and <italic>v</italic>, it is defined that <inline-formula><mml:math id="M47" altimg="si55.svg"><mml:mrow><mml:mi>u</mml:mi><mml:mi>≺</mml:mi><mml:mi>v</mml:mi></mml:mrow></mml:math></inline-formula> iff <inline-formula><mml:math id="M48" altimg="si56.svg"><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is colexicographically smaller than <inline-formula><mml:math id="M49" altimg="si57.svg"><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. The edges <italic>e</italic> are ordered colexicographically among themselves in the same way by <inline-formula><mml:math id="M50" altimg="si58.svg"><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>e</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. The Wheeler index consists of three main components: (1) a string <inline-formula><mml:math id="M51" altimg="si59.svg"><mml:mrow><mml:mi mathvariant="sans-serif">EBWT</mml:mi></mml:mrow></mml:math></inline-formula>, which is the concatenation of all edge labels of <italic>W</italic> sorted by the order of the node at the origin of the edge, with ties broken arbitrarily (2) a bit vector encoding the outdegrees of all nodes of <italic>W</italic> in the colexicographic order (3) a bit vector encoding the indegrees of all nodes of <italic>W</italic> in the colexicographic order. Remarkably, these data structures define the graph completely <xref rid="b0135" ref-type="bibr">[27]</xref>.</p>
      <p id="p0085"><xref rid="f0005" ref-type="fig">Fig. 1</xref> shows an example of a Wheeler graph. The <inline-formula><mml:math id="M52" altimg="si60.svg"><mml:mrow><mml:mi mathvariant="sans-serif">EBWT</mml:mi></mml:mrow></mml:math></inline-formula> is illustrated with vertical separators showing where the node at the origin changes. These separators are for illustration purposes only and are not included in the <inline-formula><mml:math id="M53" altimg="si61.svg"><mml:mrow><mml:mi mathvariant="sans-serif">EBWT</mml:mi></mml:mrow></mml:math></inline-formula> string. The sequence of outdegrees in colexicographic order is 1,2,1,0,0,1,1,1,1,1,2,1,1, whereas the sequence of indegrees is 0,1,1,1,2,1,1,1,1,1,1,1,1. The Wheeler graph index represents these by encoding degree <italic>d</italic> with bit string <inline-formula><mml:math id="M54" altimg="si62.svg"><mml:mrow><mml:mn>1</mml:mn><mml:mo>·</mml:mo><mml:msup><mml:mrow><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula>, and concatenating the representations. The concatenated representation of outdegrees is denoted with <italic>O</italic> and the concatenated representation of indegrees with <italic>I</italic>.<fig id="f0005"><label>Fig. 1</label><caption><p>The Wheeler graph on the right corresponds to the edge centric de Bruijn graph with edgemers of length 4 from the set of strings ACGTA, ACACGT, AGTA and GCGCGCGA. The dummy node tree is highlighted in yellow. The colexicographic order of the nodes is the following: <inline-formula><mml:math id="M55" altimg="si1.svg"><mml:mrow><mml:mi>ε</mml:mi></mml:mrow></mml:math></inline-formula>, A, ACA, CGA, GTA, AC, CAC, CGC, AG, ACG, GCG, AGT, CGT.</p></caption><graphic xlink:href="gr1"/></fig></p>
      <p id="p0090">The colexicographic ordering implies that if <italic>v</italic> and <italic>u</italic> are nodes such that <inline-formula><mml:math id="M56" altimg="si63.svg"><mml:mrow><mml:mi>v</mml:mi><mml:mi>≺</mml:mi><mml:mi>u</mml:mi></mml:mrow></mml:math></inline-formula>, and both have an outgoing edge with the same character label <inline-formula><mml:math id="M57" altimg="si64.svg"><mml:mrow><mml:mi>c</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="normal">Σ</mml:mi></mml:mrow></mml:math></inline-formula> leading to destinations <inline-formula><mml:math id="M58" altimg="si65.svg"><mml:mrow><mml:mi>v</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="M59" altimg="si66.svg"><mml:mrow><mml:mi>u</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula>, respectively, then <inline-formula><mml:math id="M60" altimg="si67.svg"><mml:mrow><mml:mi>v</mml:mi><mml:mo>′</mml:mo><mml:mi>≺</mml:mi><mml:mi>u</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula>. This means that if we have an interval <inline-formula><mml:math id="M61" altimg="si68.svg"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> of nodes in the order, and follow all outgoing edges from nodes in the interval with the same label <italic>c</italic>, we arrive at another contiguous interval <inline-formula><mml:math id="M62" altimg="si69.svg"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>′</mml:mo><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> of nodes. This, in turn, implies that it’s enough to compute just the endpoints <inline-formula><mml:math id="M63" altimg="si70.svg"><mml:mrow><mml:mi>i</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="M64" altimg="si71.svg"><mml:mrow><mml:mi>j</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> because all the other destinations will fall in between them. This can be done in <inline-formula><mml:math id="M65" altimg="si72.svg"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">log</mml:mi><mml:mi>σ</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>-time using rank queries on <inline-formula><mml:math id="M66" altimg="si73.svg"><mml:mrow><mml:mi mathvariant="sans-serif">EBWT</mml:mi></mml:mrow></mml:math></inline-formula> and rank/select queries on the indegree and outdegree bit vectors <xref rid="b0135" ref-type="bibr">[27]</xref>. Armed with this, we can locate the interval of nodes at the ends of paths labeled with any pattern <italic>P</italic> in <inline-formula><mml:math id="M67" altimg="si74.svg"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mi mathvariant="normal">log</mml:mi><mml:mi>σ</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> time by starting from the interval of all nodes, and updating the interval <inline-formula><mml:math id="M68" altimg="si75.svg"><mml:mrow><mml:mo stretchy="false">|</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">|</mml:mo></mml:mrow></mml:math></inline-formula> times, following the characters of <italic>P</italic>. In the case of the de Bruijn graph, this gives us an algorithm to locate any nodemer in the graph, and to traverse edges in the graph forward and backward.</p>
      <p id="p0095">The original BOSS representation of Bowe et al. <xref rid="b0065" ref-type="bibr">[13]</xref> uses the same ideas but the implementation is slightly different. In this representation, nodes with indegree or outdegree of zero are forbidden. This limitation allows us to represent the information of the indegrees and outdegrees by marking the last outgoing edge from each node and the first incoming edge to each node. This comes at the cost of introducing a new character $ to the alphabet and adding extra edges labeled with $ to <inline-formula><mml:math id="M69" altimg="si76.svg"><mml:mrow><mml:mi mathvariant="sans-serif">EBWT</mml:mi></mml:mrow></mml:math></inline-formula> to ensure that every node has at least one outgoing and incoming edge, but it allows a shorter representation of the indegrees and outdegrees.</p>
    </sec>
  </sec>
  <sec id="s0025">
    <label>3</label>
    <title>Dynamizing compact data structures</title>
    <p id="p0100">BufBOSS follows a line of research dating back to Bentley and Saxe <xref rid="b0055" ref-type="bibr">[11]</xref>. They proposed an approach to making static data structures semi-dynamic when queries are decomposable, where <italic>semi-dynamic</italic> means we can support additions but not deletions and <italic>decomposable</italic> means we can quickly answer a query about the union of two disjoint sets when given the answers to the queries about those two sets separately. Decomposable queries include membership, minimum, maximum and mean, for example, but not mode.</p>
    <p id="p0105">To support queries and updates to a dynamic set <italic>S</italic> using a static data structure <italic>D</italic>, Bentley and Saxe split <italic>S</italic> into a logarithmic number of disjoint subsets whose sizes are distinct powers of 2 and store an instance of <italic>D</italic> for each subset. To query <italic>S</italic>, we query each instance and combine the results. To insert a new element <italic>x</italic> into <italic>S</italic>, we pool <italic>x</italic> with the elements from the subsets of size 1, 2, 4, etc, destroying the instances of <italic>D</italic> for those subsets as we go, until we find a power of 2 for which there is currently no instance of <italic>D</italic>. We build a new instance of <italic>D</italic> storing the pooled elements, whose number of pooled elements is exactly that power of 2. The dynamic version of <italic>D</italic> for <italic>S</italic> we obtain this way is a constant factor larger than the static version of <italic>D</italic> for <italic>S</italic>, answers queries an <inline-formula><mml:math id="M70" altimg="si77.svg"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">log</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> factor more slowly, and supports each addition in amortized <inline-formula><mml:math id="M71" altimg="si78.svg"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi mathvariant="normal">log</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>/</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>-time, where <inline-formula><mml:math id="M72" altimg="si79.svg"><mml:mrow><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is the time to build the static version of <italic>D</italic> for <italic>S</italic>.</p>
    <p id="p0110">Overmars and van Leeuwen <xref rid="b0210" ref-type="bibr">[42]</xref> extended Bentley and Saxe’s approach to make the amortized complexity of additions worst-case, using copies of the subsets and background processing, and to support deletions. Two techniques for supporting deletions are keeping a “ghost” instance of <italic>D</italic> that holds the deleted elements, and “lazily” deleting elements by marking them in the dynamic version of <italic>D</italic> for <italic>S</italic> and then collapsing a subset and rebuilding when more than half its elements have been lazily deleted.</p>
    <p id="p0115">Munro et al. <xref rid="b0200" ref-type="bibr">[40]</xref> adapted Bentley and Saxe’s and Overmars and Van Leeuwen’s results to dynamize compact but static data structures, focusing on indexes for document collections. They proposed keeping a fast but space-inefficient dynamic data structure for the elements that have been added or deleted most recently, as well as a series of compact static data structures for increasingly larger subsets, according to Bentley and Saxe’s scheme; when the dynamic data structure grows too large, they empty it by rebuilding some of the static data structures and incorporating the buffer’s contents. Munro et al. <xref rid="b0200" ref-type="bibr">[40]</xref> emphasized that previous approaches to dynamizing compact data structures generally relied on dynamic bitvectors, for which there are fairly strong lower bounds <xref rid="b0130" ref-type="bibr">[26]</xref>. By maintaining a dynamic, pointer-based buffer and occasionally rebuilding a compact static data, they can avoid using dynamic bitvectors and thus side-step those lower bounds.</p>
    <p id="p0120">Munro et al. also explained how their ideas could be used to obtain dynamic compact representations of graphs, and Coimbra et al. <xref rid="b0085" ref-type="bibr">[17]</xref> recently applied those ideas to obtain an implementation of dynamic <inline-formula><mml:math id="M73" altimg="si80.svg"><mml:mrow><mml:msup><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula>-trees that is competitive with previous implementations, which were essentially just static <inline-formula><mml:math id="M74" altimg="si81.svg"><mml:mrow><mml:msup><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula>-trees but with dynamic instead of static bitvectors. Since DynamicBOSS <xref rid="b0005" ref-type="bibr">[1]</xref> is essentially the data structure of Bowe et al. <xref rid="b0065" ref-type="bibr">[13]</xref> but with dynamic instead of static bit vectors, we are naturally curious how competitive a dynamic de Bruijn graph based on Munro et al.’s ideas will be.</p>
    <p id="p0125">For simplicity and practicality, in this paper we use only one compact static data structure in addition to the dynamic buffer. The main challenge is rebuilding the compact static data structure still in small space, since many data structures that are compact once built are not compact to build, and an implementation is not really compact if it is usually small but balloons every so often.</p>
  </sec>
  <sec id="s0030">
    <label>4</label>
    <title>Buffering additions and deletions</title>
    <p id="p0130">In this section, we describe how to support additions and deletions on a static de Bruijn graph by using a dynamic buffer. Here, we denote <inline-formula><mml:math id="M75" altimg="si82.svg"><mml:mrow><mml:mi>G</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>V</mml:mi><mml:mo>,</mml:mo><mml:mi>E</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> as the (original) graph before any updates. We denote <italic>A</italic> as the set of edgemers we want to add, and <italic>D</italic> as the set of edgemers we want to delete. The edge set of the modified graph <inline-formula><mml:math id="M76" altimg="si83.svg"><mml:mrow><mml:mi>G</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> is <inline-formula><mml:math id="M77" altimg="si84.svg"><mml:mrow><mml:mi>E</mml:mi><mml:mo>′</mml:mo><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>E</mml:mi><mml:mo>∪</mml:mo><mml:mi>A</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>⧹</mml:mo><mml:mi>D</mml:mi></mml:mrow></mml:math></inline-formula> and the node set <inline-formula><mml:math id="M78" altimg="si85.svg"><mml:mrow><mml:mi>V</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> is derived from <inline-formula><mml:math id="M79" altimg="si86.svg"><mml:mrow><mml:mi>E</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> as the set of all nodemers that are prefixes or suffixes of edgemers in <inline-formula><mml:math id="M80" altimg="si87.svg"><mml:mrow><mml:mi>E</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
    <p id="p0135">Since <italic>G</italic> is represented in a BOSS format, the edges and nodes of <italic>G</italic> are identified by their colexicographic ranks. We denote the colexicographic rank of a node <inline-formula><mml:math id="M81" altimg="si88.svg"><mml:mrow><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:mi>V</mml:mi></mml:mrow></mml:math></inline-formula> with <inline-formula><mml:math id="M82" altimg="si89.svg"><mml:mrow><mml:mi mathvariant="sans-serif">colex</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="sans-serif">v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mo stretchy="false">{</mml:mo><mml:mi>ℓ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="sans-serif">u</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi>⪯</mml:mi><mml:mi>ℓ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="sans-serif">v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>:</mml:mo><mml:mspace width="0.25em"/><mml:mi mathvariant="sans-serif">u</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="sans-serif">V</mml:mi><mml:mo stretchy="false">}</mml:mo><mml:mo stretchy="false">|</mml:mo></mml:mrow></mml:math></inline-formula>, where <inline-formula><mml:math id="M83" altimg="si90.svg"><mml:mrow><mml:mi>⪯</mml:mi></mml:mrow></mml:math></inline-formula> denotes the colexicographic comparison and <inline-formula><mml:math id="M84" altimg="si91.svg"><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is the label of <italic>v</italic>. Similarly, for an edge <inline-formula><mml:math id="M85" altimg="si92.svg"><mml:mrow><mml:mi>e</mml:mi><mml:mo>∈</mml:mo><mml:mi>E</mml:mi></mml:mrow></mml:math></inline-formula>, we denote <inline-formula><mml:math id="M86" altimg="si93.svg"><mml:mrow><mml:mi mathvariant="sans-serif">colex</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="sans-serif">e</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mo stretchy="false">{</mml:mo><mml:mi>ℓ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="sans-serif">d</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi>⪯</mml:mi><mml:mi>ℓ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="sans-serif">e</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>:</mml:mo><mml:mspace width="0.25em"/><mml:mi mathvariant="sans-serif">d</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="sans-serif">E</mml:mi><mml:mo stretchy="false">}</mml:mo><mml:mo stretchy="false">|</mml:mo></mml:mrow></mml:math></inline-formula>. We abstract the BOSS structure behind the following interface.<list list-type="simple" id="l0005"><list-item id="u0005"><label>•</label><p id="p0430"><bold>Node search:</bold> Given a node label <inline-formula><mml:math id="M87" altimg="si94.svg"><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, return <inline-formula><mml:math id="M88" altimg="si95.svg"><mml:mrow><mml:mi mathvariant="sans-serif">colex</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="sans-serif">v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> if <inline-formula><mml:math id="M89" altimg="si96.svg"><mml:mrow><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:mi>V</mml:mi></mml:mrow></mml:math></inline-formula> or report that <inline-formula><mml:math id="M90" altimg="si97.svg"><mml:mrow><mml:mi>v</mml:mi><mml:mspace width="0.25em"/><mml:mo>∉</mml:mo><mml:mspace width="0.25em"/><mml:mi>V</mml:mi></mml:mrow></mml:math></inline-formula> in <inline-formula><mml:math id="M91" altimg="si98.svg"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mi mathvariant="normal">log</mml:mi><mml:mi>σ</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>-time.</p></list-item><list-item id="u0010"><label>•</label><p id="p0435"><bold>Edge search:</bold> Given an edge label <inline-formula><mml:math id="M92" altimg="si99.svg"><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>e</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, return <inline-formula><mml:math id="M93" altimg="si100.svg"><mml:mrow><mml:mi mathvariant="sans-serif">colex</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="sans-serif">e</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> if <inline-formula><mml:math id="M94" altimg="si101.svg"><mml:mrow><mml:mi>e</mml:mi><mml:mo>∈</mml:mo><mml:mi>E</mml:mi></mml:mrow></mml:math></inline-formula> or report that <inline-formula><mml:math id="M95" altimg="si102.svg"><mml:mrow><mml:mi>e</mml:mi><mml:mspace width="0.25em"/><mml:mo>∉</mml:mo><mml:mspace width="0.25em"/><mml:mi>E</mml:mi></mml:mrow></mml:math></inline-formula> in <inline-formula><mml:math id="M96" altimg="si103.svg"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mi mathvariant="normal">log</mml:mi><mml:mi>σ</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>-time.</p></list-item><list-item id="u0015"><label>•</label><p id="p0440"><bold>Out-edge label set:</bold> Given <inline-formula><mml:math id="M97" altimg="si104.svg"><mml:mrow><mml:mi mathvariant="sans-serif">colex</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="sans-serif">v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, list the single-character edge labels <inline-formula><mml:math id="M98" altimg="si105.svg"><mml:mrow><mml:mi>L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>e</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> for all edges <italic>e</italic> leaving from <italic>v</italic> in <inline-formula><mml:math id="M99" altimg="si106.svg"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="sans-serif">outdegree</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>-time.</p></list-item><list-item id="u0020"><label>•</label><p id="p0445"><bold>In-edge label:</bold> Given <inline-formula><mml:math id="M100" altimg="si107.svg"><mml:mrow><mml:mi mathvariant="sans-serif">colex</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="sans-serif">v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, return an incoming single-character edge label to <italic>v</italic>, if exists, in <inline-formula><mml:math id="M101" altimg="si108.svg"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>-time (by construction, all incoming edges to a node always have the same label).</p></list-item><list-item id="u0025"><label>•</label><p id="p0450"><bold>Out-edge rank:</bold> Given <inline-formula><mml:math id="M102" altimg="si109.svg"><mml:mrow><mml:mi mathvariant="sans-serif">colex</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="sans-serif">v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> for a node <italic>v</italic> and a character <italic>c</italic>, return the colexicographic rank the edge label <inline-formula><mml:math id="M103" altimg="si110.svg"><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>·</mml:mo><mml:mi>c</mml:mi></mml:mrow></mml:math></inline-formula>, if exists, in <inline-formula><mml:math id="M104" altimg="si111.svg"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">log</mml:mi><mml:mi>σ</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>-time.</p></list-item><list-item id="u0030"><label>•</label><p id="p0455"><bold>Forward:</bold> Given the representation of an edge <italic>e</italic> either as its rank <inline-formula><mml:math id="M105" altimg="si112.svg"><mml:mrow><mml:mi mathvariant="sans-serif">colex</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="sans-serif">e</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, or the pair <inline-formula><mml:math id="M106" altimg="si113.svg"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="sans-serif">colex</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="sans-serif">v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mi mathvariant="sans-serif">L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="sans-serif">e</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, where <italic>v</italic> is the origin of the edge, return <inline-formula><mml:math id="M107" altimg="si114.svg"><mml:mrow><mml:mi mathvariant="sans-serif">colex</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="sans-serif">u</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, where <italic>u</italic> is the node at the destination of an edge, in <inline-formula><mml:math id="M108" altimg="si115.svg"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">log</mml:mi><mml:mi>σ</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>-time.</p></list-item><list-item id="u0035"><label>•</label><p id="p0460"><bold>Backward:</bold> Given <inline-formula><mml:math id="M109" altimg="si116.svg"><mml:mrow><mml:mi mathvariant="sans-serif">colex</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="sans-serif">v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> for a node <italic>v</italic>, return <inline-formula><mml:math id="M110" altimg="si117.svg"><mml:mrow><mml:mi mathvariant="sans-serif">colex</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="sans-serif">u</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, where <italic>u</italic> is a node that has an outgoing edge to <italic>v</italic>, or report that no such edge exists, in <inline-formula><mml:math id="M111" altimg="si118.svg"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">log</mml:mi><mml:mi>σ</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>-time. If there are multiple candidates for <italic>u</italic>, we can return any.</p></list-item><list-item id="u0040"><label>•</label><p id="p0465"><bold>In-edge interval:</bold> Given <inline-formula><mml:math id="M112" altimg="si119.svg"><mml:mrow><mml:mi mathvariant="sans-serif">colex</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="sans-serif">v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, return the interval <inline-formula><mml:math id="M113" altimg="si120.svg"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> of the colexicographic ranks of the incoming edges to <italic>v</italic> in <inline-formula><mml:math id="M114" altimg="si121.svg"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>-time.</p></list-item></list>See Gagie et al. <xref rid="b0135" ref-type="bibr">[27]</xref> for the implementation details of these operations. We now describe how to use these operations and the buffers <italic>A</italic> and <italic>D</italic> to offer graph traversal functionality for <inline-formula><mml:math id="M115" altimg="si122.svg"><mml:mrow><mml:mi>G</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
    <p id="p0140">We represent the addition buffer <italic>A</italic> with a hash table <inline-formula><mml:math id="M116" altimg="si123.svg"><mml:mrow><mml:msub><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mi>A</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, where the keys are nodemers and the values are the sets of added incoming and outgoing edge labels. If an edge <italic>e</italic> is outgoing from the node then its label is the last character of <inline-formula><mml:math id="M117" altimg="si124.svg"><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>e</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>; but if it is incoming then its label in the addition buffer is defined as the <italic>first</italic> character of <inline-formula><mml:math id="M118" altimg="si125.svg"><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>e</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. We note that the label in the incoming direction is usually not the same as the label of the edge in the Wheeler graph, but rather the label of an incoming edge to a node <italic>u</italic> that is at distance <inline-formula><mml:math id="M119" altimg="si126.svg"><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="badbreak">-</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inline-formula> from the origin of <italic>e</italic> backwards. The keys are packed into integers with <inline-formula><mml:math id="M120" altimg="si127.svg"><mml:mrow><mml:mo>⌈</mml:mo><mml:mi mathvariant="normal">log</mml:mi><mml:mi>σ</mml:mi><mml:mo>⌉</mml:mo></mml:mrow></mml:math></inline-formula> bits per character. This allows efficient hashing in <inline-formula><mml:math id="M121" altimg="si128.svg"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mi mathvariant="normal">log</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>σ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>/</mml:mo><mml:mi>w</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> expected time, where <italic>w</italic> is the width of a machine word in the RAM-machine model. In practice, we limit <inline-formula><mml:math id="M122" altimg="si129.svg"><mml:mrow><mml:mi>k</mml:mi><mml:mo>⩽</mml:mo><mml:mn>32</mml:mn></mml:mrow></mml:math></inline-formula>, so that with <inline-formula><mml:math id="M123" altimg="si130.svg"><mml:mrow><mml:mi>σ</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:math></inline-formula>, all the keys can be represented with single 64-bit words. The values of <inline-formula><mml:math id="M124" altimg="si131.svg"><mml:mrow><mml:msub><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mi>A</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> are encoded with two bit vectors using <inline-formula><mml:math id="M125" altimg="si132.svg"><mml:mrow><mml:mi>σ</mml:mi></mml:mrow></mml:math></inline-formula> bits for the forward direction and <inline-formula><mml:math id="M126" altimg="si133.svg"><mml:mrow><mml:mi>σ</mml:mi><mml:mo linebreak="badbreak">+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> bits for the backward direction as the special $-symbol is also a possible incoming label.</p>
    <p id="p0145">For example, if we have a buffer nodemer ACA that is contained in buffer edgemers ACAA, ACAG and TACA, then ACA has outgoing labels A and G (the last symbols of the edgemers ACAA and ACAG, where ACA is a prefix) and an incoming label T (the first symbol of the edgemer TACA, where ACA is a suffix). This information is represented in <inline-formula><mml:math id="M127" altimg="si134.svg"><mml:mrow><mml:msub><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mi>A</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mo>′</mml:mo><mml:mi mathvariant="normal">ACA</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>by bit vectors 00001 in the incoming direction (T is the last character of the incoming alphabet $ACGT) and 1010 in the outgoing direction (A and G are the first and third characters of the outgoing alphabet ACGT). If ACA was not a suffix of any buffer edgemer, then we would have an incoming dollar, which would be encoded by 10000 in the incoming direction.</p>
    <p id="p0150">The hash table <inline-formula><mml:math id="M128" altimg="si135.svg"><mml:mrow><mml:msub><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mi>A</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> provides node and edge membership queries to <italic>A</italic> in <inline-formula><mml:math id="M129" altimg="si136.svg"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mi mathvariant="normal">log</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>σ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>/</mml:mo><mml:mi>w</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> expected time, given a nodemer <inline-formula><mml:math id="M130" altimg="si137.svg"><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> or an edgemer <inline-formula><mml:math id="M131" altimg="si138.svg"><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>e</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
    <p id="p0155">The deletion buffer <italic>D</italic> is represented with just a single bit vector <inline-formula><mml:math id="M132" altimg="si139.svg"><mml:mrow><mml:msub><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mrow><mml:mi>D</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> of length <inline-formula><mml:math id="M133" altimg="si140.svg"><mml:mrow><mml:mo stretchy="false">|</mml:mo><mml:mi>E</mml:mi><mml:mo stretchy="false">|</mml:mo></mml:mrow></mml:math></inline-formula>, such that <inline-formula><mml:math id="M134" altimg="si141.svg"><mml:mrow><mml:msub><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mrow><mml:mi>D</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi mathvariant="sans-serif">colex</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="sans-serif">e</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn mathvariant="sans-serif">1</mml:mn></mml:mrow></mml:math></inline-formula> if and only if <inline-formula><mml:math id="M135" altimg="si142.svg"><mml:mrow><mml:mi>e</mml:mi><mml:mo>∈</mml:mo><mml:mi>D</mml:mi></mml:mrow></mml:math></inline-formula>. This bit vector provides membership queries to <italic>D</italic> in constant time given <inline-formula><mml:math id="M136" altimg="si143.svg"><mml:mrow><mml:mi mathvariant="sans-serif">colex</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="sans-serif">e</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, and in <inline-formula><mml:math id="M137" altimg="si144.svg"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mi mathvariant="normal">log</mml:mi><mml:mi>σ</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> time given <inline-formula><mml:math id="M138" altimg="si145.svg"><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>e</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> by computing <inline-formula><mml:math id="M139" altimg="si146.svg"><mml:mrow><mml:mi mathvariant="sans-serif">colex</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="sans-serif">e</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> with the BOSS structure.</p>
    <p id="p0160">Adding an edgemer <italic>e</italic> to the addition set <italic>A</italic> is done by splitting <italic>e</italic> into the <inline-formula><mml:math id="M140" altimg="si147.svg"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo linebreak="badbreak">-</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>-length prefix and suffix nodemers <italic>v</italic> and <italic>u</italic>, and setting the bits corresponding to the last and first character of <italic>e</italic> in <inline-formula><mml:math id="M141" altimg="si148.svg"><mml:mrow><mml:msub><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mi>A</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>ℓ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="M142" altimg="si149.svg"><mml:mrow><mml:msub><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mi>A</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>ℓ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>, respectively. Adding an edgemer <italic>e</italic> to the deletion set <italic>D</italic> is done by searching <italic>e</italic> using the BOSS to compute <inline-formula><mml:math id="M143" altimg="si150.svg"><mml:mrow><mml:mi mathvariant="sans-serif">colex</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="sans-serif">e</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and marking the position in <inline-formula><mml:math id="M144" altimg="si151.svg"><mml:mrow><mml:msub><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mrow><mml:mi>D</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>. We keep the table <inline-formula><mml:math id="M145" altimg="si152.svg"><mml:mrow><mml:msub><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mi>A</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> and the vector <inline-formula><mml:math id="M146" altimg="si153.svg"><mml:mrow><mml:msub><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mrow><mml:mi>D</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> synchronized so that when we add an edgemer to <inline-formula><mml:math id="M147" altimg="si154.svg"><mml:mrow><mml:msub><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mi>A</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, we remove it from <inline-formula><mml:math id="M148" altimg="si155.svg"><mml:mrow><mml:msub><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mrow><mml:mi>D</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> if present, and vice versa. We do not support node deletions or additions explicitly because the node set is implicitly defined as the set of endpoints of all edges.</p>
    <p id="p0165">We now describe the query interface to the modified graph <inline-formula><mml:math id="M149" altimg="si156.svg"><mml:mrow><mml:mi>G</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula>. Instead of operating on node identifiers <inline-formula><mml:math id="M150" altimg="si157.svg"><mml:mrow><mml:mi mathvariant="sans-serif">colex</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="sans-serif">v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, we operate on node <inline-formula><mml:math id="M151" altimg="si158.svg"><mml:mrow><mml:mi mathvariant="italic">tokens</mml:mi></mml:mrow></mml:math></inline-formula>, which are pairs <inline-formula><mml:math id="M152" altimg="si159.svg"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="sans-serif">colex</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="sans-serif">v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="sans-serif">H</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="sans-serif">A</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>ℓ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="sans-serif">v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, where the first element of the pair is null if <inline-formula><mml:math id="M153" altimg="si160.svg"><mml:mrow><mml:mi>v</mml:mi><mml:mspace width="0.25em"/><mml:mo>∉</mml:mo><mml:mspace width="0.25em"/><mml:mi>V</mml:mi></mml:mrow></mml:math></inline-formula> and the second element is null if <inline-formula><mml:math id="M154" altimg="si161.svg"><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is not a key of <inline-formula><mml:math id="M155" altimg="si162.svg"><mml:mrow><mml:msub><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mi>A</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>.</p>
    <p id="p0170">We can use a token to report whether the represented node exists in <inline-formula><mml:math id="M156" altimg="si163.svg"><mml:mrow><mml:mi>G</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula>. Given the pair <inline-formula><mml:math id="M157" altimg="si164.svg"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="sans-serif">colex</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="sans-serif">v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="sans-serif">H</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="sans-serif">A</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>ℓ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="sans-serif">v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, the node <italic>v</italic> exists in <inline-formula><mml:math id="M158" altimg="si165.svg"><mml:mrow><mml:mi>G</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> if and only if one of the following holds (i) <inline-formula><mml:math id="M159" altimg="si166.svg"><mml:mrow><mml:msub><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mi>A</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>ℓ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> is not null (i.e. <italic>v</italic> is a prefix or a suffix of some edge in the addition set), or (ii) <inline-formula><mml:math id="M160" altimg="si167.svg"><mml:mrow><mml:mi mathvariant="sans-serif">colex</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="sans-serif">v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is not null (i.e. <italic>v</italic> is in the BOSS structure) and there is an incoming or outgoing edge to <italic>v</italic> in the BOSS that is not deleted. Checking case (ii) can be implemented by checking for the existence of a 0-bit in <inline-formula><mml:math id="M161" altimg="si168.svg"><mml:mrow><mml:msub><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mrow><mml:mi>D</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> in the in-edge range of <italic>v</italic> and at the colexicographic rank of every outgoing edge.</p>
    <p id="p0175">We can list all outgoing edge labels from a node represented by a token <inline-formula><mml:math id="M162" altimg="si169.svg"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="sans-serif">colex</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="sans-serif">v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="sans-serif">H</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="sans-serif">A</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>ℓ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="sans-serif">v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> by taking the union of the BOSS out-edge listing and the edges marked in <inline-formula><mml:math id="M163" altimg="si170.svg"><mml:mrow><mml:msub><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mi>A</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>ℓ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>, and removing the edges marked in <inline-formula><mml:math id="M164" altimg="si171.svg"><mml:mrow><mml:msub><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mrow><mml:mi>D</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>.</p>
    <p id="p0180">Forward traversal from a node in <inline-formula><mml:math id="M165" altimg="si172.svg"><mml:mrow><mml:mi>G</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> is done by checking the existence of the edge in <inline-formula><mml:math id="M166" altimg="si173.svg"><mml:mrow><mml:mi>G</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> using the node token, and then updating <inline-formula><mml:math id="M167" altimg="si174.svg"><mml:mrow><mml:mi mathvariant="sans-serif">colex</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="sans-serif">v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> with a BOSS traversal step and <inline-formula><mml:math id="M168" altimg="si175.svg"><mml:mrow><mml:msub><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mi>A</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>ℓ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> with hash table lookup.</p>
    <p id="p0185">If the number of dynamic additions and deletions is small, we can optimize the time of graph traversal at the cost of a little space by marking in the BOSS those nodes which are affected by dynamic operations. These are the nodes whose labels are currently keys in <inline-formula><mml:math id="M169" altimg="si176.svg"><mml:mrow><mml:msub><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mi>A</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> or that have at least one incoming or outgoing edge marked in <inline-formula><mml:math id="M170" altimg="si177.svg"><mml:mrow><mml:msub><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mrow><mml:mi>D</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>. With this, we only have to look up data from <inline-formula><mml:math id="M171" altimg="si178.svg"><mml:mrow><mml:msub><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mi>A</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="M172" altimg="si179.svg"><mml:mrow><mml:msub><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mrow><mml:mi>D</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> on those nodes, and can rely on the static BOSS most of the time when traversing the graph. The marking can be implemented by using a bit vector <italic>M</italic> such that <inline-formula><mml:math id="M173" altimg="si180.svg"><mml:mrow><mml:mi>M</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> iff the node with colexicographic rank <italic>i</italic> is marked. This allows us to mark nodes and query whether a node is marked in constant time, given the colexicographic rank of a node. The colexicographic rank of the current node is always known while traversing the graph.</p>
  </sec>
  <sec id="s0035">
    <label>5</label>
    <title>Batched Updates of Additions and Deletions</title>
    <p id="p0190">In this section, we describe a method to update a BOSS structure with a batch of additions and deletions. The input to the algorithm is a static BOSS structure <inline-formula><mml:math id="M174" altimg="si181.svg"><mml:mrow><mml:mi>G</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>V</mml:mi><mml:mo>,</mml:mo><mml:mi>E</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, a set <italic>A</italic> of edgemers we want to add, and a set <italic>D</italic> of edgemers we want to delete. The sets <italic>A</italic> and <italic>D</italic> are represented with the hash table <inline-formula><mml:math id="M175" altimg="si182.svg"><mml:mrow><mml:msub><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mi>A</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> and the bit vector <inline-formula><mml:math id="M176" altimg="si183.svg"><mml:mrow><mml:msub><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mrow><mml:mi>D</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> described in the previous section. The algorithm requires that <inline-formula><mml:math id="M177" altimg="si184.svg"><mml:mrow><mml:mi>A</mml:mi><mml:mo>∩</mml:mo><mml:mi>D</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mo>∅</mml:mo><mml:mo>,</mml:mo><mml:mi>A</mml:mi><mml:mo>∩</mml:mo><mml:mi>E</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mo>∅</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="M178" altimg="si185.svg"><mml:mrow><mml:mi>D</mml:mi><mml:mo>⊆</mml:mo><mml:mi>E</mml:mi></mml:mrow></mml:math></inline-formula>, which all hold due to the way <inline-formula><mml:math id="M179" altimg="si186.svg"><mml:mrow><mml:msub><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mi>A</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="M180" altimg="si187.svg"><mml:mrow><mml:msub><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mrow><mml:mi>D</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> are constructed and synchronized. The output is a BOSS structure containing the set of edgemers of <italic>G</italic> with the set <italic>A</italic> added and <italic>D</italic> deleted.</p>
    <p id="p0195">The update algorithm consists of four phases: (1) a dummy node preparation phase, (2) a merge planning phase, (3) a merge execution phase, which applies both the additions and the deletions, and (4) an optional dummy cleanup phase. We now proceed to describe each phase in this order.</p>
    <sec id="s0040">
      <label>5.1</label>
      <title>Dummy node preparation phase</title>
      <p id="p0200">In this phase, we iterate over the deletion buffer to check which nodes will be left without an incoming edge after the update. We must add an incoming chain of dummy nodes to these nodes during the update. For every edge that is marked for deletion in <inline-formula><mml:math id="M181" altimg="si188.svg"><mml:mrow><mml:msub><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mrow><mml:mi>D</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, we first check whether all incoming edges to its destination node <italic>v</italic> are marked for deletion. If this is the case, we check in the addition buffer whether there are new incoming edges to <italic>v</italic>. If not, we need to add the incoming dummy chain to <italic>v</italic>.</p>
      <p id="p0205">To implement these checks, we need to know <inline-formula><mml:math id="M182" altimg="si189.svg"><mml:mrow><mml:msub><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mi>A</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>ℓ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> and the indegree range of <italic>v</italic>. We can find both of these by using the static BOSS structure. We traverse the edge to <italic>v</italic> to find <inline-formula><mml:math id="M183" altimg="si190.svg"><mml:mrow><mml:mi mathvariant="sans-serif">colex</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="sans-serif">v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, which allows us compute the indegree range, and then retrieve the label <inline-formula><mml:math id="M184" altimg="si191.svg"><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> by traversing backward <inline-formula><mml:math id="M185" altimg="si192.svg"><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="badbreak">-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> times, which enables us to look up <inline-formula><mml:math id="M186" altimg="si193.svg"><mml:mrow><mml:msub><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mi>A</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>ℓ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. All the required new dummy nodes are added to the addition buffer before proceeding to the next phase.</p>
    </sec>
    <sec id="s0045">
      <label>5.2</label>
      <title>Merge planning phase</title>
      <p id="p0210">The purpose of the planning phase is to find the correct places of the node labels in the addition buffer in the colexicographic order of the node labels of the BOSS. Our approach can be seen as a streamlined variant of the planning phase of VariMerge <xref rid="b0190" ref-type="bibr">[38]</xref>, where we have a BOSS structure and a sorted addition buffer rather than two using BOSS structures. This phase does not depend on the deletion buffer at all – the deletions are taken into account in the next phase.</p>
      <p id="p0215">To aid our presentation, we assume that every node label has length <inline-formula><mml:math id="M187" altimg="si194.svg"><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="badbreak">-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>, by padding the node labels of the dummy nodes with $-symbols from the left. With this, we define the <italic>BOSS matrix</italic>, denoted with <inline-formula><mml:math id="M188" altimg="si195.svg"><mml:mrow><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">boss</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, such that <inline-formula><mml:math id="M189" altimg="si196.svg"><mml:mrow><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">boss</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> is the <inline-formula><mml:math id="M190" altimg="si197.svg"><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:math></inline-formula>-th character of the <inline-formula><mml:math id="M191" altimg="si197.svg"><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:math></inline-formula>-th node label of the BOSS in colexicographic order. Similarly, we define the <italic>buffer matrix</italic>, denoted with <inline-formula><mml:math id="M192" altimg="si198.svg"><mml:mrow><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">buffer</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, such that <inline-formula><mml:math id="M193" altimg="si199.svg"><mml:mrow><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">buffer</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> is the <inline-formula><mml:math id="M194" altimg="si197.svg"><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:math></inline-formula>-th character of the <inline-formula><mml:math id="M195" altimg="si197.svg"><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:math></inline-formula>-th node label of the addition buffer in colexicographic order. We denote with <inline-formula><mml:math id="M196" altimg="si200.svg"><mml:mrow><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>boss</mml:mi></mml:mrow></mml:msub><mml:mspace width="0.25em"/><mml:mi>and</mml:mi><mml:mspace width="0.25em"/><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>buffer</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> the number of rows in <inline-formula><mml:math id="M197" altimg="si201.svg"><mml:mrow><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">boss</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="M198" altimg="si202.svg"><mml:mrow><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">buffer</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> present in the BOSS but not in the buffer, or the other wayrespectively.</p>
      <p id="p0220">We build <inline-formula><mml:math id="M199" altimg="si203.svg"><mml:mrow><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">buffer</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> by extracting all node labels from the addition buffer and sorting them colexicographically. We also attach (as satellite data) to each row the <inline-formula><mml:math id="M200" altimg="si204.svg"><mml:mrow><mml:msub><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mi>A</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> entry encoding the outgoing and incoming labels. However, we note that the matrix <inline-formula><mml:math id="M201" altimg="si205.svg"><mml:mrow><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">boss</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> is not built explicitly. We only define and use it here for explanatory purposes and note that we can use the BOSS structure to access it column by column from right to left. The last column can be constructed by querying the in-edge labels of the nodes in colexicographic order, and Algorithm 2 describes a subroutine that takes as input the <inline-formula><mml:math id="M202" altimg="si206.svg"><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:math></inline-formula>-th column of <inline-formula><mml:math id="M203" altimg="si207.svg"><mml:mrow><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">boss</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, and returns the <inline-formula><mml:math id="M204" altimg="si208.svg"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo linebreak="badbreak">-</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>-th column, by propagating the labels forward in the de Bruijn graph.</p>
      <p id="p0225">After constructing <inline-formula><mml:math id="M205" altimg="si209.svg"><mml:mrow><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">buffer</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, we identify equal rows between <inline-formula><mml:math id="M206" altimg="si210.svg"><mml:mrow><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mi>buffer</mml:mi></mml:mrow></mml:msub><mml:mspace width="0.25em"/><mml:mi>and</mml:mi><mml:mspace width="0.25em"/><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mi>boss</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, and the colexicographic interleaving of the rest of the rows. This is done by running <inline-formula><mml:math id="M207" altimg="si211.svg"><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="badbreak">-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> iterations of a partition refinement subroutine. At the start of iteration <inline-formula><mml:math id="M208" altimg="si212.svg"><mml:mrow><mml:mi>t</mml:mi></mml:mrow></mml:math></inline-formula>, we have a sequence of pairs of half-open intervals <inline-formula><mml:math id="M209" altimg="si213.svg"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, <inline-formula><mml:math id="M210" altimg="si214.svg"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, <inline-formula><mml:math id="M211" altimg="si215.svg"><mml:mrow><mml:mo>…</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:math></inline-formula>
<inline-formula><mml:math id="M212" altimg="si216.svg"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> such that the intervals describe the coarsest partition of rows where every row in the same part has the same suffix of length <inline-formula><mml:math id="M213" altimg="si217.svg"><mml:mrow><mml:mi>t</mml:mi><mml:mo linebreak="badbreak">-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>. That is, the pairs at iteration <inline-formula><mml:math id="M214" altimg="si218.svg"><mml:mrow><mml:mi>t</mml:mi></mml:mrow></mml:math></inline-formula> have the following properties:<list list-type="simple" id="l0010"><list-item id="o0005"><label>1.</label><p id="p0470"><inline-formula><mml:math id="M215" altimg="si219.svg"><mml:mrow><mml:mn>1</mml:mn><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>⩽</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mo>⩽</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>boss</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mspace width="0.25em"/><mml:mi>and</mml:mi><mml:mspace width="0.25em"/><mml:mn>1</mml:mn><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>⩽</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mo>⩽</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>buffer</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>.</p></list-item><list-item id="o0010"><label>2.</label><p id="p0475"><inline-formula><mml:math id="M216" altimg="si220.svg"><mml:mrow><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mi>boss</mml:mi></mml:mrow></mml:msub><mml:mo>[</mml:mo><mml:mi>p</mml:mi><mml:mo>]</mml:mo><mml:mo>[</mml:mo><mml:mo>(</mml:mo><mml:mi>k</mml:mi><mml:mo>-</mml:mo><mml:mi>t</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo><mml:mo>.</mml:mo><mml:mo>.</mml:mo><mml:mo>(</mml:mo><mml:mi>k</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo><mml:mo>]</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mi>buffer</mml:mi></mml:mrow></mml:msub><mml:mo>[</mml:mo><mml:mi>q</mml:mi><mml:mo>]</mml:mo><mml:mo>[</mml:mo><mml:mo>(</mml:mo><mml:mi>k</mml:mi><mml:mo>-</mml:mo><mml:mi>t</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo><mml:mo>.</mml:mo><mml:mo>.</mml:mo><mml:mo>(</mml:mo><mml:mi>k</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo><mml:mo>]</mml:mo><mml:mspace width="0.25em"/><mml:mi>for</mml:mi><mml:mspace width="0.25em"/><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>⩽</mml:mo><mml:mi>p</mml:mi><mml:mo>&lt;</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mspace width="0.25em"/><mml:mi>and</mml:mi><mml:mspace width="0.25em"/><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>⩽</mml:mo><mml:mi>q</mml:mi><mml:mo>&lt;</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>.</p></list-item><list-item id="o0015"><label>3.</label><p id="p0480">If <inline-formula><mml:math id="M217" altimg="si221.svg"><mml:mrow><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mspace width="0.25em"/><mml:mo>≠</mml:mo><mml:mspace width="0.25em"/><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, then <inline-formula><mml:math id="M218" altimg="si222.svg"><mml:mrow><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">boss</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo linebreak="badbreak">-</mml:mo><mml:mi>t</mml:mi><mml:mo linebreak="badbreak">+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo><mml:mo>.</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo linebreak="badbreak">-</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo><mml:mspace width="0.25em"/><mml:mo>≠</mml:mo><mml:mspace width="0.25em"/><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">boss</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo linebreak="badbreak">-</mml:mo><mml:mi>t</mml:mi><mml:mo linebreak="badbreak">+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo><mml:mo>.</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo linebreak="badbreak">-</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula></p></list-item><list-item id="o0020"><label>4.</label><p id="p0485">If <inline-formula><mml:math id="M219" altimg="si223.svg"><mml:mrow><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mspace width="0.25em"/><mml:mo>≠</mml:mo><mml:mspace width="0.25em"/><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, then <inline-formula><mml:math id="M220" altimg="si224.svg"><mml:mrow><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">buffer</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo linebreak="badbreak">-</mml:mo><mml:mi>t</mml:mi><mml:mo linebreak="badbreak">+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo><mml:mo>.</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo linebreak="badbreak">-</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo><mml:mspace width="0.25em"/><mml:mo>≠</mml:mo><mml:mspace width="0.25em"/><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">buffer</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo linebreak="badbreak">-</mml:mo><mml:mi>t</mml:mi><mml:mo linebreak="badbreak">+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo><mml:mo>.</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo linebreak="badbreak">-</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula></p></list-item></list>To encode these interval pairs succinctly, we only encode the differences <inline-formula><mml:math id="M221" altimg="si225.svg"><mml:mrow><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>-</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mspace width="0.25em"/></mml:mrow></mml:msub><mml:mi>and</mml:mi><mml:mspace width="0.25em"/><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>-</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> as unary numbers, using in total only <inline-formula><mml:math id="M222" altimg="si226.svg"><mml:mrow><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>boss</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>buffer</mml:mi></mml:mrow></mml:msub><mml:mo>)</mml:mo></mml:mrow></mml:math></inline-formula>bits. Empty intervals are allowed when a node is present in the BOSS but not in the buffer, or the other way around.</p>
      <p id="p0230">At the start of iteration <inline-formula><mml:math id="M223" altimg="si227.svg"><mml:mrow><mml:mi>t</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>, we have just a single pair <inline-formula><mml:math id="M224" altimg="si228.svg"><mml:mrow><mml:mo>(</mml:mo><mml:mo>[</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>boss</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo><mml:mo>,</mml:mo><mml:mo>[</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>buffer</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo><mml:mo>)</mml:mo></mml:mrow></mml:math></inline-formula>. Each iteration refines the partition encoded in the interval pairs by splitting the intervals by the runs of characters in the previous columns of <inline-formula><mml:math id="M225" altimg="si229.svg"><mml:mrow><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mi>boss</mml:mi></mml:mrow></mml:msub><mml:mspace width="0.25em"/><mml:mi>and</mml:mi><mml:mspace width="0.25em"/><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mi>buffer</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>. The pseudocode is at Algorithm 3.<table-wrap position="float" id="t0030"><table frame="hsides" rules="groups"><thead><tr><th><bold>Algorithm 1</bold>: Dummy node preparation phase</th></tr></thead><tbody><tr><td>1. <bold>for</bold><inline-formula><mml:math id="M226" altimg="si230.svg"><mml:mrow><mml:mi>e</mml:mi><mml:mo linebreak="goodbreak">=</mml:mo><mml:mn>1</mml:mn><mml:mo>.</mml:mo><mml:mo>.</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mi mathvariant="sans-serif">EBWT</mml:mi><mml:mo stretchy="false">|</mml:mo></mml:mrow></mml:math></inline-formula><bold>do</bold> ≜ For all edges in colex order</td></tr><tr><td>2. <bold>if</bold><inline-formula><mml:math id="M227" altimg="si231.svg"><mml:mrow><mml:msub><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mrow><mml:mi>D</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>e</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo linebreak="goodbreak">=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula><bold>then</bold> ≜ Marked for deletion</td></tr><tr><td>3.  <inline-formula><mml:math id="M228" altimg="si232.svg"><mml:mrow><mml:mi>v</mml:mi><mml:mo>←</mml:mo></mml:mrow></mml:math></inline-formula> gets BOSS.Forward(<inline-formula><mml:math id="M229" altimg="si233.svg"><mml:mrow><mml:mi>e</mml:mi></mml:mrow></mml:math></inline-formula>)  ≜ Follow edge</td></tr><tr><td>4.  <inline-formula><mml:math id="M230" altimg="si234.svg"><mml:mrow><mml:mi>S</mml:mi><mml:mo>←</mml:mo></mml:mrow></mml:math></inline-formula> BOSS.NodeLabel(<inline-formula><mml:math id="M231" altimg="si235.svg"><mml:mrow><mml:mi>v</mml:mi></mml:mrow></mml:math></inline-formula>)</td></tr><tr><td>5.  <inline-formula><mml:math id="M232" altimg="si236.svg"><mml:mrow><mml:mo>[</mml:mo><mml:mi>ℓ</mml:mi><mml:mo>,</mml:mo><mml:mi>r</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math></inline-formula> ← BOSS.InEdgeInterval(<inline-formula><mml:math id="M233" altimg="si237.svg"><mml:mrow><mml:mi>v</mml:mi></mml:mrow></mml:math></inline-formula>)</td></tr><tr><td>6.  <bold>if</bold><inline-formula><mml:math id="M234" altimg="si238.svg"><mml:mrow><mml:msub><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mrow><mml:mi>D</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>l</mml:mi><mml:mo>.</mml:mo><mml:mo>.</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> has only ones <bold>then</bold></td></tr><tr><td>7.   <bold>if</bold><inline-formula><mml:math id="M235" altimg="si239.svg"><mml:mrow><mml:msub><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mi>A</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> has no incoming edges <bold>then</bold></td></tr><tr><td>8.     Add all prefixes of <inline-formula><mml:math id="M236" altimg="si239.svg"><mml:mrow><mml:mi>S</mml:mi></mml:mrow></mml:math></inline-formula> to <inline-formula><mml:math id="M237" altimg="si240.svg"><mml:mrow><mml:msub><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mi>A</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula></td></tr></tbody></table></table-wrap><table-wrap position="float" id="t0035"><table frame="hsides" rules="groups"><thead><tr><th><bold>Algorithm 2</bold>: Subroutine PrevColumn</th></tr></thead><tbody><tr><td><bold>Input:</bold> The <inline-formula><mml:math id="M238" altimg="si241.svg"><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:math></inline-formula>-th column of <inline-formula><mml:math id="M239" altimg="si242.svg"><mml:mrow><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">boss</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, denoted with <inline-formula><mml:math id="M240" altimg="si243.svg"><mml:mrow><mml:mi mathvariant="italic">Col</mml:mi></mml:mrow></mml:math></inline-formula>.</td></tr><tr><td><bold>Output:</bold> The <inline-formula><mml:math id="M241" altimg="si244.svg"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo linebreak="badbreak">-</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>-th column of <inline-formula><mml:math id="M242" altimg="si245.svg"><mml:mrow><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">boss</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula></td></tr><tr><td>1. <inline-formula><mml:math id="M243" altimg="si246.svg"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="italic">Col</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="italic">new</mml:mi></mml:mrow></mml:msub><mml:mo>←</mml:mo></mml:mrow></mml:math></inline-formula>Empty column of length <inline-formula><mml:math id="M244" altimg="si247.svg"><mml:mrow><mml:mo stretchy="false">|</mml:mo><mml:mi mathvariant="italic">Col</mml:mi><mml:mo stretchy="false">|</mml:mo></mml:mrow></mml:math></inline-formula> 2. <bold>for</bold><inline-formula><mml:math id="M245" altimg="si248.svg"><mml:mrow><mml:mi>v</mml:mi><mml:mo linebreak="goodbreak">=</mml:mo><mml:mn>1</mml:mn><mml:mo>.</mml:mo><mml:mo>.</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mi mathvariant="italic">Col</mml:mi><mml:mo stretchy="false">|</mml:mo></mml:mrow></mml:math></inline-formula><bold>do</bold></td></tr><tr><td>3. <bold>for</bold><inline-formula><mml:math id="M246" altimg="si249.svg"><mml:mrow><mml:mi>c</mml:mi></mml:mrow></mml:math></inline-formula><bold>in</bold> the outgoing label set from node <inline-formula><mml:math id="M247" altimg="si250.svg"><mml:mrow><mml:mi>v</mml:mi></mml:mrow></mml:math></inline-formula><bold>do</bold></td></tr><tr><td>4.  <inline-formula><mml:math id="M248" altimg="si251.svg"><mml:mrow><mml:mi>u</mml:mi><mml:mo>←</mml:mo></mml:mrow></mml:math></inline-formula>BOSS.Forward(<inline-formula><mml:math id="M249" altimg="si252.svg"><mml:mrow><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:mi>c</mml:mi></mml:mrow></mml:math></inline-formula>)</td></tr><tr><td>5.  <inline-formula><mml:math id="M250" altimg="si253.svg"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="italic">Col</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="italic">new</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo linebreak="goodbreak">=</mml:mo><mml:mi mathvariant="italic">Col</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula></td></tr><tr><td>6. <inline-formula><mml:math id="M251" altimg="si254.svg"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="italic">Col</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="italic">new</mml:mi></mml:mrow></mml:msub><mml:mo>[</mml:mo><mml:mn>1</mml:mn><mml:mo>]</mml:mo><mml:mo>←</mml:mo><mml:mo>$</mml:mo></mml:mrow></mml:math></inline-formula>  ≜Root node</td></tr><tr><td>7. Return <inline-formula><mml:math id="M252" altimg="si255.svg"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="italic">Col</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="italic">new</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula></td></tr></tbody></table></table-wrap><table-wrap position="float" id="t0040"><table frame="hsides" rules="groups"><thead><tr><th><bold>Algorithm 3</bold>: Merge planning phase</th></tr></thead><tbody><tr><td>1. <inline-formula><mml:math id="M253" altimg="si256.svg"><mml:mrow><mml:mi mathvariant="italic">Col</mml:mi><mml:mo>←</mml:mo></mml:mrow></mml:math></inline-formula> Array with length <inline-formula><mml:math id="M254" altimg="si257.svg"><mml:mrow><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">boss</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula></td></tr><tr><td>2. <bold>for</bold><inline-formula><mml:math id="M255" altimg="si258.svg"><mml:mrow><mml:mi>v</mml:mi><mml:mo linebreak="goodbreak">=</mml:mo><mml:mn>1</mml:mn><mml:mo>.</mml:mo><mml:mo>.</mml:mo><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">boss</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula><bold>do</bold>  ≜ For all BOSS nodes in colex order</td></tr><tr><td>3. <inline-formula><mml:math id="M256" altimg="si259.svg"><mml:mrow><mml:mi mathvariant="italic">Col</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>←</mml:mo></mml:mrow></mml:math></inline-formula>in-edge label of <inline-formula><mml:math id="M257" altimg="si260.svg"><mml:mrow><mml:mi>v</mml:mi></mml:mrow></mml:math></inline-formula>, or '$ ’ <inline-formula><mml:math id="M258" altimg="si261.svg"><mml:mrow><mml:mi>if</mml:mi><mml:mspace width="0.25em"/><mml:mi mathvariant="italic">indegree</mml:mi><mml:mo>(</mml:mo><mml:mi>v</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math></inline-formula> = 0.</td></tr><tr><td>4. Q ← Empty queue</td></tr><tr><td>5. Push <inline-formula><mml:math id="M259" altimg="si262.svg"><mml:mrow><mml:mfenced><mml:mrow><mml:mo>[</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>boss</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo><mml:mo>,</mml:mo><mml:mo>[</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>buffer</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mfenced></mml:mrow></mml:math></inline-formula> to <italic>Q</italic></td></tr><tr><td>6. <bold>for</bold><inline-formula><mml:math id="M260" altimg="si263.svg"><mml:mrow><mml:mi>t</mml:mi><mml:mo linebreak="goodbreak">=</mml:mo><mml:mn>1</mml:mn><mml:mo>.</mml:mo><mml:mo>.</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo linebreak="badbreak">-</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula><bold>do</bold></td></tr><tr><td>7. <inline-formula><mml:math id="M261" altimg="si264.svg"><mml:mrow><mml:msub><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="italic">new</mml:mi></mml:mrow></mml:msub><mml:mo>←</mml:mo></mml:mrow></mml:math></inline-formula> Empty queue</td></tr><tr><td>8. <bold>while</bold> Q is not empty <bold>do</bold></td></tr><tr><td>9.   Pop <inline-formula><mml:math id="M262" altimg="si265.svg"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> from <inline-formula><mml:math id="M263" altimg="si266.svg"><mml:mrow><mml:mi>Q</mml:mi></mml:mrow></mml:math></inline-formula></td></tr><tr><td>10.</td></tr><tr><td>11.   Refine interval pair <inline-formula><mml:math id="M264" altimg="si267.svg"><mml:mrow><mml:mo>[</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>)</mml:mo><mml:mo>,</mml:mo><mml:mo>[</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>)</mml:mo></mml:mrow></mml:math></inline-formula></td></tr><tr><td>12.  <inline-formula><mml:math id="M265" altimg="si268.svg"><mml:mrow><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>y</mml:mi><mml:mo>←</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula></td></tr><tr><td>13.  <inline-formula><mml:math id="M266" altimg="si269.svg"><mml:mrow><mml:mi>x</mml:mi><mml:mo>′</mml:mo><mml:mo>,</mml:mo><mml:mi>y</mml:mi><mml:mo>′</mml:mo><mml:mo>←</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>y</mml:mi></mml:mrow></mml:math></inline-formula></td></tr><tr><td>14.  <bold>for</bold><inline-formula><mml:math id="M267" altimg="si270.svg"><mml:mrow><mml:mi>c</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="normal">Σ</mml:mi><mml:mo>∪</mml:mo><mml:mo stretchy="false">{</mml:mo><mml:ms>$</mml:ms><mml:mo stretchy="false">}</mml:mo></mml:mrow></mml:math></inline-formula> in alphabetical order <bold>do</bold></td></tr><tr><td>15.   <bold>while</bold><inline-formula><mml:math id="M268" altimg="si271.svg"><mml:mrow><mml:mi>x</mml:mi><mml:mo>′</mml:mo><mml:mo>&lt;</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="M269" altimg="si272.svg"><mml:mrow><mml:mi mathvariant="italic">Col</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">]</mml:mo><mml:mo linebreak="goodbreak">=</mml:mo><mml:mi>c</mml:mi></mml:mrow></mml:math></inline-formula><bold>do</bold></td></tr><tr><td>16.    <inline-formula><mml:math id="M270" altimg="si273.svg"><mml:mrow><mml:mi>x</mml:mi><mml:mo>′</mml:mo><mml:mo>←</mml:mo><mml:mi>x</mml:mi><mml:mo>′</mml:mo><mml:mo linebreak="badbreak">+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula></td></tr><tr><td>17.   <bold>while</bold><inline-formula><mml:math id="M271" altimg="si274.svg"><mml:mrow><mml:mi>y</mml:mi><mml:mo>′</mml:mo><mml:mo>&lt;</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="M272" altimg="si275.svg"><mml:mrow><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">buffer</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>y</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo linebreak="badbreak">-</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo linebreak="goodbreak">=</mml:mo><mml:mi>c</mml:mi></mml:mrow></mml:math></inline-formula><bold>do</bold></td></tr><tr><td>18.     <inline-formula><mml:math id="M273" altimg="si276.svg"><mml:mrow><mml:mi>y</mml:mi><mml:mo>′</mml:mo><mml:mo>←</mml:mo><mml:mi>y</mml:mi><mml:mo>′</mml:mo><mml:mo linebreak="badbreak">+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula></td></tr><tr><td>19.  <bold>if</bold><inline-formula><mml:math id="M274" altimg="si277.svg"><mml:mrow><mml:mi>x</mml:mi><mml:mo>′</mml:mo><mml:mo>&gt;</mml:mo><mml:mi>x</mml:mi></mml:mrow></mml:math></inline-formula>or <inline-formula><mml:math id="M275" altimg="si278.svg"><mml:mrow><mml:mi>y</mml:mi><mml:mo>′</mml:mo><mml:mo>&gt;</mml:mo><mml:mi>y</mml:mi></mml:mrow></mml:math></inline-formula><bold>then</bold></td></tr><tr><td>20.    Push <inline-formula><mml:math id="M276" altimg="si279.svg"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>x</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>y</mml:mi><mml:mo>,</mml:mo><mml:mi>y</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> to <inline-formula><mml:math id="M277" altimg="si280.svg"><mml:mrow><mml:msub><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="italic">new</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula></td></tr><tr><td>21.  <inline-formula><mml:math id="M278" altimg="si281.svg"><mml:mrow><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>y</mml:mi><mml:mo>←</mml:mo><mml:mi>x</mml:mi><mml:mo>′</mml:mo><mml:mo>,</mml:mo><mml:mi>y</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula></td></tr><tr><td>22. <inline-formula><mml:math id="M279" altimg="si282.svg"><mml:mrow><mml:mi mathvariant="italic">Col</mml:mi><mml:mo>←</mml:mo></mml:mrow></mml:math></inline-formula>PrevColumn(<inline-formula><mml:math id="M280" altimg="si283.svg"><mml:mrow><mml:mi mathvariant="italic">Col</mml:mi></mml:mrow></mml:math></inline-formula>) ≜ Algorithm 2</td></tr><tr><td>23. <inline-formula><mml:math id="M281" altimg="si284.svg"><mml:mrow><mml:mi>Q</mml:mi><mml:mo>←</mml:mo><mml:msub><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="italic">new</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula></td></tr><tr><td>24.<bold>Return</bold><inline-formula><mml:math id="M282" altimg="si285.svg"><mml:mrow><mml:mi>Q</mml:mi></mml:mrow></mml:math></inline-formula></td></tr></tbody></table></table-wrap><table-wrap position="float" id="t0045"><table frame="hsides" rules="groups"><thead><tr><th><bold>Algorithm 4</bold>: Merge execution phase</th></tr></thead><tbody><tr><td><bold>Input:</bold> The addition and deletion buffers, the BOSS structure and the queue <inline-formula><mml:math id="M283" altimg="si286.svg"><mml:mrow><mml:mi>Q</mml:mi></mml:mrow></mml:math></inline-formula> returned by Algorithm 3.</td></tr><tr><td><bold>Output:</bold> BOSS of the updated graph</td></tr><tr><td>1. <bold>While</bold><inline-formula><mml:math id="M284" altimg="si287.svg"><mml:mrow><mml:mi>Q</mml:mi></mml:mrow></mml:math></inline-formula> is not empty <bold>do</bold></td></tr><tr><td>2.  Pop <inline-formula><mml:math id="M285" altimg="si288.svg"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> from <inline-formula><mml:math id="M286" altimg="si289.svg"><mml:mrow><mml:mi>Q</mml:mi></mml:mrow></mml:math></inline-formula></td></tr><tr><td>3. <bold>if</bold><inline-formula><mml:math id="M287" altimg="si290.svg"><mml:mrow><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo linebreak="badbreak">-</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo linebreak="goodbreak">=</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo linebreak="badbreak">-</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo linebreak="goodbreak">=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula><bold>then</bold>   ≜ Shared node</td></tr><tr><td>4.   Outlabels <inline-formula><mml:math id="M288" altimg="si291.svg"><mml:mrow><mml:mo>←</mml:mo></mml:mrow></mml:math></inline-formula> (BOSS.Outlabels(<inline-formula><mml:math id="M289" altimg="si292.svg"><mml:mrow><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>) <inline-formula><mml:math id="M290" altimg="si293.svg"><mml:mrow><mml:mo>⧹</mml:mo></mml:mrow></mml:math></inline-formula> DeletionsFrom(<inline-formula><mml:math id="M291" altimg="si294.svg"><mml:mrow><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>)) <inline-formula><mml:math id="M292" altimg="si295.svg"><mml:mrow><mml:mo>∪</mml:mo></mml:mrow></mml:math></inline-formula> AdditionsFrom(<inline-formula><mml:math id="M293" altimg="si296.svg"><mml:mrow><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>)</td></tr><tr><td>5.   InDegree <inline-formula><mml:math id="M294" altimg="si297.svg"><mml:mrow><mml:mo>←</mml:mo></mml:mrow></mml:math></inline-formula><inline-formula><mml:math id="M295" altimg="si298.svg"><mml:mrow><mml:mo stretchy="false">|</mml:mo></mml:mrow></mml:math></inline-formula>BOSS.InEdgeInterval(<inline-formula><mml:math id="M296" altimg="si299.svg"><mml:mrow><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>)<inline-formula><mml:math id="M297" altimg="si300.svg"><mml:mrow><mml:mo stretchy="false">|</mml:mo></mml:mrow></mml:math></inline-formula><inline-formula><mml:math id="M298" altimg="si301.svg"><mml:mrow><mml:mo linebreak="newline">-</mml:mo></mml:mrow></mml:math></inline-formula> CountDeletionsTo(<inline-formula><mml:math id="M299" altimg="si302.svg"><mml:mrow><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>) <inline-formula><mml:math id="M300" altimg="si303.svg"><mml:mrow><mml:mo linebreak="newline">+</mml:mo></mml:mrow></mml:math></inline-formula> CountAdditionsTo(<inline-formula><mml:math id="M301" altimg="si304.svg"><mml:mrow><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>)</td></tr><tr><td>6.   AddNode(Outlabels, InDegree)</td></tr><tr><td>7. <bold>if</bold><inline-formula><mml:math id="M302" altimg="si305.svg"><mml:mrow><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo linebreak="goodbreak">=</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula><bold>then</bold>    ≜ Nodes in the addition buffer only</td></tr><tr><td>8. <bold>for</bold><inline-formula><mml:math id="M303" altimg="si306.svg"><mml:mrow><mml:mi>j</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula><bold>do</bold>    ≜Add a range of nodes from the addition buffer</td></tr><tr><td>9.   AddNode(AdditionsFrom(<inline-formula><mml:math id="M304" altimg="si307.svg"><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:math></inline-formula>), CountAdditionsTo(<inline-formula><mml:math id="M305" altimg="si308.svg"><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:math></inline-formula>))   ≜ Not in BOSS, so no deletions possible from/to here</td></tr><tr><td>10. <bold>if</bold><inline-formula><mml:math id="M306" altimg="si309.svg"><mml:mrow><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo linebreak="goodbreak">=</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula><bold>then</bold>   ≜ Nodes in the BOSS only</td></tr><tr><td>11.  <bold>for</bold><inline-formula><mml:math id="M307" altimg="si310.svg"><mml:mrow><mml:mi>j</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula><bold>do</bold>  ≜Add a range of nodes from the BOSS</td></tr><tr><td>12.    Outlabels <inline-formula><mml:math id="M308" altimg="si311.svg"><mml:mrow><mml:mo>←</mml:mo></mml:mrow></mml:math></inline-formula> BOSS.Outlabels(<inline-formula><mml:math id="M309" altimg="si312.svg"><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:math></inline-formula>) <inline-formula><mml:math id="M310" altimg="si313.svg"><mml:mrow><mml:mo>⧹</mml:mo></mml:mrow></mml:math></inline-formula> DeletionsFrom(<inline-formula><mml:math id="M311" altimg="si314.svg"><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:math></inline-formula>)</td></tr><tr><td>13.    Indegree <inline-formula><mml:math id="M312" altimg="si315.svg"><mml:mrow><mml:mo>←</mml:mo><mml:mo stretchy="false">|</mml:mo></mml:mrow></mml:math></inline-formula>BOSS.InEdgeRange(<inline-formula><mml:math id="M313" altimg="si316.svg"><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:math></inline-formula>)<inline-formula><mml:math id="M314" altimg="si317.svg"><mml:mrow><mml:mo stretchy="false">|</mml:mo></mml:mrow></mml:math></inline-formula><inline-formula><mml:math id="M315" altimg="si318.svg"><mml:mrow><mml:mo linebreak="newline">-</mml:mo></mml:mrow></mml:math></inline-formula> CountDeletionsTo(<inline-formula><mml:math id="M316" altimg="si319.svg"><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:math></inline-formula>)</td></tr><tr><td>14.    AddNode(Outlabels,Indeg)</td></tr></tbody></table></table-wrap></p>
    </sec>
    <sec id="s0050">
      <label>5.3</label>
      <title>Merge execution phase</title>
      <p id="p0235">After the merge planning phase, we move to the execution phase. The interval pairs now identify the nodes that are common to the BOSS and the buffer, and the colexicographic interleaving of all nodes.</p>
      <p id="p0240">In this phase, we stream the interval pairs from the merge planning phase. As we stream the intervals, we enumerate in colexicographic order the indegree and outgoing label set of each node in the buffer and in the BOSS.</p>
      <p id="p0245">During the streaming, the deletion buffer <inline-formula><mml:math id="M317" altimg="si320.svg"><mml:mrow><mml:msub><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mrow><mml:mi>D</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> comes into play again. While iterating the nodes, we check two things for every node: (1) whether any of the outgoing edges <italic>e</italic> are marked in <inline-formula><mml:math id="M318" altimg="si321.svg"><mml:mrow><mml:msub><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mrow><mml:mi>D</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>. We can check this by using the BOSS structure to retrieve <inline-formula><mml:math id="M319" altimg="si322.svg"><mml:mrow><mml:mi mathvariant="sans-serif">colex</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="sans-serif">e</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and checking <inline-formula><mml:math id="M320" altimg="si323.svg"><mml:mrow><mml:msub><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mrow><mml:mi>D</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi mathvariant="sans-serif">colex</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="sans-serif">e</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>. (2) Whether any of the incoming edges to the node are marked for deletion: we use the BOSS structure to retrieve the colexicographic range of the incoming edges, and count how many are marked in <inline-formula><mml:math id="M321" altimg="si324.svg"><mml:mrow><mml:msub><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mrow><mml:mi>D</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>. We remove the outgoing edges that are marked from the outgoing label set, and decrease the indegree by the number of incoming edges that are marked. See <xref rid="f0010" ref-type="fig">Fig. 2</xref>.<fig id="f0010"><label>Fig. 2</label><caption><p>Merge execution phase. In the figure we start from the graph in <xref rid="f0005" ref-type="fig">Fig. 1</xref>, adding the edgemers in the sequence CGCACAGT and deleting the edgemers CGCG, CGTA and ACAC. The columns IN, OUT and NODE are the indegrees, outgoing edge label sets and the node labels, respectively, including the dummies. The lines in the middle are computed in the planning phase and represented succinctly as a sequence of interval pairs. Black lines connect nodes with the same label. Red lines are for nodes that are present in the buffer but not the BOSS, and blue lines are the other way around. Edges marked for deletion and the indegrees affected by those are marked with a strike-through line.</p></caption><graphic xlink:href="gr2"/></fig></p>
      <p id="p0250">We stream the new <inline-formula><mml:math id="M322" altimg="si325.svg"><mml:mrow><mml:mi mathvariant="sans-serif">EBWT</mml:mi><mml:mo>,</mml:mo><mml:mi>I</mml:mi></mml:mrow></mml:math></inline-formula> and <italic>O</italic> structures of the new updated BOSS to disk while iterating the interval pairs. The pseudocode is at Algorithm 4. The subroutines DeletionsFrom and CountDeletionsTo use the BOSS interface to compute the colexicographic ranks of the incoming and outgoing edges, and access the bit vector <inline-formula><mml:math id="M323" altimg="si326.svg"><mml:mrow><mml:msub><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mrow><mml:mi>D</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> to check the deletion flags. The subroutines AdditionsFrom and CountAdditionsTo read from the satellite data attached to the rows of <inline-formula><mml:math id="M324" altimg="si327.svg"><mml:mrow><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">buffer</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> in the planning phase. The subroutine AddNode appends data to the <inline-formula><mml:math id="M325" altimg="si328.svg"><mml:mrow><mml:mi mathvariant="sans-serif">EBWT</mml:mi><mml:mo>,</mml:mo><mml:mi>I</mml:mi></mml:mrow></mml:math></inline-formula> and <italic>O</italic> structures of the updated BOSS. Specifically, a call to AddNode(<inline-formula><mml:math id="M326" altimg="si329.svg"><mml:mrow><mml:mi>A</mml:mi><mml:mo>,</mml:mo><mml:mi>d</mml:mi></mml:mrow></mml:math></inline-formula>), where <italic>A</italic> is an outgoing label set and integer <italic>d</italic> is an indegree, appends <inline-formula><mml:math id="M327" altimg="si330.svg"><mml:mrow><mml:mn>1</mml:mn><mml:mo>·</mml:mo><mml:msup><mml:mrow><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mo stretchy="false">|</mml:mo><mml:mi>A</mml:mi><mml:mo stretchy="false">|</mml:mo></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> to the new <inline-formula><mml:math id="M328" altimg="si331.svg"><mml:mrow><mml:mi>O</mml:mi><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>·</mml:mo><mml:msup><mml:mrow><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> to the new <italic>I</italic> and the list <italic>A</italic> to the new <inline-formula><mml:math id="M329" altimg="si332.svg"><mml:mrow><mml:mi mathvariant="sans-serif">EBWT</mml:mi></mml:mrow></mml:math></inline-formula>. The structures <inline-formula><mml:math id="M330" altimg="si333.svg"><mml:mrow><mml:mi mathvariant="sans-serif">EBWT</mml:mi><mml:mo>,</mml:mo><mml:mi>I</mml:mi></mml:mrow></mml:math></inline-formula> and <italic>O</italic> of the updated BOSS are initialized to empty.</p>
    </sec>
    <sec id="s0055">
      <label>5.4</label>
      <title>Dummy cleanup phase</title>
      <p id="p0255">After the execution phase, we have an optional clean-up phase, where we delete dummy nodes that have become redundant after the addition of the new nodes.</p>
      <p id="p0260">We recall that the dummy nodes form a tree starting from the node of the empty string. We do a depth-first search in the tree of dummies of the updated BOSS from the root using the forward traversal operation in the BOSS interface. When we reach a leaf node of the dummy tree, we follow all the outgoing edges to full nodemers. We check the indegree of each such nodemer. If it is two or more, we can mark the incoming edge from the tree part for deletion, because the target node has another incoming edge which must come from another nodemer. If all out-edges of the dummy node were marked, we can mark the in-edge of the dummy node for deletion as well. Likewise, when we backtrack in the depth-first search, if all out-edges of a dummy tree node are marked for deletion, we mark its in-edge for deletion. This algorithm takes only time proportional to the number of dummy nodes. In the end, we stream the <inline-formula><mml:math id="M331" altimg="si334.svg"><mml:mrow><mml:mi mathvariant="sans-serif">EBWT</mml:mi><mml:mo>,</mml:mo><mml:mi>I</mml:mi></mml:mrow></mml:math></inline-formula> and <italic>O</italic> structures of the updated boss, removing marked edges and decrementing the indegrees of the destinations of the deleted edges as done in the execution phase before.</p>
    </sec>
  </sec>
  <sec id="s0060">
    <label>6</label>
    <title>Results</title>
    <p id="p0265">In this section, we demonstrate the performance of <inline-formula><mml:math id="M332" altimg="si335.svg"><mml:mrow><mml:mi mathvariant="italic">BufBOSS</mml:mi></mml:mrow></mml:math></inline-formula> against a variety of dynamic de Bruijn graph implementations from the literature.</p>
    <sec id="s0065">
      <label>6.1</label>
      <title>Experimental details</title>
      <p id="p0270">The experiments were run on a server with an Intel Xeon CPU E5-2640 v4 with 40 cores clocked at 2.40 GHz, equipped with 755GiB of RAM. The timing and peak memory (RSS) were measured using the Unix utility /usr/bin/time.</p>
    </sec>
    <sec id="s0070">
      <label>6.2</label>
      <title>Implementation of FDBG-RecSplit</title>
      <p id="p0275">As previously mentioned, we modified FDBG and compare against this modification in addition to original FDBG implementation. Here, we give some background on this modification. Alipanahi et al. <xref rid="b0005" ref-type="bibr">[1]</xref> observed that FDBG fails for datasets approaching <inline-formula><mml:math id="M333" altimg="si336.svg"><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mn>32</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> distinct nodemers. This is due to hash collisions. FDBG hashes nodemers first with the Karp-Rabin hash function <xref rid="b0160" ref-type="bibr">[32]</xref>, and then hashes these hashes with the perfect hash function BBHash <xref rid="b0170" ref-type="bibr">[34]</xref>. The problem is that the Karp-Rabin hash values are stored in 64-bit integers for best compatibility with BBHash, which means that collisions start to happen often at around <inline-formula><mml:math id="M334" altimg="si337.svg"><mml:mrow><mml:msup><mml:mrow><mml:msqrt><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msqrt></mml:mrow><mml:mrow><mml:mn>64</mml:mn></mml:mrow></mml:msup><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mn>32</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> keys due to the birthday paradox phenomenon in probability. In the interest of studying the scalability of FDBG for datasets that have more than <inline-formula><mml:math id="M335" altimg="si338.svg"><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mn>32</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> nodemers, we edited the implementation to use 128-bit Karp-Rabin hashes, and changed the perfect hashing implementation from BBHash to a recently published new implementation called RecSplit <xref rid="b0115" ref-type="bibr">[23]</xref>. RecSplit is a good choice for this purpose because it is optimized to work for uniformly random 128-bit keys, and the Karp-Rabin hashes of the nodemers satisfy this model well. Arithmetic with 128-bit values is significantly slower than with 64-bit values, especially when modulo-operations are involved, so we also include results with the original FDBG.</p>
    </sec>
    <sec id="s0075">
      <label>6.3</label>
      <title>Implementation of BufBOSS</title>
      <p id="p0280">We construct the BOSS structure by first using the KMC3 <italic>k</italic>-mer counter <xref rid="b0165" ref-type="bibr">[33]</xref> to list all distinct edgemer of the data. KMC3 is highly parallel, using both machine-level parallel vector instructions, and multi-threading to exploit all the cores available on the CPU.</p>
      <p id="p0285">We then write to disk triples (<inline-formula><mml:math id="M336" altimg="si339.svg"><mml:mrow><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>c</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi></mml:mrow></mml:math></inline-formula>), where <italic>x</italic> is a nodemer string, <italic>c</italic> is a character either to the left or to the right of <italic>x</italic> in the input data, and <italic>b</italic> is a bit that indicates whether <italic>c</italic> is on the left or on the right. We sort these triples on disk by the colexicographic order of the nodemers <italic>x</italic> using the stxxl library <xref rid="b0100" ref-type="bibr">[20]</xref>. We then scan the sorted pairs to count the number of characters to the left of <italic>x</italic>. If some nodemer <italic>x</italic> does not have characters on the left, we need to add the dummy nodes corresponding to all prefixes of <italic>x</italic> to the graph. We write these prefixes to another file on disk along with the characters of the right, and sort these colexicographically by the order of the prefixes. Finally, we merge the order of the dummy nodes into the order of the nodemers by streaming the two lists on disk and using logic of the merge phase of merge sort. While we are doing this merge we have, in the correct order, all the information to build the data structure: for every node label <italic>x</italic>, we have the count of characters on the left (the indegree of <italic>x</italic>), and the outgoing edge labels (the outdegree and the labels of the outgoing edges from <italic>x</italic>), all in the colexicographic order of the nodes.</p>
      <p id="p0290">When adding sequences to <inline-formula><mml:math id="M337" altimg="si340.svg"><mml:mrow><mml:mi mathvariant="italic">BufBOSS</mml:mi></mml:mrow></mml:math></inline-formula> dynamically, we set a threshold <inline-formula><mml:math id="M338" altimg="si341.svg"><mml:mrow><mml:mi>t</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> such that if the addition buffer <inline-formula><mml:math id="M339" altimg="si342.svg"><mml:mrow><mml:msub><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mi>A</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> contains a fraction of more than <italic>t</italic> entries compared to the number of edgemers in the static BOSS structure, we flush the buffers <inline-formula><mml:math id="M340" altimg="si343.svg"><mml:mrow><mml:msub><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mi>A</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="M341" altimg="si344.svg"><mml:mrow><mml:msub><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mrow><mml:mi>D</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> by running the update algorithm described in Section <xref rid="s0035" ref-type="sec">5</xref>, and clearing the buffers afterwards. This amortizes the cost of individual updates over the buffer flushes, with different time–space trade-offs available for different values of <italic>t</italic>.</p>
      <p id="p0295">The rank and select structures required for queries are implemented with the SDSL-library. The queries are implemented in our Wheeler graph library. The dynamic buffer hash table <inline-formula><mml:math id="M342" altimg="si345.svg"><mml:mrow><mml:msub><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mi>A</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> is implemented with the C++ standard library. Like FDBG, we store edgemers in 64-bit integers, so the maximum allowed edgemer length is 32.</p>
    </sec>
    <sec id="s0080">
      <label>6.4</label>
      <title>Competing Tools</title>
      <p id="p0300">We compare the performance of <inline-formula><mml:math id="M343" altimg="si346.svg"><mml:mrow><mml:mi mathvariant="italic">BufBOSS</mml:mi></mml:mrow></mml:math></inline-formula> to the following dynamic de Bruijn graph implementations: DynamicBOSS <xref rid="b0005" ref-type="bibr">[1]</xref>, FDBG <xref rid="b0090" ref-type="bibr">[18]</xref>, FDBG-RecSplit, and Bifrost <xref rid="b0145" ref-type="bibr">[29]</xref>. An overview of recent de Bruijn graph implementations and their attributes is given in <xref rid="t0005" ref-type="table">Table 1</xref>. Hence, we did not compare against BFT <xref rid="b0150" ref-type="bibr">[30]</xref>, Vari <xref rid="b0195" ref-type="bibr">[39]</xref>, Rainbowfish <xref rid="b0025" ref-type="bibr">[5]</xref>, and Pufferfish <xref rid="b0030" ref-type="bibr">[6]</xref>, and Mantis <xref rid="b0215" ref-type="bibr">[43]</xref> because they cannot perform addition or deletion of data.</p>
      <p id="p0305">We deviate from our experimental setup in one detail to fairly evaluate the time for addition for Bifrost: we discount the time to load the index into memory. This is because Bifrost does not serialize its index to disk but rather writes all maximal non-branching paths of the de Bruijn graph (unitigs) to disk in a graph format. When Bifrost loads the index, it must re-index the whole dataset by computing and hashing <italic>k</italic>-mer minimizers for all unitigs in the data.</p>
    </sec>
    <sec id="s0085">
      <label>6.5</label>
      <title>Datasets</title>
      <p id="p0310">Our first set of datasets is short reads from the bacteria E. coli. We used 28 428 648 paired-end reads generated from whole genome sequencing of E.coli K-12 substr. MG1655 dataset (NCBI SRA accession ERX002508). We refer to this as 28 M-e. Next, we split this dataset to generate smaller datasets of sizes 2 000, 200 000, 2 000 000, and 14 000 000 reads, which we denote by 20 K-e, 200 K-e, 2 M-e and 14 M-e, respectively.</p>
      <p id="p0315">The second set of inputs is a series of metagenomic read sets of increasing size from a study on antimicrobial resistant determinants in commercial beef production <xref rid="b0205" ref-type="bibr">[41]</xref>. This dataset consists of 87 datasets that were generated by sequencing DNA that was collected from various locations across a beef production cycle – the goal being to identify specific points where the pathogenic load either increased or decreased and thus, determine of the effectiveness of the existing interventions used to reduce pathogenic load. The NCBI SRA accession number for these datasets is PRJNA292471. From these 87 datasets, we selected the datasets with the smallest and largest number of reads, which 55 242 004 and 11 136 890 sequence reads, respectively. We refer to as 55 M and 11 M. We generated smaller datasets by randomly selecting 20 000, 200 000 and 2 000 000 reads from 11 M dataset which we refer to these as 20 K, 200 K and 2 M, respectively. Next, we concatenated three datasets that consist of 55 242 004, 44 035 852, and 52 833 978 reads to create a dataset with over 150 million reads, which we refer to as 150 M. Lastly, we added 7 different datasets to 150 M to generate a dataset with over 600 million reads, which we refer to as 600 M.</p>
      <p id="p0320">Since most of the tools we experiment with do not understand characters outside of the DNA-alphabet {A,C,G,T}, such as the invalid character N, we split the reads into pieces that contain only characters from the DNA alphabet. Since FDBG, FDBG-Recsplit and DynamicBOSS do not index reverse complements, but <inline-formula><mml:math id="M344" altimg="si347.svg"><mml:mrow><mml:mi mathvariant="italic">BufBOSS</mml:mi></mml:mrow></mml:math></inline-formula> and Bifrost do, we concatenate the input read sets with their reverse complements for the former three tools to make the graphs the same for all tools.</p>
    </sec>
    <sec id="s0090">
      <label>6.6</label>
      <title>Construction</title>
      <p id="p0325">For each E. coli dataset, we build the index of each tool using 50% of the reads, then add the next 25% of the reads and finally delete the remaining 25%. Addition and deletion are shown in the next subsection. Here, we discuss the construction time, space and memory. <xref rid="t0015" ref-type="table">Table 3</xref> shows the time and peak memory for construction as well as the size of the final data structure on disk. In addition, <xref rid="f0015" ref-type="fig">Fig. 3</xref>, <xref rid="f0015" ref-type="fig">Fig. 3</xref>b illustrate the time versus memory required for construction of the data structure using the largest E. coli dataset, and the time versus disk space required for construction of the data structure using the largest E. coli dataset.<fig id="f0015"><label>Fig. 3</label><caption><p>Index construction.</p></caption><graphic xlink:href="gr3"/></fig></p>
      <p id="p0330">The <italic>k</italic>-mer preprocessing steps of all tools are included in the time and peak memory numbers. <inline-formula><mml:math id="M345" altimg="si348.svg"><mml:mrow><mml:mi mathvariant="italic">BufBOSS</mml:mi></mml:mrow></mml:math></inline-formula> was consistently the fastest index to construct, being almost 4 times faster than the closest competitor DynamicBOSS on the largest dataset. Our index construction takes a lot of memory on the small datasets, but this is due to KMC3 always requiring a large amount of memory even on small datasets. When the size of the data increases, our peak memory becomes more competitive. Bifrost had the smallest memory by a factor of 5 to the closest competitors DynamicBOSS and <inline-formula><mml:math id="M346" altimg="si349.svg"><mml:mrow><mml:mi mathvariant="italic">BufBOSS</mml:mi></mml:mrow></mml:math></inline-formula>. DynamicBOSS had the smallest index on disk, being half the size of <inline-formula><mml:math id="M347" altimg="si350.svg"><mml:mrow><mml:mi mathvariant="italic">BufBOSS</mml:mi></mml:mrow></mml:math></inline-formula>. This is due to the BOSS-implementation of DynamicBOSS being geared more toward small size rather than speed.</p>
      <p id="p0335">We test further scalability of construction using the metagenome datasets, omitting the original FDBG as it can not handle more than <inline-formula><mml:math id="M348" altimg="si351.svg"><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mn>32</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> nodemers. The data for the rest of the tools is in <xref rid="t0010" ref-type="table">Table 2</xref>. <xref rid="f0015" ref-type="fig">Fig. 3</xref>c shows the time-memory plot for the 55 M dataset, which is the largest FDBG-Recsplit was able to process before running out of memory, and <xref rid="f0015" ref-type="fig">Fig. 3</xref>d shows the same plot for the 150 M dataset without FDBG-Recsplit.<table-wrap position="float" id="t0010"><label>Table 2</label><caption><p>Index construction on the metagenome datasets. The units of disk and peak memory are GB (<inline-formula><mml:math id="M349" altimg="si4.svg"><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mn>30</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> bytes) and the format of the time is hours:minutes:seconds. FDBG is not included because it runs into hash collisions for large datasets. FDBG-RecSplit ran out of memory (OOM) on the 150 M dataset. The edgemer packing preprocessing step of DynamicBOSS ran out of memory on the 600 M dataset. The number of distinct canonical edgemers in these datasets in increasing order of size are 1 203 852, 11 839 506, 107 122 222, 478 210 723, 1 360 576 988, 3 741 452 498 and 11 676 829 812.</p></caption><table frame="hsides" rules="groups"><thead><tr><th/><th colspan="3" align="center"><bold>BufBOSS</bold><hr/></th><th colspan="3" align="center">DynamicBOSS<hr/></th><th colspan="3" align="center">FDBG-RecSplit<hr/></th><th colspan="3" align="center">Bifrost<hr/></th></tr><tr><th/><th>Disk</th><th>Memory</th><th>Time</th><th>Disk</th><th>Memory</th><th>Time</th><th>Disk</th><th>Memory</th><th>Time</th><th>Disk</th><th>Memory</th><th>Time</th></tr></thead><tbody><tr><td>20 K</td><td>0.00</td><td>5.26</td><td>00:00:08</td><td>0.00</td><td>0.37</td><td>00:00:30</td><td>0.00</td><td>0.52</td><td>00:00:41</td><td>0.00</td><td>0.02</td><td>00:00:07</td></tr><tr><td>200 K</td><td>0.03</td><td>6.50</td><td>00:00:23</td><td>0.02</td><td>2.45</td><td>00:01:44</td><td>0.04</td><td>4.77</td><td>00:07:03</td><td>0.02</td><td>0.10</td><td>00:01:08</td></tr><tr><td>2 M</td><td>0.30</td><td>10.07</td><td>00:02:58</td><td>0.17</td><td>7.64</td><td>00:08:26</td><td>0.38</td><td>42.04</td><td>01:15:17</td><td>0.19</td><td>1.42</td><td>00:10:22</td></tr><tr><td>11 M</td><td>1.32</td><td>12.82</td><td>00:13:24</td><td>0.73</td><td>33.54</td><td>00:35:11</td><td>1.68</td><td>183.74</td><td>07:24:03</td><td>1.13</td><td>6.00</td><td>00:53:12</td></tr><tr><td>55 M</td><td>3.65</td><td>14.88</td><td>00:39:42</td><td>2.01</td><td>93.66</td><td>01:57:32</td><td>4.69</td><td>612.64</td><td>29:00:39</td><td>4.76</td><td>14.64</td><td>02:49:29</td></tr><tr><td>150 M</td><td>10.00</td><td>36.77</td><td>02:13:47</td><td>5.52</td><td>258.03</td><td>05:52:31</td><td>OOM</td><td>OOM</td><td>OOM</td><td>14.39</td><td>53.18</td><td>09:15:26</td></tr><tr><td>600 M</td><td>30.67</td><td>112.55</td><td>09:18:19</td><td>OOM</td><td>OOM</td><td>OOM</td><td>OOM</td><td>OOM</td><td>OOM</td><td>59.08</td><td>162.00</td><td>45:30:00</td></tr></tbody></table></table-wrap><table-wrap position="float" id="t0015"><label>Table 3</label><caption><p>Construction on the E. coli dataset. The units of disk and peak memory are GB (<inline-formula><mml:math id="M350" altimg="si5.svg"><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mn>30</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> bytes) and the format of the time is hours:minutes:seconds. The number of distinct canonical edgemers in these datasets in increasing order of size are 626 875, 4 087 049, 13 241 253, 63 704 311 and 128 431 292.</p></caption><table frame="hsides" rules="groups"><thead><tr><th/><th colspan="3" align="center"><bold>BufBOSS</bold><hr/></th><th colspan="3" align="center">DynamicBOSS<hr/></th><th colspan="3" align="center">FDBG-RecSplit<hr/></th><th colspan="3" align="center">FDBG<hr/></th><th colspan="3" align="center">Bifrost<hr/></th></tr><tr><th/><th>Disk</th><th>Memory</th><th>Time</th><th>Disk</th><th>Memory</th><th>Time</th><th>Disk</th><th>Memory</th><th>Time</th><th>Disk</th><th>Memory</th><th>Time</th><th>Disk</th><th>Memory</th><th>Time</th></tr></thead><tbody><tr><td>20 K-e</td><td>0.00</td><td>5.15</td><td>00:00:07</td><td>0.00</td><td>0.11</td><td>00:00:44</td><td>0.00</td><td>0.27</td><td>00:00:21</td><td>0.00</td><td>0.23</td><td>00:00:07</td><td>0.00</td><td>0.02</td><td>00:00:04</td></tr><tr><td>200 K-e</td><td>0.01</td><td>5.78</td><td>00:00:12</td><td>0.01</td><td>1.12</td><td>00:00:54</td><td>0.01</td><td>1.54</td><td>00:02:27</td><td>0.02</td><td>1.30</td><td>00:00:51</td><td>0.01</td><td>0.05</td><td>00:00:25</td></tr><tr><td>2 M-e</td><td>0.04</td><td>6.97</td><td>00:00:25</td><td>0.02</td><td>2.61</td><td>00:02:16</td><td>0.04</td><td>5.14</td><td>00:09:37</td><td>0.05</td><td>4.36</td><td>00:04:20</td><td>0.08</td><td>0.16</td><td>00:02:01</td></tr><tr><td>14 M-e</td><td>0.20</td><td>10.07</td><td>00:02:06</td><td>0.11</td><td>5.10</td><td>00:09:18</td><td>0.21</td><td>23.74</td><td>00:54:19</td><td>0.24</td><td>19.98</td><td>00:29:09</td><td>0.54</td><td>1.09</td><td>00:13:36</td></tr><tr><td>28 M-e</td><td>0.41</td><td>12.57</td><td>00:04:24</td><td>0.23</td><td>10.33</td><td>00:16:25</td><td>0.42</td><td>47.87</td><td>02:02:57</td><td>0.47</td><td>40.30</td><td>01:04:05</td><td>1.12</td><td>2.17</td><td>00:30:57</td></tr></tbody></table></table-wrap></p>
      <p id="p0340">The external memory construction of <inline-formula><mml:math id="M351" altimg="si352.svg"><mml:mrow><mml:mi mathvariant="italic">BufBOSS</mml:mi></mml:mrow></mml:math></inline-formula> now starts to show its scalability on the largest dataset, with the lowest peak memory out of all tools, while maintaining the fastest construction. DynamicBOSS again has the smallest index size on disk. The peak construction memory of FDBG-Recsplit is very large, and exceeds the 755GiB memory capacity of the machine already on the 150 M dataset. This enormous peak memory is probably caused by the fact that FDBG-Recsplit holds all input edgemers in memory while building the index. The <italic>k</italic>-mer preprocessing step of dynamicBOSS also exceeded the 755GiB capacity of the machine on the 600 M dataset.</p>
    </sec>
    <sec id="s0095">
      <label>6.7</label>
      <title>Addition and deletion</title>
      <p id="p0345">Since only two tools out of five are able to scale on construction of the metagenome datasets, we benchmark additions, deletions and queries only on the E. coli dataset. For the E. coli datasets, we evaluated the resources needed to add an additional 25% of the reads, and delete the remaining 25% of the reads. We added and deleted using the graphs that were constructed for the previous section. For deletion, we only compare to FDBG-Recsplit, FDBG and DynamicBOSS since Bifrost does not perform deletion. <xref rid="t0020" ref-type="table">Table 4</xref>, <xref rid="t0025" ref-type="table">Table 5</xref> illustrate the time, memory and disk required for addition and deletion, respectively. Also, <xref rid="f0020" ref-type="fig">Fig. 4</xref>, <xref rid="f0025" ref-type="fig">Fig. 5</xref> illustrate the time versus space for additions and deletions, respectively.<table-wrap position="float" id="t0020"><label>Table 4</label><caption><p>Additions after construction of <xref rid="t0015" ref-type="table">3</xref> on the E. coli dataset. The units of disk and peak memory are GB (<inline-formula><mml:math id="M352" altimg="si6.svg"><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mn>30</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> bytes) and the format of the time is hours:minutes:seconds. <inline-formula><mml:math id="M353" altimg="si7.svg"><mml:mrow><mml:mi mathvariant="italic">BufBOSS</mml:mi></mml:mrow></mml:math></inline-formula> uses the buffer fraction parameter 0.025. The number of distinct canonical edgemers in these datasets in the addition set in increasing order of size are 329 523, 2 501 881, 9 047 060, 38 892 710 and 56 315 888.</p></caption><table frame="hsides" rules="groups"><thead><tr><th/><th colspan="3" align="center"><bold>BufBOSS</bold><hr/></th><th colspan="3" align="center">DynamicBOSS<hr/></th><th colspan="3" align="center">FDBG-RecSplit<hr/></th><th colspan="3" align="center">FDBG<hr/></th><th colspan="3" align="center">Bifrost<hr/></th></tr><tr><th/><th>Disk</th><th>Memory</th><th>Time</th><th>Disk</th><th>Memory</th><th>Time</th><th>Disk</th><th>Memory</th><th>Time</th><th>Disk</th><th>Memory</th><th>Time</th><th>Disk</th><th>Memory</th><th>Time</th></tr></thead><tbody><tr><td>20 K-e</td><td>0.00</td><td>0.02</td><td>00:00:43</td><td>0.00</td><td>0.09</td><td>00:12:51</td><td>0.01</td><td>0.32</td><td>00:00:56</td><td>0.01</td><td>0.32</td><td>00:00:21</td><td>0.00</td><td>0.03</td><td>00:00:03</td></tr><tr><td>200 K-e</td><td>0.01</td><td>0.09</td><td>00:02:47</td><td>0.01</td><td>0.64</td><td>00:59:22</td><td>0.05</td><td>1.42</td><td>00:08:57</td><td>0.05</td><td>1.42</td><td>00:03:13</td><td>0.01</td><td>0.07</td><td>00:00:18</td></tr><tr><td>2 M-e</td><td>0.06</td><td>0.29</td><td>00:13:43</td><td>0.03</td><td>2.47</td><td>04:22:04</td><td>0.20</td><td>9.89</td><td>01:31:27</td><td>0.20</td><td>9.89</td><td>00:30:02</td><td>0.12</td><td>0.38</td><td>00:01:21</td></tr><tr><td>14 M-e</td><td>0.33</td><td>1.33</td><td>01:37:50</td><td>0.16</td><td>11.42</td><td>27:08:14</td><td>1.26</td><td>67.13</td><td>11:38:54</td><td>1.29</td><td>67.16</td><td>04:04:59</td><td>0.81</td><td>1.56</td><td>00:08:08</td></tr><tr><td>28 M-e</td><td>0.56</td><td>2.26</td><td>02:28:24</td><td>0.30</td><td>17.79</td><td>40:33:54</td><td>1.88</td><td>120.07</td><td>23:08:40</td><td>1.94</td><td>120.13</td><td>07:29:05</td><td>1.54</td><td>2.63</td><td>00:14:37</td></tr></tbody></table></table-wrap><table-wrap position="float" id="t0025"><label>Table 5</label><caption><p>Deletions after construction of <xref rid="t0015" ref-type="table">Table 3</xref> and additions of <xref rid="t0020" ref-type="table">Table 4</xref> on the E. coli dataset. The units of disk and peak memory are GB (<inline-formula><mml:math id="M354" altimg="si8.svg"><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mn>30</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> bytes) and the format of the time is hours:minutes:seconds. Bifrost is not included because it does not support deletions. The number of distinct canonical edgemers in these datasets in the deletion set in increasing order of size are 330 563, 2 526 285, 8 786 286, 4 3705 141 and 48 377 370.</p></caption><table frame="hsides" rules="groups"><thead><tr><th/><th colspan="3" align="center"><bold>BufBOSS</bold><hr/></th><th colspan="3" align="center">DynamicBOSS<hr/></th><th colspan="3" align="center">FDBG-RecSplit<hr/></th><th colspan="3" align="center">FDBG<hr/></th></tr><tr><th/><th>Disk</th><th>Memory</th><th>Time</th><th>Disk</th><th>Memory</th><th>Time</th><th>Disk</th><th>Memory</th><th>Time</th><th>Disk</th><th>Memory</th><th>Time</th></tr></thead><tbody><tr><td>20 K-e</td><td>0.00</td><td>0.01</td><td>00:00:01</td><td>0.00</td><td>0.09</td><td>00:03:32</td><td>0.01</td><td>0.22</td><td>00:00:50</td><td>0.01</td><td>0.22</td><td>00:00:17</td></tr><tr><td>200 K-e</td><td>0.01</td><td>0.04</td><td>00:00:07</td><td>0.01</td><td>0.64</td><td>01:44:39</td><td>0.10</td><td>1.22</td><td>00:28:53</td><td>0.10</td><td>1.22</td><td>00:12:50</td></tr><tr><td>2 M-e</td><td>0.06</td><td>0.13</td><td>00:01:30</td><td>0.03</td><td>2.42</td><td>04:52:23</td><td>0.34</td><td>7.84</td><td>01:28:27</td><td>0.34</td><td>7.85</td><td>00:39:22</td></tr><tr><td>14 M-e</td><td>0.33</td><td>0.79</td><td>00:17:24</td><td>0.18</td><td>12.62</td><td>12:46:43</td><td>1.56</td><td>51.69</td><td>05:49:05</td><td>1.59</td><td>51.72</td><td>03:23:58</td></tr><tr><td>28 M-e</td><td>0.56</td><td>1.23</td><td>00:32:32</td><td>0.32</td><td>15.96</td><td>17:23:39</td><td>2.31</td><td>94.22</td><td>14:35:19</td><td>2.37</td><td>94.28</td><td>08:56:51</td></tr></tbody></table></table-wrap><fig id="f0020"><label>Fig. 4</label><caption><p>Addition performance on the 28 M E. coli dataset. The data points labeled with BB-<italic>t</italic> are runs on <inline-formula><mml:math id="M355" altimg="si2.svg"><mml:mrow><mml:mi mathvariant="italic">BufBOSS</mml:mi></mml:mrow></mml:math></inline-formula> with different buffer fraction parameters <italic>t</italic>.</p></caption><graphic xlink:href="gr4"/></fig><fig id="f0025"><label>Fig. 5</label><caption><p>Deletion performance on the 28 M E. coli dataset. Here we do not vary the buffer fraction parameter for <inline-formula><mml:math id="M356" altimg="si3.svg"><mml:mrow><mml:mi mathvariant="italic">BufBOSS</mml:mi></mml:mrow></mml:math></inline-formula> because buffer flushes are not needed when doing only deletions.</p></caption><graphic xlink:href="gr5"/></fig></p>
      <p id="p0350">As previously mentioned, we discount the time to load the index into memory for Bifrost. This loading takes two minutes on the 28 M E. coli read set. The loading time of other tools is negligible in our experiment. Hence, we subtract Bifrost’s loading time out to avoid skewing the addition performance results.</p>
      <p id="p0355"><xref rid="f0020" ref-type="fig">Fig. 4</xref> shows a few different time–space trade-offs <inline-formula><mml:math id="M357" altimg="si353.svg"><mml:mrow><mml:mi mathvariant="italic">BufBOSS</mml:mi></mml:mrow></mml:math></inline-formula> can achieve by varying the buffer flushing threshold <italic>t</italic>. With the values of <inline-formula><mml:math id="M358" altimg="si354.svg"><mml:mrow><mml:mi>t</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>0.025</mml:mn></mml:mrow></mml:math></inline-formula> or <inline-formula><mml:math id="M359" altimg="si355.svg"><mml:mrow><mml:mi>t</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>0.01</mml:mn><mml:mo>,</mml:mo><mml:mi mathvariant="italic">BufBOSS</mml:mi></mml:mrow></mml:math></inline-formula> achieves the lowest peak memory out of all tools, losing in time only to Bifrost.</p>
      <p id="p0360">FDBG and FDBG-Recsplit perform very poorly with additions, because they store new nodemers in a hash table as strings. This blows up both the peak memory and the size of the index on disk. The smallest index on disk is DynamicBOSS, being about half as small as <inline-formula><mml:math id="M360" altimg="si356.svg"><mml:mrow><mml:mi mathvariant="italic">BufBOSS</mml:mi></mml:mrow></mml:math></inline-formula> in the end. Bifrost has the fastest additions even when <inline-formula><mml:math id="M361" altimg="si357.svg"><mml:mrow><mml:mi mathvariant="italic">BufBOSS</mml:mi></mml:mrow></mml:math></inline-formula> does not flush the buffer at all (<inline-formula><mml:math id="M362" altimg="si358.svg"><mml:mrow><mml:mi>t</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>1.0</mml:mn></mml:mrow></mml:math></inline-formula>).</p>
      <p id="p0365">In deletion efficiency, <inline-formula><mml:math id="M363" altimg="si359.svg"><mml:mrow><mml:mi mathvariant="italic">BufBOSS</mml:mi></mml:mrow></mml:math></inline-formula> is by far superior, being an order of magnitude better than the other tools in both time and peak space. The deletions of <inline-formula><mml:math id="M364" altimg="si360.svg"><mml:mrow><mml:mi mathvariant="italic">BufBOSS</mml:mi></mml:mrow></mml:math></inline-formula> are very efficient because we only mark the deleted edgemers in a bit vector. No buffer flushes are required since the space of the deletion buffer bit vector <inline-formula><mml:math id="M365" altimg="si361.svg"><mml:mrow><mml:msub><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mrow><mml:mi>D</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> does not depend on the number of deletions. We note that the other tools could adopt a similar technique for deletions.</p>
    </sec>
    <sec id="s0100">
      <label>6.8</label>
      <title>Edge existence queries</title>
      <p id="p0370">We test the existence query speeds of the tools on six different types of input data. The first three query types are single edgemers: we query edgemers sampled from the construction read set, the addition read set, and completely randomly generated edgemers which do not exist in the data with high probability. The last three are the same, except that instead of single edgemers, we query all edgemers of whole read sequences in the same query, which speeds up the query time per edgemer in BufBOSS, because if the queries exist in the data, we can just traverse the de Bruijn graph instead of searching all the edgemers separately.</p>
      <p id="p0375">All the queries are done on the index with the construction and addition edgemers, but without having deleted the final 25% of edgemers, because for consistency, we want all the queries to be done on the same de Bruijn graph, and Bifrost can not delete edgemers.</p>
      <p id="p0380">Again we factor out the time to load the index for all tools. Figure <xref rid="f0030" ref-type="fig">6</xref> shows the average query times on the different types of queries. Bifrost has the fastest queries on all query types, with <inline-formula><mml:math id="M366" altimg="si362.svg"><mml:mrow><mml:mi mathvariant="italic">BufBOSS</mml:mi></mml:mrow></mml:math></inline-formula> coming in second. DynamicBOSS queries are significantly slower than those of <inline-formula><mml:math id="M367" altimg="si363.svg"><mml:mrow><mml:mi mathvariant="italic">BufBOSS</mml:mi></mml:mrow></mml:math></inline-formula> because of the heavy price DynamicBOSS pays for using dynamic bit vectors in the implementation. We see that <inline-formula><mml:math id="M368" altimg="si364.svg"><mml:mrow><mml:mi mathvariant="italic">BufBOSS</mml:mi></mml:mrow></mml:math></inline-formula> benefits significantly if the queries are given as whole reads rather than single edgemers, because if the reads are in the graph, we do not have to search every edgemer from scratch, but can traverse the graph instead. This improves the time complexity of querying all edgemers of a read of length <italic>m</italic> from <inline-formula><mml:math id="M369" altimg="si365.svg"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="italic">km</mml:mi><mml:mi mathvariant="normal">log</mml:mi><mml:mi>σ</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> to <inline-formula><mml:math id="M370" altimg="si366.svg"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mi mathvariant="normal">log</mml:mi><mml:mi>σ</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Querying edgemers from the set of added edgemers did not make a noticeable difference compared to querying from the initial construction set. Random edgemers are faster to query than single existing edgemers, because the search can terminate early when a prefix of the edgemer is found to not exist in the graph, yet still slower than querying whole existing reads because of the efficiency of graph traversal.<fig id="f0030"><label>Fig. 6</label><caption><p>Edge existence queries for six different types of edgemers against the 28 M E. coli index including the added sequences. The query types are the following: EBS  = existing build sequence, EAS  = existing added sequence, EAE  = existing added edgemer, EBE  = existing build edgemer, RS  = random sequence, RE  = random edgemer.</p></caption><graphic xlink:href="gr6"/></fig></p>
      <p id="p0385">The query efficiency of Bifrost is explained partly by good memory locality. Bifrost finds the unitig containing the current edgemer, and can scan forward sequentially in memory in the unitig. On the other hand, the BOSS structure has to jump around in memory in an unpredictable way, resulting in a large number of cache misses. FDBG and FDBG-Recsplit face a similar issue because adjacent edgemers being stored by their hash values in unpredicatable memory locations. Sirén et al. <xref rid="b0245" ref-type="bibr">[49]</xref> recently developed a technique to improve BWT-based data structures’ memory locality, but so far it has been applied only in the context of variation graphs.</p>
    </sec>
  </sec>
  <sec id="s0105">
    <label>7</label>
    <title>Discussion and future work</title>
    <p id="p0390">We have shown that buffering updates into a BOSS data structure can provide attractive trade-offs in terms of time, memory and disk usage compared to other tools. In particular, our approach to deletion is clearly the most efficient method for deletion in a de Bruijn graph. Our index construction was also the fastest, which is mainly due to the efficiency of the libraries KMC3 and stxxl used for edgemer listing and sorting. An important caveat in construction is that while <inline-formula><mml:math id="M371" altimg="si367.svg"><mml:mrow><mml:mi mathvariant="italic">BufBOSS</mml:mi></mml:mrow></mml:math></inline-formula> was ran single-threaded as the other tools, the external libraries KMC3 and stxxl used for <inline-formula><mml:math id="M372" altimg="si368.svg"><mml:mrow><mml:mi mathvariant="italic">BufBOSS</mml:mi></mml:mrow></mml:math></inline-formula> construction use parallelism nonetheless.</p>
    <p id="p0395">Observing the source code of the tools reveals shortcomings in the implementations of all the tools. For example, the Bifrost index on disk is just a representation of the de Bruijn graph as a collection of unitigs and edge pointers, but it does not include a indexing structure and thus, Bifrost has to rebuild the index every time it is run. FDBG, FDBG-Recsplit and DynamicBOSS load all the distinct edgemers into memory at once for additions and deletions, even though this should not be needed. All the tools could in principle implement deletions efficiently by simply marking the deleted edgemers, like <inline-formula><mml:math id="M373" altimg="si369.svg"><mml:mrow><mml:mi mathvariant="italic">BufBOSS</mml:mi></mml:mrow></mml:math></inline-formula> does. These shortcomings indicate that much could still be gained by more careful implementations of the methods, and that the results we obtained do not necessarily reflect the fundamental limitations of the approaches. Bifrost is the most mature implementation as the codebase dates back to 2011.</p>
    <p id="p0400">The implementation of <inline-formula><mml:math id="M374" altimg="si370.svg"><mml:mrow><mml:mi mathvariant="italic">BufBOSS</mml:mi></mml:mrow></mml:math></inline-formula> could also be improved. Recently, Egidi et al. <xref rid="b0110" ref-type="bibr">[22]</xref> consider Wheeler graph merging in addition to de Bruijn graph merging, and although, they show that the problem is computationally more challenging, they propose an algorithm specific to BOSS that has a lower peak space than VariMerge in theory. It is worth noting that these results are still only theoretical and they do not provide any implementation. Nonetheless, the practicality of their results warrants future investigation.</p>
    <p id="p0405">More drastic modifications possible to <inline-formula><mml:math id="M375" altimg="si371.svg"><mml:mrow><mml:mi mathvariant="italic">BufBOSS</mml:mi></mml:mrow></mml:math></inline-formula> include applying the technique of Sirén et al. <xref rid="b0245" ref-type="bibr">[49]</xref> for improving memory locality, and maintaining a dynamic longest-common prefix (LCP) array to allow us to change the order <italic>k</italic> of the graph while navigating it, up to some maximum order set at construction time. Previously, Boucher et al. <xref rid="b0060" ref-type="bibr">[12]</xref> showed how the BOSS data structure can be augmented to support variable orders; Belazzougui et al. <xref rid="b0045" ref-type="bibr">[9]</xref>, <xref rid="b0050" ref-type="bibr">[10]</xref> showed how the resulting data structure can be made bidirectional; and Díaz-Domínguez et al. <xref rid="b0105" ref-type="bibr">[21]</xref> showed how the LCP array can be replaced by a succinct tree shape, at the cost of the order no longer being known.</p>
    <p id="p0410">Although there are tools that recommend the best fixed order for a de Bruijn graph <xref rid="b0080" ref-type="bibr">[16]</xref>, variations in read coverage, particularly from single-cell sequencing, can mean that no single order is appropriate for an entire genome or set of genomes. Some tools, such as SPAdes <xref rid="b0035" ref-type="bibr">[7]</xref> and IDBA <xref rid="b0220" ref-type="bibr">[44]</xref>, use several iterations with different orders, but rebuilding massive graphs this way would be impractical and defeat the purpose of the dynamization. As far as we know, there is currently no algorithm to maintain a dynamic LCP array, it seems like a reasonable extension of <inline-formula><mml:math id="M376" altimg="si372.svg"><mml:mrow><mml:mi mathvariant="italic">BufBOSS</mml:mi></mml:mrow></mml:math></inline-formula>. In contrast, it seems unlikely that Bifrost, for example, can be made to support variable orders without greatly increasing its memory usage.</p>
  </sec>
  <sec id="s0110">
    <title>Funding</title>
    <p id="p0415">This work was partly funded by the Academy of Finland (Grant No. 309048), NSERC Discovery Grant (Grant No. RGPIN-07185–2020), NSF IIBR (Grant No. 2029552) and NIH NIAID (Grant No. R01AI141810 and Grant No. R01HG011392).</p>
  </sec>
  <sec sec-type="COI-statement">
    <title>Declaration of Competing Interest</title>
    <p id="p0425">The authors declare that they have no known competing financial interests or personal relationships that could have appeared to influence the work reported in this paper.</p>
  </sec>
</body>
<back>
  <ref-list id="bi005">
    <title>References</title>
    <ref id="b0005">
      <label>1</label>
      <mixed-citation publication-type="other" id="h0005">Alipanahi B, Kuhnle A, Puglisi S, Salmela L, Boucher C, Succinct Dynamic de Bruijn Graphs. Bioinformatics btaa546; 2020a.</mixed-citation>
    </ref>
    <ref id="b0010">
      <label>2</label>
      <mixed-citation publication-type="other" id="h0010">Alipanahi B, Muggli M, Jundi M, Noyes N, Boucher C, Metagenome SNP calling via read-colored de Bruijn graphs. Bioinformatics btaa081; 2020b.</mixed-citation>
    </ref>
    <ref id="b0015">
      <label>3</label>
      <element-citation publication-type="book" id="h0015">
        <person-group person-group-type="author">
          <name>
            <surname>Alipanahi</surname>
            <given-names>B.</given-names>
          </name>
          <name>
            <surname>Salmela</surname>
            <given-names>L.</given-names>
          </name>
          <name>
            <surname>Puglisi</surname>
            <given-names>S.J.</given-names>
          </name>
          <name>
            <surname>Muggli</surname>
            <given-names>M.</given-names>
          </name>
          <name>
            <surname>Boucher</surname>
            <given-names>C.</given-names>
          </name>
        </person-group>
        <chapter-title>Disentangled long-read de Bruijn graphs via optical maps</chapter-title>
        <source>Proc of WABI</source>
        <year>2017</year>
        <comment>pp. 1:1–1:14</comment>
      </element-citation>
    </ref>
    <ref id="b0020">
      <label>4</label>
      <element-citation publication-type="journal" id="h0020">
        <person-group person-group-type="author">
          <name>
            <surname>Allard</surname>
            <given-names>M.W.</given-names>
          </name>
          <name>
            <surname>Strain</surname>
            <given-names>E.</given-names>
          </name>
          <name>
            <surname>Melka</surname>
            <given-names>D.</given-names>
          </name>
          <name>
            <surname>Bunning</surname>
            <given-names>K.</given-names>
          </name>
          <name>
            <surname>Musser</surname>
            <given-names>S.M.</given-names>
          </name>
          <name>
            <surname>Brown</surname>
            <given-names>E.W.</given-names>
          </name>
          <name>
            <surname>Timme</surname>
            <given-names>R.</given-names>
          </name>
        </person-group>
        <article-title>Practical value of food pathogen traceability through building a whole-genome sequencing network and database</article-title>
        <source>J Clin Microbiol</source>
        <volume>54</volume>
        <issue>8</issue>
        <year>2016</year>
        <fpage>1975</fpage>
        <lpage>1983</lpage>
        <pub-id pub-id-type="pmid">27008877</pub-id>
      </element-citation>
    </ref>
    <ref id="b0025">
      <label>5</label>
      <element-citation publication-type="book" id="h0025">
        <person-group person-group-type="author">
          <name>
            <surname>Almodaresi</surname>
            <given-names>F.</given-names>
          </name>
          <name>
            <surname>Pandey</surname>
            <given-names>P.</given-names>
          </name>
          <name>
            <surname>Patro</surname>
            <given-names>R.</given-names>
          </name>
        </person-group>
        <chapter-title>Rainbowfish: A succinct colored de Bruijn graph representation</chapter-title>
        <source>Proc of WABI</source>
        <year>2017</year>
        <fpage>251</fpage>
        <lpage>265</lpage>
      </element-citation>
    </ref>
    <ref id="b0030">
      <label>6</label>
      <element-citation publication-type="journal" id="h0030">
        <person-group person-group-type="author">
          <name>
            <surname>Almodaresi</surname>
            <given-names>F.</given-names>
          </name>
          <name>
            <surname>Sarkar</surname>
            <given-names>H.</given-names>
          </name>
          <name>
            <surname>Srivastava</surname>
            <given-names>A.</given-names>
          </name>
          <name>
            <surname>Patro</surname>
            <given-names>R.</given-names>
          </name>
        </person-group>
        <article-title>A space and time-efficient index for the compacted colored de Bruijn graph</article-title>
        <source>Bioinformatics</source>
        <volume>34</volume>
        <issue>13</issue>
        <year>2018</year>
        <fpage>i169</fpage>
        <lpage>i177</lpage>
        <pub-id pub-id-type="pmid">29949982</pub-id>
      </element-citation>
    </ref>
    <ref id="b0035">
      <label>7</label>
      <element-citation publication-type="journal" id="h0035">
        <person-group person-group-type="author">
          <name>
            <surname>Bankevich</surname>
            <given-names>A.</given-names>
          </name>
          <name>
            <surname>Nurk</surname>
            <given-names>S.</given-names>
          </name>
          <name>
            <surname>Antipov</surname>
            <given-names>D.</given-names>
          </name>
          <name>
            <surname>Gurevich</surname>
            <given-names>A.A.</given-names>
          </name>
          <name>
            <surname>Dvorkin</surname>
            <given-names>M.</given-names>
          </name>
          <name>
            <surname>Kulikov</surname>
            <given-names>A.S.</given-names>
          </name>
          <name>
            <surname>Lesin</surname>
            <given-names>V.M.</given-names>
          </name>
          <name>
            <surname>Nikolenko</surname>
            <given-names>S.I.</given-names>
          </name>
          <name>
            <surname>Pham</surname>
            <given-names>S.</given-names>
          </name>
          <name>
            <surname>Prjibelski</surname>
            <given-names>A.D.</given-names>
          </name>
        </person-group>
        <article-title>SPAdes: a new genome assembly algorithm and its applications to single-cell sequencing</article-title>
        <source>J Comput Biol</source>
        <volume>19</volume>
        <issue>5</issue>
        <year>2012</year>
        <fpage>455</fpage>
        <lpage>477</lpage>
        <pub-id pub-id-type="pmid">22506599</pub-id>
      </element-citation>
    </ref>
    <ref id="b0040">
      <label>8</label>
      <mixed-citation publication-type="other" id="h0040">Belazzougui D, Gagie T, Mäkinen V, Previtali M, Fully Dynamic de Bruijn Graphs. In: Proc of SPIRE. pp. 145–152; 2016a.</mixed-citation>
    </ref>
    <ref id="b0045">
      <label>9</label>
      <mixed-citation publication-type="other" id="h0045">Belazzougui D, Gagie T, Mäkinen V, Previtali M, Puglisi SJ, Bidirectional variable-order de Bruijn graphs. In: Proc of LATIN. Springer, pp. 164–178; 2016b.</mixed-citation>
    </ref>
    <ref id="b0050">
      <label>10</label>
      <element-citation publication-type="journal" id="h0050">
        <person-group person-group-type="author">
          <name>
            <surname>Belazzougui</surname>
            <given-names>D.</given-names>
          </name>
          <name>
            <surname>Gagie</surname>
            <given-names>T.</given-names>
          </name>
          <name>
            <surname>Mäkinen</surname>
            <given-names>V.</given-names>
          </name>
          <name>
            <surname>Previtali</surname>
            <given-names>M.</given-names>
          </name>
          <name>
            <surname>Puglisi</surname>
            <given-names>S.J.</given-names>
          </name>
        </person-group>
        <article-title>Bidirectional variable-order de bruijn graphs</article-title>
        <source>Int J Found Comput Sci</source>
        <volume>29</volume>
        <issue>08</issue>
        <year>2018</year>
        <fpage>1279</fpage>
        <lpage>1295</lpage>
      </element-citation>
    </ref>
    <ref id="b0055">
      <label>11</label>
      <element-citation publication-type="journal" id="h0055">
        <person-group person-group-type="author">
          <name>
            <surname>Bentley</surname>
            <given-names>J.L.</given-names>
          </name>
          <name>
            <surname>Saxe</surname>
            <given-names>J.B.</given-names>
          </name>
        </person-group>
        <article-title>Decomposable searching problems I: Static-to-dynamic transformation</article-title>
        <source>J Algo</source>
        <volume>1</volume>
        <issue>4</issue>
        <year>1980</year>
        <fpage>301</fpage>
        <lpage>358</lpage>
      </element-citation>
    </ref>
    <ref id="b0060">
      <label>12</label>
      <element-citation publication-type="book" id="h0060">
        <person-group person-group-type="author">
          <name>
            <surname>Boucher</surname>
            <given-names>C.</given-names>
          </name>
          <name>
            <surname>Bowe</surname>
            <given-names>A.</given-names>
          </name>
          <name>
            <surname>Gagie</surname>
            <given-names>T.</given-names>
          </name>
          <name>
            <surname>Puglisi</surname>
            <given-names>S.J.</given-names>
          </name>
          <name>
            <surname>Sadakane</surname>
            <given-names>K.</given-names>
          </name>
        </person-group>
        <chapter-title>Variable-order de Bruijn graphs</chapter-title>
        <source>Proc of DCC</source>
        <year>2015</year>
        <fpage>383</fpage>
        <lpage>392</lpage>
      </element-citation>
    </ref>
    <ref id="b0065">
      <label>13</label>
      <mixed-citation publication-type="other" id="h0065">Bowe A, Onodera T, Sadakane K, Shibuya T, Succinct de Bruijn graphs. In: Proc of WABI. pp. 225–235; 2012.</mixed-citation>
    </ref>
    <ref id="b0070">
      <label>14</label>
      <element-citation publication-type="journal" id="h0070">
        <person-group person-group-type="author">
          <name>
            <surname>Cameron</surname>
            <given-names>D.</given-names>
          </name>
          <name>
            <surname>Schröder</surname>
            <given-names>J.</given-names>
          </name>
          <name>
            <surname>Sietsma Penington</surname>
            <given-names>J.</given-names>
          </name>
          <name>
            <surname>Do</surname>
            <given-names>H.</given-names>
          </name>
          <name>
            <surname>Molania</surname>
            <given-names>R.</given-names>
          </name>
          <name>
            <surname>Dobrovic</surname>
            <given-names>A.</given-names>
          </name>
          <name>
            <surname>Speed</surname>
            <given-names>T.</given-names>
          </name>
          <name>
            <surname>Papenfuss</surname>
            <given-names>A.</given-names>
          </name>
        </person-group>
        <article-title>GRIDSS: sensitive and specific genomic rearrangement detection using positional de Bruijn graph assembly</article-title>
        <source>Genome Res</source>
        <volume>27</volume>
        <issue>12</issue>
        <year>2017</year>
        <fpage>2050</fpage>
        <lpage>2060</lpage>
        <pub-id pub-id-type="pmid">29097403</pub-id>
      </element-citation>
    </ref>
    <ref id="b0075">
      <label>15</label>
      <element-citation publication-type="journal" id="h0075">
        <person-group person-group-type="author">
          <name>
            <surname>Chikhi</surname>
            <given-names>R.</given-names>
          </name>
          <name>
            <surname>Limasset</surname>
            <given-names>A.</given-names>
          </name>
          <name>
            <surname>Medvedev</surname>
            <given-names>P.</given-names>
          </name>
        </person-group>
        <article-title>Compacting de Bruijn graphs from sequencing data quickly and in low memory</article-title>
        <source>Bioinformatics</source>
        <volume>32</volume>
        <issue>12</issue>
        <year>2016</year>
        <fpage>i201</fpage>
        <lpage>i208</lpage>
        <pub-id pub-id-type="pmid">27307618</pub-id>
      </element-citation>
    </ref>
    <ref id="b0080">
      <label>16</label>
      <element-citation publication-type="journal" id="h0080">
        <person-group person-group-type="author">
          <name>
            <surname>Chikhi</surname>
            <given-names>R.</given-names>
          </name>
          <name>
            <surname>Medvedev</surname>
            <given-names>P.</given-names>
          </name>
        </person-group>
        <article-title>Informed and automated k-mer size selection for genome assembly</article-title>
        <source>Bioinformatics</source>
        <volume>30</volume>
        <issue>1</issue>
        <year>2014</year>
        <fpage>31</fpage>
        <lpage>37</lpage>
        <pub-id pub-id-type="pmid">23732276</pub-id>
      </element-citation>
    </ref>
    <ref id="b0085">
      <label>17</label>
      <element-citation publication-type="book" id="h0085">
        <person-group person-group-type="author">
          <name>
            <surname>Coimbra</surname>
            <given-names>M.E.</given-names>
          </name>
          <name>
            <surname>Francisco</surname>
            <given-names>A.P.</given-names>
          </name>
          <name>
            <surname>Russo</surname>
            <given-names>L.M.</given-names>
          </name>
          <name>
            <surname>De Bernardo</surname>
            <given-names>G.</given-names>
          </name>
          <name>
            <surname>Ladra</surname>
            <given-names>S.</given-names>
          </name>
          <name>
            <surname>Navarro</surname>
            <given-names>G.</given-names>
          </name>
        </person-group>
        <chapter-title>On dynamic succinct graph representations</chapter-title>
        <source>Proc of DCC</source>
        <year>2020</year>
        <fpage>213</fpage>
        <lpage>222</lpage>
      </element-citation>
    </ref>
    <ref id="b0090">
      <label>18</label>
      <element-citation publication-type="journal" id="h0090">
        <person-group person-group-type="author">
          <name>
            <surname>Crawford</surname>
            <given-names>V.</given-names>
          </name>
          <name>
            <surname>Kuhnle</surname>
            <given-names>A.</given-names>
          </name>
          <name>
            <surname>Boucher</surname>
            <given-names>C.</given-names>
          </name>
          <name>
            <surname>Chikhi</surname>
            <given-names>R.</given-names>
          </name>
          <name>
            <surname>Gagie</surname>
            <given-names>T.</given-names>
          </name>
        </person-group>
        <article-title>Practical Dynamic de Bruijn Graphs</article-title>
        <source>Bioinformatics</source>
        <volume>34</volume>
        <issue>24</issue>
        <year>2018</year>
        <fpage>4189</fpage>
        <lpage>4195</lpage>
        <pub-id pub-id-type="pmid">29939217</pub-id>
      </element-citation>
    </ref>
    <ref id="b0095">
      <label>19</label>
      <element-citation publication-type="journal" id="h0095">
        <person-group person-group-type="author">
          <name>
            <surname>Danko</surname>
            <given-names>D.</given-names>
          </name>
        </person-group>
        <article-title>Global genetic cartography of urban metagenomes and anti-microbial resistance</article-title>
        <source>Cell</source>
        <volume>184</volume>
        <year>2021</year>
        <fpage>1</fpage>
        <lpage>18</lpage>
        <pub-id pub-id-type="pmid">33417857</pub-id>
      </element-citation>
    </ref>
    <ref id="b0100">
      <label>20</label>
      <element-citation publication-type="journal" id="h0100">
        <person-group person-group-type="author">
          <name>
            <surname>Dementiev</surname>
            <given-names>R.</given-names>
          </name>
          <name>
            <surname>Kettner</surname>
            <given-names>L.</given-names>
          </name>
          <name>
            <surname>Sanders</surname>
            <given-names>P.</given-names>
          </name>
        </person-group>
        <article-title>STXXL: standard template library for xxl data sets</article-title>
        <source>Softw Pract Exp</source>
        <volume>38</volume>
        <issue>6</issue>
        <year>2008</year>
        <fpage>589</fpage>
        <lpage>637</lpage>
      </element-citation>
    </ref>
    <ref id="b0105">
      <label>21</label>
      <element-citation publication-type="book" id="h0105">
        <person-group person-group-type="author">
          <name>
            <surname>Díaz-Domínguez</surname>
            <given-names>D.</given-names>
          </name>
          <name>
            <surname>Gagie</surname>
            <given-names>T.</given-names>
          </name>
          <name>
            <surname>Navarro</surname>
            <given-names>G.</given-names>
          </name>
        </person-group>
        <chapter-title>Simulating the DNA overlap graph in succinct space</chapter-title>
        <source>Proc of CPM</source>
        <year>2019</year>
        <comment>pp. 26:1–26:20</comment>
      </element-citation>
    </ref>
    <ref id="b0110">
      <label>22</label>
      <mixed-citation publication-type="other" id="h0110">Egidi L, Louza F, Manzini G, Space efficient merging of de Bruijn graphs and wheeler graphs. arXiv; 2020.</mixed-citation>
    </ref>
    <ref id="b0115">
      <label>23</label>
      <mixed-citation publication-type="other" id="h0115">Esposito E, Graf TM, Vigna S, RecSplit: Minimal perfect hashing via recursive splitting. In: Proc of ALENEX. pp. 175–185; 2020a.</mixed-citation>
    </ref>
    <ref id="b0120">
      <label>24</label>
      <mixed-citation publication-type="other" id="h0120">Esposito E, Mueller-Graf T, Vigna S, RecSplit: Minimal Perfect Hashing via Recursive Splitting. In: Proc of ALENEX. pp. 175–185; 2020b.</mixed-citation>
    </ref>
    <ref id="b0125">
      <label>25</label>
      <element-citation publication-type="journal" id="h0125">
        <person-group person-group-type="author">
          <name>
            <surname>Ferragina</surname>
            <given-names>P.</given-names>
          </name>
          <name>
            <surname>Manzini</surname>
            <given-names>G.</given-names>
          </name>
        </person-group>
        <article-title>Indexing compressed text</article-title>
        <source>JACM</source>
        <volume>52</volume>
        <issue>4</issue>
        <year>2005</year>
        <fpage>552</fpage>
        <lpage>581</lpage>
      </element-citation>
    </ref>
    <ref id="b0130">
      <label>26</label>
      <element-citation publication-type="book" id="h0130">
        <person-group person-group-type="author">
          <name>
            <surname>Fredman</surname>
            <given-names>M.</given-names>
          </name>
          <name>
            <surname>Saks</surname>
            <given-names>M.</given-names>
          </name>
        </person-group>
        <chapter-title>The cell probe complexity of dynamic data structures</chapter-title>
        <source>Proc of STOC</source>
        <year>1989</year>
        <fpage>345</fpage>
        <lpage>354</lpage>
      </element-citation>
    </ref>
    <ref id="b0135">
      <label>27</label>
      <element-citation publication-type="journal" id="h0135">
        <person-group person-group-type="author">
          <name>
            <surname>Gagie</surname>
            <given-names>T.</given-names>
          </name>
          <name>
            <surname>Manzini</surname>
            <given-names>G.</given-names>
          </name>
          <name>
            <surname>Sirén</surname>
            <given-names>J.</given-names>
          </name>
        </person-group>
        <article-title>Wheeler graphs: A framework for BWT-based data structures</article-title>
        <source>Theor Comput Sci</source>
        <volume>698</volume>
        <year>2017</year>
        <fpage>67</fpage>
        <lpage>78</lpage>
        <pub-id pub-id-type="pmid">29276331</pub-id>
      </element-citation>
    </ref>
    <ref id="b0140">
      <label>28</label>
      <mixed-citation publication-type="other" id="h0140">Holley G, Personal email communication with authors of BFT; 2019.</mixed-citation>
    </ref>
    <ref id="b0145">
      <label>29</label>
      <element-citation publication-type="journal" id="h0145">
        <person-group person-group-type="author">
          <name>
            <surname>Holley</surname>
            <given-names>G.</given-names>
          </name>
          <name>
            <surname>Melsted</surname>
            <given-names>P.</given-names>
          </name>
        </person-group>
        <article-title>Bifrost–highly parallel construction and indexing of colored and compacted de Bruijn graphs</article-title>
        <source>Genome Bio</source>
        <volume>21</volume>
        <year>2020</year>
        <fpage>249</fpage>
        <pub-id pub-id-type="pmid">32943081</pub-id>
      </element-citation>
    </ref>
    <ref id="b0150">
      <label>30</label>
      <element-citation publication-type="book" id="h0150">
        <person-group person-group-type="author">
          <name>
            <surname>Holley</surname>
            <given-names>G.</given-names>
          </name>
          <name>
            <surname>Wittler</surname>
            <given-names>R.</given-names>
          </name>
          <name>
            <surname>Stoye</surname>
            <given-names>J.</given-names>
          </name>
        </person-group>
        <chapter-title>Bloom filter trie–a data structure for pan-genome storage</chapter-title>
        <source>Proc. of WABI</source>
        <year>2015</year>
        <fpage>217</fpage>
        <lpage>230</lpage>
      </element-citation>
    </ref>
    <ref id="b0155">
      <label>31</label>
      <mixed-citation publication-type="other" id="h0155">Iqbal Z, Caccamo M, Turner I, Flicek P, McVean G, De novo assembly and genotyping of variants using colored de Bruijn graphs. Nat Genet 44 (2), 226–232; 2012.</mixed-citation>
    </ref>
    <ref id="b0160">
      <label>32</label>
      <element-citation publication-type="journal" id="h0160">
        <person-group person-group-type="author">
          <name>
            <surname>Karp</surname>
            <given-names>R.M.</given-names>
          </name>
          <name>
            <surname>Rabin</surname>
            <given-names>M.O.</given-names>
          </name>
        </person-group>
        <article-title>Efficient randomized pattern-matching algorithms</article-title>
        <source>IBM J Res Dev</source>
        <volume>31</volume>
        <issue>2</issue>
        <year>1987</year>
        <fpage>249</fpage>
        <lpage>260</lpage>
      </element-citation>
    </ref>
    <ref id="b0165">
      <label>33</label>
      <element-citation publication-type="journal" id="h0165">
        <person-group person-group-type="author">
          <name>
            <surname>Kokot</surname>
            <given-names>M.</given-names>
          </name>
          <name>
            <surname>Długosz</surname>
            <given-names>M.</given-names>
          </name>
          <name>
            <surname>Deorowicz</surname>
            <given-names>S.</given-names>
          </name>
        </person-group>
        <article-title>KMC 3: counting and manipulating k-mer statistics</article-title>
        <source>Bioinformatics</source>
        <volume>33</volume>
        <issue>17</issue>
        <year>2017</year>
        <fpage>2759</fpage>
        <lpage>2761</lpage>
        <pub-id pub-id-type="pmid">28472236</pub-id>
      </element-citation>
    </ref>
    <ref id="b0170">
      <label>34</label>
      <element-citation publication-type="book" id="h0170">
        <person-group person-group-type="author">
          <name>
            <surname>Limasset</surname>
            <given-names>A.</given-names>
          </name>
          <name>
            <surname>Rizk</surname>
            <given-names>G.</given-names>
          </name>
          <name>
            <surname>Chikhi</surname>
            <given-names>R.</given-names>
          </name>
          <name>
            <surname>Peterlongo</surname>
            <given-names>P.</given-names>
          </name>
        </person-group>
        <chapter-title>Fast and scalable minimal perfect hashing for massive key sets</chapter-title>
        <source>Proc of SEA</source>
        <year>2017</year>
        <comment>pp. 25:1–25:16</comment>
      </element-citation>
    </ref>
    <ref id="b0175">
      <label>35</label>
      <mixed-citation publication-type="other" id="h0175">Marchet C, Boucher C, Puglisi S, Medvedev P, Salson M, Chikhi R, Data structures based on k-mers for querying large collections of sequencing data sets. Genome Res 31 (1), 1–12; 2021.</mixed-citation>
    </ref>
    <ref id="b0180">
      <label>36</label>
      <element-citation publication-type="journal" id="h0180">
        <person-group person-group-type="author">
          <name>
            <surname>McVean</surname>
            <given-names>G.</given-names>
          </name>
        </person-group>
        <article-title>An integrated map of genetic variation from 1,092 human genomes</article-title>
        <source>Nature</source>
        <volume>491</volume>
        <year>2012</year>
        <fpage>56</fpage>
        <lpage>65</lpage>
        <pub-id pub-id-type="pmid">23128226</pub-id>
      </element-citation>
    </ref>
    <ref id="b0185">
      <label>37</label>
      <element-citation publication-type="journal" id="h0185">
        <person-group person-group-type="author">
          <name>
            <surname>Medvedev</surname>
            <given-names>P.</given-names>
          </name>
          <name>
            <surname>Pham</surname>
            <given-names>S.</given-names>
          </name>
          <name>
            <surname>Chaisson</surname>
            <given-names>M.</given-names>
          </name>
          <name>
            <surname>Tesler</surname>
            <given-names>G.</given-names>
          </name>
          <name>
            <surname>Pevzner</surname>
            <given-names>P.</given-names>
          </name>
        </person-group>
        <article-title>Paired de Bruijn graphs: A novel approach for incorporating mate pair information into genome assemblers</article-title>
        <source>J Comput Biol</source>
        <volume>18</volume>
        <issue>11</issue>
        <year>2011</year>
        <fpage>1625</fpage>
        <lpage>1634</lpage>
        <pub-id pub-id-type="pmid">21999285</pub-id>
      </element-citation>
    </ref>
    <ref id="b0190">
      <label>38</label>
      <element-citation publication-type="journal" id="h0190">
        <person-group person-group-type="author">
          <name>
            <surname>Muggli</surname>
            <given-names>M.</given-names>
          </name>
          <name>
            <surname>Alipanahi</surname>
            <given-names>B.</given-names>
          </name>
          <name>
            <surname>Boucher</surname>
            <given-names>C.</given-names>
          </name>
        </person-group>
        <article-title>Building large updatable colored de Bruijn graphs via merging</article-title>
        <source>Bioinformatics</source>
        <volume>35</volume>
        <year>2019</year>
        <fpage>i51</fpage>
        <lpage>i60</lpage>
        <pub-id pub-id-type="pmid">31510647</pub-id>
      </element-citation>
    </ref>
    <ref id="b0195">
      <label>39</label>
      <element-citation publication-type="journal" id="h0195">
        <person-group person-group-type="author">
          <name>
            <surname>Muggli</surname>
            <given-names>M.</given-names>
          </name>
          <name>
            <surname>Bowe</surname>
            <given-names>A.</given-names>
          </name>
          <name>
            <surname>Noyes</surname>
            <given-names>N.</given-names>
          </name>
          <name>
            <surname>Morley</surname>
            <given-names>P.</given-names>
          </name>
          <name>
            <surname>Belk</surname>
            <given-names>K.</given-names>
          </name>
          <name>
            <surname>Raymond</surname>
            <given-names>R.</given-names>
          </name>
          <name>
            <surname>Gagie</surname>
            <given-names>T.</given-names>
          </name>
          <name>
            <surname>Puglisi</surname>
            <given-names>S.</given-names>
          </name>
          <name>
            <surname>Boucher</surname>
            <given-names>C.</given-names>
          </name>
        </person-group>
        <article-title>Succinct colored de Bruijn graphs</article-title>
        <source>Bioinformatics</source>
        <volume>33</volume>
        <issue>20</issue>
        <year>2017</year>
        <fpage>3181</fpage>
        <lpage>3187</lpage>
        <pub-id pub-id-type="pmid">28200001</pub-id>
      </element-citation>
    </ref>
    <ref id="b0200">
      <label>40</label>
      <mixed-citation publication-type="other" id="h0200">Munro I, Nekrich Y, Vitter JS, Dynamic data structures for document collections and graphs. In: Proc of PODS. pp. 277–289; 2015.</mixed-citation>
    </ref>
    <ref id="b0205">
      <label>41</label>
      <element-citation publication-type="journal" id="h0205">
        <person-group person-group-type="author">
          <name>
            <surname>Noyes</surname>
            <given-names>N.</given-names>
          </name>
        </person-group>
        <article-title>Resistome diversity in cattle and the environment decreases during beef production</article-title>
        <source>eLife</source>
        <volume>5</volume>
        <year>2016</year>
        <fpage>e13195</fpage>
        <pub-id pub-id-type="pmid">26952213</pub-id>
      </element-citation>
    </ref>
    <ref id="b0210">
      <label>42</label>
      <element-citation publication-type="journal" id="h0210">
        <person-group person-group-type="author">
          <name>
            <surname>Overmars</surname>
            <given-names>M.H.</given-names>
          </name>
          <name>
            <surname>van Leeuwen</surname>
            <given-names>J.</given-names>
          </name>
        </person-group>
        <article-title>Worst-case optimal insertion and deletion methods for decomposable searching problems</article-title>
        <source>Inf Process Lett</source>
        <volume>12</volume>
        <issue>4</issue>
        <year>1981</year>
        <fpage>168</fpage>
        <lpage>173</lpage>
      </element-citation>
    </ref>
    <ref id="b0215">
      <label>43</label>
      <element-citation publication-type="journal" id="h0215">
        <person-group person-group-type="author">
          <name>
            <surname>Pandey</surname>
            <given-names>P.</given-names>
          </name>
          <name>
            <surname>Almodaresi</surname>
            <given-names>F.</given-names>
          </name>
          <name>
            <surname>Bender</surname>
            <given-names>M.</given-names>
          </name>
          <name>
            <surname>Ferdman</surname>
            <given-names>M.</given-names>
          </name>
          <name>
            <surname>Johnson</surname>
            <given-names>R.</given-names>
          </name>
          <name>
            <surname>Patro</surname>
            <given-names>R.</given-names>
          </name>
        </person-group>
        <article-title>Mantis: A fast, small, and exact large-scale sequence-search index</article-title>
        <source>Cell</source>
        <volume>7</volume>
        <issue>2</issue>
        <year>2018</year>
        <fpage>201</fpage>
        <lpage>207</lpage>
      </element-citation>
    </ref>
    <ref id="b0220">
      <label>44</label>
      <element-citation publication-type="book" id="h0220">
        <person-group person-group-type="author">
          <name>
            <surname>Peng</surname>
            <given-names>Y.</given-names>
          </name>
          <name>
            <surname>Leung</surname>
            <given-names>H.C.</given-names>
          </name>
          <name>
            <surname>Yiu</surname>
            <given-names>S.-M.</given-names>
          </name>
          <name>
            <surname>Chin</surname>
            <given-names>F.Y.</given-names>
          </name>
        </person-group>
        <chapter-title>IDBA–a practical iterative de Bruijn graph de novo assembler</chapter-title>
        <source>Proc of RECOMB</source>
        <year>2010</year>
        <fpage>426</fpage>
        <lpage>440</lpage>
      </element-citation>
    </ref>
    <ref id="b0225">
      <label>45</label>
      <element-citation publication-type="journal" id="h0225">
        <person-group person-group-type="author">
          <name>
            <surname>Peng</surname>
            <given-names>Y.</given-names>
          </name>
        </person-group>
        <article-title>IDBA-UD: A de novo assembler for single-cell and metagenomic sequencing data with highly uneven depth</article-title>
        <source>Bioinformatics</source>
        <volume>28</volume>
        <issue>11</issue>
        <year>2012</year>
      </element-citation>
    </ref>
    <ref id="b0230">
      <label>46</label>
      <element-citation publication-type="journal" id="h0230">
        <person-group person-group-type="author">
          <name>
            <surname>Pevzner</surname>
            <given-names>P.</given-names>
          </name>
          <name>
            <surname>Tang</surname>
            <given-names>H.</given-names>
          </name>
          <name>
            <surname>Waterman</surname>
            <given-names>M.</given-names>
          </name>
        </person-group>
        <article-title>An Eulerian path approach to DNA fragment assembly</article-title>
        <source>Proc Natl Acad Sci</source>
        <volume>98</volume>
        <issue>17</issue>
        <year>2001</year>
        <fpage>9748</fpage>
        <lpage>9753</lpage>
        <pub-id pub-id-type="pmid">11504945</pub-id>
      </element-citation>
    </ref>
    <ref id="b0235">
      <label>47</label>
      <element-citation publication-type="book" id="h0235">
        <person-group person-group-type="author">
          <name>
            <surname>Prezza</surname>
            <given-names>N.</given-names>
          </name>
        </person-group>
        <chapter-title>A framework of dynamic data structures for string processing</chapter-title>
        <source>Proc of SEA</source>
        <year>2017</year>
        <comment>p. 11:1–11:15</comment>
      </element-citation>
    </ref>
    <ref id="b0240">
      <label>48</label>
      <element-citation publication-type="journal" id="h0240">
        <person-group person-group-type="author">
          <name>
            <surname>Ronen</surname>
            <given-names>R.</given-names>
          </name>
          <name>
            <surname>Boucher</surname>
            <given-names>C.</given-names>
          </name>
          <name>
            <surname>Chitsaz</surname>
            <given-names>H.</given-names>
          </name>
          <name>
            <surname>Pevzner</surname>
            <given-names>P.</given-names>
          </name>
        </person-group>
        <article-title>SEQuel: improving the accuracy of genome assemblies</article-title>
        <source>Bioinformatics</source>
        <volume>28</volume>
        <issue>12</issue>
        <year>2012</year>
        <fpage>i188</fpage>
        <lpage>i196</lpage>
        <pub-id pub-id-type="pmid">22689760</pub-id>
      </element-citation>
    </ref>
    <ref id="b0245">
      <label>49</label>
      <element-citation publication-type="journal" id="h0245">
        <person-group person-group-type="author">
          <name>
            <surname>Sirén</surname>
            <given-names>J.</given-names>
          </name>
          <name>
            <surname>Garrison</surname>
            <given-names>E.</given-names>
          </name>
          <name>
            <surname>Novak</surname>
            <given-names>A.M.</given-names>
          </name>
          <name>
            <surname>Paten</surname>
            <given-names>B.</given-names>
          </name>
          <name>
            <surname>Durbin</surname>
            <given-names>R.</given-names>
          </name>
        </person-group>
        <article-title>Haplotype-aware graph indexes</article-title>
        <source>Bioinformatics</source>
        <volume>36</volume>
        <issue>2</issue>
        <year>2020</year>
        <fpage>400</fpage>
        <lpage>407</lpage>
        <pub-id pub-id-type="pmid">31406990</pub-id>
      </element-citation>
    </ref>
    <ref id="b0250">
      <label>50</label>
      <element-citation publication-type="journal" id="h0250">
        <person-group person-group-type="author">
          <name>
            <surname>Turnbull</surname>
            <given-names>C.</given-names>
          </name>
        </person-group>
        <article-title>The 100,000 genomes project: bringing whole genome sequencing to the nhs</article-title>
        <source>Br Med J</source>
        <volume>361</volume>
        <year>2018</year>
      </element-citation>
    </ref>
    <ref id="b0255">
      <label>51</label>
      <element-citation publication-type="journal" id="h0255">
        <person-group person-group-type="author">
          <name>
            <surname>Turner</surname>
            <given-names>I.</given-names>
          </name>
          <name>
            <surname>Garimella</surname>
            <given-names>K.</given-names>
          </name>
          <name>
            <surname>Iqbal</surname>
            <given-names>Z.</given-names>
          </name>
          <name>
            <surname>McVean</surname>
            <given-names>G.</given-names>
          </name>
        </person-group>
        <article-title>Integrating long-range connectivity information into de Bruijn graphs</article-title>
        <source>Bioinformatics</source>
        <volume>34</volume>
        <issue>15</issue>
        <year>2018</year>
        <fpage>2556</fpage>
        <lpage>2565</lpage>
        <pub-id pub-id-type="pmid">29554215</pub-id>
      </element-citation>
    </ref>
    <ref id="b0260">
      <label>52</label>
      <element-citation publication-type="journal" id="h0260">
        <person-group person-group-type="author">
          <name>
            <surname>Zerbino</surname>
            <given-names>D.</given-names>
          </name>
          <name>
            <surname>Birney</surname>
            <given-names>E.</given-names>
          </name>
        </person-group>
        <article-title>Velvet: Algorithms for de novo short read assembly using de Bruijn graphs</article-title>
        <source>Genome Res</source>
        <volume>18</volume>
        <year>2008</year>
        <fpage>821</fpage>
        <lpage>829</lpage>
        <pub-id pub-id-type="pmid">18349386</pub-id>
      </element-citation>
    </ref>
  </ref-list>
</back>
