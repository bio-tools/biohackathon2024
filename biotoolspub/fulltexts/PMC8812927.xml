<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.1d3 20150301//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 39.96?>
<?ConverterInfo.XSLTName jats2jats3.xsl?>
<?ConverterInfo.Version 1?>
<?properties open_access?>
<processing-meta base-tagset="archiving" mathml-version="3.0" table-model="xhtml" tagset-family="jats">
  <restricted-by>pmc</restricted-by>
</processing-meta>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">PLoS Comput Biol</journal-id>
    <journal-id journal-id-type="iso-abbrev">PLoS Comput Biol</journal-id>
    <journal-id journal-id-type="publisher-id">plos</journal-id>
    <journal-title-group>
      <journal-title>PLoS Computational Biology</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1553-734X</issn>
    <issn pub-type="epub">1553-7358</issn>
    <publisher>
      <publisher-name>Public Library of Science</publisher-name>
      <publisher-loc>San Francisco, CA USA</publisher-loc>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">8812927</article-id>
    <article-id pub-id-type="pmid">35073327</article-id>
    <article-id pub-id-type="publisher-id">PCOMPBIOL-D-21-01915</article-id>
    <article-id pub-id-type="doi">10.1371/journal.pcbi.1009802</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Research Article</subject>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Biology and Life Sciences</subject>
        <subj-group>
          <subject>Genetics</subject>
          <subj-group>
            <subject>Genomics</subject>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Research and Analysis Methods</subject>
        <subj-group>
          <subject>Database and Informatics Methods</subject>
          <subj-group>
            <subject>Bioinformatics</subject>
            <subj-group>
              <subject>Sequence Analysis</subject>
              <subj-group>
                <subject>Sequence Alignment</subject>
              </subj-group>
            </subj-group>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Biology and Life Sciences</subject>
        <subj-group>
          <subject>Microbiology</subject>
          <subj-group>
            <subject>Bacteriology</subject>
            <subj-group>
              <subject>Bacterial Genetics</subject>
              <subj-group>
                <subject>Bacterial Genomics</subject>
              </subj-group>
            </subj-group>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Biology and Life Sciences</subject>
        <subj-group>
          <subject>Genetics</subject>
          <subj-group>
            <subject>Microbial Genetics</subject>
            <subj-group>
              <subject>Bacterial Genetics</subject>
              <subj-group>
                <subject>Bacterial Genomics</subject>
              </subj-group>
            </subj-group>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Biology and Life Sciences</subject>
        <subj-group>
          <subject>Genetics</subject>
          <subj-group>
            <subject>Genomics</subject>
            <subj-group>
              <subject>Microbial Genomics</subject>
              <subj-group>
                <subject>Bacterial Genomics</subject>
              </subj-group>
            </subj-group>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Biology and Life Sciences</subject>
        <subj-group>
          <subject>Microbiology</subject>
          <subj-group>
            <subject>Microbial Genomics</subject>
            <subj-group>
              <subject>Bacterial Genomics</subject>
            </subj-group>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Biology and Life Sciences</subject>
        <subj-group>
          <subject>Biochemistry</subject>
          <subj-group>
            <subject>Nucleotides</subject>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Research and Analysis Methods</subject>
        <subj-group>
          <subject>Computational Techniques</subject>
          <subj-group>
            <subject>Split-Decomposition Method</subject>
            <subj-group>
              <subject>Multiple Alignment Calculation</subject>
            </subj-group>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Biology and Life Sciences</subject>
        <subj-group>
          <subject>Molecular Biology</subject>
          <subj-group>
            <subject>Molecular Biology Techniques</subject>
            <subj-group>
              <subject>Sequencing Techniques</subject>
              <subj-group>
                <subject>Genome Sequencing</subject>
              </subj-group>
            </subj-group>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Research and Analysis Methods</subject>
        <subj-group>
          <subject>Molecular Biology Techniques</subject>
          <subj-group>
            <subject>Sequencing Techniques</subject>
            <subj-group>
              <subject>Genome Sequencing</subject>
            </subj-group>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Biology and Life Sciences</subject>
        <subj-group>
          <subject>Organisms</subject>
          <subj-group>
            <subject>Bacteria</subject>
            <subj-group>
              <subject>Klebsiella</subject>
              <subj-group>
                <subject>Klebsiella Oxytoca</subject>
              </subj-group>
            </subj-group>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Biology and Life Sciences</subject>
        <subj-group>
          <subject>Microbiology</subject>
          <subj-group>
            <subject>Medical Microbiology</subject>
            <subj-group>
              <subject>Microbial Pathogens</subject>
              <subj-group>
                <subject>Bacterial Pathogens</subject>
                <subj-group>
                  <subject>Klebsiella</subject>
                  <subj-group>
                    <subject>Klebsiella Oxytoca</subject>
                  </subj-group>
                </subj-group>
              </subj-group>
            </subj-group>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Medicine and Health Sciences</subject>
        <subj-group>
          <subject>Pathology and Laboratory Medicine</subject>
          <subj-group>
            <subject>Pathogens</subject>
            <subj-group>
              <subject>Microbial Pathogens</subject>
              <subj-group>
                <subject>Bacterial Pathogens</subject>
                <subj-group>
                  <subject>Klebsiella</subject>
                  <subj-group>
                    <subject>Klebsiella Oxytoca</subject>
                  </subj-group>
                </subj-group>
              </subj-group>
            </subj-group>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Engineering and Technology</subject>
        <subj-group>
          <subject>Nanotechnology</subject>
        </subj-group>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Polypolish: Short-read polishing of long-read bacterial genome assemblies</article-title>
      <alt-title alt-title-type="running-head">Polypolish: Short-read polishing of long-read bacterial genome assemblies</alt-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <contrib-id authenticated="true" contrib-id-type="orcid">https://orcid.org/0000-0001-8349-0778</contrib-id>
        <name>
          <surname>Wick</surname>
          <given-names>Ryan R.</given-names>
        </name>
        <role content-type="http://credit.niso.org/contributor-roles/conceptualization/">Conceptualization</role>
        <role content-type="http://credit.niso.org/contributor-roles/data-curation/">Data curation</role>
        <role content-type="http://credit.niso.org/contributor-roles/formal-analysis/">Formal analysis</role>
        <role content-type="http://credit.niso.org/contributor-roles/investigation/">Investigation</role>
        <role content-type="http://credit.niso.org/contributor-roles/methodology/">Methodology</role>
        <role content-type="http://credit.niso.org/contributor-roles/software/">Software</role>
        <role content-type="http://credit.niso.org/contributor-roles/visualization/">Visualization</role>
        <role content-type="http://credit.niso.org/contributor-roles/writing-original-draft/">Writing – original draft</role>
        <role content-type="http://credit.niso.org/contributor-roles/writing-review-editing/">Writing – review &amp; editing</role>
        <xref rid="aff001" ref-type="aff">
          <sup>1</sup>
        </xref>
        <xref rid="cor001" ref-type="corresp">*</xref>
      </contrib>
      <contrib contrib-type="author">
        <contrib-id authenticated="true" contrib-id-type="orcid">https://orcid.org/0000-0003-3949-2471</contrib-id>
        <name>
          <surname>Holt</surname>
          <given-names>Kathryn E.</given-names>
        </name>
        <role content-type="http://credit.niso.org/contributor-roles/funding-acquisition/">Funding acquisition</role>
        <role content-type="http://credit.niso.org/contributor-roles/project-administration/">Project administration</role>
        <role content-type="http://credit.niso.org/contributor-roles/supervision/">Supervision</role>
        <role content-type="http://credit.niso.org/contributor-roles/writing-review-editing/">Writing – review &amp; editing</role>
        <xref rid="aff001" ref-type="aff">
          <sup>1</sup>
        </xref>
        <xref rid="aff002" ref-type="aff">
          <sup>2</sup>
        </xref>
      </contrib>
    </contrib-group>
    <aff id="aff001">
      <label>1</label>
      <addr-line>Department of Infectious Diseases, Central Clinical School, Monash University, Melbourne, Victoria, Australia</addr-line>
    </aff>
    <aff id="aff002">
      <label>2</label>
      <addr-line>Department of Infection Biology, London School of Hygiene &amp; Tropical Medicine, London, United Kingdom</addr-line>
    </aff>
    <contrib-group>
      <contrib contrib-type="editor">
        <name>
          <surname>Schneidman-Duhovny</surname>
          <given-names>Dina</given-names>
        </name>
        <role>Editor</role>
        <xref rid="edit1" ref-type="aff"/>
      </contrib>
    </contrib-group>
    <aff id="edit1">
      <addr-line>Hebrew University of Jerusalem, ISRAEL</addr-line>
    </aff>
    <author-notes>
      <fn fn-type="COI-statement" id="coi001">
        <p>The authors have declared that no competing interests exist.</p>
      </fn>
      <corresp id="cor001">* E-mail: <email>rrwick@gmail.com</email></corresp>
    </author-notes>
    <pub-date pub-type="collection">
      <month>1</month>
      <year>2022</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>24</day>
      <month>1</month>
      <year>2022</year>
    </pub-date>
    <volume>18</volume>
    <issue>1</issue>
    <elocation-id>e1009802</elocation-id>
    <history>
      <date date-type="received">
        <day>21</day>
        <month>10</month>
        <year>2021</year>
      </date>
      <date date-type="accepted">
        <day>3</day>
        <month>1</month>
        <year>2022</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© 2022 Wick, Holt</copyright-statement>
      <copyright-year>2022</copyright-year>
      <copyright-holder>Wick, Holt</copyright-holder>
      <license>
        <ali:license_ref xmlns:ali="http://www.niso.org/schemas/ali/1.0/" specific-use="textmining" content-type="ccbylicense">https://creativecommons.org/licenses/by/4.0/</ali:license_ref>
        <license-p>This is an open access article distributed under the terms of the <ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution License</ext-link>, which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited.</license-p>
      </license>
    </permissions>
    <self-uri content-type="pdf" xlink:href="pcbi.1009802.pdf"/>
    <abstract>
      <p>Long-read-only bacterial genome assemblies usually contain residual errors, most commonly homopolymer-length errors. Short-read polishing tools can use short reads to fix these errors, but most rely on short-read alignment which is unreliable in repeat regions. Errors in such regions are therefore challenging to fix and often remain after short-read polishing. Here we introduce Polypolish, a new short-read polisher which uses all-per-read alignments to repair errors in repeat sequences that other polishers cannot. Polypolish performed well in benchmarking tests using both simulated and real reads, and it almost never introduced errors during polishing. The best results were achieved by using Polypolish in combination with other short-read polishers.</p>
    </abstract>
    <abstract abstract-type="summary">
      <title>Author summary</title>
      <p>Recent improvements in Oxford Nanopore Technologies sequencing platforms and assembly algorithms have made it easier than ever to generate complete bacterial genome sequences. However, Oxford Nanopore genome sequences suffer from errors that limit their utility in downstream analyses. To fix these errors, one can ‘polish’ the genome with Illumina sequencing, exploiting the fact that Oxford Nanopore and Illumina sequencing have different error profiles. There are several polishing tools which can fix most errors in an Oxford Nanopore genome, but they struggle with errors in repetitive regions of the genome. With this in mind, we have developed a polisher, Polypolish, which uses a novel approach that allows it to fix more errors in genomic repeats. Our results show that Polypolish is both effective at repairing sequence errors and very unlikely to introduce new errors. Polypolish can often fix errors that other polishers cannot and vice versa, so the best results come from using a combination of tools. Polypolish therefore has an important role in bacterial genome assembly methods that aim for the highest possible sequence accuracy.</p>
    </abstract>
    <funding-group>
      <award-group id="award001">
        <funding-source>
          <institution-wrap>
            <institution-id institution-id-type="funder-id">http://dx.doi.org/10.13039/100000865</institution-id>
            <institution>Bill and Melinda Gates Foundation</institution>
          </institution-wrap>
        </funding-source>
        <award-id>OPP1175797</award-id>
        <principal-award-recipient>
          <contrib-id authenticated="true" contrib-id-type="orcid">https://orcid.org/0000-0003-3949-2471</contrib-id>
          <name>
            <surname>Holt</surname>
            <given-names>Kathryn E.</given-names>
          </name>
        </principal-award-recipient>
      </award-group>
      <award-group id="award002">
        <funding-source>
          <institution>Australian Government Research Training Program Scholarship</institution>
        </funding-source>
        <principal-award-recipient>
          <contrib-id authenticated="true" contrib-id-type="orcid">https://orcid.org/0000-0001-8349-0778</contrib-id>
          <name>
            <surname>Wick</surname>
            <given-names>Ryan R.</given-names>
          </name>
        </principal-award-recipient>
      </award-group>
      <award-group id="award003">
        <funding-source>
          <institution-wrap>
            <institution-id institution-id-type="funder-id">http://dx.doi.org/10.13039/100008717</institution-id>
            <institution>Sylvia and Charles Viertel Charitable Foundation</institution>
          </institution-wrap>
        </funding-source>
        <principal-award-recipient>
          <contrib-id authenticated="true" contrib-id-type="orcid">https://orcid.org/0000-0003-3949-2471</contrib-id>
          <name>
            <surname>Holt</surname>
            <given-names>Kathryn E.</given-names>
          </name>
        </principal-award-recipient>
      </award-group>
      <funding-statement>This work was supported, in whole or in part, by the Bill &amp; Melinda Gates Foundation (KEH, grant number OPP1175797). Under the grant conditions of the Foundation, a Creative Commons Attribution 4.0 Generic License has already been assigned to the Author Accepted Manuscript version that might arise from this submission. This work was also supported by an Australian Government Research Training Program Scholarship (RRW), and a Senior Medical Research Fellowship from the Sylvia and Charles Viertel Charitable Foundation (KEH). The funders had no role in study design, data collection and analysis, decision to publish, or preparation of the manuscript.</funding-statement>
    </funding-group>
    <counts>
      <fig-count count="3"/>
      <table-count count="0"/>
      <page-count count="13"/>
    </counts>
    <custom-meta-group>
      <custom-meta>
        <meta-name>PLOS Publication Stage</meta-name>
        <meta-value>vor-update-to-uncorrected-proof</meta-value>
      </custom-meta>
      <custom-meta>
        <meta-name>Publication Update</meta-name>
        <meta-value>2022-02-03</meta-value>
      </custom-meta>
      <custom-meta id="data-availability">
        <meta-name>Data Availability</meta-name>
        <meta-value>The Polypolish tool and documentation can be found at github.com/rrwick/Polypolish. All supplementary figures, tables, methods and scripts can be found on a GitHub repository at github.com/rrwick/Polypolish-paper (doi: <ext-link xlink:href="https://doi.org/10.5281/zenodo.5581894" ext-link-type="uri">10.5281/zenodo.5581894</ext-link>). All read sets and assemblies can be downloaded from bridges.monash.edu/articles/dataset/Polypolish_paper_dataset/16727680 (doi: <ext-link xlink:href="https://doi.org/10.26180/16727680" ext-link-type="uri">10.26180/16727680</ext-link>).</meta-value>
      </custom-meta>
    </custom-meta-group>
  </article-meta>
  <notes>
    <title>Data Availability</title>
    <p>The Polypolish tool and documentation can be found at github.com/rrwick/Polypolish. All supplementary figures, tables, methods and scripts can be found on a GitHub repository at github.com/rrwick/Polypolish-paper (doi: <ext-link xlink:href="https://doi.org/10.5281/zenodo.5581894" ext-link-type="uri">10.5281/zenodo.5581894</ext-link>). All read sets and assemblies can be downloaded from bridges.monash.edu/articles/dataset/Polypolish_paper_dataset/16727680 (doi: <ext-link xlink:href="https://doi.org/10.26180/16727680" ext-link-type="uri">10.26180/16727680</ext-link>).</p>
  </notes>
</front>
<body>
  <disp-quote>
    <p>This is a <italic toggle="yes">PLOS Computational Biology</italic> Software paper.</p>
  </disp-quote>
  <sec sec-type="intro" id="sec001">
    <title>Introduction</title>
    <p>Long-read-only genome assemblies are inferred using Oxford Nanopore Technologies (ONT) or Pacific Biosciences (PacBio) sequencing reads. For bacterial genomes, reads from these platforms are often longer than the largest repeat in the genome, making complete assemblies (one contig per replicon) possible [<xref rid="pcbi.1009802.ref001" ref-type="bibr">1</xref>]. However, systematic errors in long reads can lead to hundreds of residual errors in long-read-only assemblies of bacterial genomes, most of which are indels in homopolymer sequences [<xref rid="pcbi.1009802.ref002" ref-type="bibr">2</xref>, <xref rid="pcbi.1009802.ref003" ref-type="bibr">3</xref>]. When these errors occur in protein-coding sequences, they cause frameshifts in the open reading frame, leading to problems with genome annotation and limiting the utility of long-read-only assemblies [<xref rid="pcbi.1009802.ref004" ref-type="bibr">4</xref>].</p>
    <p>Short reads from Illumina platforms do not suffer from the same errors in homopolymer sequences as long reads [<xref rid="pcbi.1009802.ref005" ref-type="bibr">5</xref>]. Hybrid assembly, using both short and long reads together, can therefore produce sequences which are both complete and highly accurate. Hybrid assembly can be carried out in a short-read-first manner, where long reads are used to scaffold short-read-based contigs into complete genomes, or a long-read-first manner, where short reads are used to correct errors in long-read-based contigs [<xref rid="pcbi.1009802.ref006" ref-type="bibr">6</xref>]. Given sufficient read depth, long-read-first hybrid assemblies can be more accurate than short-read-first hybrid assemblies, but errors often remain, particularly in repetitive regions of the genome [<xref rid="pcbi.1009802.ref003" ref-type="bibr">3</xref>].</p>
    <p>Long-read-first hybrid assembly commonly contains three stages: long-read assembly, long-read polishing and short-read polishing [<xref rid="pcbi.1009802.ref007" ref-type="bibr">7</xref>]. All three stages are important when maximising assembly accuracy. The first stage (long-read assembly) aims to create a complete assembly free of any structural errors, i.e. an assembly where the only errors are small in scale. The second stage (long-read polishing) aims to repair as many of the residual small-scale errors as possible using only long reads, e.g. with a platform-specific tool such as Medaka [<xref rid="pcbi.1009802.ref008" ref-type="bibr">8</xref>]. This study is concerned with the final stage, short-read polishing, which aims to repair any remaining small-scale errors using short reads.</p>
    <p>There are many short-read polishing tools appropriate for bacterial genomes, including HyPo [<xref rid="pcbi.1009802.ref009" ref-type="bibr">9</xref>], NextPolish [<xref rid="pcbi.1009802.ref010" ref-type="bibr">10</xref>], ntEdit [<xref rid="pcbi.1009802.ref011" ref-type="bibr">11</xref>], Pilon [<xref rid="pcbi.1009802.ref012" ref-type="bibr">12</xref>], POLCA [<xref rid="pcbi.1009802.ref013" ref-type="bibr">13</xref>], Racon [<xref rid="pcbi.1009802.ref014" ref-type="bibr">14</xref>] and wtpoa [<xref rid="pcbi.1009802.ref015" ref-type="bibr">15</xref>]. Except for ntEdit, which uses a <italic toggle="yes">k</italic>-mer-based algorithm, each of these tools relies on short-read alignments. The standard approach to short-read alignment involves placing each read in a single location where it best aligns (with ties broken randomly), and this is how popular aligners such as BWA-MEM [<xref rid="pcbi.1009802.ref016" ref-type="bibr">16</xref>] and Bowtie2 [<xref rid="pcbi.1009802.ref017" ref-type="bibr">17</xref>] behave with default settings. This method is reliable for non-repetitive parts of the genome, but errors in repeat sequences can cause problems. Specifically, if one instance of a repeat sequence contains an error but another instance does not, reads will preferentially align to the error-free instance, leaving no reads aligned over the error (<xref rid="pcbi.1009802.g001" ref-type="fig">Fig 1A</xref>). Short-read polishing tools which use the alignments may therefore be unable to fix errors in repeats.</p>
    <fig position="float" id="pcbi.1009802.g001">
      <object-id pub-id-type="doi">10.1371/journal.pcbi.1009802.g001</object-id>
      <label>Fig 1</label>
      <caption>
        <title>Short-read alignments for assembly polishing.</title>
        <p>In both examples, the aligned reads (above the line) contain no errors and the assembly sequence (below the line) contains three errors indicated by highlighted columns, one of which is in a repeat sequence. <bold>A</bold>: standard one-per-read alignments where each read is aligned to a single best location (randomly chosen in a tie). The errors in non-repeat sequences are covered by read alignments, but the error in the repeat has no coverage because reads preferentially aligned to the other instance of the repeat which is error-free. <bold>B</bold>: all-per-read alignments where each read is aligned to all possible locations. Reads aligned to multiple positions are coloured red. All errors are covered by alignments, including the error in the repeat sequence.</p>
      </caption>
      <graphic xlink:href="pcbi.1009802.g001" position="float"/>
    </fig>
    <p>Here, we introduce Polypolish, a new short-read polishing tool which addresses this problem by using a different type of short-read alignment as input. Instead of alignments where each read is placed in a single location, Polypolish is designed to use alignments where each read is aligned to all possible locations (<xref rid="pcbi.1009802.g001" ref-type="fig">Fig 1B</xref>). This ensures that errors in repeats are covered by alignments, allowing Polypolish to fix errors that other short-read polishing tools cannot.</p>
  </sec>
  <sec sec-type="results" id="sec002">
    <title>Results</title>
    <sec id="sec003">
      <title>Implementation</title>
      <p>Before users run Polypolish, they must align short reads to their long-read assembly using a short-read aligner such as BWA-MEM or Bowtie2. Importantly, the reads must be aligned using the aligner’s all-alignments-per-read option to ensure coverage over genomic repeats (<xref rid="pcbi.1009802.g001" ref-type="fig">Fig 1B</xref> and <xref rid="pcbi.1009802.s001" ref-type="supplementary-material">S1(A) Fig</xref>).</p>
      <p>Polypolish then builds a pileup, where for each position of the assembly sequence, all the read nucleotides associated with that position are collected (<xref rid="pcbi.1009802.s001" ref-type="supplementary-material">S1(B) Fig</xref>). ‘Nucleotides’ in the pileup usually consist of a single base, but a read may contribute more than one base per position in the case of an insertion relative to the assembly. When building the pileup, Polypolish trims off two or more bases at the end of each alignment: whatever base is at the end of the read, however many times it occurs, and one more additional base. This trimming ensures that homopolymer indel errors are properly represented in the pileup (<xref rid="pcbi.1009802.s002" ref-type="supplementary-material">S2 Fig</xref>). Polypolish then calculates a read depth for each position of the assembly (<xref rid="pcbi.1009802.s001" ref-type="supplementary-material">S1(B) Fig</xref>). Reads which align to a single location contribute one unit of depth for each position they cover. Reads which align to multiple locations contribute fractional depth (the reciprocal of their alignment count) to their covered positions; note that this results in approximately the same read depth that would be calculated from the more typical best-match alignment (<xref rid="pcbi.1009802.s003" ref-type="supplementary-material">S3 Fig</xref>).</p>
      <p>Polypolish then assesses each base call in the assembly using the pileup and read depth. For any assembly position at which the pileup contains one and only one valid nucleotide, that valid nucleotide differs from the one currently in the assembly, and all other nucleotides in the pileup are invalid, the assembly base call will be changed to the valid nucleotide (<xref rid="pcbi.1009802.s001" ref-type="supplementary-material">S1(C) Fig</xref>). Valid nucleotides are defined as those which have a count greater than the valid threshold: 50% of the read depth at that position, or five, whichever is greater (adjustable by the <monospace>--fraction_valid</monospace> and <monospace>--min_depth</monospace> options). Invalid nucleotides are defined as those which have a count less than the invalid threshold: 20% of the read depth at that position (adjustable by the <monospace>--fraction_invalid</monospace> option). In this manner, Polypolish is a conservative polisher, only making a change where the reads indicate a single unambiguous alternative. In all other cases (e.g. when there are multiple valid nucleotides or there are nucleotides between the two thresholds), the assembly base call is left unchanged. Polypolish is therefore very unlikely to introduce errors during polishing.</p>
    </sec>
    <sec id="sec004">
      <title>Simulated-read tests</title>
      <p>We conducted tests using reads simulated from 100 NCBI reference genomes (details in Materials and methods, <xref rid="pcbi.1009802.s015" ref-type="supplementary-material">S1 Table</xref>) to test the effectiveness of Polypolish v0.4.3 and other short-read polishers: HyPo v1.0.3, NextPolish v1.3.1, Pilon v1.24, POLCA v4.0.3, Racon v1.4.21 and wtpoa v2.5. For each genome, we generated a simulated short-read set and an error-containing long-read assembly with an accuracy of ∼Q30 (equating to approximately 1000–10000 errors per genome). We then polished the genomes using the short-read polishers and counted the number of remaining errors by aligning the result to the original reference genome (<xref rid="pcbi.1009802.s016" ref-type="supplementary-material">S2 Table</xref>).</p>
      <p>We tested each short-read polisher in isolation by running three consecutive rounds of polishing. The resulting per-genome error counts after the third round of polishing are shown in <xref rid="pcbi.1009802.g002" ref-type="fig">Fig 2A</xref>. HyPo, NextPolish, Pilon, POLCA and Polypolish performed well, each achieving a mean per-genome error count of &lt;100 and reducing some genomes to zero errors. NextPolish performed best, with a mean per-genome error count of 35. Racon and ntEdit were able to reduce the number of assembly errors, but their mean per-genome error count was &gt;100. wtpoa is excluded from our main results because it increased the number of errors in most genomes (<xref rid="pcbi.1009802.s004" ref-type="supplementary-material">S4 Fig</xref>). Pilon was the tool which most benefitted from multiple rounds (Q46.4 after one round, Q48.8 after two rounds); other tools produced no more than a small increase in accuracy with polishing rounds after the first (<xref rid="pcbi.1009802.s004" ref-type="supplementary-material">S4 Fig</xref>). For most polishing tools, the majority of residual errors were in genomic repeats (<xref rid="pcbi.1009802.s004" ref-type="supplementary-material">S4 Fig</xref>), i.e. the sequence accuracy of non-repeat regions was much higher (&gt;Q50 for most tools) than that of repeat regions (&lt;Q40 for all tools). ntEdit was a notable exception, having a smaller difference between non-repeat and repeat accuracy (Q40.6 vs Q37.2, respectively).</p>
      <fig position="float" id="pcbi.1009802.g002">
        <object-id pub-id-type="doi">10.1371/journal.pcbi.1009802.g002</object-id>
        <label>Fig 2</label>
        <caption>
          <title>Short-read polishing tool benchmarking results using 100 genomes with simulated Illumina reads.</title>
          <p>A: per-genome error rates after polishing with three consecutive rounds with a single tool. Mean qscores and error totals are shown at the top of the plot, and the horizontal lines indicate median error rates for each polisher. B: greedy polishing error totals. Each polisher was run on all 100 genomes, and whichever polisher produced the lowest total error count was used as the starting point for another round of polishing with all tools. Decreases in error totals are indicated with a blue box, increases with a red box and no change with a grey box. The lowest total error count for each round is indicated with bold type.</p>
        </caption>
        <graphic xlink:href="pcbi.1009802.g002" position="float"/>
      </fig>
      <p>To test ideal combinations of polishing tools, we combined them in an iterative greedy manner. We ran all polishing tools (excluding wtpoa) on all 100 genomes, and whichever output contained the lowest total number of errors was used as the input for the next round of polishing with each tool (<xref rid="pcbi.1009802.g002" ref-type="fig">Fig 2B</xref>). This approach achieved 237 total errors across the 100 genomes, less than one-tenth the total error count of any single tool. After seven rounds, 59 genomes had zero remaining errors, but as with single-tool polishing, most remaining errors were in repeat regions (<xref rid="pcbi.1009802.s005" ref-type="supplementary-material">S5 Fig</xref>). To assess the contribution of Polypolish to the greedy combination results, we performed the same approach with Polypolish excluded (<xref rid="pcbi.1009802.s006" ref-type="supplementary-material">S6 Fig</xref>). This resulted in a total error count of 1002 (more than 4× the error count of greedy polishing including Polypolish) and only 31 genomes had zero remaining errors.</p>
      <p>To assess each polisher’s likelihood of introducing errors, we quantified false positive changes (per-reference-base introduced errors) that occurred in the first round of polishing (<xref rid="pcbi.1009802.s007" ref-type="supplementary-material">S7 Fig</xref> and <xref rid="pcbi.1009802.s017" ref-type="supplementary-material">S3 Table</xref>). Polypolish achieved the lowest false positive rate (2 introduced errors across all 100 genomes), followed by POLCA (37 errors), HyPo (51 errors), NextPolish (102 errors), ntEdit (371 errors), Pilon (2760 errors), Racon (5161 errors) and wtpoa (8183772 errors). We also ran each polishing tool using the original reference genome as input to test their likelihood of introducing errors into an error-free assembly (<xref rid="pcbi.1009802.s008" ref-type="supplementary-material">S8 Fig</xref>). ntEdit, Pilon, POLCA and Polypolish produced error-free output for all 100 genomes. HyPo introduced an error into three of the genomes, and NextPolish introduced an error into one of the genomes. Racon and wtpoa introduced errors into all 100 genomes. The greedy polishing tests (<xref rid="pcbi.1009802.g002" ref-type="fig">Fig 2B</xref> and <xref rid="pcbi.1009802.s006" ref-type="supplementary-material">S6 Fig</xref>) also demonstrate each polisher’s likelihood of introducing errors: HyPo, NextPolish, Pilon and Racon sometimes increased the total error count, while ntEdit, POLCA and Polypolish never increased total errors.</p>
      <p>Hybrid polishing involves using both short and long reads to correct assembly errors. Only two tools, HyPo and Pilon, can perform true hybrid polishing, where both short and long reads are used in the same algorithm (NextPolish, Racon and wtpoa are capable of short-read polishing and long-read polishing but not both at the same time). We therefore tested HyPo and Pilon’s hybrid polishing with the simulated reads to compare their performance to short-read-only polishing with the same tools (<xref rid="pcbi.1009802.s009" ref-type="supplementary-material">S9 Fig</xref>). HyPo-hybrid performed better than HyPo-short (2827 vs 4696 remaining errors across the 100 test genomes after three rounds of polishing), but HyPo-hybrid was much more likely than HyPo-short to introduce errors into an error-free assembly (2550 vs 3 total added errors). Pilon-hybrid performed considerably worse than Pilon-short (231739 vs 4918 remaining errors after three rounds of polishing).</p>
      <p>We also used the simulated read sets to explore potential correlates of accuracy that can be calculated without a reference genome and could thus be used to assess genomes assembled using real read sets (<xref rid="pcbi.1009802.s018" ref-type="supplementary-material">S4 Table</xref>). The best overall reference-free predictor of reference-based accuracy was ALE score (<xref rid="pcbi.1009802.s010" ref-type="supplementary-material">S10 Fig</xref>), which is generated by the tool ALE [<xref rid="pcbi.1009802.ref018" ref-type="bibr">18</xref>] using short-read alignments to the assembly. ALE scores are calculated using the quality of read alignments, insert sizes inferred from read alignments, evenness of read depth and the assembly’s <italic toggle="yes">k</italic>-mer distribution. ALE scores do not provide an absolute metric of assembly quality but rather a relative metric which can be used to compare alternative assemblies of the same genome, with higher scores suggesting fewer errors.</p>
    </sec>
    <sec id="sec005">
      <title>Real-read tests</title>
      <p>As error-free reference genomes are not available for real read sets, we instead used six isolates for which we had four independent sets of matched Illumina and ONT reads for each isolate (<xref rid="pcbi.1009802.s011" ref-type="supplementary-material">S11(A) and S11(B) Fig</xref>): <italic toggle="yes">A. baumannii</italic> J9, <italic toggle="yes">C. koseri</italic> MINF_9D, <italic toggle="yes">E. kobei</italic> MSB1_1B, <italic toggle="yes">Haemophilus</italic> M1C132_1, <italic toggle="yes">K. oxytoca</italic> MSB1_2C and <italic toggle="yes">K. variicola</italic> INF345 [<xref rid="pcbi.1009802.ref019" ref-type="bibr">19</xref>]. For each isolate, we produced four long-read-only assemblies (one for each ONT read set) using Trycycler [<xref rid="pcbi.1009802.ref003" ref-type="bibr">3</xref>] and Medaka [<xref rid="pcbi.1009802.ref008" ref-type="bibr">8</xref>] (<xref rid="pcbi.1009802.s011" ref-type="supplementary-material">S11(C) Fig</xref>). We then polished each assembly with an independent set of Illumina data using each of the short-read polishing tools (<xref rid="pcbi.1009802.s011" ref-type="supplementary-material">S11(D) Fig</xref>). In the absence of a reference genome against which to directly count assembly errors (as was done for the simulated-read tests), we instead quantified accuracy using ALE scores and the total pairwise chromosomal distance between the four assemblies of each genome that were produced using independent read sets derived from the same isolate (<xref rid="pcbi.1009802.s011" ref-type="supplementary-material">S11(E) Fig</xref> and <xref rid="pcbi.1009802.s019" ref-type="supplementary-material">S5 Table</xref>). Lower pairwise distances imply more accurate assemblies, with a total distance of zero indicating that all four assemblies have identical chromosome sequences.</p>
      <p>As with the simulated-read tests, we tested each short-read polisher in isolation by running three consecutive rounds of polishing, as well as combining polishing tools in a greedy fashion (<xref rid="pcbi.1009802.s019" ref-type="supplementary-material">S5 Table</xref>). Polypolish performed best in the single-polisher tests and was the only polisher which reduced the total pairwise distance to less than 10 for all six isolates (<xref rid="pcbi.1009802.g003" ref-type="fig">Fig 3A</xref> and <xref rid="pcbi.1009802.s012" ref-type="supplementary-material">S12 Fig</xref>). Polypolish also achieved the highest mean ALE score for the real-read assemblies. The best results in the greedy combination tests came from one round of Polypolish followed by one round of POLCA (<xref rid="pcbi.1009802.g003" ref-type="fig">Fig 3B</xref>). This strategy reduced all genomes to zero total pairwise distance except for one of the four assemblies of <italic toggle="yes">A. baumannii</italic> J9, which had a single difference in a homopolymer in an IS<italic toggle="yes">Aba1</italic> sequence (a 6× repeat in this genome) [<xref rid="pcbi.1009802.ref020" ref-type="bibr">20</xref>]. Greedy polishing without Polypolish was only able to reduce a single genome to zero total pairwise distance (<xref rid="pcbi.1009802.s013" ref-type="supplementary-material">S13 Fig</xref> and <xref rid="pcbi.1009802.s019" ref-type="supplementary-material">S5 Table</xref>).</p>
      <fig position="float" id="pcbi.1009802.g003">
        <object-id pub-id-type="doi">10.1371/journal.pcbi.1009802.g003</object-id>
        <label>Fig 3</label>
        <caption>
          <title>Short-read polishing tool benchmarking results using six clusters of genomes with real ONT and Illumina reads.</title>
          <p>Each cluster contains 3–4 assemblies of the same genome made from independent read sets, each assembled and polished with independent ONT reads and then polished with matched Illumina reads. Instead of quantifying error rates directly (as was done with the simulated-read tests), accuracy is quantified as the sum of pairwise sequence distances within each cluster. A: per-cluster distances after polishing with three consecutive rounds with a single tool. Distance totals (lower is better) and mean ALE scores relative to the unpolished genomes (higher is better) are shown at the top of the plot. B: greedy polishing distance totals. Each polisher was run on all clusters, and whichever polisher produced the lowest total distance was used as the starting point for another round of polishing. Decreases in distance totals are indicated with a blue box, increases with a red box and no change with a grey box. The lowest total for each round is indicated with bold type.</p>
        </caption>
        <graphic xlink:href="pcbi.1009802.g003" position="float"/>
      </fig>
      <p>Some polishers performed poorly on just one or two isolates in the real-read tests, with different isolates yielding the greatest total pairwise distance for different polishers (see <xref rid="pcbi.1009802.g003" ref-type="fig">Fig 3A</xref> and detailed descriptions in <xref rid="pcbi.1009802.s019" ref-type="supplementary-material">S5 Table</xref>). Most notably, Pilon introduced large deletion errors into the <italic toggle="yes">K. oxytoca</italic> and <italic toggle="yes">K. variicola</italic> assemblies which did not always result in a decrease in the assembly’s ALE score (<xref rid="pcbi.1009802.s014" ref-type="supplementary-material">S14 Fig</xref>).</p>
    </sec>
  </sec>
  <sec sec-type="conclusions" id="sec006">
    <title>Discussion</title>
    <p>By taking all-per-read alignments as input, Polypolish was able to fix errors in long-read assemblies that other short-read polishers could not. This was particularly true for repetitive regions of the genome, where residual errors were most common. While Polypolish did well on its own, the best results came from combining polishers which use different algorithms. For many of our simulated-read tests, a combination of Polypolish with other polishers enabled perfect (zero-error) assemblies (<xref rid="pcbi.1009802.s005" ref-type="supplementary-material">S5 Fig</xref>).</p>
    <p>We found that some polishers could introduce errors into assemblies, for example, Pilon created large deletion errors in both <italic toggle="yes">Klebsiella</italic> genomes in our real-read tests. In most real-world scenarios, a ground truth reference genome is not available against which to compare an assembly, so it can be difficult to tell whether a polisher’s changes are fixing or introducing errors. We found that an assembly’s ALE score was a good proxy for its accuracy (<xref rid="pcbi.1009802.s018" ref-type="supplementary-material">S4 Table</xref> and <xref rid="pcbi.1009802.s010" ref-type="supplementary-material">S10 Fig</xref>), so researchers can run ALE before and after polishing, using the difference in ALE score to inform whether any changes are likely to be improvements. However, we did encounter cases where a decrease in assembly accuracy caused an increase in ALE score (<xref rid="pcbi.1009802.s014" ref-type="supplementary-material">S14 Fig</xref>). We therefore recommend using POLCA and Polypolish, the two polishers with the lowest false positive rates (<xref rid="pcbi.1009802.s007" ref-type="supplementary-material">S7 Fig</xref>) and the only two polishers which never made the error/distance totals increase in either our simulated-read or real-read greedy combination tests (Figs <xref rid="pcbi.1009802.g002" ref-type="fig">2B</xref> and <xref rid="pcbi.1009802.g003" ref-type="fig">3B</xref>, and <xref rid="pcbi.1009802.s006" ref-type="supplementary-material">S6</xref> and <xref rid="pcbi.1009802.s013" ref-type="supplementary-material">S13</xref> Figs).</p>
    <p>Since errors in repeats are the most challenging errors to fix in bacterial genomes, there are two strategies which can lead to higher quality assemblies. The first is to improve assembly accuracy before short-read polishing. Long reads are often longer than the repeats in a bacterial genome, so long-read assemblies do not generally yield a pronounced quality discrepancy between repeat and non-repeat sequences. Fewer overall errors in long-read assemblies should therefore mean fewer hard-to-fix errors in repeats. The second strategy is to employ repeat-aware short-read polishing strategies, as is done by Polypolish. We can therefore expect future improvements in long-read sequencing, long-read polishing and short-read polishing to all contribute to making bacterial genome assemblies reliably error-free.</p>
  </sec>
  <sec sec-type="materials|methods" id="sec007">
    <title>Materials and methods</title>
    <sec id="sec008">
      <title>Simulated-read tests</title>
      <p>To prepare the reference genomes for the simulated-read tests, we first downloaded all 120 prokaryote reference sequences included in NCBI’s curated subset of high-quality genomes of scientific importance (<ext-link xlink:href="https://ftp.ncbi.nlm.nih.gov/genomes/GENOME_REPORTS/prok_reference_genomes.txt" ext-link-type="uri">prok_reference_genomes.txt</ext-link>). Genomes with multiple chromosomes and those which had problems with long-read assembly (see below) were excluded, leaving 108 genomes. We then identified the eight pairs of genomes that were most closely related (as determined by Mash distance [<xref rid="pcbi.1009802.ref021" ref-type="bibr">21</xref>]) and excluded one genome from each pair, producing a set of 100 genomes with minimal redundancy (listed in <xref rid="pcbi.1009802.s015" ref-type="supplementary-material">S1 Table</xref>). We excluded plasmids from each genome, leaving only the chromosome, and any ambiguous DNA bases (e.g. <monospace>N</monospace>) were replaced with random unambiguous bases (<monospace>A</monospace>, <monospace>C</monospace>, <monospace>G</monospace> or <monospace>T</monospace>).</p>
      <p>For each genome, we simulated both long and short reads from the reference sequence. Long reads were simulated with Badread v0.2.0 [<xref rid="pcbi.1009802.ref022" ref-type="bibr">22</xref>] using the following parameters: 100× depth, 90% mean identity, 98% maximum identity, 4% identity stdev, 20 kbp mean read length, 12 kbp read length standard deviation, and all other parameters left at defaults. Paired-end short reads were simulated with ART v2016–06-05 [<xref rid="pcbi.1009802.ref023" ref-type="bibr">23</xref>] using the following parameters: 100× depth, HiSeqX TruSeq preset, 150 bp read length, 400 bp mean fragment length, 50 bp fragment length standard deviation, and all other parameters left at defaults. All simulated read sets are available in the manuscript’s data repository (<ext-link xlink:href="https://bridges.monash.edu/articles/dataset/Polypolish_paper_dataset/16727680" ext-link-type="uri">bridges.monash.edu/articles/dataset/Polypolish_paper_dataset/16727680</ext-link>).</p>
      <p>To identify repeat regions of each reference genome, we simulated deep (300×), error-free, 150 bp, unpaired reads using wgsim [<xref rid="pcbi.1009802.ref024" ref-type="bibr">24</xref>]. These reads were aligned to their reference genome with BWA-MEM v0.7.17 using the <monospace>-a</monospace> option (all alignments per read) [<xref rid="pcbi.1009802.ref016" ref-type="bibr">16</xref>]. We then used a custom script (<monospace>find_repetitive_regions.py</monospace>, available at <ext-link xlink:href="https://github.com/rrwick/Polypolish-paper" ext-link-type="uri">github.com/rrwick/Polypolish-paper</ext-link>) to parse these alignments and identify all regions of the genome where reads aligned to multiple places. I.e. we defined repetitive regions as those with high enough sequence identity to allow for cross-repeat alignment with BWA-MEM.</p>
      <p>To produce an unpolished sequence (an error-containing long-read assembly) for each genome, we first assembled the simulated long-read set using Flye v2.8.3 [<xref rid="pcbi.1009802.ref025" ref-type="bibr">25</xref>] and then adjusted the strand and starting position of the resulting contig to match the original reference sequence. The errors in the resulting contigs were mostly homopolymer deletions (a consequence of the Badread error profile), so we used a custom script (<monospace>add_errors.py</monospace>, available at <ext-link xlink:href="https://github.com/rrwick/Polypolish-paper" ext-link-type="uri">github.com/rrwick/Polypolish-paper</ext-link>) to add additional error types (homopolymer insertions, non-homopolymer indels and substitutions, each at a rate of 0.01%) to produce the unpolished genomes for the simulated-read tests. These sequences had identities ranging from 99.57% (Q23.7) to 99.94% (Q32.3), and their worst-100-bp identities (the minimum identity in a 100-bp sliding window across an alignment to the reference sequence) were all above 80%, indicating that none of the sequences suffered from large-scale structural errors.</p>
      <p>Polished genome sequences were generated by running the short-read polishers using default settings or (if provided) by following recommended commands in their documentation. Exact commands used are available in the wrapper scripts in the manuscript’s code repository (<ext-link xlink:href="https://github.com/rrwick/Polypolish-paper" ext-link-type="uri">github.com/rrwick/Polypolish-paper</ext-link>). For the single-tool tests, each polisher was run consecutively three times on each genome, using the polisher’s output assembly as input for the next round. Reference-polishing tests were conducted by running each polishing tool once using the error-free reference sequence as input. For the greedy combination tests, each polisher (excluding the hybrid polishers and wtpoa which performed poorly in the single-tool tests) was run once on each genome, and the best-performing polisher was defined as the one with the fewest total errors in its output assemblies. The best-performing polisher’s output was then used as input for another round of polishing. This process was repeated for a total of seven rounds, after which almost no changes occurred: only four of the 100 genomes changed in the fifth round and only one genome (NC_008596.1) changed in the sixth and seventh rounds. The greedy combination tests were then performed again with Polypolish excluded.</p>
      <p>Assembly accuracy was quantified using a custom script (<monospace>assess_assembly.py</monospace>, available at <ext-link xlink:href="https://github.com/rrwick/Polypolish-paper" ext-link-type="uri">github.com/rrwick/Polypolish-paper</ext-link>). This script uses the edlib [<xref rid="pcbi.1009802.ref026" ref-type="bibr">26</xref>] library to perform a global alignment of the assembly to the reference sequence. It reports an error count (the number of non-matching positions in the alignment) and identity (the number of matching positions divided by the length of the alignment). It further characterises errors based on their type (substitution, insertion or deletion) and whether they are in a repeat region of the genome. The script then generates other potential metrics of assembly quality using coding sequences and read alignments. It uses Prodigal [<xref rid="pcbi.1009802.ref027" ref-type="bibr">27</xref>] to identify potential coding sequences in the assembly (as indel errors are known to cause frame-shift mutations and premature stop codons), reporting the total number of predicted coding sequences, the total length of predicted coding sequences and the mean length of predicted coding sequences. It also uses ALE [<xref rid="pcbi.1009802.ref018" ref-type="bibr">18</xref>] to assess the quality of the assembly using short-read alignments (from BWA-MEM [<xref rid="pcbi.1009802.ref016" ref-type="bibr">16</xref>]), reporting the total mapping quality, total short-read alignment score, ALE score and ALE sub-scores (placement score, insert score, depth score and <italic toggle="yes">k</italic>-mer score).</p>
      <p>Confusion matrices (true positive, true negative, false positive and false negative counts across all 100 genomes) were generated for each polisher using a custom script (<monospace>confusion_matrix.py</monospace>, available at <ext-link xlink:href="https://github.com/rrwick/Polypolish-paper" ext-link-type="uri">github.com/rrwick/Polypolish-paper</ext-link>). This script generates a whole-genome multiple sequence alignment of the reference sequence, the unpolished sequence and the polished sequence (one polishing round) using Trycycler v0.5.0 [<xref rid="pcbi.1009802.ref003" ref-type="bibr">3</xref>]. It then categorises each position of the genome as a true positive (polisher fixed an error), true negative (polisher did not change a correct base), false negative (polisher failed to correct an error) or false positive (polisher introduced an error) (<xref rid="pcbi.1009802.s007" ref-type="supplementary-material">S7 Fig</xref>).</p>
      <p>We assessed potential reference-free metrics of assembly quality using all available data: single-tool results, reference-polishing results and greedy combination results. For each metric, we calculated a Kendall rank correlation coefficient for each genome (true assembly identity as determined by alignment to the reference vs the reference-free metric), and then took the mean of all 100 coefficients (one per genome) to get the metric’s overall correlation coefficient (<xref rid="pcbi.1009802.s018" ref-type="supplementary-material">S4 Table</xref>).</p>
    </sec>
    <sec id="sec009">
      <title>Real-read tests</title>
      <p>The six bacterial isolates used in the real-read tests each belong to a different species: <italic toggle="yes">Acinetobacter baumannii</italic>, <italic toggle="yes">Citrobacter koseri</italic>, <italic toggle="yes">Enterobacter kobei</italic>, an unnamed <italic toggle="yes">Haemophilus</italic> species (given the placeholder name <italic toggle="yes">Haemophilus sp002998595</italic> in GTDB R202 [<xref rid="pcbi.1009802.ref028" ref-type="bibr">28</xref>, <xref rid="pcbi.1009802.ref029" ref-type="bibr">29</xref>]), <italic toggle="yes">Klebsiella oxytoca</italic> and <italic toggle="yes">Klebsiella variicola</italic>. Sequencing was previously described in Wick et al. (2021) [<xref rid="pcbi.1009802.ref019" ref-type="bibr">19</xref>]. Briefly, isolates were cultured overnight at 37°C in Luria-Bertani broth and DNA was extracted using GenFind v3 according to the manufacturer’s instructions (Beckman Coulter). The same DNA extract was used to sequence each isolate using three different approaches: ONT ligation, ONT rapid and Illumina (<xref rid="pcbi.1009802.s011" ref-type="supplementary-material">S11(A) Fig</xref>). For ONT ligation, we followed the protocol for the SQK-LSK109 ligation sequencing kit and EXP-NBD104 native barcoding expansion (Oxford Nanopore Technologies). For ONT rapid, we followed the protocol for the SQK-RBK004 rapid barcoding kit (Oxford Nanopore Technologies). All ONT libraries were sequenced on MinION R9.4.1 flow cells. ONT read sets were basecalled and demultiplexed with Guppy v5.0.7, using the super-accuracy model. For Illumina, we followed a modified Illumina DNA Prep protocol (catalogue number 20018705), whereby the reaction volumes were quartered to conserve reagents. Illumina libraries were sequenced on the NovaSeq 6000 using SP reagent kits v1.0 (300 cycles, Illumina Inc.), producing 150 bp paired-end reads with a mean insert size of 331 bp. The resulting Illumina read pairs were shuffled and evenly split into two separate read sets, which were combined with the ONT read sets to produce two independent hybrid read sets (<xref rid="pcbi.1009802.s011" ref-type="supplementary-material">S11(B) Fig</xref>). We repeated this process (from culture to sequencing) to generate another two hybrid read sets for a total of four hybrid read sets per isolate. All reads are available in the manuscript’s data repository (<ext-link xlink:href="https://bridges.monash.edu/articles/dataset/Polypolish_paper_dataset/16727680" ext-link-type="uri">bridges.monash.edu/articles/dataset/Polypolish_paper_dataset/16727680</ext-link>).</p>
      <p>For each hybrid read set, we performed a long-read-only assembly using Trycycler v0.5.0 [<xref rid="pcbi.1009802.ref003" ref-type="bibr">3</xref>] and Medaka v1.4.3 [<xref rid="pcbi.1009802.ref008" ref-type="bibr">8</xref>], following the instructions in Trycycler’s documentation (<xref rid="pcbi.1009802.s011" ref-type="supplementary-material">S11(C) Fig</xref> and <xref rid="pcbi.1009802.s020" ref-type="supplementary-material">S6 Table</xref>). One of the ONT read sets for <italic toggle="yes">K. oxytoca</italic> MSB1_2C had very low depth (10×) and was therefore not able to yield a high-quality long-read-only assembly, leaving only three assemblies for this genome. We were able to produce four complete (circularised) long-read-only assemblies for the other five genomes, giving a total of 23 assemblies which served as the ‘unpolished’ assemblies in our real-read tests.</p>
      <p>Polished genome sequences were generated by running the short-read polishers as described above (<xref rid="pcbi.1009802.s011" ref-type="supplementary-material">S11(D) Fig</xref>). For the single-tool tests, each polisher was run consecutively three times on each assembly. For the greedy combination tests, each polisher (excluding the hybrid polishers and wtpoa which performed poorly in the single-tool tests) was run once on each genome, and the best-performing polisher was defined as the one with the smallest total pairwise distance in its output assemblies. The best-performing polisher’s output was then used as input for another round of polishing until there were no more improvements. The greedy combination tests were then performed again with Polypolish excluded.</p>
      <p>To assess the quality of real-read assemblies, we used the edlib [<xref rid="pcbi.1009802.ref026" ref-type="bibr">26</xref>] library to perform a global alignment of the chromosome sequences for all pairwise combinations within each genome (<xref rid="pcbi.1009802.s011" ref-type="supplementary-material">S11(E) Fig</xref>). The total distance was used as a metric of assembly quality, with lower values being better and a value of zero indicating that all assemblies for the genome were identical. We also ran ALE [<xref rid="pcbi.1009802.ref018" ref-type="bibr">18</xref>] on each real-read assembly using short-read alignments from BWA-MEM [<xref rid="pcbi.1009802.ref016" ref-type="bibr">16</xref>].</p>
    </sec>
  </sec>
  <sec id="sec010" sec-type="supplementary-material">
    <title>Supporting information</title>
    <supplementary-material id="pcbi.1009802.s001" position="float" content-type="local-data">
      <label>S1 Fig</label>
      <caption>
        <title>Illustrated steps of the Polypolish algorithm.</title>
        <p>(PDF)</p>
      </caption>
      <media xlink:href="pcbi.1009802.s001.pdf">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
    <supplementary-material id="pcbi.1009802.s002" position="float" content-type="local-data">
      <label>S2 Fig</label>
      <caption>
        <title>Alignment trimming in the Polypolish algorithm.</title>
        <p>(PDF)</p>
      </caption>
      <media xlink:href="pcbi.1009802.s002.pdf">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
    <supplementary-material id="pcbi.1009802.s003" position="float" content-type="local-data">
      <label>S3 Fig</label>
      <caption>
        <title>Fractional depth in the Polypolish algorithm.</title>
        <p>(PDF)</p>
      </caption>
      <media xlink:href="pcbi.1009802.s003.pdf">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
    <supplementary-material id="pcbi.1009802.s004" position="float" content-type="local-data">
      <label>S4 Fig</label>
      <caption>
        <title>Short-read polishing tool benchmarking results with simulated Illumina reads (detailed results).</title>
        <p>(PDF)</p>
      </caption>
      <media xlink:href="pcbi.1009802.s004.pdf">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
    <supplementary-material id="pcbi.1009802.s005" position="float" content-type="local-data">
      <label>S5 Fig</label>
      <caption>
        <title>Greedy combination per-genome error counts using simulated reads.</title>
        <p>(PDF)</p>
      </caption>
      <media xlink:href="pcbi.1009802.s005.pdf">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
    <supplementary-material id="pcbi.1009802.s006" position="float" content-type="local-data">
      <label>S6 Fig</label>
      <caption>
        <title>Greedy combination error totals excluding Polypolish using simulated reads.</title>
        <p>(PDF)</p>
      </caption>
      <media xlink:href="pcbi.1009802.s006.pdf">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
    <supplementary-material id="pcbi.1009802.s007" position="float" content-type="local-data">
      <label>S7 Fig</label>
      <caption>
        <title>Confusion matrices for single-round polishing using simulated reads.</title>
        <p>(PDF)</p>
      </caption>
      <media xlink:href="pcbi.1009802.s007.pdf">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
    <supplementary-material id="pcbi.1009802.s008" position="float" content-type="local-data">
      <label>S8 Fig</label>
      <caption>
        <title>Polishing error-free reference sequences using simulated reads.</title>
        <p>(PDF)</p>
      </caption>
      <media xlink:href="pcbi.1009802.s008.pdf">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
    <supplementary-material id="pcbi.1009802.s009" position="float" content-type="local-data">
      <label>S9 Fig</label>
      <caption>
        <title>Short-read vs hybrid polishing benchmarking results using simulated reads.</title>
        <p>(PDF)</p>
      </caption>
      <media xlink:href="pcbi.1009802.s009.pdf">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
    <supplementary-material id="pcbi.1009802.s010" position="float" content-type="local-data">
      <label>S10 Fig</label>
      <caption>
        <title>ALE score rank vs identity rank correlations for each of the 100 simulated-read genomes.</title>
        <p>(PDF)</p>
      </caption>
      <media xlink:href="pcbi.1009802.s010.pdf">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
    <supplementary-material id="pcbi.1009802.s011" position="float" content-type="local-data">
      <label>S11 Fig</label>
      <caption>
        <title>Sequencing, assembly and distance methods for the real-read tests.</title>
        <p>(PDF)</p>
      </caption>
      <media xlink:href="pcbi.1009802.s011.pdf">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
    <supplementary-material id="pcbi.1009802.s012" position="float" content-type="local-data">
      <label>S12 Fig</label>
      <caption>
        <title>Short-read polishing tool benchmarking results with real Illumina reads (detailed results).</title>
        <p>(PDF)</p>
      </caption>
      <media xlink:href="pcbi.1009802.s012.pdf">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
    <supplementary-material id="pcbi.1009802.s013" position="float" content-type="local-data">
      <label>S13 Fig</label>
      <caption>
        <title>Greedy combination error totals excluding Polypolish using real reads.</title>
        <p>(PDF)</p>
      </caption>
      <media xlink:href="pcbi.1009802.s013.pdf">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
    <supplementary-material id="pcbi.1009802.s014" position="float" content-type="local-data">
      <label>S14 Fig</label>
      <caption>
        <title>Illumina and ONT read alignments to assemblies of the <italic toggle="yes">K. oxytoca</italic> MSB1_2C read-set-A genome, before and after Pilon polishing.</title>
        <p>(PDF)</p>
      </caption>
      <media xlink:href="pcbi.1009802.s014.pdf">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
    <supplementary-material id="pcbi.1009802.s015" position="float" content-type="local-data">
      <label>S1 Table</label>
      <caption>
        <title>Genome details for the simulated-read tests.</title>
        <p>(XLSX)</p>
      </caption>
      <media xlink:href="pcbi.1009802.s015.xlsx">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
    <supplementary-material id="pcbi.1009802.s016" position="float" content-type="local-data">
      <label>S2 Table</label>
      <caption>
        <title>Raw results for the simulated-read tests.</title>
        <p>(TSV)</p>
      </caption>
      <media xlink:href="pcbi.1009802.s016.tsv">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
    <supplementary-material id="pcbi.1009802.s017" position="float" content-type="local-data">
      <label>S3 Table</label>
      <caption>
        <title>Confusion matrices for the simulated-read tests.</title>
        <p>(TSV)</p>
      </caption>
      <media xlink:href="pcbi.1009802.s017.tsv">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
    <supplementary-material id="pcbi.1009802.s018" position="float" content-type="local-data">
      <label>S4 Table</label>
      <caption>
        <title>Predictors of assembly quality.</title>
        <p>(XLSX)</p>
      </caption>
      <media xlink:href="pcbi.1009802.s018.xlsx">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
    <supplementary-material id="pcbi.1009802.s019" position="float" content-type="local-data">
      <label>S5 Table</label>
      <caption>
        <title>Raw results for the real-read tests.</title>
        <p>(XLSX)</p>
      </caption>
      <media xlink:href="pcbi.1009802.s019.xlsx">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
    <supplementary-material id="pcbi.1009802.s020" position="float" content-type="local-data">
      <label>S6 Table</label>
      <caption>
        <title>Assembly and polishing details for the real-read tests.</title>
        <p>(XLSX)</p>
      </caption>
      <media xlink:href="pcbi.1009802.s020.xlsx">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
  </sec>
</body>
<back>
  <ref-list>
    <title>References</title>
    <ref id="pcbi.1009802.ref001">
      <label>1</label>
      <mixed-citation publication-type="journal"><name><surname>Koren</surname><given-names>S</given-names></name>, <name><surname>Phillippy</surname><given-names>AM</given-names></name>. <source>One chromosome, one contig: complete microbial genomes from long-read sequencing and assembly</source>;<volume>23</volume>:<fpage>110</fpage>–<lpage>120</lpage>.</mixed-citation>
    </ref>
    <ref id="pcbi.1009802.ref002">
      <label>2</label>
      <mixed-citation publication-type="journal"><name><surname>Wick</surname><given-names>RR</given-names></name>, <name><surname>Holt</surname><given-names>KE</given-names></name>. <source>Benchmarking of long-read assemblers for prokaryote whole genome sequencing</source>;<volume>8</volume> (<issue>2138</issue>).</mixed-citation>
    </ref>
    <ref id="pcbi.1009802.ref003">
      <label>3</label>
      <mixed-citation publication-type="journal"><name><surname>Wick</surname><given-names>RR</given-names></name>, <name><surname>Judd</surname><given-names>LM</given-names></name>, <name><surname>Cerdeira</surname><given-names>LT</given-names></name>, <name><surname>Hawkey</surname><given-names>J</given-names></name>, <name><surname>Méric</surname><given-names>G</given-names></name>, <name><surname>Vezina</surname><given-names>B</given-names></name>, <etal>et al</etal>. <source>Trycycler: consensus long-read assemblies for bacterial genomes</source>;<volume>22</volume>(<issue>1</issue>):<fpage>266</fpage>.</mixed-citation>
    </ref>
    <ref id="pcbi.1009802.ref004">
      <label>4</label>
      <mixed-citation publication-type="journal"><name><surname>Watson</surname><given-names>M</given-names></name>, <name><surname>Warr</surname><given-names>A</given-names></name>. <source>Errors in long-read assemblies can critically affect protein prediction</source>;<volume>37</volume>(<issue>2</issue>):<fpage>124</fpage>–<lpage>126</lpage>.</mixed-citation>
    </ref>
    <ref id="pcbi.1009802.ref005">
      <label>5</label>
      <mixed-citation publication-type="journal"><name><surname>Jain</surname><given-names>M</given-names></name>, <name><surname>Koren</surname><given-names>S</given-names></name>, <name><surname>Miga</surname><given-names>KH</given-names></name>, <name><surname>Quick</surname><given-names>J</given-names></name>, <name><surname>Rand</surname><given-names>AC</given-names></name>, <name><surname>Sasani</surname><given-names>TA</given-names></name>, <etal>et al</etal>. <source>Nanopore sequencing and assembly of a human genome with ultra-long reads</source>;<volume>36</volume>(<issue>4</issue>):<fpage>338</fpage>–<lpage>345</lpage>.</mixed-citation>
    </ref>
    <ref id="pcbi.1009802.ref006">
      <label>6</label>
      <mixed-citation publication-type="journal"><name><surname>Wick</surname><given-names>RR</given-names></name>, <name><surname>Judd</surname><given-names>LM</given-names></name>, <name><surname>Gorrie</surname><given-names>CL</given-names></name>, <name><surname>Holt</surname><given-names>KE</given-names></name>. <source>Unicycler: Resolving bacterial genome assemblies from short and long sequencing reads</source>;<volume>13</volume>(<issue>6</issue>):<fpage>e1005595</fpage>.</mixed-citation>
    </ref>
    <ref id="pcbi.1009802.ref007">
      <label>7</label>
      <mixed-citation publication-type="journal"><name><surname>Zhang</surname><given-names>P</given-names></name>, <name><surname>Jiang</surname><given-names>D</given-names></name>, <name><surname>Wang</surname><given-names>Y</given-names></name>, <name><surname>Yao</surname><given-names>X</given-names></name>, <name><surname>Luo</surname><given-names>Y</given-names></name>, <name><surname>Yang</surname><given-names>Z</given-names></name>. <source>Comparison of <italic toggle="yes">De Novo</italic> Assembly Strategies for Bacterial Genomes</source>;<volume>22</volume>(<issue>14</issue>).</mixed-citation>
    </ref>
    <ref id="pcbi.1009802.ref008">
      <label>8</label>
      <mixed-citation publication-type="other">Wright C, Wykes M. Medaka;. Available from: <ext-link xlink:href="https://github.com/nanoporetech/medaka" ext-link-type="uri">https://github.com/nanoporetech/medaka</ext-link>.</mixed-citation>
    </ref>
    <ref id="pcbi.1009802.ref009">
      <label>9</label>
      <mixed-citation publication-type="journal"><name><surname>Kundu</surname><given-names>R</given-names></name>, <name><surname>Casey</surname><given-names>J</given-names></name>, <name><surname>Sung</surname><given-names>WK</given-names></name>. <source>HyPo: Super Fast &amp; Accurate Polisher for Long Read Genome Assemblies</source>; p. 2019.12.19.882506.</mixed-citation>
    </ref>
    <ref id="pcbi.1009802.ref010">
      <label>10</label>
      <mixed-citation publication-type="journal"><name><surname>Hu</surname><given-names>J</given-names></name>, <name><surname>Fan</surname><given-names>J</given-names></name>, <name><surname>Sun</surname><given-names>Z</given-names></name>, <name><surname>Liu</surname><given-names>S</given-names></name>. <source>NextPolish: a fast and efficient genome polishing tool for long-read assembly</source>;<volume>36</volume>(<issue>7</issue>):<fpage>2253</fpage>–<lpage>2255</lpage>.</mixed-citation>
    </ref>
    <ref id="pcbi.1009802.ref011">
      <label>11</label>
      <mixed-citation publication-type="journal"><name><surname>Warren</surname><given-names>RL</given-names></name>, <name><surname>Coombe</surname><given-names>L</given-names></name>, <name><surname>Mohamadi</surname><given-names>H</given-names></name>, <name><surname>Zhang</surname><given-names>J</given-names></name>, <name><surname>Jaquish</surname><given-names>B</given-names></name>, <name><surname>Isabel</surname><given-names>N</given-names></name>, <etal>et al</etal>. <source>ntEdit: scalable genome sequence polishing</source>;<volume>35</volume>(<issue>21</issue>):<fpage>4430</fpage>–<lpage>4432</lpage>.</mixed-citation>
    </ref>
    <ref id="pcbi.1009802.ref012">
      <label>12</label>
      <mixed-citation publication-type="journal"><name><surname>Walker</surname><given-names>BJ</given-names></name>, <name><surname>Abeel</surname><given-names>T</given-names></name>, <name><surname>Shea</surname><given-names>T</given-names></name>, <name><surname>Priest</surname><given-names>M</given-names></name>, <name><surname>Abouelliel</surname><given-names>A</given-names></name>, <name><surname>Sakthikumar</surname><given-names>S</given-names></name>, <etal>et al</etal>. <source>Pilon: An Integrated Tool for Comprehensive Microbial Variant Detection and Genome Assembly Improvement</source>;<volume>9</volume>(<issue>11</issue>):<fpage>e112963</fpage>.</mixed-citation>
    </ref>
    <ref id="pcbi.1009802.ref013">
      <label>13</label>
      <mixed-citation publication-type="journal"><name><surname>Zimin</surname><given-names>AV</given-names></name>, <name><surname>Salzberg</surname><given-names>SL</given-names></name>. <source>The genome polishing tool POLCA makes fast and accurate corrections in genome assemblies</source>;<volume>16</volume>(<issue>6</issue>):<fpage>e1007981</fpage>.</mixed-citation>
    </ref>
    <ref id="pcbi.1009802.ref014">
      <label>14</label>
      <mixed-citation publication-type="journal"><name><surname>Vaser</surname><given-names>R</given-names></name>, <name><surname>Sović</surname><given-names>I</given-names></name>, <name><surname>Nagarajan</surname><given-names>N</given-names></name>, <name><surname>Šikić</surname><given-names>M</given-names></name>. <source>Fast and accurate <italic toggle="yes">de novo</italic> genome assembly from long uncorrected reads</source>;<volume>27</volume>(<issue>5</issue>):<fpage>737</fpage>–<lpage>746</lpage>.</mixed-citation>
    </ref>
    <ref id="pcbi.1009802.ref015">
      <label>15</label>
      <mixed-citation publication-type="journal"><name><surname>Ruan</surname><given-names>J</given-names></name>, <name><surname>Li</surname><given-names>H</given-names></name>. <source>Fast and accurate long-read assembly with wtdbg2</source>;<volume>17</volume>(<issue>2</issue>):<fpage>155</fpage>–<lpage>158</lpage>.</mixed-citation>
    </ref>
    <ref id="pcbi.1009802.ref016">
      <label>16</label>
      <mixed-citation publication-type="journal"><name><surname>Li</surname><given-names>H</given-names></name>, <name><surname>Durbin</surname><given-names>R</given-names></name>. <source>Fast and accurate short read alignment with Burrows-Wheeler transform</source>;<volume>25</volume>(<issue>14</issue>):<fpage>1754</fpage>–<lpage>1760</lpage>.</mixed-citation>
    </ref>
    <ref id="pcbi.1009802.ref017">
      <label>17</label>
      <mixed-citation publication-type="journal"><name><surname>Langmead</surname><given-names>B</given-names></name>, <name><surname>Salzberg</surname><given-names>SL</given-names></name>. <source>Fast gapped-read alignment with Bowtie 2</source>;<volume>9</volume>(<issue>4</issue>):<fpage>357</fpage>–<lpage>359</lpage>.</mixed-citation>
    </ref>
    <ref id="pcbi.1009802.ref018">
      <label>18</label>
      <mixed-citation publication-type="journal"><name><surname>Clark</surname><given-names>SC</given-names></name>, <name><surname>Egan</surname><given-names>R</given-names></name>, <name><surname>Frazier</surname><given-names>PI</given-names></name>, <name><surname>Wang</surname><given-names>Z</given-names></name>. <source>ALE: a generic assembly likelihood evaluation framework for assessing the accuracy of genome and metagenome assemblies</source>;<volume>29</volume>(<issue>4</issue>):<fpage>435</fpage>–<lpage>443</lpage>.</mixed-citation>
    </ref>
    <ref id="pcbi.1009802.ref019">
      <label>19</label>
      <mixed-citation publication-type="journal"><name><surname>Wick</surname><given-names>RR</given-names></name>, <name><surname>Judd</surname><given-names>LM</given-names></name>, <name><surname>Wyres</surname><given-names>KL</given-names></name>, <name><surname>Holt</surname><given-names>KE</given-names></name>. <source>Recovery of small plasmid sequences via Oxford Nanopore sequencing</source>;<volume>7</volume>(<issue>8</issue>).</mixed-citation>
    </ref>
    <ref id="pcbi.1009802.ref020">
      <label>20</label>
      <mixed-citation publication-type="journal"><name><surname>Siguier</surname><given-names>P</given-names></name>, <name><surname>Perochon</surname><given-names>J</given-names></name>, <name><surname>Lestrade</surname><given-names>L</given-names></name>, <name><surname>Mahillon</surname><given-names>J</given-names></name>, <name><surname>Chandler</surname><given-names>M</given-names></name>. <source>ISfinder: the reference centre for bacterial insertion sequences</source>;<volume>34</volume>(<issue>suppl_1</issue>):<fpage>D32</fpage>–<lpage>D36</lpage>.</mixed-citation>
    </ref>
    <ref id="pcbi.1009802.ref021">
      <label>21</label>
      <mixed-citation publication-type="journal"><name><surname>Ondov</surname><given-names>BD</given-names></name>, <name><surname>Treangen</surname><given-names>TJ</given-names></name>, <name><surname>Melsted</surname><given-names>P</given-names></name>, <name><surname>Mallonee</surname><given-names>AB</given-names></name>, <name><surname>Bergman</surname><given-names>NH</given-names></name>, <name><surname>Koren</surname><given-names>S</given-names></name>, <etal>et al</etal>. <source>Mash: fast genome and metagenome distance estimation using MinHash</source>;<volume>17</volume>(<issue>1</issue>):<fpage>132</fpage>.</mixed-citation>
    </ref>
    <ref id="pcbi.1009802.ref022">
      <label>22</label>
      <mixed-citation publication-type="journal"><name><surname>Wick</surname><given-names>RR</given-names></name>. <source>Badread: simulation of error-prone long reads</source>;<volume>4</volume>(<issue>36</issue>):<fpage>1316</fpage>.</mixed-citation>
    </ref>
    <ref id="pcbi.1009802.ref023">
      <label>23</label>
      <mixed-citation publication-type="journal"><name><surname>Huang</surname><given-names>W</given-names></name>, <name><surname>Li</surname><given-names>L</given-names></name>, <name><surname>Myers</surname><given-names>JR</given-names></name>, <name><surname>Marth</surname><given-names>GT</given-names></name>. <source>ART: a next-generation sequencing read simulator</source>;<volume>28</volume>(<issue>4</issue>):<fpage>593</fpage>–<lpage>594</lpage>.</mixed-citation>
    </ref>
    <ref id="pcbi.1009802.ref024">
      <label>24</label>
      <mixed-citation publication-type="other">Li H. wgsim;. Available from: <ext-link xlink:href="https://github.com/lh3/wgsim" ext-link-type="uri">https://github.com/lh3/wgsim</ext-link>.</mixed-citation>
    </ref>
    <ref id="pcbi.1009802.ref025">
      <label>25</label>
      <mixed-citation publication-type="journal"><name><surname>Kolmogorov</surname><given-names>M</given-names></name>, <name><surname>Yuan</surname><given-names>J</given-names></name>, <name><surname>Lin</surname><given-names>Y</given-names></name>, <name><surname>Pevzner</surname><given-names>PA</given-names></name>. <source>Assembly of long, error-prone reads using repeat graphs</source>;<volume>37</volume>(<issue>5</issue>):<fpage>540</fpage>–<lpage>546</lpage>.</mixed-citation>
    </ref>
    <ref id="pcbi.1009802.ref026">
      <label>26</label>
      <mixed-citation publication-type="journal"><name><surname>Šošić</surname><given-names>M</given-names></name>, <name><surname>Šikić</surname><given-names>M</given-names></name>. <source>Edlib: a C/C++ library for fast, exact sequence alignment using edit distance</source>;<volume>33</volume>(<issue>9</issue>):<fpage>1394</fpage>–<lpage>1395</lpage>.</mixed-citation>
    </ref>
    <ref id="pcbi.1009802.ref027">
      <label>27</label>
      <mixed-citation publication-type="journal"><name><surname>Hyatt</surname><given-names>D</given-names></name>, <name><surname>Chen</surname><given-names>GL</given-names></name>, <name><surname>LoCascio</surname><given-names>PF</given-names></name>, <name><surname>Land</surname><given-names>ML</given-names></name>, <name><surname>Larimer</surname><given-names>FW</given-names></name>, <name><surname>Hauser</surname><given-names>LJ</given-names></name>. <source>Prodigal: prokaryotic gene recognition and translation initiation site identification</source>;<volume>11</volume>(<issue>1</issue>):<fpage>119</fpage>.</mixed-citation>
    </ref>
    <ref id="pcbi.1009802.ref028">
      <label>28</label>
      <mixed-citation publication-type="journal"><name><surname>Chaumeil</surname><given-names>PA</given-names></name>, <name><surname>Mussig</surname><given-names>AJ</given-names></name>, <name><surname>Hugenholtz</surname><given-names>P</given-names></name>, <name><surname>Parks</surname><given-names>DH</given-names></name>. <source>GTDB-Tk: a toolkit to classify genomes with the Genome Taxonomy Database</source>;<volume>36</volume>(<issue>6</issue>):<fpage>1925</fpage>–<lpage>1927</lpage>.</mixed-citation>
    </ref>
    <ref id="pcbi.1009802.ref029">
      <label>29</label>
      <mixed-citation publication-type="journal"><name><surname>Parks</surname><given-names>DH</given-names></name>, <name><surname>Chuvochina</surname><given-names>M</given-names></name>, <name><surname>Chaumeil</surname><given-names>PA</given-names></name>, <name><surname>Rinke</surname><given-names>C</given-names></name>, <name><surname>Mussig</surname><given-names>AJ</given-names></name>, <name><surname>Hugenholtz</surname><given-names>P</given-names></name>. <source>A complete domain-to-species taxonomy for Bacteria and Archaea</source>;<volume>38</volume>(<issue>9</issue>):<fpage>1079</fpage>–<lpage>1086</lpage>.</mixed-citation>
    </ref>
  </ref-list>
</back>
