<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.1 20151215//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 1.1?>
<?ConverterInfo.XSLTName jp2nlmx2.xsl?>
<?ConverterInfo.Version 1?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">7005598</article-id>
    <article-id pub-id-type="pmid">31504206</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/btz663</article-id>
    <article-id pub-id-type="publisher-id">btz663</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Original Papers</subject>
        <subj-group subj-group-type="category-toc-heading">
          <subject>Genome Analysis</subject>
        </subj-group>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Fast and accurate correction of optical mapping data via spaced seeds</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <contrib-id contrib-id-type="orcid" authenticated="false">http://orcid.org/0000-0002-0756-543X</contrib-id>
        <name>
          <surname>Salmela</surname>
          <given-names>Leena</given-names>
        </name>
        <xref ref-type="aff" rid="btz663-aff1">1</xref>
        <xref ref-type="corresp" rid="btz663-cor1"/>
        <!--<email>leena.salmela@cs.helsinki.fi</email>-->
      </contrib>
      <contrib contrib-type="author">
        <contrib-id contrib-id-type="orcid" authenticated="false">http://orcid.org/0000-0002-1647-8741</contrib-id>
        <name>
          <surname>Mukherjee</surname>
          <given-names>Kingshuk</given-names>
        </name>
        <xref ref-type="aff" rid="btz663-aff2">2</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Puglisi</surname>
          <given-names>Simon J</given-names>
        </name>
        <xref ref-type="aff" rid="btz663-aff1">1</xref>
      </contrib>
      <contrib contrib-type="author">
        <contrib-id contrib-id-type="orcid" authenticated="false">http://orcid.org/0000-0002-9283-0049</contrib-id>
        <name>
          <surname>Muggli</surname>
          <given-names>Martin D</given-names>
        </name>
        <xref ref-type="aff" rid="btz663-aff3">3</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Boucher</surname>
          <given-names>Christina</given-names>
        </name>
        <xref ref-type="aff" rid="btz663-aff2">2</xref>
        <xref ref-type="corresp" rid="btz663-cor1"/>
        <!--<email>cboucher@cise.ufl.edu</email>-->
      </contrib>
    </contrib-group>
    <contrib-group>
      <contrib contrib-type="editor">
        <name>
          <surname>Hancock</surname>
          <given-names>John</given-names>
        </name>
        <role>Associate Editor</role>
      </contrib>
    </contrib-group>
    <aff id="btz663-aff1"><label>1</label><institution>Department of Computer Science, Helsinki Institute for Information Technology HIIT</institution>, FI-00014 University of Helsinki, Helsinki 00100, Finland</aff>
    <aff id="btz663-aff2"><label>2</label><institution>Department of Computer and Information Science and Engineering</institution>, University of Florida, Gainesville, FL 32611, <country country="US">USA</country></aff>
    <aff id="btz663-aff3"><label>3</label><institution>Department of Computer Science, Colorado State University</institution>, Fort Collins, CO 80523, <country country="US">USA</country></aff>
    <author-notes>
      <corresp id="btz663-cor1">To whom correspondence should be addressed. <email>leena.salmela@cs.helsinki.fi</email> or <email>cboucher@cise.ufl.edu</email></corresp>
    </author-notes>
    <pub-date pub-type="ppub">
      <day>01</day>
      <month>2</month>
      <year>2020</year>
    </pub-date>
    <pub-date pub-type="epub" iso-8601-date="2019-09-03">
      <day>03</day>
      <month>9</month>
      <year>2019</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>03</day>
      <month>9</month>
      <year>2019</year>
    </pub-date>
    <!-- PMC Release delay is 0 months and 0 days and was based on the <pub-date pub-type="epub"/>. -->
    <volume>36</volume>
    <issue>3</issue>
    <fpage>682</fpage>
    <lpage>689</lpage>
    <history>
      <date date-type="received">
        <day>10</day>
        <month>4</month>
        <year>2019</year>
      </date>
      <date date-type="rev-recd">
        <day>25</day>
        <month>7</month>
        <year>2019</year>
      </date>
      <date date-type="accepted">
        <day>30</day>
        <month>8</month>
        <year>2019</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© The Author(s) 2019. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2019</copyright-year>
      <license license-type="cc-by" xlink:href="http://creativecommons.org/licenses/by/4.0/">
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</ext-link>), which permits unrestricted reuse, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="btz663.pdf"/>
    <abstract>
      <title>Abstract</title>
      <sec id="s1">
        <title>Motivation</title>
        <p>Optical mapping data is used in many core genomics applications, including structural variation detection, scaffolding assembled contigs and mis-assembly detection. However, the pervasiveness of spurious and deleted cut sites in the raw data, which are called Rmaps, make assembly and alignment of them challenging. Although there exists another method to error correct Rmap data, named cOMet, it is unable to scale to even moderately large sized genomes. The challenge faced in error correction is in determining pairs of Rmaps that originate from the same region of the same genome.</p>
      </sec>
      <sec id="s2">
        <title>Results</title>
        <p>We create an efficient method for determining pairs of Rmaps that contain significant overlaps between them. Our method relies on the novel and nontrivial adaption and application of spaced seeds in the context of optical mapping, which allows for spurious and deleted cut sites to be accounted for. We apply our method to detecting and correcting these errors. The resulting error correction method, referred to as <sc>Elmeri</sc>, improves upon the results of state-of-the-art correction methods but in a fraction of the time. More specifically, cOMet required 9.9 CPU days to error correct Rmap data generated from the human genome, whereas <sc>Elmeri</sc> required less than 15 CPU hours and improved the quality of the Rmaps by more than four times compared to cOMet.</p>
      </sec>
      <sec id="s3">
        <title>Availability and implementation</title>
        <p><sc>Elmeri</sc> is publicly available under GNU Affero General Public License at <ext-link ext-link-type="uri" xlink:href="https://github.com/LeenaSalmela/Elmeri">https://github.com/LeenaSalmela/Elmeri</ext-link>.</p>
      </sec>
      <sec id="s4">
        <title>Supplementary information</title>
        <p><xref ref-type="supplementary-material" rid="sup1">Supplementary data</xref> are available at <italic>Bioinformatics</italic> online.</p>
      </sec>
    </abstract>
    <funding-group>
      <award-group award-type="grant">
        <funding-source>
          <named-content content-type="funder-name">Academy of Finland</named-content>
          <named-content content-type="funder-identifier">10.13039/501100002341</named-content>
        </funding-source>
        <award-id>308030</award-id>
        <award-id>314170</award-id>
        <award-id>294143</award-id>
        <award-id>319454</award-id>
      </award-group>
      <award-group award-type="grant">
        <funding-source>
          <named-content content-type="funder-name">National Science Foundation</named-content>
          <named-content content-type="funder-identifier">10.13039/100000001</named-content>
        </funding-source>
        <award-id>1618814</award-id>
      </award-group>
    </funding-group>
    <counts>
      <page-count count="8"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec>
    <title>1 Introduction</title>
    <p>Optical mapping is a process in which DNA is first isolated, denaturated and fragmented, restriction enzymes are then applied to the fragmented DNA to further cut it at prescribed restriction sites, before finally the resulting DNA is imaged to capture the relative order and size of the fragments between the cut sites (<xref rid="btz663-B9" ref-type="bibr">Dimalanta <italic>et al.</italic>, 2004</xref>; <xref rid="btz663-B31" ref-type="bibr">Samad <italic>et al.</italic>, 1995</xref>). The ordered lists of fragment sizes are the result of this process and are referred to as <italic>Rmaps</italic>. Rmaps are analogous to sequence reads in the context of genome sequencing, and, as with genome sequencing, the optical mapping process is repeated for all DNA molecules in a single sample. This leads to there being overlap between pairs of Rmaps, which are then used to error correct or assemble the set of Rmaps produced by a single experiment. Rmap data spans genomic regions that are significantly longer than short read sequence data—200 kbp versus 250 bp—but cheaper than long read data, making it a viable option to reference-based assembly (<xref rid="btz663-B20" ref-type="bibr">Lin <italic>et al.</italic>, 1999</xref>), identification of mis-assembled regions in draft genomes (<xref rid="btz663-B26" ref-type="bibr">Muggli <italic>et al.</italic>, 2015</xref>), structural variation detection (<xref rid="btz663-B33" ref-type="bibr">Teague <italic>et al.</italic>, 2010</xref>) and <italic>de novo</italic> assembly of large genomes (<xref rid="btz663-B2" ref-type="bibr">Beier <italic>et al.</italic>, 2017</xref>; <xref rid="btz663-B8" ref-type="bibr">Daccord <italic>et al.</italic>, 2017</xref>; <xref rid="btz663-B10" ref-type="bibr">Dong <italic>et al.</italic>, 2013</xref>; <xref rid="btz663-B12" ref-type="bibr">Ganapathy <italic>et al.</italic>, 2014</xref>; <xref rid="btz663-B14" ref-type="bibr">Jarvis <italic>et al.</italic>, 2017</xref>; <xref rid="btz663-B36" ref-type="bibr">Vij <italic>et al.</italic>, 2016</xref>).</p>
    <p>Due to the fragile nature of the DNA and the inexactness of restriction enzymes, Rmaps are prone to having added or deleted cut sites. When Rmaps are viewed as a sequence of fragment sizes, added and deleted cut sites merge or split fragments and thus appear as insertions and deletions. In addition, the measurement of the fragment is error prone and likely to differ from the true length of the DNA fragment. These errors make finding pairs of overlapping Rmaps challenging.</p>
    <p>Previous approaches, such as our earlier Rmap error correction method cOMet (<xref rid="btz663-B27" ref-type="bibr">Mukherjee <italic>et al.</italic>, 2018</xref>), use <italic>k</italic>-mers as seeds to detect whether two Rmaps have significant overlap. More specifically, as Rmaps are sequences of fragment lengths, <italic>k</italic>-mers are defined as <italic>k</italic> consecutive fragment lengths observed in an Rmap. Thus, these tools compare all <italic>k</italic>-length subsequences of one Rmap with every other Rmap to find those that have a significant number in common; those that do are deemed to have significant alignments. Due to the presence of errors in the Rmaps, <italic>k</italic> has to be very small (less than 5 where the average Rmap length is 20 fragments long), resulting in a method that has high sensitivity but low specificity. Extra filtering has to be done in order to increase the specificity at the expense of running time.</p>
    <p>In this paper, we view Rmaps as line segments, where cut sites are points on that line. In this representation added and deleted cut sites behave like mismatches as the cut site is either present or not on the line segment. Furthermore, this representation offers another natural way of extending the notion of <italic>k</italic>-mers to optical mapping. Instead of using <italic>k</italic> consecutive fragments as a seed, we can use a fixed length subsegment of the line as a seed. Here, we call these seeds <italic>ℓ</italic>-mers. We further extend this definition to (<italic>ℓ</italic>, <italic>k</italic>)-mers which require the seeds to have at least <italic>k</italic> fragments and spaced (<italic>ℓ</italic>, <italic>k</italic>)-mers, which allow for gaps in the seeds that account for the mismatches caused by added and deleted cut sites.</p>
    <p>The concept of spaced (<italic>ℓ</italic>, <italic>k</italic>)-mers is used for error correction of Rmap data. Our previous method, referred to as cOMet (<xref rid="btz663-B27" ref-type="bibr">Mukherjee <italic>et al.</italic>, 2018</xref>), is currently the only available method for error correction of Rmap data. It can correct a large number of added and deleted cut sites but requires almost 10 CPU days to error correct Rmap data from the human genome. Thus, for even moderately large sized genomes, high performance computing resources are needed. In this paper, we give an error correction algorithm that is based on spaced (<italic>ℓ</italic>, <italic>k</italic>)-mers. We refer to our method as <sc>Elmeri</sc>, and demonstrate that it is 16 times faster than cOMet (<xref rid="btz663-B27" ref-type="bibr">Mukherjee <italic>et al.</italic>, 2018</xref>) on the human data. In addition, <sc>Elmeri</sc> gives better quality results. We aligned the original (uncorrected) data, the data corrected by cOMet and the data corrected by <sc>Elmeri</sc> to the error-free reference genome wide optical map and found that the mean improvement on alignment scores of Rmaps corrected by <sc>Elmeri</sc> is more than four times that of cOMet.</p>
    <p>Lastly, we mention that the concept of spaced (<italic>ℓ</italic>, <italic>k</italic>)-mers may be of interest in other applications of optical mapping data such as alignment of Rmaps and assembly of Rmaps into genome wide optical maps where similar Rmaps need to be found. Our experiments show that spaced (<italic>ℓ</italic>, <italic>k</italic>)-mers can have more than double recall with a similar precision as compared to <italic>k</italic>-mers in identifying similar Rmaps.</p>
  </sec>
  <sec>
    <title>2 Related work</title>
    <sec>
      <title>2.1 Algorithms for optical maps</title>
      <p>Several methods have been developed to analyze optical mapping data—either alone or in conjunction with sequence data. The most closely related work to the one presented in this paper is our previous method for error correction of Rmap data (<xref rid="btz663-B27" ref-type="bibr">Mukherjee <italic>et al.</italic>, 2018</xref>), which we discussed in the introduction. AGORA (<xref rid="btz663-B19" ref-type="bibr">Lin <italic>et al.</italic>, 2012</xref>) and misSEQuel (<xref rid="btz663-B26" ref-type="bibr">Muggli <italic>et al.</italic>, 2015</xref>) aim at using optical mapping data to help in determining or preventing mis-assembled contigs. AGORA performs sequence assembly guided by optical maps by comparing <italic>in silico</italic> digested contigs (which correspond to a path in the de Bruijn graph) to the optical map. If the paths do not agree then the path is discarded as incorrect. misSEQuel (<xref rid="btz663-B26" ref-type="bibr">Muggli <italic>et al.</italic>, 2015</xref>) assembles sequence data, aligns <italic>in silico</italic> digested contigs to optical maps using Twin (<xref rid="btz663-B24" ref-type="bibr">Muggli <italic>et al.</italic>, 2014</xref>) and then deciphers which contigs are misassembled based on the alignment. Most-recently <xref rid="btz663-B30" ref-type="bibr">Pan <italic>et al.</italic> (2019)</xref> presented OMGS, which is an optical mapping based genome scaffolder.</p>
      <p>Both <xref rid="btz663-B34" ref-type="bibr">Valouev <italic>et al.</italic> (2006a</xref>) and <xref rid="btz663-B28" ref-type="bibr">Nagarajan <italic>et al.</italic> (2008)</xref> use dynamic programming to compute the best alignment between pairs of optical mapping sequences, where these sequences can be Rmaps and/or genome wide optical maps. Valouev <italic>et al.</italic> computes the best alignment using a dynamic programming based scoring scheme similar to the Needleman–Wunsch algorithm (<xref rid="btz663-B29" ref-type="bibr">Needleman and Wunsch, 1970</xref>). Their scoring function is defined as a log likelihood ratio test that takes into account the various errors prevalent in the optical map data. SOMA (<xref rid="btz663-B28" ref-type="bibr">Nagarajan <italic>et al.</italic>, 2008</xref>) aligns assembled contigs to a genome-wide optical map using a dynamic programming algorithm that is optimized by using a different scoring function that imposes a fixed cost penalty on added and deleted cut sites, and a chi-squared function to penalize for sizing errors.</p>
      <p>In the past several years, new data structures and algorithms have been applied to optical map alignment to create Twin (<xref rid="btz663-B26" ref-type="bibr">Muggli <italic>et al.</italic>, 2015</xref>), OMBlast (<xref rid="btz663-B16" ref-type="bibr">Leung <italic>et al.</italic>, 2017</xref>), Maligner (<xref rid="btz663-B22" ref-type="bibr">Mendelowitz <italic>et al.</italic>, 2016</xref>) and Kohdista (<xref rid="btz663-B25" ref-type="bibr">Muggli <italic>et al.</italic>, 2018</xref>). OMBlast modifies the seed-and-extend approach used in BLAST (<xref rid="btz663-B1" ref-type="bibr">Altschul <italic>et al.</italic>, 1990</xref>) for finding alignments in optical mapping data. Maligner provides two modes of alignment: an efficient, sensitive dynamic programming implementation that scales to large eukaryotic genomes, and a faster index based implementation for finding alignments with unmatched sites in the reference but not the query. Twin (<xref rid="btz663-B24" ref-type="bibr">Muggli <italic>et al.</italic>, 2014</xref>) uses an FM-index for aligning contigs to a genome-wide optical map. The FM-index search is modified to allow sizing errors but Twin is unable to account for added and deleted cut sites. Kohdista (<xref rid="btz663-B25" ref-type="bibr">Muggli <italic>et al.</italic>, 2018</xref>) formulates the alignment problem as automaton path searching and thus tolerates both sizing errors and added and deleted cut sites.</p>
    </sec>
    <sec>
      <title>2.2 Seeds and spaced seeds</title>
      <p>Homology search algorithms, such as BLAST (<xref rid="btz663-B1" ref-type="bibr">Altschul <italic>et al.</italic>, 1990</xref>) pervade bioinformatics. Initially, determining whether two sequences were homologous or not was based on pairwise alignment of the two sequences using dynamic programming algorithms with quadratic time complexity. Yet, computing the alignment between pairs of sequences is infeasible with large sequence sets as the number of sequence pairs also increases quadratically. Computing and comparing a set of seeds remedied this problem. The main idea is that homologous sequences have well-conserved regions which are very similar in all sequences and thus, identical seeds can be found in these regions. For example BLAST (<xref rid="btz663-B1" ref-type="bibr">Altschul <italic>et al.</italic>, 1990</xref>) uses exact matches of <italic>k</italic>-length sequences as ‘seeds’ and extends the seed matches to longer alignments containing them.</p>
      <p>The introduction and application of spaced seeds represented another major advance in homology search (<xref rid="btz663-B5" ref-type="bibr">Burkhardt and Kärkkäinen, 2003</xref>; <xref rid="btz663-B7" ref-type="bibr">Choi <italic>et al.</italic>, 2004</xref>; <xref rid="btz663-B13" ref-type="bibr">Ilie and Ilie, 2007</xref>; <xref rid="btz663-B21" ref-type="bibr">Ma <italic>et al.</italic>, 2002</xref>). Spaced seeds extend the idea of an exact seed: a spaced seed is <italic>k</italic> discontinuous nucleotide matches, where there exists a preset number of wildcard positions that match any nucleotide (<xref rid="btz663-B15" ref-type="bibr">Keich <italic>et al.</italic>, 2004</xref>). PatternHunter (<xref rid="btz663-B21" ref-type="bibr">Ma <italic>et al.</italic>, 2002</xref>) introduced the concept of <italic>optimized spaced seed</italic>, where the relative positions of the <italic>k</italic> nucleotides are optimized in advance. This extension allowed PatternHunter to significantly increase its sensitivity over BLAST. Independently, <xref rid="btz663-B4" ref-type="bibr">Buhler <italic>et al.</italic> (2005)</xref>, <xref rid="btz663-B21" ref-type="bibr">Ma <italic>et al.</italic> (2002)</xref> and <xref rid="btz663-B3" ref-type="bibr">Brejová <italic>et al.</italic> (2003)</xref> noticed that increasing the number of spaced seeds will increase sensitivity. In practice, this concept of comparing seeds has been shown to have high sensitivity and specificity for homology search even when the spaced seeds are not optimized (<xref rid="btz663-B18" ref-type="bibr">Li <italic>et al.</italic>, 2004</xref>; <xref rid="btz663-B21" ref-type="bibr">Ma <italic>et al.</italic>, 2002</xref>).</p>
      <p>Spaced seeds are not confounded by mismatches and thus, are effective when there exist regions that are well-conserved and uninterrupted by insertions or deletions (<italic>indels</italic>). However, when the frequency of indels increases, the length of the seed or the number of common seeds becomes low enough that it is no longer effective for sensitive and specific detection of alignment, which has been witnessed in long read alignment (<xref rid="btz663-B6" ref-type="bibr">Chaisson and Tesler, 2012</xref>).</p>
    </sec>
  </sec>
  <sec>
    <title>3 Background and definitions</title>
    <sec>
      <title>3.1 Rmaps and optical mapping</title>
      <p>From a computational perspective, optical mapping takes in a DNA sequence and a restriction enzyme that cuts the DNA at a unique restriction site, and returns a sequence (or array) of fragment sizes R, i.e. where <inline-formula id="IE15"><mml:math id="IM1"><mml:mrow><mml:mi>R</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> is the number of nucleotides between the <inline-formula id="IE16"><mml:math id="IM2"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>th and <italic>i</italic>th cut site. Analogous to short read sequencing, the method is commonly applied to multiple DNA molecules from the same individual. The result is millions of fragmented DNA molecules that overlap. The raw data resulting from the process is referred to as <italic>Rmaps</italic>—whose analogue are sequence reads in the context of genome sequencing.</p>
      <p>We denote an Rmap R as <inline-formula id="IE17"><mml:math id="IM3"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mi>n</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>. We refer to the <italic>size</italic> of R as the number of fragments, i.e. <italic>n</italic> is the size of <italic>R</italic>, and the <italic>length</italic> of R as <inline-formula id="IE18"><mml:math id="IM4"><mml:mrow><mml:mo>|</mml:mo><mml:mi>R</mml:mi><mml:mo>|</mml:mo><mml:mo>=</mml:mo><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:msubsup><mml:mrow><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>. For example, given a DNA sequence <monospace>CGCGTCGCGAATATCGCGTTAATAATAACGCGACGCG</monospace> and a restriction site sequence CGCG, the corresponding Rmap is <inline-formula id="IE19"><mml:math id="IM5"><mml:mrow><mml:mi>R</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mn>5</mml:mn><mml:mo>,</mml:mo><mml:mn>9</mml:mn><mml:mo>,</mml:mo><mml:mn>14</mml:mn><mml:mo>,</mml:mo><mml:mn>5</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> assuming that the restriction enzyme cuts between the center G and C in the restriction site.</p>
      <p>Equivalently R can be viewed as a sequence of cut site locations in the DNA. More formally, optical mapping takes in a DNA sequence <inline-formula id="IE20"><mml:math id="IM6"><mml:mrow><mml:mi>A</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mn>1..</mml:mn><mml:mi>a</mml:mi></mml:mrow></mml:math></inline-formula>] and a restriction sequence <inline-formula id="IE21"><mml:math id="IM7"><mml:mrow><mml:mi>B</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mn>1..</mml:mn><mml:mi>b</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>, and produces an array (string) of integers <inline-formula id="IE22"><mml:math id="IM8"><mml:mrow><mml:mi>C</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>, such that <inline-formula id="IE23"><mml:math id="IM9"><mml:mrow><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi>j</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> if and only if the substring <inline-formula id="IE24"><mml:math id="IM10"><mml:mrow><mml:mi>A</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mn>..</mml:mn><mml:mi>j</mml:mi><mml:mo>+</mml:mo><mml:mi>b</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mi>B</mml:mi></mml:mrow></mml:math></inline-formula> is the <italic>i</italic>th occurrence of B in A. Without loss of generality we assume that <inline-formula id="IE25"><mml:math id="IM11"><mml:mrow><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula> i.e. the first cut site occurs at <inline-formula id="IE26"><mml:math id="IM12"><mml:mrow><mml:mi>A</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mn>1…</mml:mn><mml:mi>b</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>. This definition of Rmaps allows us to visualize an Rmap as a line segment from 0 to <inline-formula id="IE27"><mml:math id="IM13"><mml:mrow><mml:mo>|</mml:mo><mml:mi>R</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula> where each cut site <italic>c<sub>i</sub></italic> is a point on the line. We note that <inline-formula id="IE28"><mml:math id="IM14"><mml:mrow><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE29"><mml:math id="IM15"><mml:mrow><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mrow><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>. It will be more natural to describe some of further definitions using this <italic>cut site representation</italic> rather than the former <italic>fragment size representation</italic>. For our running example <inline-formula id="IE30"><mml:math id="IM16"><mml:mrow><mml:mi>R</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mn>5</mml:mn><mml:mo>,</mml:mo><mml:mn>9</mml:mn><mml:mo>,</mml:mo><mml:mn>14</mml:mn><mml:mo>,</mml:mo><mml:mn>5</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>, the corresponding cut site representation is <inline-formula id="IE31"><mml:math id="IM17"><mml:mrow><mml:mi>C</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>5</mml:mn><mml:mo>,</mml:mo><mml:mn>14</mml:mn><mml:mo>,</mml:mo><mml:mn>28</mml:mn><mml:mo>,</mml:mo><mml:mn>33</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>. <xref ref-type="fig" rid="btz663-F1">Figure 1</xref> illustrates the two representations. We will prompt the reader when we use the cut site representation; otherwise, it can be assumed that we will use the fragment size representation.
</p>
      <fig id="btz663-F1" orientation="portrait" position="float">
        <label>Fig. 1.</label>
        <caption>
          <p>The cut site representation (above) and the fragment length representation (below)</p>
        </caption>
        <graphic xlink:href="btz663f1"/>
      </fig>
      <p>Here, for simplicity, we have used small examples and integer values for the fragment sizes. In practice fragment sizes are given in 1000 bp (1 kbp) and real numbers. For example, on the real human Bionano dataset (<xref rid="btz663-B32" ref-type="bibr">Shi <italic>et al.</italic>, 2016</xref>) cut sites occur once every 10 kbp and the average Rmap covers 200 kbp. Also, we note that in practice high-throughput optical mapping technologies (e.g. Bionano) use enzymes that nick the DNA rather than cutting it to decrease the error rate of the resulting data.</p>
      <p>Nonetheless, Rmaps are highly error prone— the majority of errors are characterized as one of the following three types: (i) sizing error, (ii) deleted cut sites and (iii) added cut sites. Sizing error occurs from inability of estimating the size of the fragments exactly. For example, if 10 bp exists between two cut sites, the optical mapping process may output the size to be 12 bp, resulting in a 2 bp error in the size of the fragment. Secondly, restriction enzymes can end up deleting a cut site, which results in the two neighboring fragments being merged into one. In the above example, if the enzyme misses the second cut site, the resulting Rmap would be <inline-formula id="IE32"><mml:math id="IM18"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mn>14</mml:mn><mml:mo>,</mml:mo><mml:mn>14</mml:mn><mml:mo>,</mml:mo><mml:mn>5</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>. Lastly, due to the fragile nature of DNA, the DNA molecule can break spontaneously at a location where a restriction site is not present. This causes a fragment to be split into two. For example, the third fragment in our example could be split into two fragments, 8 and 6, resulting in the Rmap <inline-formula id="IE33"><mml:math id="IM19"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mn>5</mml:mn><mml:mo>,</mml:mo><mml:mn>9</mml:mn><mml:mo>,</mml:mo><mml:mn>6</mml:mn><mml:mo>,</mml:mo><mml:mn>8</mml:mn><mml:mo>,</mml:mo><mml:mn>5</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
    </sec>
    <sec>
      <title>3.2 <italic>k</italic>-mers, <italic>ℓ</italic>-mers and spaced (<italic>ℓ</italic>, <italic>k</italic>)-mers</title>
      <p>A <italic>k</italic>-mer of an Rmap R is a <italic>k</italic>-length subsequence of fragment sizes of R. For example, given an Rmap <inline-formula id="IE34"><mml:math id="IM20"><mml:mrow><mml:mi>R</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mn>4</mml:mn><mml:mo>,</mml:mo><mml:mn>28</mml:mn><mml:mo>,</mml:mo><mml:mn>10</mml:mn><mml:mo>,</mml:mo><mml:mn>6</mml:mn><mml:mo>,</mml:mo><mml:mn>9</mml:mn><mml:mo>,</mml:mo><mml:mn>3</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> and <italic>k </italic>=<italic> </italic>4, three <italic>k</italic>-mers, <inline-formula id="IE35"><mml:math id="IM21"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mn>4</mml:mn><mml:mo>,</mml:mo><mml:mn>28</mml:mn><mml:mo>,</mml:mo><mml:mn>10</mml:mn><mml:mo>,</mml:mo><mml:mn>6</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mn>28</mml:mn><mml:mo>,</mml:mo><mml:mn>10</mml:mn><mml:mo>,</mml:mo><mml:mn>6</mml:mn><mml:mo>,</mml:mo><mml:mn>9</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE36"><mml:math id="IM22"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mn>10</mml:mn><mml:mo>,</mml:mo><mml:mn>6</mml:mn><mml:mo>,</mml:mo><mml:mn>9</mml:mn><mml:mo>,</mml:mo><mml:mn>3</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>, can be extracted from R as shown in <xref ref-type="fig" rid="btz663-F2">Figure 2a</xref>.
</p>
      <p>For simplicity of explanation, we consider the cut site representation of an Rmap in this subsection. We define an <italic>ℓ</italic>-mer as a sequence of all cut sites of C contained within an interval <inline-formula id="IE41"><mml:math id="IM23"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mi>p</mml:mi><mml:mo>,</mml:mo><mml:mi>p</mml:mi><mml:mo>+</mml:mo><mml:mi>ℓ</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> for some <inline-formula id="IE42"><mml:math id="IM24"><mml:mrow><mml:mn>0</mml:mn><mml:mo>≤</mml:mo><mml:mi>p</mml:mi><mml:mo>≤</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:mi>ℓ</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>. From a more intuitive perspective, if we illustrate an Rmap as a line segment starting at 0 and ending at position <inline-formula id="IE43"><mml:math id="IM25"><mml:mrow><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mo>|</mml:mo><mml:mi>R</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula> where the cut sites are points on that line segment, then an <italic>ℓ</italic>-mer corresponds to any consecutive sequence of elements of C such that they can be fully contained within an <italic>ℓ</italic>-length subsegment and all cut sites within the <italic>ℓ</italic>-length subsegment are included. This is illustrated in <xref ref-type="fig" rid="btz663-F2">Figure 2b</xref>. In our method we use the fragment size representation of <italic>ℓ</italic>-mers: If the cut site representation of an <italic>ℓ</italic>-mer is <inline-formula id="IE44"><mml:math id="IM26"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mi>x</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> then the corresponding fragment size representation is <inline-formula id="IE45"><mml:math id="IM27"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mi>x</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>, where <inline-formula id="IE46"><mml:math id="IM28"><mml:mrow><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>.</p>
      <fig id="btz663-F2" orientation="portrait" position="float">
        <label>Fig. 2.</label>
        <caption>
          <p>Extraction of (<bold>a</bold>) <italic>k</italic>-mers for <italic>k </italic>=<italic> </italic>4, (<bold>b</bold>) <italic>ℓ</italic>-mers for <inline-formula id="IE37"><mml:math id="IM29"><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo>=</mml:mo><mml:mn>40</mml:mn></mml:mrow></mml:math></inline-formula>, (<bold>c</bold>) (<italic>ℓ</italic>, <italic>k</italic>)-mers for <inline-formula id="IE38"><mml:math id="IM30"><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo>=</mml:mo><mml:mn>40</mml:mn></mml:mrow></mml:math></inline-formula> and <italic>k </italic>=<italic> </italic>3 and (<bold>d</bold>) spaced (<italic>ℓ</italic>, <italic>k</italic>)-mers for <inline-formula id="IE39"><mml:math id="IM31"><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo>=</mml:mo><mml:mn>40</mml:mn></mml:mrow></mml:math></inline-formula>, <italic>k </italic>=<italic> </italic>3 and spacing pattern <italic>S </italic>=<italic> </italic><monospace>1111110000111111111111111000111100111111</monospace> from the Rmap <inline-formula id="IE40"><mml:math id="IM32"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mn>4</mml:mn><mml:mo>,</mml:mo><mml:mn>28</mml:mn><mml:mo>,</mml:mo><mml:mn>10</mml:mn><mml:mo>,</mml:mo><mml:mn>6</mml:mn><mml:mo>,</mml:mo><mml:mn>9</mml:mn><mml:mo>,</mml:mo><mml:mn>3</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>. For (<italic>ℓ</italic>, <italic>k</italic>)-mers and spaced (<italic>ℓ</italic>, <italic>k</italic>)-mers we use dotted lines to show the extension beyond <italic>ℓ</italic> positions to include at least <italic>k</italic> fragments. For spaced (<italic>ℓ</italic>, <italic>k</italic>)-mers missing line segments denote spaces in the spacing pattern. The extracted <italic>k</italic>-mers, <italic>ℓ</italic>-mers, (<italic>ℓ</italic>, <italic>k</italic>)-mers and spaced (<italic>ℓ</italic>, <italic>k</italic>)-mers are shown on the right. To extract all <italic>k</italic>-mers from an Rmap, we first extract the <italic>k</italic>-mer containing the <italic>k</italic> leftmost fragments. To get the next <italic>k</italic>-mer, the leftmost fragment is dropped and the next fragment on the right is added. To extract all <italic>ℓ</italic>-mers and (spaced) (<italic>ℓ</italic>, <italic>k</italic>)-mers we first consider the <italic>ℓ</italic>-length subsegment of the line positioned at the leftmost position. To get the next <italic>ℓ</italic>-mer or (spaced) (<italic>ℓ</italic>, <italic>k</italic>)-mer, the subsegment is shifted to the right until a cut site enters or exits (the solid part of) the subsegment</p>
        </caption>
        <graphic xlink:href="btz663f2"/>
      </fig>
      <p>To extract all different <italic>ℓ</italic>-mers from an Rmap, we start by positioning the line subsegment at the leftmost position. The next position for the line subsegment is obtained by moving it to the right until either the leftmost cut site currently within the line subsegment drops outside the line subsegment or the next cut site on the right enters the line subsegment. <xref ref-type="fig" rid="btz663-F2">Figure 2b</xref> illustrates this process for Rmap <inline-formula id="IE47"><mml:math id="IM33"><mml:mrow><mml:mi>R</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mn>4</mml:mn><mml:mo>,</mml:mo><mml:mn>28</mml:mn><mml:mo>,</mml:mo><mml:mn>10</mml:mn><mml:mo>,</mml:mo><mml:mn>6</mml:mn><mml:mo>,</mml:mo><mml:mn>9</mml:mn><mml:mo>,</mml:mo><mml:mn>3</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> when <inline-formula id="IE48"><mml:math id="IM34"><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo>=</mml:mo><mml:mn>40</mml:mn></mml:mrow></mml:math></inline-formula>.</p>
      <p>Some <italic>ℓ</italic>-mers can have very few fragments, which is problematic in practice since these are usually not unique in the genome. To correct for this, we define an (<italic>ℓ</italic>, <italic>k</italic>)-mer of Rmap <italic>R</italic> by computing all <italic>ℓ</italic>-mers of <italic>R</italic> and inserting fragments from the right until there exists at least <italic>k</italic> fragments. Going back to our line segment illustration, this corresponds to extending the <italic>ℓ</italic>-length line subsegment to the right until at least <italic>k</italic> fragments are fully contained in it. We note that there can be more than <italic>k</italic> fragments if the <italic>ℓ</italic>-mer contains more than <italic>k</italic> fragments. <xref ref-type="fig" rid="btz663-F2">Figure 2c</xref> illustrates the extraction of (<italic>ℓ</italic>, <italic>k</italic>)-mers for <inline-formula id="IE49"><mml:math id="IM35"><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo>=</mml:mo><mml:mn>40</mml:mn></mml:mrow></mml:math></inline-formula> and <italic>k </italic>=<italic> </italic>3. (<italic>ℓ</italic>, <italic>k</italic>)-mers are a generalization of <italic>k</italic>-mers and <italic>ℓ</italic>-mers: <inline-formula id="IE50"><mml:math id="IM36"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>-mers are equivalent to <italic>k</italic>-mers and <inline-formula id="IE51"><mml:math id="IM37"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ℓ</mml:mi><mml:mo>,</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>-mers are equivalent to <italic>ℓ</italic>-mers.</p>
      <p>We now extend the definition of (<italic>ℓ</italic>, <italic>k</italic>)-mers to spaced (<italic>ℓ</italic>, <italic>k</italic>)-mers. Spaced (<italic>ℓ</italic>, <italic>k</italic>)-mers are defined by <italic>ℓ</italic>, <italic>k</italic> and a spacing pattern <italic>S</italic> of length <italic>ℓ</italic>. A spacing pattern is a sequence of 0 and 1 s, where 0 s denote gaps, and 1 s denote solid parts. Again we consider the cut site representation of an Rmap. We align the spacing pattern to an <italic>ℓ</italic>-mer corresponding to the interval <inline-formula id="IE52"><mml:math id="IM38"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mi>p</mml:mi><mml:mo>,</mml:mo><mml:mi>p</mml:mi><mml:mo>+</mml:mo><mml:mi>ℓ</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> for some <inline-formula id="IE53"><mml:math id="IM39"><mml:mrow><mml:mn>0</mml:mn><mml:mo>≤</mml:mo><mml:mi>p</mml:mi><mml:mo>≤</mml:mo><mml:mo>|</mml:mo><mml:mi>R</mml:mi><mml:mo>|</mml:mo><mml:mo>−</mml:mo><mml:mi>ℓ</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>. Then we construct a modified Rmap <inline-formula id="IE54"><mml:math id="IM40"><mml:mrow><mml:mi>C</mml:mi><mml:mo>′</mml:mo><mml:mo>=</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>c</mml:mi><mml:msub><mml:mrow><mml:mo>′</mml:mo></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>c</mml:mi><mml:msub><mml:mrow><mml:mo>′</mml:mo></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>′</mml:mo><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> in cut site representation by removing any cut site from <italic>C</italic> that falls within a gap in the spacing pattern. The corresponding modified Rmap <inline-formula id="IE55"><mml:math id="IM41"><mml:mrow><mml:mi>R</mml:mi><mml:mo>′</mml:mo><mml:mo>=</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>r</mml:mi><mml:msub><mml:mrow><mml:mo>′</mml:mo></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>r</mml:mi><mml:msub><mml:mrow><mml:mo>′</mml:mo></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> in fragment size representation can now be constructed by setting <inline-formula id="IE56"><mml:math id="IM42"><mml:mrow><mml:mi>r</mml:mi><mml:msub><mml:mrow><mml:mo>′</mml:mo></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi>c</mml:mi><mml:msub><mml:mrow><mml:mo>′</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:mi>c</mml:mi><mml:msub><mml:mrow><mml:mo>′</mml:mo></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>. The spaced (<italic>ℓ</italic>, <italic>k</italic>)-mer is then defined as the (<italic>ℓ</italic>, <italic>k</italic>)-mer extracted from <inline-formula id="IE57"><mml:math id="IM43"><mml:mrow><mml:mi>R</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> at position <italic>p</italic>. Going back to our line segment illustration, all spaced (<italic>ℓ</italic>, <italic>k</italic>)-mers can be extracted from an Rmap by first aligning the spacing pattern to the leftmost position of the line segment and extracting the first spaced (<italic>ℓ</italic>, <italic>k</italic>)-mer. The spacing pattern is then shifted to the right until a cut site exits or enters the solid part of the spacing pattern and the next spaced (<italic>ℓ</italic>, <italic>k</italic>)-mer is extracted. We repeat the shifting of the spacing pattern until its end is shifted beyond the line segment. <xref ref-type="fig" rid="btz663-F2">Figure 2d</xref> illustrates this process for <inline-formula id="IE58"><mml:math id="IM44"><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo>=</mml:mo><mml:mn>40</mml:mn></mml:mrow></mml:math></inline-formula>, <italic>k </italic>=<italic> </italic>3 and <italic>S </italic>=<italic> </italic>1111110000111111111111111000111100111111.</p>
      <p>As mentioned earlier, in practice fragment sizes are in thousands of base pairs and so typical values of <italic>ℓ</italic> are in tens of thousands of base pairs. Thus it is impractical to have a spacing pattern of length <italic>ℓ</italic>. Instead in practice each bit of the spacing pattern spans <inline-formula id="IE59"><mml:math id="IM45"><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo>/</mml:mo><mml:mo>|</mml:mo><mml:mi>S</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula> base pairs.</p>
    </sec>
  </sec>
  <sec>
    <title>4 Methods</title>
    <p>The input to our method is a set (Actually, the input is a multi-set since we allow repetition.) of Rmaps <inline-formula id="IE72"><mml:math id="IM46"><mml:mrow><mml:mi mathvariant="script">R</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mi>m</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>. First, we create a spaced (<italic>ℓ</italic>, <italic>k</italic>)-mer index that maps spaced (<italic>ℓ</italic>, <italic>k</italic>)-mers to the Rmaps in which they occur in. The index is further refined by merging entries for similar spaced (<italic>ℓ</italic>, <italic>k</italic>)-mers. Then, we use this index to find a sets of Rmaps that share spaced (<italic>ℓ</italic>, <italic>k</italic>)-mers for a given Rmap <italic>R<sub>i</sub></italic> and thus, are likely to originate from the same genomic area. We repeat this for all Rmaps which results in a set of Rmaps for each <italic>R<sub>i</sub></italic>. Next, we filter each set by aligning each Rmap pairwise to <italic>R<sub>i</sub></italic> and keeping only those that align well enough. Lastly, we create a multiple alignment of each set of Rmaps and correct them towards the consensus of the multiple alignment. The overview of our method is shown in <xref ref-type="fig" rid="btz663-F3">Figure 3</xref>. Each of the steps of our method is discussed in detail in the following subsections. Further, we present a method for optimizing the spacing pattern used in the spaced (<italic>ℓ</italic>, <italic>k</italic>)-mer index.
</p>
    <fig id="btz663-F3" orientation="portrait" position="float">
      <label>Fig. 3.</label>
      <caption>
        <p>Overview of the error correction process in Elmeri</p>
      </caption>
      <graphic xlink:href="btz663f3"/>
    </fig>
    <sec>
      <title>4.1 Finding sets of related Rmaps</title>
      <p>First, we quantize the fragment lengths in each Rmap to account for the sizing error. We use bins of fixed length <italic>b</italic> for the quantization (by default <italic>b </italic>=<italic> </italic>1000), i.e. if the original fragment length is <italic>x</italic> then the quantized length is <inline-formula id="IE70"><mml:math id="IM47"><mml:mrow><mml:mo>⌊</mml:mo><mml:mrow><mml:mi>x</mml:mi><mml:mo>/</mml:mo><mml:mi>b</mml:mi></mml:mrow><mml:mo>⌋</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
      <p>Next, we extract spaced (<italic>ℓ</italic>, <italic>k</italic>)-mers from each Rmap, and use a hash table to map each spaced (<italic>ℓ</italic>, <italic>k</italic>)-mer to the Rmaps that contain it. Given a spaced (<italic>ℓ</italic>, <italic>k</italic>)-mer <italic>M</italic>, we denote the corresponding set of Rmaps as <inline-formula id="IE71"><mml:math id="IM48"><mml:mrow><mml:mi mathvariant="script">R</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>M</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, i.e. <inline-formula id="IE1"><mml:math id="IM49"><mml:mrow><mml:mi mathvariant="script">R</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>M</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:mi mathvariant="script">R</mml:mi><mml:mo>|</mml:mo><mml:mi>M</mml:mi><mml:mo> </mml:mo><mml:mtext>occurs</mml:mtext><mml:mo> </mml:mo><mml:mtext>in</mml:mtext><mml:mo> </mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
      <p>Most fragments originating from the same region of the genome are quantized to the same value. However, when the correct fragment length is close to the boundary of two quantization bins, the estimated fragment lengths can fall into either bin. Therefore, to find related Rmaps more effectively, we merge the sets of Rmaps corresponding to similar spaced (<italic>ℓ</italic>, <italic>k</italic>)-mers.</p>
      <p>Given two spaced (<italic>ℓ</italic>, <italic>k</italic>)-mers <italic>M</italic><sub>1</sub> and <italic>M</italic><sub>2</sub> with the same number of fragments, we define their distance as follows:
<disp-formula id="E1"><mml:math id="M1"><mml:mrow><mml:mtext>dist</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>|</mml:mo></mml:mrow></mml:munderover><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>|</mml:mo><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p>
      <p>We then set a similarity threshold <inline-formula id="IE2"><mml:math id="IM50"><mml:mrow><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mtext>sim</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> and extend the set of Rmaps corresponding to a spaced (<italic>ℓ</italic>, <italic>k</italic>)-mer:
<disp-formula id="E2"><mml:math id="M2"><mml:mrow><mml:mi mathvariant="script">R</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>M</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:munder><mml:mo>⋃</mml:mo><mml:mrow><mml:mi>M</mml:mi><mml:mo>′</mml:mo><mml:mo>|</mml:mo><mml:mtext>dist</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>M</mml:mi><mml:mo>,</mml:mo><mml:mi>M</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>≤</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mtext>sim</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:munder><mml:mi mathvariant="script">R</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>M</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p>
      <p>In practice the above procedure is inefficient with respect to memory usage because many Rmaps are replicated several times with small variations. Thus, we implemented a heuristic merging procedure for the Rmap sets as follows. For each set <inline-formula id="IE3"><mml:math id="IM51"><mml:mrow><mml:mi mathvariant="script">R</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>M</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> we keep a counter <italic>i<sub>M</sub></italic> initialized to 1 indicating how many spaced (<italic>ℓ</italic>, <italic>k</italic>)-mers have been merged to it. We iterate through all spaced (<italic>ℓ</italic>, <italic>k</italic>)-mers in the index twice. For each spaced (<italic>ℓ</italic>, <italic>k</italic>)-mer <italic>M</italic>, we find the spaced (<italic>ℓ</italic>, <italic>k</italic>)-mers <inline-formula id="IE4"><mml:math id="IM52"><mml:mrow><mml:mi>M</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> for which <inline-formula id="IE5"><mml:math id="IM53"><mml:mrow><mml:mtext>dist</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>M</mml:mi><mml:mo>,</mml:mo><mml:mi>M</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>. If <inline-formula id="IE6"><mml:math id="IM54"><mml:mrow><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mi>M</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>M</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mtext>sim</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> then we set both <inline-formula id="IE7"><mml:math id="IM55"><mml:mrow><mml:mi mathvariant="script">R</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>M</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE8"><mml:math id="IM56"><mml:mrow><mml:mi mathvariant="script">R</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>M</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> to <inline-formula id="IE9"><mml:math id="IM57"><mml:mrow><mml:mi mathvariant="script">R</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>M</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∪</mml:mo><mml:mi mathvariant="script">R</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>M</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and both <italic>i<sub>M</sub></italic> and <inline-formula id="IE10"><mml:math id="IM58"><mml:mrow><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>M</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> equal to <inline-formula id="IE11"><mml:math id="IM59"><mml:mrow><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mi>M</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>M</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>. This process guarantees that the Rmap sets for two spaced (<italic>ℓ</italic>, <italic>k</italic>)-mers with distance higher than the similarity threshold are never merged. However, Rmap sets for some spaced (<italic>ℓ</italic>, <italic>k</italic>)-mers that are similar enough might not get merged if they have been previously merged with other sets.</p>
      <p>To find sets of related Rmaps, we iterate through the set <inline-formula id="IE12"><mml:math id="IM60"><mml:mrow><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mi>m</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>. Let <italic>R<sub>i</sub></italic> be the current Rmap. We extract all spaced (<italic>ℓ</italic>, <italic>k</italic>)-mers from <italic>R<sub>i</sub></italic>, query the spaced (<italic>ℓ</italic>, <italic>k</italic>)-mer index for each spaced (<italic>ℓ</italic>, <italic>k</italic>)-mer and count the number of spaced (<italic>ℓ</italic>, <italic>k</italic>)-mers each Rmap shares with <italic>R<sub>i</sub></italic>. Using these counts, we select the <italic>N</italic> Rmaps that share the greatest number of spaced (<italic>ℓ</italic>, <italic>k</italic>)-mers with <italic>R<sub>i</sub></italic> to be the set of <italic>related Rmaps</italic> for <italic>R<sub>i</sub></italic>. We denote this set of related Rmaps of <italic>R<sub>i</sub></italic> as <italic>R<sup>i</sup></italic>. Lastly, we note that <italic>N</italic> should be roughly equal to the coverage of the Rmap set, and set the default value of <italic>N</italic> to be 64.</p>
      <p>As our experiments in Section 5.2 show, the spaced (<italic>ℓ</italic>, <italic>k</italic>)-mer index sometimes return related Rmaps that do not originate from the same genomic area as the current Rmap <italic>R<sub>i</sub></italic>. Therefore, we filter out unrelated Rmaps from <italic>R<sup>i</sup></italic> using the following procedure. First, we transform Rmaps into binary strings by using the cut site representation and considering each Rmap as a line segment where each cut site defines a point on the line. We divide each line segment into blocks of size <italic>B</italic> (by default 2000), and transform them into binary strings as follows: if a block contains one or more cut sites then we add as many 1 s as there are cut sites; otherwise, we add a 0. See <xref ref-type="fig" rid="btz663-F4">Figure 4</xref> for an example. We note that this representation is ambiguous with regard to the block boundaries. However, we are concerned with determining which cut sites originate from the same cut site in the genome and thus block boundaries need not be unambiguous.
</p>
      <fig id="btz663-F4" orientation="portrait" position="float">
        <label>Fig. 4.</label>
        <caption>
          <p>Transforming the Rmap <inline-formula id="IE13"><mml:math id="IM61"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mn>4</mml:mn><mml:mo>,</mml:mo><mml:mn>28</mml:mn><mml:mo>,</mml:mo><mml:mn>10</mml:mn><mml:mo>,</mml:mo><mml:mn>6</mml:mn><mml:mo>,</mml:mo><mml:mn>9</mml:mn><mml:mo>,</mml:mo><mml:mn>3</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> to a binary string. The block size in this example is 5</p>
        </caption>
        <graphic xlink:href="btz663f4"/>
      </fig>
      <p>Next, we align each (transformed) Rmap in <italic>R<sup>i</sup></italic> pairwise against <italic>R<sub>i</sub></italic> using a variant of the Needleman-Wunsch algorithm (<xref rid="btz663-B29" ref-type="bibr">Needleman and Wunsch, 1970</xref>). When aligning the binary strings, we consider the 0 and 1 s to be normal characters. If the alignment contains a gap, this is denoted by a separate gap character, ‘-’. We allow free gaps in the beginning and end of the alignment for both Rmaps allowing us to find prefix-suffix overlaps between them. The binary strings are sparse with only a few 1 s. With uniform edit costs, the algorithm tends not to align the 1 s (i.e. cut sites) because the much more abundant 0 s are easily aligned with each other. Since aligning the cut sites is crucial in our application, we set the alignment costs so that any error involving a cut site costs <inline-formula id="IE14"><mml:math id="IM62"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mn>0</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>/</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula>, where <italic>c</italic><sub>0</sub> (<italic>c</italic><sub>1</sub>) is the number of 0 s (1 s) in all binary strings participating in the alignment, and all other errors have a cost of 1. We assume that Rmaps should not have more than 40% added and missing cut sites and thus, an alignment of two Rmaps should not have more than 80% added and added cut sites taking into account errors in both Rmaps. This is a conservative assumption as <xref rid="btz663-B17" ref-type="bibr">Li <italic>et al.</italic> (2016)</xref> estimate the average digestion rate of an Rmap fragment to be 0.8. Therefore, if the number of edits exceeds 0.8 times the number of cut sites in the Rmap having less cut sites, the related Rmap is removed from <italic>R<sup>i</sup></italic>.</p>
    </sec>
    <sec>
      <title>4.2 Multiple alignment based correction of Rmaps</title>
      <p>Next, we construct a multiple alignment for <italic>R<sub>i</sub></italic> and the filtered <italic>R<sup>i</sup></italic>. We use the same transformation of Rmaps to binary strings as above and then proceed to compute a heuristic multiple alignment for the binary strings. <italic>R<sub>i</sub></italic> is set as the initial consensus of the alignment. The related Rmaps are then aligned against the consensus consecutively using the same algorithm as for the pairwise alignments above. After each pairwise alignment, the consensus is updated accordingly. If there is a deletion in the newly aligned binary string, a gap symbol is added to that sequence. If there is an insertion in the newly aligned binary string, we add a new column to the multiple alignment at that position and update those binary strings that are already aligned to include the gap. Then we compute for each column in the multiple alignment the most prevalent symbol or gap which then becomes the consensus at that position.</p>
      <p>Lastly, we determine if there exists any Rmaps in the multiple alignment that contain a substantial amount of added and/or deleted cut sites as compared to the consensus—indicating that they do not originate from the same genomic region. Hence, we remove any Rmaps that have more than 3 extra cut sites or more than 40% deleted cut sites as compared to the consensus. After this filtering step, we recompute the multiple alignment for all the remaining Rmaps.</p>
      <p>Once the multiple alignment for an Rmap <italic>R<sub>i</sub></italic> and its related Rmaps has been computed, we are ready to correct the Rmaps in the alignment. We require that at least five Rmaps participate in the alignment to proceed to the correction phase.</p>
      <p>To get an accurate estimate of the fragment lengths in the consensus we retrieve the original unquantized Rmaps and compute the average of the fragment lengths for all Rmaps that have the fragment in question (i.e. both flanking cut sites have to be present in the Rmap). The aligned Rmaps can then be corrected by extracting from the consensus Rmap the part where that Rmap aligns to.</p>
      <p>For high coverage datasets, the above method builds multiple alignments for the same genomic region excessively many times. Since all Rmaps in the alignment are corrected, many Rmaps are corrected more times than is necessary. Therefore, we count how many times each Rmap has already been corrected, and when iterating over the multiset of Rmaps, we skip an Rmap if it has already been corrected many times. In practice, we found a threshold of five corrections to be sufficient for a good overall correction result.</p>
    </sec>
    <sec>
      <title>4.3 Optimizing the spacing pattern</title>
      <p>The accuracy of the spaced (<italic>ℓ</italic>, <italic>k</italic>)-mer index depends on the choice of the spacing pattern. In our experiments we mostly use <italic>ℓ</italic> = 80 kbp and quantization constant <italic>b </italic>=<italic> </italic>1 kbp. The spacing pattern had 80 bits and thus, each bit represents a 1 kbp region. For evaluating the performance of the spaced (<italic>ℓ</italic>, <italic>k</italic>)-mer index using a given spacing pattern we use a small dataset with 2000 Rmaps simulated from the <italic>E.</italic><italic>coli</italic> genome. We evaluate the precision and recall of the index on this dataset as detailed in Section 5.2 and use F-score, which is the harmonic mean of precision and recall, to evaluate the fitness of the spacing patterns. Exhaustive enumeration of all 80 bit spacing patterns is infeasible and thus we use a simulated annealing algorithm to optimize the spacing pattern. We initialize the algorithm with a random spacing pattern where the probability of both 0 and 1 is 0.5. In each round we then choose a random bit and flip it. If the new spacing pattern is better than the previous one, it always becomes the current spacing pattern. If the new spacing pattern is worse than the previous one, we still accept it with a probability depending on the current temperature as in a simulated annealing algorithm.</p>
    </sec>
  </sec>
  <sec>
    <title>5 Experimental results</title>
    <p>In this section, we first compare indexing schemes which use <italic>k</italic>-mers, <italic>ℓ</italic>-mers, (<italic>ℓ</italic>, <italic>k</italic>)-mers and spaced (<italic>ℓ</italic>, <italic>k</italic>)-mers to show the advantage of the spaced (<italic>ℓ</italic>, <italic>k</italic>)-mers. Then, we compare the performance of <sc>Elmeri</sc> to that of cOMet (<xref rid="btz663-B27" ref-type="bibr">Mukherjee <italic>et al.</italic>, 2018</xref>).</p>
    <sec>
      <title>5.1 Data</title>
      <p>We performed experiments on both simulated and real Bionano datasets. We used the simulated Bionano Rmap datasets from <xref rid="btz663-B27" ref-type="bibr">Mukherjee <italic>et al.</italic> (2018)</xref>, which are generated from the <italic>E.</italic><italic>coli</italic> K-12 substr. MG1655 genome with OMSim (<xref rid="btz663-B23" ref-type="bibr">Miclotte <italic>et al.</italic>, 2017</xref>). Default parameters with enzyme BspQI were used with varying rates at which additional and missing cut sites were introduced. The number of additional cut sites was varied from 0.5 to 5 per 100 kbp and the percentage of missing cut sites was varied from 5 to 25%. In total eight different datasets were produced that have a varying number of Rmaps, e.g. between 123 251 and 157 743 Rmaps. We collectively refer to these eight datasets as Ecoli1.</p>
      <p>In addition, we used the simulated Rmap <italic>E.</italic><italic>coli</italic> data from <xref rid="btz663-B27" ref-type="bibr">Mukherjee <italic>et al.</italic> (2018)</xref> which was generated by first constructing error free Rmaps from the <italic>E.</italic><italic>coli</italic> K-12 substr. MG1655 genome and then introducing added and missing cut sites and sizing error according to the error model by <xref rid="btz663-B17" ref-type="bibr">Li <italic>et al.</italic> (2016)</xref>. The resulting dataset consists of 2504 error-free Rmaps and 2504 Rmaps, which contain 7485 missing cut sites and 554 additional cut sites. We refer to this dataset as Ecoli2.</p>
      <p>Lastly, we performed experiments using the human Bionano Rmap dataset produced by <xref rid="btz663-B32" ref-type="bibr">Shi <italic>et al.</italic> (2016)</xref>, which consists of 793 199 Rmaps and <italic>Anabas testudineus</italic> (climbing perch) genome generated for the Vertebrate Genome Project, which consists of 3 121 480 Rmaps. <xref rid="btz663-T1" ref-type="table">Table 1</xref> summarizes the datasets used in the experiments.
</p>
      <table-wrap id="btz663-T1" orientation="portrait" position="float">
        <label>Table 1.</label>
        <caption>
          <p>Datasets used in the experiments</p>
        </caption>
        <table frame="hsides" rules="groups">
          <colgroup span="1">
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="left" span="1"/>
          </colgroup>
          <thead>
            <tr>
              <th rowspan="1" colspan="1">Dataset</th>
              <th align="left" rowspan="1" colspan="1">Genome</th>
              <th align="left" rowspan="1" colspan="1">Genome size</th>
              <th align="left" rowspan="1" colspan="1">Number of Rmaps</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="1" colspan="1">Ecoli1</td>
              <td rowspan="1" colspan="1"><italic>E.coli</italic> K-12 MG 1655</td>
              <td rowspan="1" colspan="1">4.6 Mbp</td>
              <td rowspan="1" colspan="1">123 251–157 743</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Ecoli2</td>
              <td rowspan="1" colspan="1"><italic>E.coli</italic> K-12 MG 1655</td>
              <td rowspan="1" colspan="1">4.6 Mbp</td>
              <td rowspan="1" colspan="1">2504</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Human</td>
              <td rowspan="1" colspan="1">Chinese individual (HX1)</td>
              <td rowspan="1" colspan="1">3.2 Gbp</td>
              <td rowspan="1" colspan="1">793 199</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">AnaTes</td>
              <td rowspan="1" colspan="1">
                <italic>Anabas testudineus</italic>
              </td>
              <td rowspan="1" colspan="1">0.66 Gbp</td>
              <td rowspan="1" colspan="1">3 121 480</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <fn id="tblfn1">
            <p><italic>Note</italic>: The Ecoli1 dataset contains eight simulated <italic>E.coli</italic> datasets with varying error rates and thus also the number of Rmaps varies. The genome size of <italic>A.testudineus</italic> is an estimate since there exists no reference genome.</p>
          </fn>
        </table-wrap-foot>
      </table-wrap>
    </sec>
    <sec>
      <title>5.2 Comparison of the indexing schemes</title>
      <p>For evaluating the indexing schemes, we used a subset of 2000 Rmaps with at least 10 fragments from the Ecoli1 dataset which contains 1.0 additional cut site per 100 kbp and 15% missing cut sites. We used a small subset instead of the full dataset, to quickly explore a large parameter space of the proposed method. Because the Rmaps are simulated, we know their genomic positions. We classified two Rmaps as related if their genomic positions overlap by at least 100 kbp and by at least 7 fragments. For a predicted set of related Rmaps we can now compute following statistics: (i) true positives (TP), i.e. number of Rmap pairs which are predicted to be related and are also actually related, (ii) false positives (FP), i.e. number of Rmap pairs which are predicted to be related but are actually not and (iii) false negatives (FN), i.e. number of Rmap pairs which are predicted not to be related but are actually related. Based on these we computed precision and recall: <inline-formula id="IE60"><mml:math id="IM63"><mml:mrow><mml:mtext>Precision</mml:mtext><mml:mo>=</mml:mo><mml:mtext>TP</mml:mtext><mml:mo>/</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mtext>TP</mml:mtext><mml:mo>+</mml:mo><mml:mtext>FP</mml:mtext><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mtext>Recall</mml:mtext><mml:mo>=</mml:mo><mml:mtext>TP</mml:mtext><mml:mo>/</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mtext>TP</mml:mtext><mml:mo>+</mml:mo><mml:mtext>FN</mml:mtext><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
      <p>We compared the following indexing schemes:
<list list-type="bullet"><list-item><p><italic>k</italic>-mers</p></list-item><list-item><p><italic>k</italic>-mers with merging of similar <italic>k</italic>-mers</p></list-item><list-item><p><italic>ℓ</italic>-mers with merging of similar <italic>ℓ</italic>-mers</p></list-item><list-item><p><inline-formula id="IE61"><mml:math id="IM64"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ℓ</mml:mi><mml:mo>,</mml:mo><mml:mn>5</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>-mers with merging of similar <inline-formula id="IE62"><mml:math id="IM65"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ℓ</mml:mi><mml:mo>,</mml:mo><mml:mn>5</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>-mers</p></list-item><list-item><p>Spaced <italic>ℓ</italic>-mers with merging of similar spaced <italic>ℓ</italic>-mers</p></list-item><list-item><p>Spaced <inline-formula id="IE63"><mml:math id="IM66"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ℓ</mml:mi><mml:mo>,</mml:mo><mml:mn>5</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>-mers</p></list-item><list-item><p>Spaced <inline-formula id="IE64"><mml:math id="IM67"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ℓ</mml:mi><mml:mo>,</mml:mo><mml:mn>5</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>-mers with merging of similar spaced <inline-formula id="IE65"><mml:math id="IM68"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ℓ</mml:mi><mml:mo>,</mml:mo><mml:mn>5</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>-mers</p></list-item></list></p>
      <p>All indexes using spaced (<italic>ℓ</italic>, <italic>k</italic>)-mers used the spacing pattern 11111111110001110110010010011101001110001010010100001010011000010111100000001100. In all cases two Rmaps are considered related if they share at least two <italic>k</italic>-mers/<italic>ℓ</italic>-mers/<inline-formula id="IE66"><mml:math id="IM69"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ℓ</mml:mi><mml:mo>,</mml:mo><mml:mn>5</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>-mers. To obtain various precision-recall measurements, we varied the value of <italic>k</italic> or <italic>ℓ</italic> for each scheme. Thus, <italic>k</italic> was varied from 3 to 8 and <italic>ℓ</italic> from 40 to 100 kbp. We note that in the error correction method we filter related Rmaps returned by the index based on the pairwise alignment. This additional filtering was not used in these experiments because it could confound the effect that the seeding methods have on precision and recall.</p>
      <p>All experiments in this section were run on Intel Xeon E 5540 CPUs operating at 2.53 GHz, equipped with 32 GB of memory and running Linux 4.10. The running time and memory usage was recorded with the Linux/Unix time command. We report the elapsed (wall-clock) time. None of the indexing implementations take advantage of parallelism.</p>
      <p>The left hand side of <xref ref-type="fig" rid="btz663-F5">Figure 5</xref> shows the precision and recall for the different indexing schemes and the right hand side shows the trade-off between running time and memory. The <italic>k</italic>-mer index is the most efficient with respect to both memory and time but its recall is unsatisfactory. Merging similar <italic>k</italic>-mers improves the recall but significantly lowers the precision. <xref ref-type="fig" rid="btz663-F5">Figure 5</xref> (left) also illustrates that <italic>ℓ</italic>-mers are not selective. The spaced <italic>ℓ</italic>-mer index returns most Rmap pairs as related reflected by a low precision and a recall score of almost one. However, the (<italic>ℓ</italic>, <italic>k</italic>)-mers increase the precision substantively. For example, the spaced <inline-formula id="IE67"><mml:math id="IM70"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ℓ</mml:mi><mml:mo>,</mml:mo><mml:mn>5</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>-mer index using merging has superior precision-recall trade-off but is less efficient with respect to memory and time than the <italic>k</italic>-mer index. Further, merging significantly improves the recall of the spaced (<italic>ℓ</italic>, <italic>k</italic>)-mer index with a small decrease in precision but it also increases the running time.
</p>
      <fig id="btz663-F5" orientation="portrait" position="float">
        <label>Fig. 5.</label>
        <caption>
          <p>Comparison of the performance of the different indexing schemes. The precision and recall of the different indexing schemes when <italic>k</italic> or <italic>ℓ</italic> is varied is shown on the left and the runtime and memory usage of the different indexing schemes on the right. The performance of the spaced (<italic>ℓ</italic>, <italic>k</italic>)-mer index with the default parameters is shown with a black rectangle</p>
        </caption>
        <graphic xlink:href="btz663f5"/>
      </fig>
      <p>In light of these results, we ran experiments for various values of <italic>k</italic> for the spaced (<italic>ℓ</italic>, <italic>k</italic>)-mer index with merging of similar spaced (<italic>ℓ</italic>, <italic>k</italic>)-mers. <xref ref-type="supplementary-material" rid="sup1">Supplementary Figure S1</xref> shows that <italic>k </italic>=<italic> </italic>5 gives the best trade-off and thus it was used in all other experiments.</p>
      <p><xref ref-type="supplementary-material" rid="sup1">Supplementary Figure S2</xref> shows how the performance of the spaced (<italic>ℓ</italic>, <italic>k</italic>)-mer index is affected by the choice of the spacing pattern. The optimized spacing patterns perform better than the random ones although the difference is not large. Spacing patterns that have more weight in the beginning generally performed better. We also noticed that best spacing patterns can have 0s in the end. This is likely due to us adding fragments to the (<italic>ℓ</italic>, <italic>k</italic>)-mers until at least <italic>k</italic> fragments are used.</p>
    </sec>
    <sec>
      <title>5.3 Performance of error correction</title>
      <p>We compare the performance of our method <sc>Elmeri</sc> to our previous method, cOMet (<xref rid="btz663-B27" ref-type="bibr">Mukherjee <italic>et al.</italic>, 2018</xref>), on the full human and Ecoli1 datasets. Here, we performed all experiments on Intel E5-2698v3 processors with 192 GB of RAM running 64-bit Linux, and used the default parameters for cOMet. cOMet was parallelized to use five processes. Based on the experiments of the previous section, we set the spaced (<italic>ℓ</italic>, <italic>k</italic>)-mer index parameters for <sc>Elmeri</sc> as follows: <italic>ℓ</italic> = 80 kbp, <italic>k </italic>=<italic> </italic>5, <inline-formula id="IE68"><mml:math id="IM71"><mml:mrow><mml:mi>S</mml:mi><mml:mo>=</mml:mo><mml:mn>11111111110001110110010010011101001110001010010100001010011000010111100000001100</mml:mn></mml:mrow></mml:math></inline-formula>. The performance of the index with these default parameters is shown in <xref ref-type="fig" rid="btz663-F5">Figure 5</xref> with a black rectangle. <sc>Elmeri</sc> was run on a single node using eight threads for the error correction phase.</p>
      <p><sc>Elmeri</sc> obtained superior results on the human dataset when <italic>k </italic>=<italic> </italic>6, which is likely due to the increased size of the genome. Since the human genome is significant longer than <italic>E.</italic><italic>coli</italic>, a larger value of <italic>k</italic> is likely needed to ensure most spaced (<italic>ℓ</italic>, <italic>k</italic>)-mers are unique in the genome. Further, since the human dataset has significantly lower coverage than each of the eight Ecoli1 datasets, we only consider the top 32 related Rmaps for each Rmap in the error correction algorithm instead of the default 64.</p>
      <p>To evaluate the accuracy of correction, we aligned the uncorrected and the corrected Rmaps against an <italic>in silico</italic> digested reference genome using the alignment tool by <xref rid="btz663-B34" ref-type="bibr">Valouev <italic>et al.</italic> (2006a</xref>). As previously mentioned, the method of <xref rid="btz663-B34" ref-type="bibr">Valouev <italic>et al.</italic> (2006a</xref>) uses dynamic programming to find the optimal alignment for any pair of Rmaps by optimizing a scoring function that accounts for added and missing cut-sites, which is called the <italic>S-score</italic>. We then counted the number of Rmaps whose S-score had improved, and computed the mean increase in the S-score.</p>
      <p><xref rid="btz663-T2" ref-type="table">Table 2</xref> shows the results on the Ecoli1 datasets. In all but one case, the percentage of Rmaps with improved S-score is higher for <sc>Elmeri</sc> than for cOMet. Furthermore, the mean increase in S-score is almost double for <sc>Elmeri</sc> as compared to cOMet, and <sc>Elmeri</sc> is significantly faster than cOMet. <sc>Elmeri</sc> uses more memory, however, all datasets were able to be ran with less than 21 GB of memory.
</p>
      <table-wrap id="btz663-T2" orientation="portrait" position="float">
        <label>Table 2.</label>
        <caption>
          <p>The accuracy, runtime and memory usage of <sc>Elmeri</sc> and cOMet on simulated <italic>E.coli</italic> data when the number of additional cut sites introduced per 100 kbp and the rate of missing cut sites are varied</p>
        </caption>
        <table frame="hsides" rules="groups">
          <colgroup span="1">
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
          </colgroup>
          <thead>
            <tr>
              <th rowspan="1" colspan="1">Added cut sites per 100 kbp</th>
              <th align="left" rowspan="1" colspan="1">Deleted cut site rate</th>
              <th align="left" colspan="2" rowspan="1">Percent of Rmaps with improved S-score<hr/></th>
              <th align="left" colspan="2" rowspan="1">Mean increase in S-score<hr/></th>
              <th align="left" colspan="2" rowspan="1">CPU time (hours)<hr/></th>
              <th align="left" colspan="2" rowspan="1">Peak memory (GB)<hr/></th>
            </tr>
            <tr>
              <th rowspan="1" colspan="1"/>
              <th rowspan="1" colspan="1"/>
              <th rowspan="1" colspan="1">
                <sc>Elmeri</sc>
              </th>
              <th align="left" rowspan="1" colspan="1">cOMet</th>
              <th align="left" rowspan="1" colspan="1">
                <sc>Elmeri</sc>
              </th>
              <th align="left" rowspan="1" colspan="1">cOMet</th>
              <th align="left" rowspan="1" colspan="1">
                <sc>Elmeri</sc>
              </th>
              <th align="left" rowspan="1" colspan="1">cOMet</th>
              <th align="left" rowspan="1" colspan="1">
                <sc>Elmeri</sc>
              </th>
              <th align="left" rowspan="1" colspan="1">cOMet</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="1" colspan="1">0.5</td>
              <td rowspan="1" colspan="1">15</td>
              <td rowspan="1" colspan="1">93.22</td>
              <td rowspan="1" colspan="1">
                <bold>93.42</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>23.58</bold>
              </td>
              <td rowspan="1" colspan="1">12.46</td>
              <td rowspan="1" colspan="1">
                <bold>10.44</bold>
              </td>
              <td rowspan="1" colspan="1">24.50</td>
              <td rowspan="1" colspan="1">13.67</td>
              <td rowspan="1" colspan="1">
                <bold>7.29</bold>
              </td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">1</td>
              <td rowspan="1" colspan="1">5</td>
              <td rowspan="1" colspan="1">
                <bold>87.98</bold>
              </td>
              <td rowspan="1" colspan="1">87.36</td>
              <td rowspan="1" colspan="1">
                <bold>16.61</bold>
              </td>
              <td rowspan="1" colspan="1">6.30</td>
              <td rowspan="1" colspan="1">
                <bold>18.54</bold>
              </td>
              <td rowspan="1" colspan="1">35.85</td>
              <td rowspan="1" colspan="1">16.11</td>
              <td rowspan="1" colspan="1">
                <bold>8.55</bold>
              </td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1">15</td>
              <td rowspan="1" colspan="1">
                <bold>94.79</bold>
              </td>
              <td rowspan="1" colspan="1">94.01</td>
              <td rowspan="1" colspan="1">
                <bold>24.97</bold>
              </td>
              <td rowspan="1" colspan="1">13.19</td>
              <td rowspan="1" colspan="1">
                <bold>11.90</bold>
              </td>
              <td rowspan="1" colspan="1">28.15</td>
              <td rowspan="1" colspan="1">16.27</td>
              <td rowspan="1" colspan="1">
                <bold>7.56</bold>
              </td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1">25</td>
              <td rowspan="1" colspan="1">
                <bold>96.84</bold>
              </td>
              <td rowspan="1" colspan="1">96.09</td>
              <td rowspan="1" colspan="1">
                <bold>30.76</bold>
              </td>
              <td rowspan="1" colspan="1">17.20</td>
              <td rowspan="1" colspan="1">
                <bold>10.04</bold>
              </td>
              <td rowspan="1" colspan="1">42.20</td>
              <td rowspan="1" colspan="1">15.68</td>
              <td rowspan="1" colspan="1">
                <bold>6.49</bold>
              </td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">2</td>
              <td rowspan="1" colspan="1">5</td>
              <td rowspan="1" colspan="1">
                <bold>90.41</bold>
              </td>
              <td rowspan="1" colspan="1">89.23</td>
              <td rowspan="1" colspan="1">
                <bold>18.13</bold>
              </td>
              <td rowspan="1" colspan="1">7.93</td>
              <td rowspan="1" colspan="1">
                <bold>19.90</bold>
              </td>
              <td rowspan="1" colspan="1">55.01</td>
              <td rowspan="1" colspan="1">20.20</td>
              <td rowspan="1" colspan="1">
                <bold>8.98</bold>
              </td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1">15</td>
              <td rowspan="1" colspan="1">
                <bold>93.68</bold>
              </td>
              <td rowspan="1" colspan="1">92.99</td>
              <td rowspan="1" colspan="1">
                <bold>24.20</bold>
              </td>
              <td rowspan="1" colspan="1">13.36</td>
              <td rowspan="1" colspan="1">
                <bold>16.78</bold>
              </td>
              <td rowspan="1" colspan="1">25.40</td>
              <td rowspan="1" colspan="1">20.14</td>
              <td rowspan="1" colspan="1">
                <bold>7.29</bold>
              </td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1">25</td>
              <td rowspan="1" colspan="1">
                <bold>96.98</bold>
              </td>
              <td rowspan="1" colspan="1">93.02</td>
              <td rowspan="1" colspan="1">
                <bold>31.15</bold>
              </td>
              <td rowspan="1" colspan="1">14.70</td>
              <td rowspan="1" colspan="1">
                <bold>12.99</bold>
              </td>
              <td rowspan="1" colspan="1">66.01</td>
              <td rowspan="1" colspan="1">19.46</td>
              <td rowspan="1" colspan="1">
                <bold>6.87</bold>
              </td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">5</td>
              <td rowspan="1" colspan="1">15</td>
              <td rowspan="1" colspan="1">
                <bold>90.55</bold>
              </td>
              <td rowspan="1" colspan="1">81.35</td>
              <td rowspan="1" colspan="1">
                <bold>15.74</bold>
              </td>
              <td rowspan="1" colspan="1">6.71</td>
              <td rowspan="1" colspan="1">
                <bold>25.92</bold>
              </td>
              <td rowspan="1" colspan="1">143.15</td>
              <td rowspan="1" colspan="1">29.52</td>
              <td rowspan="1" colspan="1">
                <bold>7.83</bold>
              </td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <fn id="tblfn2">
            <p><italic>Note</italic>: For each measured quantity we have highlighted the best result.</p>
          </fn>
        </table-wrap-foot>
      </table-wrap>
      <p><xref rid="btz663-T3" ref-type="table">Table 3</xref> shows the error correction results on the real human and <italic>A.</italic><italic>testudineus</italic> Bionano data. A higher percentage of cOMet corrected Rmaps have an improved S-score but the mean S-score improvement of the <sc>Elmeri</sc> corrected Rmaps is more than 4 times that of cOMet on the human data and almost twice that of cOMet on the <italic>A.</italic><italic>testudineus</italic> data. On the human data <sc>Elmeri</sc> is 16 times faster than cOMet but uses 5 times more memory, whereas on the <italic>A.</italic><italic>testudineus</italic> data <sc>Elmeri</sc> is 34 times faster but uses 10 times more memory.
</p>
      <table-wrap id="btz663-T3" orientation="portrait" position="float">
        <label>Table 3.</label>
        <caption>
          <p>The accuracy, runtime and memory usage of <sc>Elmeri</sc> and cOMet on human Bionano data and on <italic>A.testudineus</italic> genome</p>
        </caption>
        <table frame="hsides" rules="groups">
          <colgroup span="1">
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
          </colgroup>
          <thead>
            <tr>
              <th rowspan="1" colspan="1">Dataset</th>
              <th align="left" colspan="2" rowspan="1">Percent of Rmaps with improved S-score<hr/></th>
              <th align="left" colspan="2" rowspan="1">Mean increase in S-score<hr/></th>
              <th align="left" colspan="2" rowspan="1">CPU time (hours)<hr/></th>
              <th align="left" colspan="2" rowspan="1">Peak memory (GB)<hr/></th>
            </tr>
            <tr>
              <th rowspan="1" colspan="1"/>
              <th rowspan="1" colspan="1">
                <sc>Elmeri</sc>
              </th>
              <th align="left" rowspan="1" colspan="1">cOMet</th>
              <th align="left" rowspan="1" colspan="1">
                <sc>Elmeri</sc>
              </th>
              <th align="left" rowspan="1" colspan="1">cOMet</th>
              <th align="left" rowspan="1" colspan="1">
                <sc>Elmeri</sc>
              </th>
              <th align="left" rowspan="1" colspan="1">cOMet</th>
              <th align="left" rowspan="1" colspan="1">
                <sc>Elmeri</sc>
              </th>
              <th align="left" rowspan="1" colspan="1">cOMet</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="1" colspan="1">Human</td>
              <td rowspan="1" colspan="1">69.21</td>
              <td rowspan="1" colspan="1">
                <bold>74.78</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>11.89</bold>
              </td>
              <td rowspan="1" colspan="1">2.69</td>
              <td rowspan="1" colspan="1">
                <bold>14.76</bold>
              </td>
              <td rowspan="1" colspan="1">236.80</td>
              <td rowspan="1" colspan="1">101.39</td>
              <td rowspan="1" colspan="1">
                <bold>19.51</bold>
              </td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">AnaTes</td>
              <td rowspan="1" colspan="1">59.15</td>
              <td rowspan="1" colspan="1">
                <bold>62.25</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>9.54</bold>
              </td>
              <td rowspan="1" colspan="1">5.00</td>
              <td rowspan="1" colspan="1">
                <bold>214.82</bold>
              </td>
              <td rowspan="1" colspan="1">7430.99</td>
              <td rowspan="1" colspan="1">399.60</td>
              <td rowspan="1" colspan="1">
                <bold>37.61</bold>
              </td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <fn id="tblfn3">
            <p><italic>Note</italic>: For each measured quantity we have highlighted the best result.</p>
          </fn>
        </table-wrap-foot>
      </table-wrap>
      <p>To demonstrate the effect of error correction on assembling Rmap data, we corrected the Ecoli2 dataset with <sc>Elmeri</sc> and cOMet, then assembled the corrected Rmaps using the assembler of <xref rid="btz663-B35" ref-type="bibr">Valouev <italic>et al.</italic> (2006b</xref>). We aligned the assembled maps to the genome-wide optical map using the alignment method of <xref rid="btz663-B34" ref-type="bibr">Valouev <italic>et al.</italic> (2006a</xref>) and calculated the fraction of the genome covered by the assembled maps and the number of missing and added cut sites in the assembled map. <xref rid="btz663-T4" ref-type="table">Table 4</xref> compares these assembled maps directly to the results presented by <xref rid="btz663-B27" ref-type="bibr">Mukherjee <italic>et al.</italic> (2018)</xref>. The Rmaps corrected by <sc>Elmeri</sc> were assembled to a single map, whereas Rmaps corrected by cOMet assembled into two maps. The assembled maps from data corrected by <sc>Elmeri</sc> cover a larger fraction of the genome than assembled maps from cOMet corrected data and the number of missing and added cut sites in assembled maps produced from <sc>Elmeri</sc> corrected data is also less than third of those assembled from cOMet corrected Rmaps.
</p>
      <table-wrap id="btz663-T4" orientation="portrait" position="float">
        <label>Table 4.</label>
        <caption>
          <p>Assembly results for uncorrected Rmaps, Rmaps corrected by cOMet and <sc>Elmeri</sc> and errorfree Rmaps</p>
        </caption>
        <table frame="hsides" rules="groups">
          <colgroup span="1">
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="center" span="1"/>
          </colgroup>
          <thead>
            <tr>
              <th rowspan="1" colspan="1">Rmap status</th>
              <th align="left" rowspan="1" colspan="1">Number of assembled maps</th>
              <th align="left" rowspan="1" colspan="1">Genome coverage</th>
              <th align="left" rowspan="1" colspan="1">Missing/added cut sites</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="1" colspan="1">Uncorrected</td>
              <td rowspan="1" colspan="1">5</td>
              <td rowspan="1" colspan="1">81.2</td>
              <td rowspan="1" colspan="1">47</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Corrected by cOMet</td>
              <td rowspan="1" colspan="1">2</td>
              <td rowspan="1" colspan="1">82.2</td>
              <td rowspan="1" colspan="1">34</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Corrected by <sc>Elmeri</sc></td>
              <td rowspan="1" colspan="1">
                <bold>1</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>86.2</bold>
              </td>
              <td rowspan="1" colspan="1">10</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Error free</td>
              <td rowspan="1" colspan="1">3</td>
              <td rowspan="1" colspan="1">79.6</td>
              <td rowspan="1" colspan="1">
                <bold>1</bold>
              </td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <fn id="tblfn4">
            <p><italic>Note</italic>: The results for uncorrected Rmaps, Rmaps corrected by cOMet and errorfree Rmaps are directly from <xref rid="btz663-B27" ref-type="bibr">Mukherjee <italic>et al.</italic> (2018)</xref>. We have highlighted the best results for each column.</p>
          </fn>
        </table-wrap-foot>
      </table-wrap>
    </sec>
  </sec>
  <sec>
    <title>6 Conclusion</title>
    <p>Finding similar Rmaps is a fundamental step in many problems on optical mapping data such as finding pairwise alignments between Rmaps, aligning Rmaps against a reference and correcting errors in Rmaps. We have extended the notion of spaced seeds to optical mapping data by defining spaced (<italic>ℓ</italic>, <italic>k</italic>)-mers. We show that indexing spaced (<italic>ℓ</italic>, <italic>k</italic>)-mers more than doubles the recall for retrieving related Rmaps as compared to the previously introduced <italic>k</italic>-mer indexing.</p>
    <p>We have also presented a simulated annealing based method for optimizing the spacing pattern. Further work in this direction includes studying the use of multiple spacing patterns as well as seed design in general. Many optimization techniques developed for spaced seeds in homology search, such as overlap complexity (<xref rid="btz663-B13" ref-type="bibr">Ilie and Ilie, 2007</xref>) and quadratic residual seeds (<xref rid="btz663-B11" ref-type="bibr">Egidi and Manzini, 2013</xref>), are likely applicable also in our setting. We apply spaced (<italic>ℓ</italic>, <italic>k</italic>)-mer based retrieval of related Rmaps to correcting Rmaps. We give results demonstrating that on a human dataset <sc>Elmeri</sc> is 16 times faster than cOMet, the only previous method for correcting Rmap data. We also show the alignment scores of Rmaps corrected by <sc>Elmeri</sc> improve more than four times on the scores for Rmaps corrected by cOMet. We note that <sc>Elmeri</sc> uses more memory than cOMet and suggest that the index structures used by <sc>Elmeri</sc> could be optimized to reduce the memory footprint. Lastly, we suggest that another direction for future work is to apply spaced (<italic>ℓ</italic>, <italic>k</italic>)-mers to other analysis problems that use optical mapping data, namely, Rmap alignment problems.</p>
  </sec>
  <sec>
    <title>Funding</title>
    <p>This work was supported by Academy of Finland (grants 308030 and 314170 to L.S. and grants 294143 and 319454 to S.J.P.) and the National Science Foundation (NSF) IIS (Grant No. 1618814 to C.B., L.S. and S.J.P.).</p>
    <p><italic>Conflict of Interest</italic>: K.M. has done an internship at Bionano.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material content-type="local-data" id="sup1">
      <label>btz663_Supplementary_File</label>
      <media xlink:href="btz663_supplementary_file.pdf">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
  </sec>
</body>
<back>
  <ref-list id="ref1">
    <title>References</title>
    <ref id="btz663-B1">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Altschul</surname><given-names>S.F.</given-names></name></person-group><etal>et al</etal> (<year>1990</year>) 
<article-title>Basic local alignment search tool</article-title>. <source>J. Mol. Biol</source>., <volume>215</volume>, <fpage>403</fpage>–<lpage>410</lpage>.<pub-id pub-id-type="pmid">2231712</pub-id></mixed-citation>
    </ref>
    <ref id="btz663-B2">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Beier</surname><given-names>S.</given-names></name></person-group><etal>et al</etal> (<year>2017</year>) 
<article-title>Construction of a map-based reference genome sequence for barley, <italic>Hordeum vulgare</italic> L</article-title>. <source>Sci. Data</source>, <volume>4</volume>, <fpage>170044.</fpage><pub-id pub-id-type="pmid">28448065</pub-id></mixed-citation>
    </ref>
    <ref id="btz663-B3">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Brejová</surname><given-names>B.</given-names></name></person-group><etal>et al</etal> (<year>2003</year>) 
<article-title>Optimal spaced seeds for hidden Markov models, with application to homologous coding regions</article-title>. In: <source>Proc. of CPM</source>, pp. <fpage>42</fpage>–<lpage>54</lpage>.</mixed-citation>
    </ref>
    <ref id="btz663-B4">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Buhler</surname><given-names>J.</given-names></name></person-group><etal>et al</etal> (<year>2005</year>) 
<article-title>Designing seeds for similarity search in genomic DNA</article-title>. <source>J. Comput. Syst. Sci</source>., <volume>70</volume>, <fpage>342</fpage>–<lpage>363</lpage>.</mixed-citation>
    </ref>
    <ref id="btz663-B5">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Burkhardt</surname><given-names>S.</given-names></name>, <name name-style="western"><surname>Kärkkäinen</surname><given-names>J.</given-names></name></person-group> (<year>2003</year>) 
<article-title>Better filtering with gapped q-grams</article-title>. <source>Fundamenta Informaticae</source>, <volume>56</volume>, <fpage>51</fpage>–<lpage>70</lpage>.</mixed-citation>
    </ref>
    <ref id="btz663-B6">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Chaisson</surname><given-names>M.J.</given-names></name>, <name name-style="western"><surname>Tesler</surname><given-names>G.</given-names></name></person-group> (<year>2012</year>) 
<article-title>Mapping single molecule sequencing reads using basic local alignment with successive refinement (BLASR): application and theory</article-title>. <source>BMC Bioinformatics</source>, <volume>13</volume>, <fpage>238.</fpage><pub-id pub-id-type="pmid">22988817</pub-id></mixed-citation>
    </ref>
    <ref id="btz663-B7">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Choi</surname><given-names>K.P.</given-names></name></person-group><etal>et al</etal> (<year>2004</year>) 
<article-title>Good spaced seeds for homology search</article-title>. <source>Bioinformatics</source>, <volume>20</volume>, <fpage>1053</fpage>–<lpage>1059</lpage>.<pub-id pub-id-type="pmid">14764573</pub-id></mixed-citation>
    </ref>
    <ref id="btz663-B8">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Daccord</surname><given-names>N.</given-names></name></person-group><etal>et al</etal> (<year>2017</year>) 
<article-title>High-quality <italic>de novo</italic> assembly of the apple genome and methylome dynamics of early fruit development</article-title>. <source>Nat. Genet</source>., <volume>49</volume>, <fpage>1099</fpage>–<lpage>1106</lpage>.<pub-id pub-id-type="pmid">28581499</pub-id></mixed-citation>
    </ref>
    <ref id="btz663-B9">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Dimalanta</surname><given-names>E.T.</given-names></name></person-group><etal>et al</etal> (<year>2004</year>) 
<article-title>A microfluidic system for large DNA molecule arrays</article-title>. <source>Anal. Chem</source>., <volume>76</volume>, <fpage>5293</fpage>–<lpage>5301</lpage>.<pub-id pub-id-type="pmid">15362885</pub-id></mixed-citation>
    </ref>
    <ref id="btz663-B10">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Dong</surname><given-names>Y.</given-names></name></person-group><etal>et al</etal> (<year>2013</year>) 
<article-title>Sequencing and automated whole-genome optical mapping of the genome of a domestic goat (<italic>Capra hircus</italic>)</article-title>. <source>Nat. Biotechnol</source>., <volume>31</volume>, <fpage>135</fpage>–<lpage>141</lpage>.<pub-id pub-id-type="pmid">23263233</pub-id></mixed-citation>
    </ref>
    <ref id="btz663-B11">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Egidi</surname><given-names>L.</given-names></name>, <name name-style="western"><surname>Manzini</surname><given-names>G.</given-names></name></person-group> (<year>2013</year>) 
<article-title>Better spaced seeds using quadratic residues</article-title>. <source>J. Comput. Syst. Sci</source>., <volume>79</volume>, <fpage>1144</fpage>–<lpage>1155</lpage>.</mixed-citation>
    </ref>
    <ref id="btz663-B12">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Ganapathy</surname><given-names>G.</given-names></name></person-group><etal>et al</etal> (<year>2014</year>) 
<article-title>High-coverage sequencing and annotated assemblies of the budgerigar genome</article-title>. <source>GigaScience</source>, <volume>3</volume>, <fpage>11.</fpage><pub-id pub-id-type="pmid">25061512</pub-id></mixed-citation>
    </ref>
    <ref id="btz663-B13">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Ilie</surname><given-names>L.</given-names></name>, <name name-style="western"><surname>Ilie</surname><given-names>S.</given-names></name></person-group> (<year>2007</year>) 
<article-title>Multiple spaced seeds for homology search</article-title>. <source>Bioinformatics</source>, <volume>23</volume>, <fpage>2969</fpage>–<lpage>2977</lpage>.<pub-id pub-id-type="pmid">17804438</pub-id></mixed-citation>
    </ref>
    <ref id="btz663-B14">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Jarvis</surname><given-names>D.E.</given-names></name></person-group><etal>et al</etal> (<year>2017</year>) 
<article-title>The genome of <italic>Chenopodium quinoa</italic></article-title>. <source>Nature</source>, <volume>542</volume>, <fpage>307</fpage>–<lpage>312</lpage>.<pub-id pub-id-type="pmid">28178233</pub-id></mixed-citation>
    </ref>
    <ref id="btz663-B15">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Keich</surname><given-names>U.</given-names></name></person-group><etal>et al</etal> (<year>2004</year>) 
<article-title>On spaced seeds for similarity search</article-title>. <source>Discret. Appl. Math</source>., <volume>138</volume>, <fpage>253</fpage>–<lpage>263</lpage>.</mixed-citation>
    </ref>
    <ref id="btz663-B16">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Leung</surname><given-names>A.K.-Y.</given-names></name></person-group><etal>et al</etal> (<year>2017</year>) 
<article-title>OMBlast: alignment tool for optical mapping using a seed-and-extend approach</article-title>. <source>Bioinformatics</source>, <volume>33</volume>, <fpage>311</fpage>–<lpage>319</lpage>.<pub-id pub-id-type="pmid">28172448</pub-id></mixed-citation>
    </ref>
    <ref id="btz663-B17">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Li</surname><given-names>M.</given-names></name></person-group><etal>et al</etal> (<year>2016</year>) 
<article-title>Towards a more accurate error model for BioNano optical maps</article-title>. In: <source>Proc of ISBRA</source>, pp. <fpage>67</fpage>–<lpage>79</lpage>.</mixed-citation>
    </ref>
    <ref id="btz663-B18">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Li</surname><given-names>M.</given-names></name></person-group><etal>et al</etal> (<year>2004</year>) 
<article-title>PatternHunter II: highly sensitive and fast homology search</article-title>. <source>J. Bioinf. Comput. Biol</source>., <volume>2</volume>, <fpage>417</fpage>–<lpage>439</lpage>.</mixed-citation>
    </ref>
    <ref id="btz663-B19">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Lin</surname><given-names>H.C.</given-names></name></person-group><etal>et al</etal> (<year>2012</year>) 
<article-title>AGORA: assembly guided by optical restriction alignment</article-title>. <source>BMC Bioinformatics</source>, <volume>13</volume>, <fpage>189.</fpage><pub-id pub-id-type="pmid">22856673</pub-id></mixed-citation>
    </ref>
    <ref id="btz663-B20">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Lin</surname><given-names>J.</given-names></name></person-group><etal>et al</etal> (<year>1999</year>) 
<article-title>Whole-genome shotgun optical mapping of <italic>Deinococcus radiodurans</italic></article-title>. <source>Science</source>, <volume>285</volume>, <fpage>1558</fpage>–<lpage>1562</lpage>.<pub-id pub-id-type="pmid">10477518</pub-id></mixed-citation>
    </ref>
    <ref id="btz663-B21">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Ma</surname><given-names>B.</given-names></name></person-group><etal>et al</etal> (<year>2002</year>) 
<article-title>PatternHunter: faster and more sensitive homology search</article-title>. <source>Bioinformatics</source>, <volume>18</volume>, <fpage>440</fpage>–<lpage>445</lpage>.<pub-id pub-id-type="pmid">11934743</pub-id></mixed-citation>
    </ref>
    <ref id="btz663-B22">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Mendelowitz</surname><given-names>L.M.</given-names></name></person-group><etal>et al</etal> (<year>2016</year>) 
<article-title>Maligner: a fast ordered restriction map aligner</article-title>. <source>Bioinformatics</source>, <volume>32</volume>, <fpage>1016</fpage>–<lpage>1022</lpage>.<pub-id pub-id-type="pmid">26637292</pub-id></mixed-citation>
    </ref>
    <ref id="btz663-B23">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Miclotte</surname><given-names>G.</given-names></name></person-group><etal>et al</etal> (<year>2017</year>) 
<article-title>OMSim: a simulator for optical map data</article-title>. <source>Bioinformatics</source>, <volume>33</volume>, <fpage>2740</fpage>–<lpage>2742</lpage>.<pub-id pub-id-type="pmid">28472230</pub-id></mixed-citation>
    </ref>
    <ref id="btz663-B24">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Muggli</surname><given-names>M.D.</given-names></name></person-group><etal>et al</etal> (<year>2014</year>) 
<article-title>Efficient indexed alignment of contigs to optical maps</article-title>. In: <source>Proc of WABI</source>, pp. <fpage>68</fpage>–<lpage>81</lpage>.</mixed-citation>
    </ref>
    <ref id="btz663-B25">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Muggli</surname><given-names>M.D.</given-names></name></person-group><etal>et al</etal> (<year>2018</year>) 
<article-title>A succinct solution to Rmap alignment</article-title>. In: <source>Proc of WABI</source>, pp. <fpage>12.1</fpage>–<lpage>12.16</lpage>.</mixed-citation>
    </ref>
    <ref id="btz663-B26">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Muggli</surname><given-names>M.D.</given-names></name></person-group><etal>et al</etal> (<year>2015</year>) 
<article-title>Misassembly detection using paired-end sequence reads and optical mapping data</article-title>. <source>Bioinformatics</source>, <volume>31</volume>, <fpage>i80</fpage>–<lpage>i88</lpage>.<pub-id pub-id-type="pmid">26072512</pub-id></mixed-citation>
    </ref>
    <ref id="btz663-B27">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Mukherjee</surname><given-names>K.</given-names></name></person-group><etal>et al</etal> (<year>2018</year>) 
<article-title>Error correcting optical mapping data</article-title>. <source>GigaScience</source>, <volume>7</volume>, <fpage>giy061.</fpage></mixed-citation>
    </ref>
    <ref id="btz663-B28">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Nagarajan</surname><given-names>N.</given-names></name></person-group><etal>et al</etal> (<year>2008</year>) 
<article-title>Scaffolding and validation of bacterial genome assemblies using optical restriction maps</article-title>. <source>Bioinformatics</source>, <volume>24</volume>, <fpage>1229</fpage>–<lpage>1235</lpage>.<pub-id pub-id-type="pmid">18356192</pub-id></mixed-citation>
    </ref>
    <ref id="btz663-B29">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Needleman</surname><given-names>S.B.</given-names></name>, <name name-style="western"><surname>Wunsch</surname><given-names>C.D.</given-names></name></person-group> (<year>1970</year>) 
<article-title>A general method applicable to the search for similarities in the amino acid sequence of two proteins</article-title>. <source>J. Mol. Biol</source>., <volume>48</volume>, <fpage>443</fpage>–<lpage>453</lpage>.<pub-id pub-id-type="pmid">5420325</pub-id></mixed-citation>
    </ref>
    <ref id="btz663-B30">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Pan</surname><given-names>W.</given-names></name></person-group><etal>et al</etal> (<year>2019</year>) 
<article-title>OMGS: optical map-based genome scaffolding</article-title>. In: <source>Proc. of RECOMB</source>.</mixed-citation>
    </ref>
    <ref id="btz663-B31">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Samad</surname><given-names>A.</given-names></name></person-group><etal>et al</etal> (<year>1995</year>) 
<article-title>Optical mapping: a novel, single-molecule approach to genomic analysis</article-title>. <source>Genome Res</source>., <volume>5</volume>, <fpage>1</fpage>–<lpage>4</lpage>.<pub-id pub-id-type="pmid">8717049</pub-id></mixed-citation>
    </ref>
    <ref id="btz663-B32">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Shi</surname><given-names>L.</given-names></name></person-group><etal>et al</etal> (<year>2016</year>) 
<article-title>Long-read sequencing and <italic>de novo</italic> assembly of a Chinese genome</article-title>. <source>Nat. Commun</source>., <volume>7</volume>, <fpage>12065.</fpage><pub-id pub-id-type="pmid">27356984</pub-id></mixed-citation>
    </ref>
    <ref id="btz663-B33">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Teague</surname><given-names>B.</given-names></name></person-group><etal>et al</etal> (<year>2010</year>) 
<article-title>High-resolution human genome structure by single-molecule analysis</article-title>. <source>Proc. Natl. Acad. Sci. USA</source>, <volume>107</volume>, <fpage>10848</fpage>–<lpage>10853</lpage>.<pub-id pub-id-type="pmid">20534489</pub-id></mixed-citation>
    </ref>
    <ref id="btz663-B34">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Valouev</surname><given-names>A.</given-names></name></person-group><etal>et al</etal> (<year>2006a</year>) 
<article-title>Alignment of optical maps</article-title>. <source>J. Comput. Biol</source>., <volume>13</volume>, <fpage>442</fpage>–<lpage>462</lpage>.<pub-id pub-id-type="pmid">16597251</pub-id></mixed-citation>
    </ref>
    <ref id="btz663-B35">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Valouev</surname><given-names>A.</given-names></name></person-group><etal>et al</etal> (<year>2006b</year>) 
<article-title>An algorithm for assembly of ordered restriction maps from single DNA molecules</article-title>. <source>Proc. Natl. Acad. Sci. USA</source>, <volume>103</volume>, <fpage>15770</fpage>–<lpage>15775</lpage>.<pub-id pub-id-type="pmid">17043225</pub-id></mixed-citation>
    </ref>
    <ref id="btz663-B36">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Vij</surname><given-names>S.</given-names></name></person-group><etal>et al</etal> (<year>2016</year>) 
<article-title>Chromosomal-level assembly of the Asian seabass genome using long sequence reads and multi-layered scaffolding</article-title>. <source>PLoS Genet</source>., <volume>12</volume>, <fpage>e1005954.</fpage><pub-id pub-id-type="pmid">27082250</pub-id></mixed-citation>
    </ref>
  </ref-list>
</back>
