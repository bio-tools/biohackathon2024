<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Archiving and Interchange DTD v1.1 20151215//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-archivearticle1.dtd?>
<?SourceDTD.Version 1.1?>
<?ConverterInfo.XSLTName jp2nlmx2.xsl?>
<?ConverterInfo.Version 1?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">PLoS One</journal-id>
    <journal-id journal-id-type="iso-abbrev">PLoS ONE</journal-id>
    <journal-id journal-id-type="publisher-id">plos</journal-id>
    <journal-id journal-id-type="pmc">plosone</journal-id>
    <journal-title-group>
      <journal-title>PLoS ONE</journal-title>
    </journal-title-group>
    <issn pub-type="epub">1932-6203</issn>
    <publisher>
      <publisher-name>Public Library of Science</publisher-name>
      <publisher-loc>San Francisco, USA</publisher-loc>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">3877093</article-id>
    <article-id pub-id-type="pmid">24391826</article-id>
    <article-id pub-id-type="publisher-id">PONE-D-13-31592</article-id>
    <article-id pub-id-type="doi">10.1371/journal.pone.0083784</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Research Article</subject>
      </subj-group>
      <subj-group subj-group-type="Discipline-v2">
        <subject>Biology</subject>
        <subj-group>
          <subject>Computational Biology</subject>
          <subj-group>
            <subject>Genomics</subject>
            <subj-group>
              <subject>Genome Sequencing</subject>
            </subj-group>
          </subj-group>
        </subj-group>
        <subj-group>
          <subject>Genomics</subject>
          <subj-group>
            <subject>Genome Sequencing</subject>
          </subj-group>
        </subj-group>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Low-Bandwidth and Non-Compute Intensive Remote Identification of Microbes from Raw Sequencing Reads</article-title>
      <alt-title alt-title-type="running-head">Identification of Raw Sequencing Reads</alt-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Gautier</surname>
          <given-names>Laurent</given-names>
        </name>
        <xref ref-type="aff" rid="aff1">
          <sup>1</sup>
        </xref>
        <xref ref-type="aff" rid="aff2">
          <sup>2</sup>
        </xref>
        <xref ref-type="corresp" rid="cor1">
          <sup>*</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Lund</surname>
          <given-names>Ole</given-names>
        </name>
        <xref ref-type="aff" rid="aff1">
          <sup>1</sup>
        </xref>
      </contrib>
    </contrib-group>
    <aff id="aff1">
      <label>1</label>
      <addr-line>Center for Biological Sequence Analysis (CBS), Department of Systems Biology, Technical University of Denmark, Lyngby, Denmark</addr-line>
    </aff>
    <aff id="aff2">
      <label>2</label>
      <addr-line>DTU Multiassay Core (DMAC), Technical University of Denmark, Lyngby, Denmark</addr-line>
    </aff>
    <contrib-group>
      <contrib contrib-type="editor">
        <name>
          <surname>Hubbard</surname>
          <given-names>Tim J.</given-names>
        </name>
        <role>Editor</role>
        <xref ref-type="aff" rid="edit1"/>
      </contrib>
    </contrib-group>
    <aff id="edit1">
      <addr-line>Wellcome Trust Sanger Institute, United Kingdom</addr-line>
    </aff>
    <author-notes>
      <corresp id="cor1">* E-mail: <email>laurent@cbs.dtu.dk</email></corresp>
      <fn fn-type="COI-statement">
        <p><bold>Competing Interests: </bold>The authors have the following interests. The following patent application related to the work presented has been filed: Database-driven Primary Analysis of Raw Sequencing Data, PCT/EP2013/071280. This does not alter the authors' adherence to all the PLOS ONE policies on sharing data and materials.</p>
      </fn>
      <fn fn-type="con">
        <p>Conceived and designed the experiments: LG. Performed the experiments: LG. Analyzed the data: LG. Contributed reagents/materials/analysis tools: LG OL. Wrote the paper: LG.</p>
      </fn>
    </author-notes>
    <pub-date pub-type="collection">
      <year>2013</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>31</day>
      <month>12</month>
      <year>2013</year>
    </pub-date>
    <volume>8</volume>
    <issue>12</issue>
    <elocation-id>e83784</elocation-id>
    <history>
      <date date-type="received">
        <day>25</day>
        <month>6</month>
        <year>2013</year>
      </date>
      <date date-type="accepted">
        <day>21</day>
        <month>10</month>
        <year>2013</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© 2013 Gautier, Lund</copyright-statement>
      <copyright-year>2013</copyright-year>
      <copyright-holder>Gautier, Lund</copyright-holder>
      <license xlink:href="http://creativecommons.org/licenses/by/4.0/">
        <license-p>This is an open-access article distributed under the terms of the Creative Commons Attribution License, which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are properly credited.</license-p>
      </license>
    </permissions>
    <abstract>
      <p>Cheap DNA sequencing may soon become routine not only for human genomes but also for practically anything requiring the identification of living organisms from their DNA: tracking of infectious agents, control of food products, bioreactors, or environmental samples. We propose a novel general approach to the analysis of sequencing data where a reference genome does not have to be specified. Using a distributed architecture we are able to query a remote server for hints about what the reference might be, transferring a relatively small amount of data. Our system consists of a server with known reference DNA indexed, and a client with raw sequencing reads. The client sends a sample of unidentified reads, and in return receives a list of matching references. Sequences for the references can be retrieved and used for exhaustive computation on the reads, such as alignment. To demonstrate this approach we have implemented a web server, indexing tens of thousands of publicly available genomes and genomic regions from various organisms and returning lists of matching hits from query sequencing reads. We have also implemented two clients: one running in a web browser, and one as a python script. Both are able to handle a large number of sequencing reads and from portable devices (the browser-based running on a tablet), perform its task within seconds, and consume an amount of bandwidth compatible with mobile broadband networks. Such client-server approaches could develop in the future, allowing a fully automated processing of sequencing data and routine instant quality check of sequencing runs from desktop sequencers. A web access is available at <ext-link ext-link-type="uri" xlink:href="http://tapir.cbs.dtu.dk">http://tapir.cbs.dtu.dk</ext-link>. The source code for a python command-line client, a server, and supplementary data are available at <ext-link ext-link-type="uri" xlink:href="http://bit.ly/1aURxkc">http://bit.ly/1aURxkc</ext-link>.</p>
    </abstract>
    <funding-group>
      <funding-statement>Laurent Gautier's work was supported by the DTU Multi-Assay Core funded by the Technical University of Denmark, and Ole Lund was funded by grant 09-067103/DSF from the Danish Council for Strategic Research. The funders had no role in study design, data collection and analysis, decision to publish, or preparation of the manuscript.</funding-statement>
    </funding-group>
    <counts>
      <page-count count="10"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec id="s1">
    <title>Introduction</title>
    <p>The sequencing of DNA has become increasingly affordable during the last decade <xref rid="pone.0083784-Shendure1" ref-type="bibr">[1]</xref> and modern high-end sequencers have the capacity to process the equivalent of several human genomes or several hundred bacteria. Current desktop sequencers require limited initial investments, and are providing flexibility over sequencing volumes. The sequencing of complete bacterial genomes from isolates can be performed in a day. Recent announcements on nanopore sequencing <xref rid="pone.0083784-Rusk1" ref-type="bibr">[2]</xref> are even suggesting that sequencers could be so cheap that they would be disposable. Extracting DNA is itself a relatively simple procedure, and it is foreseeable that DNA sequencing will soon be a relatively cheap routine procedure in molecular biology. Patients will be sequenced routinely, outbreaks of infectious agents traced by their DNA, quality of water and food also monitored with DNA sequencing.</p>
    <p>On the analytic side, local alignment of sequences, with pioneering tools such as the Smith-Waterman algorithm <xref rid="pone.0083784-Smith1" ref-type="bibr">[3]</xref>, has been a cornerstone of bioinformatics. Once applied between a query and a collection of references it allowed the scoring and ranking of alignments, letting researchers infer the origin and function of newly sequenced DNA or RNA from its similarity to already existing sequences. Although the methodology has come under criticism for being inaccurate at times <xref rid="pone.0083784-Devos1" ref-type="bibr">[4]</xref>, <xref rid="pone.0083784-Rost1" ref-type="bibr">[5]</xref>, its popularity remains indisputable with a large number of functional annotations in public databases having the mention ‘by sequence homology’. However, aligning newly obtained DNA to existing references archived in database remains a relatively demanding computational task. BLAST <xref rid="pone.0083784-Altschul1" ref-type="bibr">[6]</xref> and later BLAT <xref rid="pone.0083784-Kent1" ref-type="bibr">[7]</xref> increased the speed at which alignments can be done, although at the cost accuracy, yet with the number of sequences currently available searching a sequence against the pool of known sequences still requires significant compute ressources, and despite all its computing power the NCBI do not recommend submitting to their servers more than 50 query sequences at once. New tools designed for short-read sequencing have since been developed, such as Bowtie <xref rid="pone.0083784-Langmead1" ref-type="bibr">[8]</xref>, BWA <xref rid="pone.0083784-Li1" ref-type="bibr">[9]</xref>, and SHRiMP <xref rid="pone.0083784-Rumble1" ref-type="bibr">[10]</xref> to name only a few, but these tools are designed to align all sequencing reads against a given known reference. Li <italic>et al </italic>
<xref rid="pone.0083784-Li2" ref-type="bibr">[11]</xref> can be consulted for a more comprehensive review of short-read aligners. In order to achieve speed, such tools load an index of the reference into memory, and thus limit the amount of reference DNA that can be handled unless costly computing infrastructure with a lot of shared memory is used.</p>
  </sec>
  <sec id="s2">
    <title>Results</title>
    <sec id="s2a">
      <title>Matching a sample of sequencing reads against a comprehensive collection of references</title>
      <p>A subjective way of looking at the alignment programs is to split them into two main categories: the ones designed to map one query sequence against a collection of known reference (e.g., BLAST), and the ones designed to map a large number of short sequences against one specified reference as quickly as possible (e.g., bowtie or BWA). We propose an intermediate approach in which candidate references are quickly identified before more detailed work, such as aligning the reads, is performed. We use a small random sample of initial data to query a server acting as a <italic>DNA search engine</italic>, thus consuming a small amount of bandwidth when compared to approaches that transfer all sequencing data to computation servers. Using synthetic reads generated from full genomes, we demonstrate that identifying a pure culture from raw DNA sequencing reads can be achieved with 100 random reads.</p>
      <p>When building the database of references, we do not require a feature selection step and the building of a classifier. We simply index <italic>k</italic>-mers found in the reference genomes, simplifying greatly the complexity of the procedure. This comes at the cost of space usage, with potentially less informative <italic>k</italic>-mers being indexed, but also comes with the advantage of being linear in the total size for the collection of references and relatively easy to parallelize. This makes the indexing of all known DNA, like web search engines index all documents on the internet, a plausible eventuality.</p>
      <p>Our approach also differs from alignment algorithms, in which one sequence is matched against a collection of reference sequences, as we consider several sequences (sequencing reads) against a collection of reference sequences, and vote which references are most representative of the query set. Each read sent to the server is matched against the reference sequences, and a summary of candidate DNA references over all the reads is returned.</p>
      <p>The matching of reads is done by splitting them into overlapping <italic>k</italic>-mers and searching whether <italic>k</italic>-mers are associated with a reference. <italic>k</italic>-mers are not disssociated from the sequencing read they come from and we are looking for clusters of matching <italic>k</italic>-mers, close to one another although not necessarily in the same order on both the query read and the reference sequence, as shown in <xref ref-type="fig" rid="pone-0083784-g001">Figure 1</xref>.</p>
      <fig id="pone-0083784-g001" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.1371/journal.pone.0083784.g001</object-id>
        <label>Figure 1</label>
        <caption>
          <title>Overview of the indexing and scoring procedures.</title>
          <p>(A) During the indexing of a collection of reference sequences, non-overlapping <italic>k</italic>-mers are indexed into two distinct key-value stores, one associating <italic>k</italic>-mers with the references they were found in (‘presence’) and one associating <italic>k</italic>-mers with the position in the reference at which the k-mer was found (‘position’). (B) When processing a sequencing read in a query set, overlapping <italic>k</italic>-mers are looked up in the ‘presence’ store. Using overlapping <italic>k</italic>-mers allows to resolve relatively rapidly misalignments between the beginning of the read and the beginning of the reference sequence (dotted lines). On the figure, only <italic>k</italic>-mers in red are in phase with the indexing step, therefore only those can be found in ‘presence’. (C) For a given read, a threshold is applied to retain only references potentially matching enough of the read. Situations where very large references containing disjoint scattered <italic>k</italic>-mers, such as a bacterial read against a mammalian genome, are resolved in the last step where the ‘position’ store is queried.</p>
        </caption>
        <graphic xlink:href="pone.0083784.g001"/>
      </fig>
      <p>We currently use non-overlapping <italic>k</italic>-mers for the indexing while we use overlapping <italic>k</italic>-mers in the queries, but we consider this an implementation detail. We could easily use overlapping <italic>k</italic>-mers for the indexing and non-overlapping <italic>k</italic>-mers in the queries while keeping the same guiding principles for giving scores to matching references. The trade-off is that non-overlapping <italic>k</italic>-mers in the database take less space, but will necessitate more queries since the <italic>k</italic>-mers in the reads will have to be overlapping.</p>
      <p>When having a query set of DNA data to identify, such as raw reads from a sequencer for the purpose of diagnostics, we consider the brute-force approach that consists in mapping all reads against comprehensive reference databases to have two main disadvantages: hundreds of megabytes or gigabytes of data must be transferred from the sequencing facility to a computing center, and the computing resources necessary to perform the task are significant. Assuming that a reference collection contains 10,000 <italic>E.coli</italic>-sized bacteria and that it takes 30 seconds for an optimized aligner such as BWA or bowtie2 to process 250 Mbases of raw sequencing data (about 60x in average coverage if the genome is 4 Mbases in size), it would take 3.5 days on a CPU, although this could be parallelized trivially on multiple CPUs. Refinements such as the the concatenation of the genomes, or the use of a generalized suffix arrays can be made but at the cost of requiring ever increasing amounts of memory for a given monilithic index, particularly for the suffix and post-processing computation to assign mapping positions to initial reference genomes, and inevitable multiple matches as close genomes are referenced, something that short read aligners do not report by default <xref rid="pone.0083784-Hoffimann1" ref-type="bibr">[12]</xref>. The time complexity of locating the <inline-formula><inline-graphic xlink:href="pone.0083784.e001.jpg"/></inline-formula> occurrences of a string of length <inline-formula><inline-graphic xlink:href="pone.0083784.e002.jpg"/></inline-formula> in a reference of size <inline-formula><inline-graphic xlink:href="pone.0083784.e003.jpg"/></inline-formula> using an FM-Index has an upper bound of <inline-formula><inline-graphic xlink:href="pone.0083784.e004.jpg"/></inline-formula>
<xref rid="pone.0083784-Ferragina1" ref-type="bibr">[13]</xref>, meaning that although the complexity grows slowly as the size of the reference increases, with a term in <inline-formula><inline-graphic xlink:href="pone.0083784.e005.jpg"/></inline-formula> (<inline-formula><inline-graphic xlink:href="pone.0083784.e006.jpg"/></inline-formula>), it grows linearly with the number of highly similar genomes (leading to multiple occurences). Of noteworthy interest is the similarity in time complexity for locating the <inline-formula><inline-graphic xlink:href="pone.0083784.e007.jpg"/></inline-formula> occurrences of a string of length <inline-formula><inline-graphic xlink:href="pone.0083784.e008.jpg"/></inline-formula> in a B-tree indexing non-overlapping <italic>k</italic>-mers in <inline-formula><inline-graphic xlink:href="pone.0083784.e009.jpg"/></inline-formula> as we have implemented it. The time complexity for searching one of the <inline-formula><inline-graphic xlink:href="pone.0083784.e010.jpg"/></inline-formula> non-overlapping <italic>k</italic>-mers indexed is <inline-formula><inline-graphic xlink:href="pone.0083784.e011.jpg"/></inline-formula>
<xref rid="pone.0083784-Cormen1" ref-type="bibr">[14]</xref>, to which iterating through already sorted <inline-formula><inline-graphic xlink:href="pone.0083784.e012.jpg"/></inline-formula> matching positions must be added: <inline-formula><inline-graphic xlink:href="pone.0083784.e013.jpg"/></inline-formula>. This is repeated for the <inline-formula><inline-graphic xlink:href="pone.0083784.e014.jpg"/></inline-formula> overlapping <italic>k</italic>-mers in the query sequence: <inline-formula><inline-graphic xlink:href="pone.0083784.e015.jpg"/></inline-formula>. Time complexity for exact matches is clearly in favour of the FM-Index, but the sampling keeps the number of strings to look up rather low and the existing B-tree in NoSQL solutions allowed us to quickly implement a working prototype. Furthermore, when one considers that we do not have one reference of size <inline-formula><inline-graphic xlink:href="pone.0083784.e016.jpg"/></inline-formula> but <inline-formula><inline-graphic xlink:href="pone.0083784.e017.jpg"/></inline-formula> references of average size <inline-formula><inline-graphic xlink:href="pone.0083784.e018.jpg"/></inline-formula>, and that we need to keep track of which reference is matching, the naive approach evoked earlier becomes <inline-formula><inline-graphic xlink:href="pone.0083784.e019.jpg"/></inline-formula> (each reference matched in turn) while an approach using concatenation of the references and a <italic>post hoc</italic> assignment of the matches to the corresponding reference sequences using a binary search would run in <inline-formula><inline-graphic xlink:href="pone.0083784.e020.jpg"/></inline-formula>, or <inline-formula><inline-graphic xlink:href="pone.0083784.e021.jpg"/></inline-formula>. Burrow-Wheeler based mapping algorithms have largely focused on putting data in memory to achieve speed, historically with the goal of having a human genome fit in the RAM of cluster nodes prevalent at the time <xref rid="pone.0083784-Langmead1" ref-type="bibr">[8]</xref>, although more recent efforts have looked at applying them to increasingly large collections of sequences <xref rid="pone.0083784-Cox1" ref-type="bibr">[15]</xref>, while our approach embraces the perspective of enormous reference databases and does not try to keep it all within the RAM of one computer.</p>
      <p>In addition to time complexity, the data transfer would be 250 Mbases of DNA, with the sequencing data moved to a data center that holds the references. Our approach tries to restrict the search space for detailed investigation such as aligning all reads, or SNP calling, or even template-based <italic>de-novo</italic> assembly, to a small set of references; when evaluating the performance we arbitrarily chose to initially consider a search a success only if the right answer is within a set of 5 proposed matches. The task of mapping all reads against these references in order to identify precisely the best match can be performed in 12 minutes on the same CPU, or in much less if a powerful multicore architecture. Transferring all genomes would represent about 20 Mbases of DNA, which could be performed even over a 3 G mobile internet connection. Our approach would enable a mobile sequencing facility such as the Ion bus <xref rid="pone.0083784-Accessed1" ref-type="bibr">[16]</xref> to perform critical diagnostics or scientific tasks in remote locations on the field. Should there be unmapped reads, because of the presence of smaller DNA sources such as a plasmid, virulence genes, a virus, or a mixture of bacteria, these reads can be processed similarly and the full content be identified over a few iterations (see <xref ref-type="fig" rid="pone-0083784-g002">Figure 2</xref>).</p>
      <fig id="pone-0083784-g002" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.1371/journal.pone.0083784.g002</object-id>
        <label>Figure 2</label>
        <caption>
          <title>Workflow.</title>
          <p>Quick identification of DNA as performed with Tapir is a step in an analysis workflow when working with unknown samples. The current web browser-based client implements the part of the process in the grey area, with the downloading of reference sequence currently in test and made available on our production server very soon. At the beginning, all reads are unmapped and a sample of them is submitted for identification. The resulting list contains a pointer to the reference DNA represented most in the sample, and the sequences for the top hits can then be fetched, indexed and used for mapping all unmapped reads, for example with an aligner for short reads. If unmapped reads remain after this step, they constitute a new set of unmapped reads to iterate on. This procedure works by iteratively decreasing the number of reads; should a mixture of DNA such as plasmids, or different species be present they will remain as unmapped and be handled with the next iteration.</p>
        </caption>
        <graphic xlink:href="pone.0083784.g002"/>
      </fig>
      <p>Alternatives to brute force mapping require the building of a classifier, which becomes an increasingly computationally demanding problem as the collection of references increases.</p>
    </sec>
    <sec id="s2b">
      <title>Building a benchmark</title>
      <p>To benchmark our system, originally designed to identify bacteria in sequencing data, we took what was all sequences from bacteria available from the EBI circa the beginning of 2012, that is 747 bacterial genomes while the full database of references contained in addition to those: bacterial references from the NCBI, phages and viruses, plasmids, and the human genome (see <xref ref-type="table" rid="pone-0083784-t001">Table 1</xref>). For each genome, we generated random possibly overlapping sub-sequences from the genome sequence in order to simulate reads obtained from a DNA sequencer; sub-sequences of length 50, 100, 150, 200, and 250 bases were used. We also introduced uniform random substitutions of bases with rates of 0% (no error), 1%, 5%, and 10% in order to simulate both a class of sequencing errors and the presence of point mutations in real samples. For each genome, length, and substitution rates, a random sample of 100 sub-sequences, or reads, was performed and that sampling repeated 3 times.</p>
      <table-wrap id="pone-0083784-t001" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.1371/journal.pone.0083784.t001</object-id>
        <label>Table 1</label>
        <caption>
          <title>Genomic references</title>
        </caption>
        <alternatives>
          <graphic id="pone-0083784-t001-1" xlink:href="pone.0083784.t001"/>
          <table frame="hsides" rules="groups">
            <colgroup span="1">
              <col align="left" span="1"/>
              <col align="center" span="1"/>
              <col align="center" span="1"/>
            </colgroup>
            <thead>
              <tr>
                <td align="left" rowspan="1" colspan="1"/>
                <td align="left" rowspan="1" colspan="1">Number of references</td>
                <td align="left" rowspan="1" colspan="1">Size (DNA bases)</td>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="left" rowspan="1" colspan="1">HIV</td>
                <td align="left" rowspan="1" colspan="1">4,053</td>
                <td align="left" rowspan="1" colspan="1">36,471,153</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">Phage genomes (EBI)</td>
                <td align="left" rowspan="1" colspan="1">1,078</td>
                <td align="left" rowspan="1" colspan="1">59,538,128</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">Viral genomes (EBI)</td>
                <td align="left" rowspan="1" colspan="1">3,464</td>
                <td align="left" rowspan="1" colspan="1">64,859,892</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">Bacterial genomes (EBI)</td>
                <td align="left" rowspan="1" colspan="1">747</td>
                <td align="left" rowspan="1" colspan="1">2,418,028,337</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">Bacterial genes (NCBI)</td>
                <td align="left" rowspan="1" colspan="1">5,218,077</td>
                <td align="left" rowspan="1" colspan="1">4,963,568,551</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">Bacterial genomes (NCBI)</td>
                <td align="left" rowspan="1" colspan="1">4,693</td>
                <td align="left" rowspan="1" colspan="1">8,584,324,670</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">Viral genomes (NCBI)</td>
                <td align="left" rowspan="1" colspan="1">1,750</td>
                <td align="left" rowspan="1" colspan="1">60,637,755</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">Fungi (NCBI)</td>
                <td align="left" rowspan="1" colspan="1">202,270</td>
                <td align="left" rowspan="1" colspan="1">298,736,207</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">Human Microbiome sequences</td>
                <td align="left" rowspan="1" colspan="1">1,653,700</td>
                <td align="left" rowspan="1" colspan="1">1,490,442,185</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">Plasmids (NCBI)</td>
                <td align="left" rowspan="1" colspan="1">159,705</td>
                <td align="left" rowspan="1" colspan="1">132,800,479</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">Viruses (EBI)</td>
                <td align="left" rowspan="1" colspan="1">78,630</td>
                <td align="left" rowspan="1" colspan="1">65,110,952</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1"><italic>Homo sapiens</italic> (Hg19)</td>
                <td align="left" rowspan="1" colspan="1">3,134</td>
                <td align="left" rowspan="1" colspan="1">2,844,000,504</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">
                  <italic>Mus musculus</italic>
                </td>
                <td align="left" rowspan="1" colspan="1">305</td>
                <td align="left" rowspan="1" colspan="1">2,745,142,291</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">Plant (RefSeq)</td>
                <td align="left" rowspan="1" colspan="1">558,267</td>
                <td align="left" rowspan="1" colspan="1">8,622,349,159</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">Invertebrates (Genbank)</td>
                <td align="left" rowspan="1" colspan="1">1,123,813</td>
                <td align="left" rowspan="1" colspan="1">18,429,666,992</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">Protozoa (Genbank)</td>
                <td align="left" rowspan="1" colspan="1">47,275</td>
                <td align="left" rowspan="1" colspan="1">1,997,449,553</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">Fungi (Genbank)</td>
                <td align="left" rowspan="1" colspan="1">200</td>
                <td align="left" rowspan="1" colspan="1">242,402,709</td>
              </tr>
            </tbody>
          </table>
        </alternatives>
        <table-wrap-foot>
          <fn id="nt101">
            <label/>
            <p>Snapshot of genomic references (source and number of references). The references are a mixture of full genomes or plasmids, and of genomic fragments such as contigs or genes.</p>
          </fn>
        </table-wrap-foot>
      </table-wrap>
      <p>We use synthetic reads from genomes we referenced, rather than a leave-one-out validation, because we place ourselves in a context of information retrieval, not machine learning and classification. Given the pace at which new organisms are sequenced our hypothesis is that a building a central index containing most of the DNA found in organisms will be possible. With the approach we present here, sequencing sites would simply query that central server and only retrieve the relevant reference genomes to perform detailed on all the reads locally. The volume of data transfer required is minimal, making it practical for sequencing facilities in the field, and the use of central reference would also allow make the update of the collection of reference shared across all users of the service.</p>
    </sec>
    <sec id="s2c">
      <title>Performance of genome identification</title>
      <p>For each bacterial genome, we took 100 random simulated reads and scored them against a database comprising these bacterial genomes, among a larger collection of sequences and genomes from other bacteria, phages, plant, fungi, viruses, and mammals using our method, recording the rank of the query genomes in a list of the 25 best matching references (see <xref ref-type="fig" rid="pone-0083784-g003">Figure 3</xref>). In order to assess the variability of the results for each test bacterial genome, this was repeated 3 times for each genome. The average ranks and the standard deviation for the ranks are presented in <xref ref-type="fig" rid="pone-0083784-g004">Figure 4</xref>.</p>
      <fig id="pone-0083784-g003" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.1371/journal.pone.0083784.g003</object-id>
        <label>Figure 3</label>
        <caption>
          <title>Bacterial reads.</title>
          <p>For each bacterial genome in a set of 747 genomes, we simulated several read lengths (50 nt, 75 nt, 100 nt, 150 nt, 200 nt, 250 nt) and several substitution error rates (0%, 1%, 5%, 10%). 100 random reads were used in each query and the distribution of the rank of the correct references in the list recorded; a rank of <inline-formula><inline-graphic xlink:href="pone.0083784.e022.jpg"/></inline-formula> means that the correct reference was at the very top of the list. The list of hits has a maximum length of 25 and we count the reference as ‘not found’ if not in the list at all. The percentage of correct test bacterial genomes present in the list is represented in a bar nested on the right side of each panel. The figure shows that, as expected, the performance degrades as the substitution rate increases, but also that reads of length 50 appear of little practical use for identification purposes. Increasing the read length beyond 100 nt brings only small improvements, and has a limited compensatory effect on the substitution rate. The figure suggests that current leading technology for sequencing possess sufficient length for an accurate identification, and should focus on sequence quality rather than increased read length.</p>
        </caption>
        <graphic xlink:href="pone.0083784.g003"/>
      </fig>
      <fig id="pone-0083784-g004" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.1371/journal.pone.0083784.g004</object-id>
        <label>Figure 4</label>
        <caption>
          <title>Bacterial reads, variability of accuracy when identifying a genome.</title>
          <p>Average rank (<inline-formula><inline-graphic xlink:href="pone.0083784.e023.jpg"/></inline-formula>, x-axis) and standard deviation of the rank (<inline-formula><inline-graphic xlink:href="pone.0083784.e024.jpg"/></inline-formula>, y-axis) of the correct reference when performing the identification procedure for 747 test bacterial genomes, using 100 random reads and 3 times for each genome. The closest the average rank is to 1 the closest to a perfect performance, and the smallest the standard deviation of the ranks the least sensitive to sampling effects. In order to increase clarity when many bacterial genomes tested produce equal or close coordinates on the scatter, we use hexagonal binning and color the areas accordingly. The vertical bar on the right side of panel indicates the percentage of times the correct reference was within the top 25 matches. Various reads size (rows) and error rates (random substitution, columns) were tried, producing a matrix of scatter plots.</p>
        </caption>
        <graphic xlink:href="pone.0083784.g004"/>
      </fig>
      <p>The performance was not satisfactory with reads of 50 bases in length, but we observed dramatic improvements when increasing the read length, with reads of length 150 nt already close to the maximum performance observed in this study: the correct genome is then in the list of results, in the top 5 hits over 97% of the times with low substitution rates and in the top 15 with higher substitution rates (see <xref ref-type="fig" rid="pone-0083784-g005">Figure 5</xref>).</p>
      <fig id="pone-0083784-g005" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.1371/journal.pone.0083784.g005</object-id>
        <label>Figure 5</label>
        <caption>
          <title>Bacterial reads (number of reads).</title>
          <p>For each bacterial genome in a set of 747 genomes, we simulated several read lengths (50 nt, 75 nt, 100 nt, 150 nt, 200 nt, 250 nt) and several substitution error rates (0%, 1%, 5%, 10%). Independent samples of 5, 10, 25, 50, 100, 200, or 300 random reads were used in each query and the distribution of the rank of the correct references in the list recorded; a rank of <inline-formula><inline-graphic xlink:href="pone.0083784.e025.jpg"/></inline-formula> means that the correct reference was at the very top of the list. The list of hits has a maximum length of 25 and we count the reference as ‘not found’ if it not present in the list. The percentages of correct test bacterial genomes found in that list are represented in a bar plot nested on the right side of each panel. Increasing the number of reads in the random sample beyond 100 reads only improves very slightly the performance observed, mostly for shorter read lengths and higher substitution rates. The substitution rate or the read length has much stronger effects on the performance.</p>
        </caption>
        <graphic xlink:href="pone.0083784.g005"/>
      </fig>
      <p>Increasing the read length up to 250 bases helped partially compensate for the negative effect of increasing substitution rates. Increasing the number of reads in the random sample sent for identification could also compensate for shorter reads, or increasing substitution rates up to <inline-formula><inline-graphic xlink:href="pone.0083784.e026.jpg"/></inline-formula>. Within the range of read lengths and number of reads we tested, a substitution error rate of <inline-formula><inline-graphic xlink:href="pone.0083784.e027.jpg"/></inline-formula> only permitted us to retrive the correct hit in less than <inline-formula><inline-graphic xlink:href="pone.0083784.e028.jpg"/></inline-formula> of the cases.</p>
      <p>As detailed earlier our method aims at returning the right reference within a set of proposed matches and by doing so simplifies the search space that a brute-force approach would require to explore with computationally demanding procedures. Restricting ourselves to finding the query sequence within the top five results is probably stricter than necessary, as running the analysis on all 25 would still be a significant improvement compared to an exhaustive search, but emphasizes that the method is already able to return the right answer within very small sets of candidate answers.</p>
      <p>In the context of iterative search and identification we consider that pointing out the right bacterial specie, even if not the correct precise strain or genomic reference, is already a relatively successful answer. <xref ref-type="fig" rid="pone-0083784-g006">Figure 6</xref> shows that our identification procedure performs relatively well, except with the shortest reads. It also shows that as little as 5 random reads of 200 nucleotides are enough to identify correctly the specie in up to over <inline-formula><inline-graphic xlink:href="pone.0083784.e029.jpg"/></inline-formula> of the cases.</p>
      <fig id="pone-0083784-g006" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.1371/journal.pone.0083784.g006</object-id>
        <label>Figure 6</label>
        <caption>
          <title>Bacterial reads, same specie.</title>
          <p>Percentage of matches giving the correct specie, that is a reference in our collection that belongs to a bacteria of the same specie rather than the correct exact same reference as shown in <xref ref-type="fig" rid="pone-0083784-g003">Figure 3</xref>, and the percentage of cases for which the correct specie was not in the top 25 matches. Independent samples of 5, 10, 25, 50, 100, 200, or 300 random reads were used in each query and the distribution of the rank of the correct references in the list recorded; a rank of <inline-formula><inline-graphic xlink:href="pone.0083784.e030.jpg"/></inline-formula> means that the correct reference was at the very top of the list. The list of hits has a maximum length of 25 and we count the reference as ‘not found’ if it not present in the list. The percentages of correct test bacterial genomes found in that list are represented in a bar plot nested on the right side of each panel. The performance remains poor for the shorter reads (50 nt), with noise decreasing it further (barplot on the first row), but become extremely good from 100 nt and stays robust against noise.</p>
        </caption>
        <graphic xlink:href="pone.0083784.g006"/>
      </fig>
      <p>The range of lengths and substitution rates we used are comparable to the ones obtained from next-generation sequencing platforms such as Illumina (maximum of 150 nucleotides with an error rate of about 0.1–1%, Life Technologies' SOLiD 5500 (maximum of 75 nt reads with an error rate of 0.01%), Ion Torrent PGM (maximum of 200–300 nucleotides with an error rate of 1%), or Pacific Bioscience (3,000 nucleotides with an error rate of 15%). Our method performs well within these ranges, and we anticipate to increase performance further by adding support for paired-end sequencing. Our method appears relatively insensitive to sequencing errors such as base substitutions and the expected low ranks for our test queries were minimally affected as substitution rates increased.</p>
      <p>We have also tried the approach on sequencing data from Ion Torrent PGM from samples ranging from viral and bacterial isolates to metagenomics mixtures. Very similar genomes in the collection of references indexed, such as several strains of the same specie, can contribute to a degradation of the performance by increasing the probability of having closely related genomes with lower ranks than the correct reference genomes. This is confirmed by the increased performance when considering the species rather than the exact reference, and this is a moderate inconvenience that can be disambiguated during a second iteration. Finally, because we are considering <italic>k</italic>-mers within the context of reads rather than breaking down all reads into <italic>k</italic>-mers and pooling all <italic>k</italic>-mers together for analysis, we are obtaining very promising results with sequencing from samples from diverse mammals, and anticipate to reliably identify them in the near future.</p>
    </sec>
    <sec id="s2d">
      <title>Exhaustive computation on the sequencing reads</title>
      <p>The approach we present describes the use of a client-server approach for performing the analysis of sequencing data without specifying a reference genome (see <xref ref-type="fig" rid="pone-0083784-g007">Figure 7</xref>). The first component in the approach returns a list of hits as candidate reference sequences, the guiding principle being to restrict the search space for more computationally demanding methods, such as the alignment of all sequencing reads. We have shown that the correct reference can be found in an ordered set of hits when using randomd sampling of reads on a client and a simple <italic>k</italic>-mers based scoring algorithm on a server; as a proof-of-concept, we implemented the last step as an alignment of all reads against the reference genomes returned in the list, and select the reference against which the largest number of reads can be aligned.</p>
      <fig id="pone-0083784-g007" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.1371/journal.pone.0083784.g007</object-id>
        <label>Figure 7</label>
        <caption>
          <title>Client-server alignment without pre-specified reference genome.</title>
          <p>(A) A small random sample of the umapped reads (initially all reads) is taken by the client and sent to the server. (B) In return the server sends a list of hits, or candidate reference sequences for the sample. (C) The client then iterates through the top hits and for each one requests the full genomic sequence from the server after checking that it does not already have a copy of it locally, and calls bowtie2 to build an index for that reference and align all currently unmapped reads to it. The reference for which the most reads map is kept, and unmapped reads remaining are moved back to step (A). The outcome is a list of reference genomes, along with a percentage of the reads iteratively aligning to these references (screenshot in (D)).</p>
        </caption>
        <graphic xlink:href="pone.0083784.g007"/>
      </fig>
    </sec>
    <sec id="s2e">
      <title>Computing performance</title>
      <sec id="s2e1">
        <title>Server</title>
        <p>Memory usage on the server can be minimized by using a disk-based key value store, and tuning performances can be achieved by caching this into the memory available on the computer running it. Thanks to the use of a NoSQL database, we also anticipate to be able to scale up as genomic data get increasingly abundant, and continue being able to index and query increasingly large collections of references on relatively affordable computer systems using sharding.</p>
        <p>With the current implementation both the indexing system and the server are implemented in Python, and the indexing of 44 Gbases of reference DNA is performed in a few hours using 8 cores (Intel Xeon, 2.93 GHz), and the processing of one incoming sample taking under 10 seconds. We are aware that a significant speedup could be achieved with optimization efforts such as bottlenecks moved to C, but it is also possible to increase global performance in the handling of more requests by dedicating more cores, should the need arise.</p>
      </sec>
      <sec id="s2e2">
        <title>Clients</title>
        <p>We have implemented a command-line tool to perform the complete workflow in <xref ref-type="fig" rid="pone-0083784-g002">Figure 2</xref>. The tool performs a random sampling of the sequencing reads, queries the server with these reads, and retrieves a list of top hits. In a second step, it fetches the full reference genomes associated with the reads and performs the alignment of all reads using bowtie2, keeping along each alignment the unmapped reads. The alignment for which the lowest number of unmapped reads is obtained is considered the best hit, and the umapped reads are sampled and queried in turn. This is repeated until a specified maximum number of iterations is reached, there are no unmapped reads remaining, or the list of candidate matches returned by the server is empty.</p>
        <p>To facilitate the use of our method, and demonstrate the relatively low computational demand of working with microbial genomes without the reference genome matching the sample being known, we have also developed a browser-based client using Javascript and HTML5 features that can be accessed at <ext-link ext-link-type="uri" xlink:href="http://tapir.cbs.dtu.dk">http://tapir.cbs.dtu.dk</ext-link>. The client is currently only implementing the sampling and query, and is generally working on the latest releases of Firefox and Chrome/Chromium. Safari and Internet Explorer do not appear to support the HTML5 features we require. Chromium v.25 running on a laptop with an Intel Core i7 CPU clocked at 2.10 GHz, is able to process the raw reads in a 500 Mb FASTQ file in size could be processed in under 15 seconds, with few seconds spent communicating with the server.</p>
      </sec>
    </sec>
  </sec>
  <sec id="s3">
    <title>Discussion</title>
    <p>The concept underlying TAPIR is rather simple, and to some extent a continuation of the generic work around document search in computing and information technology, and of the use of <italic>k</italic>-mers when working on DNA sequences <xref rid="pone.0083784-Ning1" ref-type="bibr">[17]</xref>, <xref rid="pone.0083784-Ning2" ref-type="bibr">[18]</xref>. The increase in size of DNA databases has been announced and observed for at least a decade, but recent developments in DNA sequencing technology have made fast and affordable generation of data a reality. We argue that matching experimentally-obtained DNA sequences against all known DNA is one of the most important challenges in bioinformatics. We show here that this can be done with a speed and ease that matches what the internet web search giants have made us expect.</p>
    <p>We also found the first step of the approach to mapping proposed very recently by Liao and collaborators <xref rid="pone.0083784-Liao1" ref-type="bibr">[19]</xref> to be similar to the way we score hits for a given read, although both approaches were developed independently. We plan on working further on both the implementation, moving the slowest parts to C in order to allow an increased number of connections while keeping hardware requirements for the server relatively modest.</p>
    <p>We have shown with synthetic sequencing reads from almost 750 bacteria that while our approach does not always find the exact reference as the first hit, it can find it among the first hits in over 97% of the time, and can find the correct specie almost all the time. When coupled with more detailed methods such as state-of-the-art aligners, we think of our approach as a way to simplify the search space when confronted with unknown DNA, and the detailed methods have to be performed only on that restricted number of candidate references.</p>
    <p>The results obtained from our general client-server approach also suggest that the analysis of NGS data could benefit from taking naive approaches, in the sense that the expected reference sequence is not provided, but determined by a query to a service such as TAPIR. We also observed that results obtained with very few reads in the sample were better than anticipated for the longer read lengths, and suggest that further work will be needed for assigning score for situations where only very and very few reads are available. We implemented the computationally exhaustive step on the sequencing as an alignment of the reads using bowtie2, and select the match for which the largest number of reads are aligned. This number is closely related to the average coverage, and recent work shows that better measures can be found <xref rid="pone.0083784-Lindner1" ref-type="bibr">[20]</xref>. Further work will be required to refine the approach presented here.</p>
    <p>When considering tasks such as real time surveillance, such as infections in patients, biodefense, or food safety, modern desktop DNA sequencers such the Ion Torrent PGM or Illumina MiSeq are already up to the task and our method provides an immediate early step during which the search space can be narrowed down and more advanced analysis methods can be performed locally afterwards, without the need to transfer large amounts of raw data between a laboratory performing the DNA sequencing and a computing facility.</p>
    <p>Although initially designed for pure cultures, with the eventuality of a plasmid or a viral component also present, we obtain very encouraging results with more complex samples with reads from tens of different bacteria. We anticipate that this client-asks-server-for-hints approach will develop more, with de-novo genome assembly methods even looking whether known genomes can provide good templates and reserve the hardest computational task to the reads that belong to genomes or genomic fragments not yet in a database such as ours.</p>
    <p>Finally, our use of B-trees in NoSQL databases is less efficient than FM-Index searches when perfect matches are considered. However, we argue that the semi-independence from the length of the reference sequence FM-index search can achieve can be counterbalanced, at least in part, by an increase in the number of different reference sequences. Such indexes must also be contained into the memory of one computer, the only alternative being to build several indexes from complementary subsets of reference sequences. Because of sampling, limited computing ressource are needed, and B-trees or hashes can be split across several compute nodes, a technique known as sharding, represents a larger benefit.</p>
  </sec>
  <sec sec-type="methods" id="s4">
    <title>Methods</title>
    <sec id="s4a">
      <title>Sources of genomic references</title>
      <p>Publicly available genomes, contigs, plasmids, and individual genes available from the EBI and the NCBI were downloaded to be our reference DNA. The exact composition of the references will be expanding with time, but we listed the snapshot used for the writing of the manuscript in <xref ref-type="table" rid="pone-0083784-t001">Table 1</xref>.</p>
    </sec>
    <sec id="s4b">
      <title>Indexing of references</title>
      <p>Each reference sequence was split into non-overlapping <italic>k</italic>-mers and for all <italic>k</italic>-mers across all references a key-value store, or NoSQL database (we used KyotoCabinet <xref rid="pone.0083784-Hirabayashi1" ref-type="bibr">[21]</xref>), was created, associating to each k-mer (key in the database) a list of identifiers corresponding to the references having that k-mer. We called this the presence database. Similarly, the positions in the reference at which the k-mer is found were stored in what we call the position database. <inline-formula><inline-graphic xlink:href="pone.0083784.e031.jpg"/></inline-formula> was chosen to be equal to 16, as it gave us satisfactory results, and as a multiple of <inline-formula><inline-graphic xlink:href="pone.0083784.e032.jpg"/></inline-formula> was well-suited for bit-packing. The associations between references identifiers and information, such as a description line and the source of data, were stored in a separate SQL database.</p>
    </sec>
    <sec id="s4c">
      <title>Scoring</title>
      <p>In order to score a set of short query sequences, presumably sequencing reads, we iterate through a random sample of them. The larger the sample size the more reliably accurate it will become. For each read, we iterate over the consecutive <italic>k</italic>-mers obtained by sliding a window of width <italic>k</italic> across the sequence. For each <italic>k</italic>-mer within a read, if it has not been counted before and it is found in the presence database we then query the position(s) for the reference(s). Once all <italic>k</italic>-mers for a read have been processed, we look at the number of approximate contiguous positions matched in the references and only consider the largest clusters of matches, that is the largest concentration of matching <italic>k</italic>-mers originating from the same read across all matching references. To achieve this, we are sorting the positions of the matching <italic>k-mers</italic> on the reference and look at consecutive positions within a tolerance gap from one an other. For each such cluster, we add the number of <italic>k</italic>-mers to a possibly previously added number for that reference and we update the list of <italic>k</italic>-mers already counted. The next sequence, or read, is then processed. When all reads have been processed we obtain a list of references to which is associated a count of matching <italic>k</italic>-mers. For each pair <inline-formula><inline-graphic xlink:href="pone.0083784.e033.jpg"/></inline-formula>, the count is divided by the number of unique <italic>k</italic>-mers in the query set, giving us a rough score for the amount of DNA in the query matched by a given reference. If a query set completely matches the sequence that score will be 1, it will be lower otherwise; for example, if the query set is a mixture in equal proportion of two references the score would be around <inline-formula><inline-graphic xlink:href="pone.0083784.e034.jpg"/></inline-formula> for both references. That count is also divided by the size of the reference, giving a rough score for the fraction of the reference that is represented by the query; that second score is helpful to sort the matching references, and avoid bias toward the largest references. The final score is a weighted sum of those two scores, default being equal weights. If the query set is large, for example if we are considering all reads coming out of a DNA sequencing run, we use only a random sample of that set. The Python code for our server is available and can be consulted for full details about the implementation.</p>
    </sec>
    <sec id="s4d">
      <title>Implementation of a client</title>
      <p>To facilitate the use of the service, we implemented an HTML5/Javascript client running as a page in a web browser. Developement was made with Firefox 15 as a target platform, at it was the only browser implementing all needed features on all platforms (Linux, Mac OS X, Microsoft Windows, as well as on Android 4.0 (tablet ASUS TF101 - we anticipate that it would also work from a high-end smartphone). At the time of writing, the latest release of Firefox (v.21) is not working but the lastest release of Chrome (v.25) is working.</p>
      <p>We have also made available a Python library and command-line tool for easy integration in existing workflows and pipelines. This script is available as supplementary material and we hope to expand it and release a Python package.</p>
    </sec>
    <sec id="s4e">
      <title>Other technical specifications</title>
      <p>With the exception of bindings to libraries such as KyotoCabinet, all implementation was made using Python version 2.7.3 on the server side. The web application uses the micro-framework Flask and is served by lighttp. We have not yet dedicated much effort to optimization, such as moving specific parts of the code to the C language to obtain gain in speed, as the performance is sufficient for our current needs.</p>
      <p>The client-side library and command-line tool were developed for Python version 3.3.</p>
    </sec>
  </sec>
</body>
<back>
  <ack>
    <p>Aron Eklund for critical reading. The authors would also like to thank the anonymous reviewers and Titus Brown for helping to improve the manuscript through their comments.</p>
  </ack>
  <ref-list>
    <title>References</title>
    <ref id="pone.0083784-Shendure1">
      <label>1</label>
      <mixed-citation publication-type="journal"><name><surname>Shendure</surname><given-names>J</given-names></name>, <name><surname>Ji</surname><given-names>H</given-names></name> (<year>2008</year>) <article-title>Next-generation DNA sequencing</article-title>. <source>Nature Biotechnology</source>
<volume>26</volume>: <fpage>1135</fpage>–<lpage>1145</lpage>.</mixed-citation>
    </ref>
    <ref id="pone.0083784-Rusk1">
      <label>2</label>
      <mixed-citation publication-type="journal"><name><surname>Rusk</surname><given-names>N</given-names></name> (<year>2009</year>) <article-title>Cheap third-generation sequencing</article-title>. <source>Nature Methods</source>
<volume>6</volume>: <fpage>244</fpage>–<lpage>244</lpage>.</mixed-citation>
    </ref>
    <ref id="pone.0083784-Smith1">
      <label>3</label>
      <mixed-citation publication-type="journal"><name><surname>Smith</surname><given-names>T</given-names></name>, <name><surname>Waterman</surname><given-names>M</given-names></name> (<year>1981</year>) <article-title>Identification of common molecular subsequences</article-title>. <source>Journal of Molec- ular Biology</source>
<volume>147</volume>: <fpage>195</fpage>–<lpage>197</lpage>.</mixed-citation>
    </ref>
    <ref id="pone.0083784-Devos1">
      <label>4</label>
      <mixed-citation publication-type="journal"><name><surname>Devos</surname><given-names>D</given-names></name>, <name><surname>Valencia</surname><given-names>A</given-names></name> (<year>2000</year>) <article-title>Practical limits of function prediction</article-title>. <source>Proteins: Structure, Function, and Genetics</source>
<volume>41</volume>: <fpage>98</fpage>–<lpage>107</lpage>.</mixed-citation>
    </ref>
    <ref id="pone.0083784-Rost1">
      <label>5</label>
      <mixed-citation publication-type="journal"><name><surname>Rost</surname><given-names>B</given-names></name> (<year>2002</year>) <article-title>Enzyme function less conserved than anticipated</article-title>. <source>Journal of Molecular Biology</source>
<volume>318</volume>: <fpage>595</fpage>–<lpage>608</lpage>.<pub-id pub-id-type="pmid">12051862</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0083784-Altschul1">
      <label>6</label>
      <mixed-citation publication-type="journal"><name><surname>Altschul</surname><given-names>SF</given-names></name>, <name><surname>Gish</surname><given-names>W</given-names></name>, <name><surname>Miller</surname><given-names>W</given-names></name>, <name><surname>Myers</surname><given-names>EW</given-names></name>, <name><surname>Lipman</surname><given-names>DJ</given-names></name> (<year>1990</year>) <article-title>Basic local alignment search tool</article-title>. <source>Journal of Molecular Biology</source>
<volume>215</volume>: <fpage>403</fpage>–<lpage>410</lpage>.<pub-id pub-id-type="pmid">2231712</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0083784-Kent1">
      <label>7</label>
      <mixed-citation publication-type="journal"><name><surname>Kent</surname><given-names>WJ</given-names></name> (<year>2002</year>) <article-title>BLAT—The BLAST-Like alignment tool</article-title>. <source>Genome Research</source>
<volume>12</volume>: <fpage>656</fpage>–<lpage>664</lpage>.<pub-id pub-id-type="pmid">11932250</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0083784-Langmead1">
      <label>8</label>
      <mixed-citation publication-type="journal"><name><surname>Langmead</surname><given-names>B</given-names></name>, <name><surname>Trapnell</surname><given-names>C</given-names></name>, <name><surname>Pop</surname><given-names>M</given-names></name>, <name><surname>Salzberg</surname><given-names>SL</given-names></name> (<year>2009</year>) <article-title>Ultrafast and memory-efficient alignment of short DNA sequences to the human genome</article-title>. <source>Genome Biology</source>
<volume>10</volume>: <fpage>R25</fpage>.<pub-id pub-id-type="pmid">19261174</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0083784-Li1">
      <label>9</label>
      <mixed-citation publication-type="journal"><name><surname>Li</surname><given-names>H</given-names></name>, <name><surname>Durbin</surname><given-names>R</given-names></name> (<year>2009</year>) <article-title>Fast and accurate short read alignment with burrows-wheeler transform</article-title>. <source>Bioinformatics</source>
<volume>25</volume>: <fpage>1754</fpage>–<lpage>1760</lpage>.<pub-id pub-id-type="pmid">19451168</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0083784-Rumble1">
      <label>10</label>
      <mixed-citation publication-type="journal"><name><surname>Rumble</surname><given-names>SM</given-names></name>, <name><surname>Lacroute</surname><given-names>P</given-names></name>, <name><surname>Dalca</surname><given-names>AV</given-names></name>, <name><surname>Fiume</surname><given-names>M</given-names></name>, <name><surname>Sidow</surname><given-names>A</given-names></name>, <etal>et al</etal> (<year>2009</year>) <article-title>SHRiMP: accurate mapping of short color-space reads</article-title>. <source>PLoS Computational Biology</source>
<volume>5</volume>: <fpage>e1000386</fpage>.<pub-id pub-id-type="pmid">19461883</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0083784-Li2">
      <label>11</label>
      <mixed-citation publication-type="journal"><name><surname>Li</surname><given-names>H</given-names></name>, <name><surname>Homer</surname><given-names>N</given-names></name> (<year>2010</year>) <article-title>A survey of sequence alignment algorithms for next-generation sequencing</article-title>. <source>Briefings in Bioinformatics</source>
<volume>11</volume>: <fpage>473</fpage>–<lpage>483</lpage>.<pub-id pub-id-type="pmid">20460430</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0083784-Hoffimann1">
      <label>12</label>
      <mixed-citation publication-type="journal"><name><surname>Hoffimann</surname><given-names>S</given-names></name>, <name><surname>Otto</surname><given-names>C</given-names></name>, <name><surname>Kurtz</surname><given-names>S</given-names></name>, <name><surname>Sharma</surname><given-names>CM</given-names></name>, <name><surname>Khaitovich</surname><given-names>P</given-names></name>, <etal>et al</etal> (<year>2009</year>) <article-title>Fast mapping of short sequences with mismatches, insertions and deletions using index structures</article-title>. <source>PLoS computational biology</source>
<volume>5</volume>: <fpage>e1000502</fpage>.<pub-id pub-id-type="pmid">19750212</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0083784-Ferragina1">
      <label>13</label>
      <mixed-citation publication-type="other">Ferragina P, Manzini G (2000) Opportunistic data structures with applications. In: Foundations of Computer Science, 2000. Proceedings. 41st Annual Symposium on. IEEE, pp. 390–398.</mixed-citation>
    </ref>
    <ref id="pone.0083784-Cormen1">
      <label>14</label>
      <mixed-citation publication-type="other">Cormen TH, Leiserson CE, Rivest RL, Stein C (2001) Introduction to algorithms. MIT press.</mixed-citation>
    </ref>
    <ref id="pone.0083784-Cox1">
      <label>15</label>
      <mixed-citation publication-type="journal"><name><surname>Cox</surname><given-names>AJ</given-names></name>, <name><surname>Bauer</surname><given-names>MJ</given-names></name>, <name><surname>Jakobi</surname><given-names>T</given-names></name>, <name><surname>Rosone</surname><given-names>G</given-names></name> (<year>2012</year>) <article-title>Large-scale compression of genomic sequence databases with the burrows-wheeler transform</article-title>. <source>Bioinformatics</source>
<volume>28</volume>: <fpage>1415</fpage>–<lpage>1419</lpage>.<pub-id pub-id-type="pmid">22556365</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0083784-Accessed1">
      <label>16</label>
      <mixed-citation publication-type="other">(Accessed 2013 Aug 3rd). Ion bus. URL <ext-link ext-link-type="uri" xlink:href="http://ioncommunity.lifetechnologies.com/docs/DOC-2691">http://ioncommunity.lifetechnologies.com/docs/DOC-2691</ext-link>.</mixed-citation>
    </ref>
    <ref id="pone.0083784-Ning1">
      <label>17</label>
      <mixed-citation publication-type="journal"><name><surname>Ning</surname><given-names>Z</given-names></name> (<year>2001</year>) <article-title>SSAHA: a fast search method for large DNA databases</article-title>. <source>Genome Research</source>
<volume>11</volume>: <fpage>1725</fpage>–<lpage>1729</lpage>.<pub-id pub-id-type="pmid">11591649</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0083784-Ning2">
      <label>18</label>
      <mixed-citation publication-type="other">Ning Z, Spooner W, Spargo A, Leonard S, Rae M, <etal>et al</etal>.. (2004) The SSAHA trace server. In: Computational Systems Bioinformatics Conference. IEEE, pp. 519–520.</mixed-citation>
    </ref>
    <ref id="pone.0083784-Liao1">
      <label>19</label>
      <mixed-citation publication-type="other">Liao Y, Smyth GK, Shi W (2013) The subread aligner: fast, accurate and scalable read mapping by seed-and-vote. Nucleic acids research.</mixed-citation>
    </ref>
    <ref id="pone.0083784-Lindner1">
      <label>20</label>
      <mixed-citation publication-type="journal"><name><surname>Lindner</surname><given-names>MS</given-names></name>, <name><surname>Kollock</surname><given-names>M</given-names></name>, <name><surname>Zickmann</surname><given-names>F</given-names></name>, <name><surname>Renard</surname><given-names>BY</given-names></name> (<year>2013</year>) <article-title>Analyzing genome coverage profiles with applications to quality control in metagenomics</article-title>. <source>Bioinformatics</source>
<volume>29</volume>: <fpage>1260</fpage>–<lpage>1267</lpage>.<pub-id pub-id-type="pmid">23589648</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0083784-Hirabayashi1">
      <label>21</label>
      <mixed-citation publication-type="other">Hirabayashi M (Accessed 2010 Oct 10th). Kyoto cabinet: a straightforward implementation of DBM. <ext-link ext-link-type="uri" xlink:href="http://fallabs.com/kyotocabinet/">http://fallabs.com/kyotocabinet/</ext-link>. URL <ext-link ext-link-type="uri" xlink:href="http://fallabs.com/kyotocabinet/">http://fallabs.com/kyotocabinet/</ext-link>.</mixed-citation>
    </ref>
  </ref-list>
</back>
